{"version":3,"mappings":"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","names":["SelectEventType","SelectEvent","Event","type","selected","deselected","mapBrowserEvent","originalFeatureStyles","Select","Interaction","options","singleClick","never","shiftKeyOnly","TRUE","getDefaultStyleFunction","Collection","layerFilter","layers","layer","feature","getUid","hitTolerance","map","CollectionEventType","evt","VectorLayer","key","interactions","i","interaction","Feature","features","clear","add","remove","toggle","set","foundAtCursor","modifiedFeature","styles","createEditingStyle","extend","u8","u16","i32","fleb","fdeb","clim","freb","eb","start","b","r","j","_a","fl","revfl","_b","fd","rev","x","hMap","cd","mb","s","l","le","co","rvb","sv","r_1","v","m","flt","fdt","flrm","fdrm","max","a","bits","d","p","o","bits16","shft","slc","e","ec","err","ind","msg","nt","inflt","dat","st","buf","dict","sl","dl","noBuf","resize","noSt","cbuf","bl","nbuf","final","pos","bt","lm","dm","lbt","dbt","tbts","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","c","n","lt","dt","t","lms","dms","lpos","sym","dsym","end","shift","dend","et","gzs","flg","zs","gzl","zls","inflateSync","data","opts","gunzipSync","unzlibSync","decompressSync","td","tds","B","h","W","E","y","w","z","f","u","N","k","q","G","ie","J","D","F","O","_","Y","Q","A","C","T","g","X","Z","U","I","K","R","M","P","H","__defProp","__getOwnPropSymbols","__hasOwnProp","__propIsEnum","__defNormalProp","obj","value","__spreadValues","prop","__name","target","__async","__this","__arguments","generator","resolve","reject","fulfilled","step","rejected","_PMTilesRasterSource","DataTileSource","src","img","PMTiles","projection","createXYZ","extentFromProjection","response","image","PMTilesRasterSource","_PMTilesVectorSource","VectorTileSource","MVT","tile","url","vtile","re","result","extent","resolution","tile_result","format","TileState","PMTilesVectorSource","ErrorEvent","BaseEvent","error","EventType","LABEL_EXTENSION","transparentFill","Fill","getStyle","strokeColor","strokeWidth","fillColor","circleRadius","fill","stroke","Stroke","Style","Circle","defaultBoundsStyle","defaultCollectionStyle","getStacObjectsForEvent","event","exclude","selectedFeatures","objects","stac","STAC","getGeoTiffSourceInfoFromAsset","asset","selectedBands","sourceInfo","source","bands","minimum","maximum","band","nodata","bandNoData","visualBands","loadProjection","code","fromProjectionCode","fromEPSGCode","__vitePreload","getProjection","reference","defaultProjection","isProj4Registered","getBoundsStyle","originalStyle","layerGroup","style","getSpecificWebMapUrl","link","isScalar","isMask","readRGB","preference","interpretation","interpretations","geotiffGlobals.photometricInterpretations","STATISTICS_MAXIMUM","STATISTICS_MINIMUM","defaultTileSize","workerPool","getWorkerPool","Pool","getBoundingBox","getOrigin","getResolutions","referenceImage","getProjectionFromKeys","geoKeys","geoKey","unitKey","loadMissingProjection","getCachedProjection","units","unitsFromCode","Projection","getImagesForTIFF","tiff","count","requests","getImagesForSource","request","tiffFromBlob","tiffFromUrls","tiffFromUrl","assertEqual","expected","got","tolerance","message","rejector","length","getMinForDataType","array","getMaxForDataType","GeoTIFFSource","DataTile","numSources","self","sources","logError","firstSource","modelTransformation","matrix","multiplyTransform","origin","commonRenderTileSizes","commonSourceTileSizes","resolutions","samplesPerPixel","nodataValues","metadata","minZoom","sourceCount","sourceIndex","images","masks","item","imageCount","sourceExtent","sourceOrigin","sourceTileSizes","renderTileSizes","sourceResolutions","imageIndex","nodataValue","wantedSamples","level","imageResolutions","sourceTileSize","aspectRatio","getIntersection","resolutionFactor","scaledSourceResolutions","ii","sourceImagery","outer","values","bandCount","tileGrid","TileGrid","zoom","viewExtent","makeInverse","createMatrix","transformFn","createTransformFromCoordinateTransform","input","applyMatrix","applyTransform","toUserCoordinate","getCenter","toUserExtent","pool","pixelBounds","samples","bandNumber","fillValue","sampleIndex","readOptions","maskIndex","mask","sourceSamples","normalize","addAlpha","pixelCount","dataLength","dataIndex","pixelIndex","transparent","min","gain","bias","stats","sourceValue","clamp","bandIndex","nodataIsNaN","SourceType","name","STACLayer","LayerGroup","superOptions","responseType","bbox","isEmpty","children","assets","Asset","create","updateBoundsStyle","errorHandler","promises","collection","defaultOptions","subgroup","bboxes","transformExtent","ImageLayer","StaticImage","updateOptions","headers","pmtiles.PMTiles","pmtiles.TileType","TileJSON","params","wmsOptions","WMS","wmtsCapabilities","wmtsOptions","optionsFromCapabilities","uriTemplate","vars","isObject","schema","WMTS","XYZ","VectorTileLayer","WebGLTileLayer","TileLayer","GeoTIFF","status","zIndex","geojson","toGeoJSON","visible","GeoJSON","VectorSource","fixGeoJson","Item","labelAsset","geojsonMediaType","sourceLinks","items","emit","oldLayers","ref","APICollection","links","geotiff","thumbnails","boundsLayer","types","mapLinks","match","candidate","prioA","prioB","updateLayers","childs","ItemCollection","CollectionCollection","child","view","unionBoundingBox","state","attribution","encoding","urlObj","WMTSCapabilities","selectStyle","mapId","_sfc_main","defineAsyncComponent","LayerControl","TextControl","MapMixin","mapGetters","empty","selection","StacLayer","writer","container","MapUtils","STACReference","_hoisted_1","_hoisted_4","_hoisted_5","_openBlock","_createElementBlock","_createElementVNode","$data","_createVNode","_component_LayerControl","_ctx","_createBlock","_component_TextControl","_hoisted_3","$props","_component_b_popover","$options","_component_Items","_component_Catalogs","_component_Features","_component_b_button"],"ignoreList":[0,1,2,3,4,5,6,7,8],"sources":["../../node_modules/ol/interaction/Select.js","../../node_modules/fflate/esm/browser.js","../../node_modules/pmtiles/dist/esm/index.js","../../node_modules/ol-pmtiles/dist/esm/index.js","../../node_modules/ol-stac/events/ErrorEvent.js","../../node_modules/ol-stac/util.js","../../node_modules/ol-stac/source/GeoTIFF.js","../../node_modules/ol-stac/source/type.js","../../node_modules/ol-stac/layer/STAC.js","../../src/components/MapView.vue"],"sourcesContent":["/**\n * @module ol/interaction/Select\n */\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Feature from '../Feature.js';\nimport {extend} from '../array.js';\nimport Event from '../events/Event.js';\nimport {never, shiftKeyOnly, singleClick} from '../events/condition.js';\nimport {TRUE} from '../functions.js';\nimport VectorLayer from '../layer/Vector.js';\nimport {clear} from '../obj.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {getUid} from '../util.js';\nimport Interaction from './Interaction.js';\n\n/**\n * @enum {string}\n */\nconst SelectEventType = {\n  /**\n   * Triggered when feature(s) has been (de)selected.\n   * @event SelectEvent#select\n   * @api\n   */\n  SELECT: 'select',\n};\n\n/**\n * A function that takes a {@link module:ol/Feature~Feature} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @typedef {function(import(\"../Feature.js\").default, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [addCondition] A function\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is the event\n * for the selected features as a whole. By default, this is\n * {@link module:ol/events/condition.singleClick}. Clicking on a feature selects that\n * feature and removes any that were in the selection. Clicking outside any\n * feature removes all from the selection.\n * See `toggle`, `add`, `remove` options for adding/removing extra features to/\n * from the selection.\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers]\n * A list of layers from which features should be selected. Alternatively, a\n * filter function can be provided. The function will be called for each layer\n * in the map and should return `true` for layers that you want to be\n * selectable. If the option is absent, all visible layers will be considered\n * selectable.\n * @property {import(\"../style/Style.js\").StyleLike|null} [style]\n * Style for the selected features. By default the default edit style is used\n * (see {@link module:ol/style/Style~Style}). Set to `null` if this interaction should not apply\n * any style changes for selected features.\n * If set to a falsey value, the selected feature's style will not change.\n * @property {import(\"../events/condition.js\").Condition} [removeCondition] A function\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [toggleCondition] A function\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is in addition\n * to the `condition` event. By default,\n * {@link module:ol/events/condition.shiftKeyOnly}, i.e. pressing `shift` as\n * well as the `condition` event, adds that feature to the current selection if\n * it is not currently selected, and removes it if it is. See `add` and `remove`\n * if you want to use different events instead of a toggle.\n * @property {boolean} [multi=false] A boolean that determines if the default\n * behaviour should select only single features or all (overlapping) features at\n * the clicked map position. The default of `false` means single select.\n * @property {Collection<Feature>} [features]\n * Collection where the interaction will place selected features. Optional. If\n * not set the interaction will create a collection. In any case the collection\n * used by the interaction is returned by\n * {@link module:ol/interaction/Select~Select#getFeatures}.\n * @property {FilterFunction} [filter] A function\n * that takes a {@link module:ol/Feature~Feature} and a\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside\n * the radius around the given position will be checked for features.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of\n * this type.\n */\nexport class SelectEvent extends Event {\n  /**\n   * @param {SelectEventType} type The event type.\n   * @param {Array<import(\"../Feature.js\").default>} selected Selected features.\n   * @param {Array<import(\"../Feature.js\").default>} deselected Deselected features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Associated\n   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   */\n  constructor(type, selected, deselected, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * Selected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.selected = selected;\n\n    /**\n     * Deselected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.deselected = deselected;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/**\n * Original feature styles to reset to when features are no longer selected.\n * @type {Object<number, import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction>}\n */\nconst originalFeatureStyles = {};\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'select', SelectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'select', Return>} SelectOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for selecting vector features. By default, selected features are\n * styled differently, so this interaction can be used for visual highlighting,\n * as well as selecting features for other actions, such as modification or\n * output. There are three ways of controlling which features are selected:\n * using the browser event as defined by the `condition` and optionally the\n * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a\n * further feature filter using the `filter` option.\n *\n * @fires SelectEvent\n * @api\n */\nclass Select extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {SelectOnSignature<void>}\n     */\n    this.un;\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     */\n    this.boundAddFeature_ = this.addFeature_.bind(this);\n\n    /**\n     * @private\n     */\n    this.boundRemoveFeature_ = this.removeFeature_.bind(this);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : singleClick;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.addCondition_ = options.addCondition ? options.addCondition : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.removeCondition_ = options.removeCondition\n      ? options.removeCondition\n      : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.toggleCondition_ = options.toggleCondition\n      ? options.toggleCondition\n      : shiftKeyOnly;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multi_ = options.multi ? options.multi : false;\n\n    /**\n     * @private\n     * @type {FilterFunction}\n     */\n    this.filter_ = options.filter ? options.filter : TRUE;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n\n    /**\n     * @private\n     * @type {import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction|null}\n     */\n    this.style_ =\n      options.style !== undefined ? options.style : getDefaultStyleFunction();\n\n    /**\n     * @private\n     * @type {Collection<Feature>}\n     */\n    this.features_ = options.features || new Collection();\n\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\n    let layerFilter;\n    if (options.layers) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        const layers = options.layers;\n        layerFilter = function (layer) {\n          return layers.includes(layer);\n        };\n      }\n    } else {\n      layerFilter = TRUE;\n    }\n\n    /**\n     * @private\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\n     */\n    this.layerFilter_ = layerFilter;\n\n    /**\n     * An association between selected feature (key)\n     * and layer (value)\n     * @private\n     * @type {Object<string, import(\"../layer/Layer.js\").default>}\n     */\n    this.featureLayerAssociation_ = {};\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"../layer/Layer.js\").default} layer Layer.\n   * @private\n   */\n  addFeatureLayerAssociation_(feature, layer) {\n    this.featureLayerAssociation_[getUid(feature)] = layer;\n  }\n\n  /**\n   * Get the selected features.\n   * @return {Collection<Feature>} Features collection.\n   * @api\n   */\n  getFeatures() {\n    return this.features_;\n  }\n\n  /**\n   * Returns the Hit-detection tolerance.\n   * @return {number} Hit tolerance in pixels.\n   * @api\n   */\n  getHitTolerance() {\n    return this.hitTolerance_;\n  }\n\n  /**\n   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of\n   * a selected feature.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @return {import('../layer/Vector.js').default} Layer.\n   * @api\n   */\n  getLayer(feature) {\n    return /** @type {import('../layer/Vector.js').default} */ (\n      this.featureLayerAssociation_[getUid(feature)]\n    );\n  }\n\n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n  setHitTolerance(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  }\n\n  /**\n   * Remove the interaction from its current map, if any,  and attach it to a new\n   * map, if any. Pass `null` to just remove the interaction from the current map.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   * @override\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    if (currentMap && this.style_) {\n      this.features_.forEach(this.restorePreviousStyle_.bind(this));\n    }\n    super.setMap(map);\n    if (map) {\n      this.features_.addEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_,\n      );\n      this.features_.addEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_,\n      );\n\n      if (this.style_) {\n        this.features_.forEach(this.applySelectedStyle_.bind(this));\n      }\n    } else {\n      this.features_.removeEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_,\n      );\n      this.features_.removeEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_,\n      );\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  addFeature_(evt) {\n    const feature = evt.element;\n    if (this.style_) {\n      this.applySelectedStyle_(feature);\n    }\n    if (!this.getLayer(feature)) {\n      const layer = this.findLayerOfFeature_(feature);\n      if (layer) {\n        this.addFeatureLayerAssociation_(feature, layer);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  removeFeature_(evt) {\n    if (this.style_) {\n      this.restorePreviousStyle_(evt.element);\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature of which to get the layer\n   * @return {VectorLayer} layer, if one was found.\n   * @private\n   */\n  findLayerOfFeature_(feature) {\n    const layer = /** @type {VectorLayer} */ (\n      this.getMap()\n        .getAllLayers()\n        .find(function (layer) {\n          if (\n            layer instanceof VectorLayer &&\n            layer.getSource() &&\n            layer.getSource().hasFeature(feature)\n          ) {\n            return layer;\n          }\n        })\n    );\n    return layer;\n  }\n\n  /**\n   * @return {import(\"../style/Style.js\").StyleLike|null} Select style.\n   */\n  getStyle() {\n    return this.style_;\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  applySelectedStyle_(feature) {\n    const key = getUid(feature);\n    if (!(key in originalFeatureStyles)) {\n      originalFeatureStyles[key] = feature.getStyle();\n    }\n    feature.setStyle(this.style_);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  restorePreviousStyle_(feature) {\n    const interactions = this.getMap().getInteractions().getArray();\n    for (let i = interactions.length - 1; i >= 0; --i) {\n      const interaction = interactions[i];\n      if (\n        interaction !== this &&\n        interaction instanceof Select &&\n        interaction.getStyle() &&\n        interaction.getFeatures().getArray().lastIndexOf(feature) !== -1\n      ) {\n        feature.setStyle(interaction.getStyle());\n        return;\n      }\n    }\n\n    const key = getUid(feature);\n    feature.setStyle(originalFeatureStyles[key]);\n    delete originalFeatureStyles[key];\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  removeFeatureLayerAssociation_(feature) {\n    delete this.featureLayerAssociation_[getUid(feature)];\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").FeatureLike} feature The feature to select\n   * @param {import(\"../layer/Layer.js\").default} layer Optional layer containing this feature\n   * @param {Array<Feature>} [selected] optional array to which selected features will be added\n   * @return {Feature|undefined} The feature, if it got selected.\n   * @private\n   */\n  selectFeatureInternal_(feature, layer, selected) {\n    if (!(feature instanceof Feature)) {\n      return;\n    }\n    if (!this.filter_(feature, layer)) {\n      return;\n    }\n    const features = this.getFeatures();\n    if (!features.getArray().includes(feature)) {\n      this.addFeatureLayerAssociation_(feature, layer);\n      features.push(feature);\n      selected?.push(feature);\n    }\n    return feature;\n  }\n\n  /**\n   * Try to select a feature as if it was clicked and `addCondition` evaluated to True.\n   * Unlike modifying `select.getFeatures()` directly, this respects the `filter` and `layers` options (except `multi`, which is ignored).\n   * The {@link module:ol/interaction/Select~SelectEvent} fired by this won't have a mapBrowserEvent property\n   * @param {Feature} feature The feature to select\n   * @return {boolean} True if the feature was selected\n   */\n  selectFeature(feature) {\n    const layer = this.findLayerOfFeature_(feature);\n    if (!this.layerFilter_(layer)) {\n      return false;\n    }\n    const selected = this.selectFeatureInternal_(feature, layer);\n    if (selected) {\n      this.dispatchEvent(\n        new SelectEvent(SelectEventType.SELECT, [selected], [], undefined),\n      );\n    }\n    return !!selected;\n  }\n\n  /**\n   * Deselects a feature if it was previously selected. Also removes layer association.\n   * @param {import(\"../Feature.js\").FeatureLike} feature The feature to deselect\n   * @param {Array<Feature>} [deselected] optional array to which deselected features will be added\n   * @return {Feature|undefined} The feature, if it was previously selected.\n   * @private\n   */\n  removeFeatureInternal_(feature, deselected) {\n    const features = this.getFeatures();\n    if (\n      !(feature instanceof Feature) ||\n      !features.getArray().includes(feature)\n    ) {\n      return;\n    }\n    features.remove(feature);\n    this.removeFeatureLayerAssociation_(feature);\n    deselected?.push(feature);\n    return feature;\n  }\n\n  /**\n   * Try to deselect a feature as if it was clicked.\n   * Compared to `select.getFeatures().remove(feature)` this causes a SelectEvent.\n   * The {@link module:ol/interaction/Select~SelectEvent} fired by this won't have a mapBrowserEvent property\n   * @param {Feature} feature The feature to deselect\n   * @return {boolean} True if the feature was deselected\n   */\n  deselectFeature(feature) {\n    const deselected = this.removeFeatureInternal_(feature);\n    if (deselected) {\n      this.dispatchEvent(\n        new SelectEvent(SelectEventType.SELECT, [], [deselected], undefined),\n      );\n    }\n    return !!deselected;\n  }\n\n  /**\n   * Try to toggle a feature as if it was clicked and `toggleCondition` was True.\n   * Unlike modifying `select.getFeatures()` directly, this respects the `filter` and `layers` options (except `multi`, which is ignored).\n   * The {@link module:ol/interaction/Select~SelectEvent} fired by this won't have a mapBrowserEvent property\n   * @param {Feature} feature The feature to deselect\n   */\n  toggleFeature(feature) {\n    if (!this.deselectFeature(feature)) {\n      this.selectFeature(feature);\n    }\n  }\n  /**\n   * Deselect all features as if a user deselected them.\n   * Compared to `select.getFeatures().clear()` this causes a SelectEvent.\n   * The {@link module:ol/interaction/Select~SelectEvent} fired by this won't have a mapBrowserEvent property\n   */\n  clearSelection() {\n    clear(this.featureLayerAssociation_);\n    const features = this.getFeatures();\n    const deselected = features.getArray().slice(); // shallow copy\n    features.clear();\n    if (deselected.length !== 0) {\n      this.dispatchEvent(\n        new SelectEvent(SelectEventType.SELECT, [], deselected, undefined),\n      );\n    }\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the\n   * selected state of features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @override\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    const add = this.addCondition_(mapBrowserEvent);\n    const remove = this.removeCondition_(mapBrowserEvent);\n    const toggle = this.toggleCondition_(mapBrowserEvent);\n    const set = !add && !remove && !toggle;\n    const map = mapBrowserEvent.map;\n    const features = this.getFeatures();\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const deselected = [];\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const selected = [];\n\n    // TODO: technically the way i've restructured this logic means that\n    //       instead of first emptying the features list of all extra features and then adding the selected ones back,\n    //       the selected features get added and then the old ones get removed.\n    //       a grow then shrink, instead of a shrink then grow. I can't imagine anyone relying on this, but alas, its worth a mention.\n    if (set) {\n      // Replace the currently selected feature(s) with the feature(s) at the\n      // pixel, or clear the selected feature(s) if there is no feature at\n      // the pixel.\n      let foundAtCursor = false;\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        (feature, layer) => {\n          foundAtCursor = true;\n          if (!this.selectFeatureInternal_(feature, layer, selected)) {\n            return; // keep going, this one wasn't selected\n          }\n          return !this.multi_; // stop if not multi\n        },\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        },\n      );\n\n      for (let i = features.getLength() - 1; i >= 0; --i) {\n        const feature = features.item(i);\n        if (\n          // remove all but selected, if there were any selected\n          (selected.length > 0 && !selected.includes(feature)) ||\n          // remove all, if click outside of layer\n          !foundAtCursor\n        ) {\n          this.removeFeatureInternal_(feature, deselected);\n        }\n      }\n    } else {\n      // Modify the currently selected feature(s).\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        (feature, layer) => {\n          let modifiedFeature;\n          if (remove || toggle) {\n            modifiedFeature = this.removeFeatureInternal_(feature, deselected);\n          }\n          if ((add || toggle) && !modifiedFeature) {\n            modifiedFeature = this.selectFeatureInternal_(\n              feature,\n              layer,\n              selected,\n            );\n          }\n          if (!modifiedFeature) {\n            return; // keep going, this one wasn't removed/selected\n          }\n          return !this.multi_; // stop if not multi\n        },\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        },\n      );\n    }\n    if (selected.length > 0 || deselected.length > 0) {\n      this.dispatchEvent(\n        new SelectEvent(\n          SelectEventType.SELECT,\n          selected,\n          deselected,\n          mapBrowserEvent,\n        ),\n      );\n    }\n    return true;\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  extend(styles['Polygon'], styles['LineString']);\n  extend(styles['GeometryCollection'], styles['LineString']);\n\n  return function (feature) {\n    if (!feature.getGeometry()) {\n      return null;\n    }\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\nexport default Select;\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new i32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return { b: b, r: r };\n};\nvar _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8)) >> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 1; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    return new u8(v.subarray(s, e));\n};\n/**\n * Codes for errors generated within this library\n */\nexport var FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, st, buf, dict) {\n    // source length       dict length\n    var sl = dat.length, dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l)\n        return buf || new u8(0);\n    var noBuf = !buf;\n    // have to estimate size\n    var resize = noBuf || st.i != 2;\n    // no state\n    var noSt = st.i;\n    // Assumes roughly 33% compression ratio average\n    if (noBuf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (resize)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17\n        if (resize)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (resize)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                if (bt < dt) {\n                    var shift = dl - dt, dend = Math.min(dt, end);\n                    if (shift + bt < 0)\n                        err(3);\n                    for (; bt < dend; ++bt)\n                        buf[bt] = dict[shift + bt];\n                }\n                for (; bt < end; ++bt)\n                    buf[bt] = buf[bt - dt];\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    // don't reallocate for streams or user buffers\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n    d[o + 2] |= v >> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return { t: et, l: 0 };\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return { t: v, l: 1 };\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return { t: new u8(tr), l: mbt };\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return { c: cl.subarray(0, cli), n: s };\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;\n    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;\n    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;\n    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        ++lcfreq[lclt[i] & 31];\n    for (var i = 0; i < lcdt.length; ++i)\n        ++lcfreq[lcdt[i] & 31];\n    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];\n    if (bs >= 0 && flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >> 5) & 127), p += clct[i] >> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        var sym = syms[i];\n        if (sym > 255) {\n            var len = (sym >> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (sym >> 23) & 31), p += fleb[len];\n            var dst = sym & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (sym >> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[sym]), p += ll[sym];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, st) {\n    var s = st.z || dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var lst = st.l;\n    var pos = (st.r || 0) & 7;\n    if (lvl) {\n        if (pos)\n            w[0] = st.r >> 3;\n        var opt = deo[lvl - 1];\n        var n = opt >> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new i32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos\n        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;\n        for (; i + 2 < s; ++i) {\n            // hash value\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = i - dif + j & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one int32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        for (i = Math.max(i, wi); i < s; ++i) {\n            syms[li++] = dat[i];\n            ++lf[dat[i]];\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        if (!lst) {\n            st.r = (pos & 7) | w[(pos / 8) | 0] << 3;\n            // shft(pos) now 1 less if pos & 7 != 0\n            pos -= 7;\n            st.h = head, st.p = prev, st.i = i, st.w = wi;\n        }\n    }\n    else {\n        for (var i = st.w || 0; i < s + lst; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[(pos / 8) | 0] = lst;\n                e = s;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n        st.i = s;\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Adler32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | (b >> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    if (!st) {\n        st = { l: 1 };\n        if (opt.dictionary) {\n            var dict = opt.dictionary.subarray(-32768);\n            var newDat = new u8(dict.length + dat.length);\n            newDat.set(dict);\n            newDat.set(dat, dict.length);\n            dat = newDat;\n            st.w = dict.length;\n        }\n    }\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? (st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20) : (12 + opt.mem), pre, post, st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return fnStr;\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            fnStr = wcln(fns[i], fnStr, td_1);\n        ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };\n    }\n    var td = mrg({}, ch[id].e);\n    return wk(ch[id].c + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt]; };\nvar bDflt = function () { return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zls]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get opts\nvar gopt = function (o) { return o && {\n    out: o.size && new u8(o.size),\n    dictionary: o.dictionary\n}; };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) {\n        if (ev.data.length) {\n            strm.push(ev.data[0], ev.data[1]);\n            postMessage([ev.data[0].length]);\n        }\n        else\n            strm.flush();\n    };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id, flush, ext) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else if (!Array.isArray(dat))\n            ext(dat);\n        else if (dat.length == 1) {\n            strm.queuedSize -= dat[0];\n            if (strm.ondrain)\n                strm.ondrain(dat[0]);\n        }\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.queuedSize = 0;\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        strm.queuedSize += d.length;\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n    if (flush) {\n        strm.flush = function () { w.postMessage([]); };\n    }\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + (o.filename ? o.filename.length + 1 : 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (o.dictionary && 32);\n    c[1] |= 31 - ((c[0] << 8) | c[1]) % 31;\n    if (o.dictionary) {\n        var h = adler();\n        h.p(o.dictionary);\n        wbytes(c, 2, h.d());\n    }\n};\n// zlib start\nvar zls = function (d, dict) {\n    if ((d[0] & 15) != 8 || (d[0] >> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if ((d[1] >> 5 & 1) == +!dict)\n        err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');\n    return (d[1] >> 3 & 4) + 2;\n};\nfunction StrmOpt(opts, cb) {\n    if (typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n        this.s = { l: 0, i: 32768, w: 32768, z: 32768 };\n        // Buffer length must always be 0 mod 32768 for index calculations to be correct when modifying head and prev\n        // 98304 = 32768 (lookback) + 65536 (common chunk size)\n        this.b = new u8(98304);\n        if (this.o.dictionary) {\n            var dict = this.o.dictionary.subarray(-32768);\n            this.b.set(dict, 32768 - dict.length);\n            this.s.i = 32768 - dict.length;\n        }\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, this.s), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        var endLen = chunk.length + this.s.z;\n        if (endLen > this.b.length) {\n            if (endLen > 2 * this.b.length - 32768) {\n                var newBuf = new u8(endLen & -32768);\n                newBuf.set(this.b.subarray(0, this.s.z));\n                this.b = newBuf;\n            }\n            var split = this.b.length - this.s.z;\n            this.b.set(chunk.subarray(0, split), this.s.z);\n            this.s.z = this.b.length;\n            this.p(this.b, false);\n            this.b.set(this.b.subarray(-32768));\n            this.b.set(chunk.subarray(split), 32768);\n            this.s.z = chunk.length - split + 32768;\n            this.s.i = 32766, this.s.w = 32768;\n        }\n        else {\n            this.b.set(chunk, this.s.z);\n            this.s.z += chunk.length;\n        }\n        this.s.l = final & 1;\n        if (this.s.z > this.s.w + 8191 || final) {\n            this.p(this.b, final || false);\n            this.s.w = this.s.i, this.s.i -= 2;\n        }\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * deflated output for small inputs.\n     */\n    Deflate.prototype.flush = function () {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        this.p(this.b, false);\n        this.s.w = this.s.i, this.s.i -= 2;\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6, 1);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    function Inflate(opts, cb) {\n        // no StrmOpt here to avoid adding to workerizer\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n        this.s = { i: 0, b: dict ? dict.length : 0 };\n        this.o = new u8(32768);\n        this.p = new u8(0);\n        if (dict)\n            this.o.set(dict);\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        if (!this.p.length)\n            this.p = c;\n        else if (c.length) {\n            var n = new u8(this.p.length + c.length);\n            n.set(this.p), n.set(c, this.p.length), this.p = n;\n        }\n    };\n    Inflate.prototype.c = function (final) {\n        this.s.i = +(this.d = final || false);\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.s, this.o);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    function AsyncInflate(opts, cb) {\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Inflate(ev.data);\n            onmessage = astrm(strm);\n        }, 7, 0);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gopt(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, opts) {\n    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        this.l += chunk.length;\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * GZIPped output for small inputs.\n     */\n    Gzip.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8, 1);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming single or multi-member GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    function Gunzip(opts, cb) {\n        this.v = 1;\n        this.r = 0;\n        Inflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        this.r += chunk.length;\n        if (this.v) {\n            var p = this.p.subarray(this.v - 1);\n            var s = p.length > 3 ? gzs(p) : 4;\n            if (s > p.length) {\n                if (!final)\n                    return;\n            }\n            else if (this.v > 1 && this.onmember) {\n                this.onmember(this.r - p.length);\n            }\n            this.p = p.subarray(s), this.v = 0;\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n        // process concatenated GZIP\n        if (this.s.f && !this.s.l && !final) {\n            this.v = shft(this.s.p) + 9;\n            this.s = { i: 0 };\n            this.o = new u8(0);\n            this.push(new u8(0), final);\n        }\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming single or multi-member GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    function AsyncGunzip(opts, cb) {\n        var _this = this;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gunzip(ev.data);\n            strm.onmember = function (offset) { return postMessage(offset); };\n            onmessage = astrm(strm);\n        }, 9, 0, function (offset) { return _this.onmember && _this.onmember(offset); });\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0], ev.data[1])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, opts) {\n    var st = gzs(data);\n    if (st + 8 > data.length)\n        err(6, 'invalid gzip data');\n    return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * zlibbed output for small inputs.\n     */\n    Zlib.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10, 1);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    function Unzlib(opts, cb) {\n        Inflate.call(this, opts, cb);\n        this.v = opts && opts.dictionary ? 2 : 1;\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 6 && !final)\n                return;\n            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    function AsyncUnzlib(opts, cb) {\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Unzlib(ev.data);\n            onmessage = astrm(strm);\n        }, 11, 0);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gopt(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, opts) {\n    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    function Decompress(opts, cb) {\n        this.o = StrmOpt.call(this, opts, cb) || {};\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n    }\n    // init substream\n    // overriden by AsyncDecompress\n    Decompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (dat, final) {\n            _this.ondata(dat, final);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(this.o)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(this.o)\n                        : new this.Z(this.o);\n                this.i();\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    function AsyncDecompress(opts, cb) {\n        Decompress.call(this, opts, cb);\n        this.queuedSize = 0;\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n    }\n    AsyncDecompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        };\n        this.s.ondrain = function (size) {\n            _this.queuedSize -= size;\n            if (_this.ondrain)\n                _this.ondrain(size);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        this.queuedSize += chunk.length;\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, opts) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, opts)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, opts)\n            : unzlibSync(data, opts);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return { s: r, r: slc(d, i - 1) };\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (final) {\n            if (r.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = r;\n        this.ondata(s, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td) {\n        return td.decode(dat);\n    }\n    else {\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (r.length)\n            err(8);\n        return s;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this.ondata(err, dat, final);\n                    _this.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this.d & 1))\n                        return;\n                    _this.u.splice(-1, 1);\n                    _this.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this = this;\n        this.i = new Inflate(function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this.k[0] == chks_3 && _this.c)\n                                        _this.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nexport function unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    // Synchronously decompress under 512KB, or barely-compressed data\n                    if (su < 524288 || sc > 0.8 * su) {\n                        try {\n                            cbl(null, inflateSync(infl, { out: new u8(su) }));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nexport function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n","var j=Object.defineProperty;var B=Math.pow;var l=(o,t)=>j(o,\"name\",{value:t,configurable:!0});var m=(o,t,e)=>new Promise((r,n)=>{var s=c=>{try{a(e.next(c))}catch(u){n(u)}},i=c=>{try{a(e.throw(c))}catch(u){n(u)}},a=c=>c.done?r(c.value):Promise.resolve(c.value).then(s,i);a((e=e.apply(o,t)).next())});import{decompressSync as F}from\"fflate\";var re=l((o,t)=>{let e=!1,r=\"\",n=L.GridLayer.extend({createTile:l((s,i)=>{let a=document.createElement(\"img\"),c=new AbortController,u=c.signal;return a.cancel=()=>{c.abort()},e||(o.getHeader().then(d=>{d.tileType===1?console.error(\"Error: archive contains MVT vector tiles, but leafletRasterLayer is for displaying raster tiles. See https://github.com/protomaps/PMTiles/tree/main/js for details.\"):d.tileType===2?r=\"image/png\":d.tileType===3?r=\"image/jpeg\":d.tileType===4?r=\"image/webp\":d.tileType===5&&(r=\"image/avif\")}),e=!0),o.getZxy(s.z,s.x,s.y,u).then(d=>{if(d){let h=new Blob([d.data],{type:r}),p=window.URL.createObjectURL(h);a.src=p}else a.style.display=\"none\";a.cancel=void 0,i(void 0,a)}).catch(d=>{if(d.name!==\"AbortError\")throw d}),a},\"createTile\"),_removeTile:l(function(s){let i=this._tiles[s];i&&(i.el.cancel&&i.el.cancel(),i.el.width=0,i.el.height=0,i.el.deleted=!0,L.DomUtil.remove(i.el),delete this._tiles[s],this.fire(\"tileunload\",{tile:i.el,coords:this._keyToTileCoords(s)}))},\"_removeTile\")});return new n(t)},\"leafletRasterLayer\"),W=l(o=>(t,e)=>{if(e instanceof AbortController)return o(t,e);let r=new AbortController;return o(t,r).then(n=>e(void 0,n.data,n.cacheControl||\"\",n.expires||\"\"),n=>e(n)).catch(n=>e(n)),{cancel:l(()=>r.abort(),\"cancel\")}},\"v3compat\"),E=class E{constructor(t){this.tilev4=l((t,e)=>m(this,null,function*(){if(t.type===\"json\"){let p=t.url.substr(10),y=this.tiles.get(p);if(y||(y=new w(p),this.tiles.set(p,y)),this.metadata){let z=yield y.getTileJson(t.url);return e.signal.throwIfAborted(),{data:z}}let f=yield y.getHeader();return e.signal.throwIfAborted(),(f.minLon>=f.maxLon||f.minLat>=f.maxLat)&&console.error(`Bounds of PMTiles archive ${f.minLon},${f.minLat},${f.maxLon},${f.maxLat} are not valid.`),{data:{tiles:[`${t.url}/{z}/{x}/{y}`],minzoom:f.minZoom,maxzoom:f.maxZoom,bounds:[f.minLon,f.minLat,f.maxLon,f.maxLat]}}}let r=new RegExp(/pmtiles:\\/\\/(.+)\\/(\\d+)\\/(\\d+)\\/(\\d+)/),n=t.url.match(r);if(!n)throw new Error(\"Invalid PMTiles protocol URL\");let s=n[1],i=this.tiles.get(s);i||(i=new w(s),this.tiles.set(s,i));let a=n[2],c=n[3],u=n[4],d=yield i.getHeader(),h=yield i==null?void 0:i.getZxy(+a,+c,+u,e.signal);if(e.signal.throwIfAborted(),h)return{data:new Uint8Array(h.data),cacheControl:h.cacheControl,expires:h.expires};if(d.tileType===1){if(this.errorOnMissingTile)throw new Error(\"Tile not found.\");return{data:new Uint8Array}}return{data:null}}),\"tilev4\");this.tile=W(this.tilev4);this.tiles=new Map,this.metadata=(t==null?void 0:t.metadata)||!1,this.errorOnMissingTile=(t==null?void 0:t.errorOnMissingTile)||!1}add(t){this.tiles.set(t.source.getKey(),t)}get(t){return this.tiles.get(t)}};l(E,\"Protocol\");var S=E;function b(o,t){return(t>>>0)*4294967296+(o>>>0)}l(b,\"toNum\");function N(o,t){let e=t.buf,r=e[t.pos++],n=(r&112)>>4;if(r<128||(r=e[t.pos++],n|=(r&127)<<3,r<128)||(r=e[t.pos++],n|=(r&127)<<10,r<128)||(r=e[t.pos++],n|=(r&127)<<17,r<128)||(r=e[t.pos++],n|=(r&127)<<24,r<128)||(r=e[t.pos++],n|=(r&1)<<31,r<128))return b(o,n);throw new Error(\"Expected varint not more than 10 bytes\")}l(N,\"readVarintRemainder\");function x(o){let t=o.buf,e=t[o.pos++],r=e&127;return e<128||(e=t[o.pos++],r|=(e&127)<<7,e<128)||(e=t[o.pos++],r|=(e&127)<<14,e<128)||(e=t[o.pos++],r|=(e&127)<<21,e<128)?r:(e=t[o.pos],r|=(e&15)<<28,N(r,o))}l(x,\"readVarint\");function k(o,t,e,r,n){return n===0?r!==0?[o-1-e,o-1-t]:[e,t]:[t,e]}l(k,\"rotate\");function q(o,t,e){if(o>26)throw new Error(\"Tile zoom level exceeds max safe number limit (26)\");if(t>=1<<o||e>=1<<o)throw new Error(\"tile x/y outside zoom level bounds\");let r=((1<<o)*(1<<o)-1)/3,n=o-1,[s,i]=[t,e];for(let a=1<<n;a>0;a>>=1){let c=s&a,u=i&a;r+=(3*c^u)*(1<<n),[s,i]=k(a,s,i,c,u),n--}return r}l(q,\"zxyToTileId\");function G(o){let t=3*o+1;return t<4294967296?31-Math.clz32(t):63-Math.clz32(t/4294967296)}l(G,\"tileIdToZ\");function ie(o){let t=G(o)>>1;if(t>26)throw new Error(\"Tile zoom level exceeds max safe number limit (26)\");let e=((1<<t)*(1<<t)-1)/3,r=o-e,n=0,s=0,i=1<<t;for(let a=1;a<i;a<<=1){let c=a&r/2,u=a&(r^c);[n,s]=k(a,n,s,c,u),r=r/2,n+=c,s+=u}return[t,n,s]}l(ie,\"tileIdToZxy\");var J=(s=>(s[s.Unknown=0]=\"Unknown\",s[s.None=1]=\"None\",s[s.Gzip=2]=\"Gzip\",s[s.Brotli=3]=\"Brotli\",s[s.Zstd=4]=\"Zstd\",s))(J||{});function D(o,t){return m(this,null,function*(){if(t===1||t===0)return o;if(t===2){if(typeof globalThis.DecompressionStream==\"undefined\")return F(new Uint8Array(o));let e=new Response(o).body;if(!e)throw new Error(\"Failed to read response stream\");let r=e.pipeThrough(new globalThis.DecompressionStream(\"gzip\"));return new Response(r).arrayBuffer()}throw new Error(\"Compression method not supported\")})}l(D,\"defaultDecompress\");var O=(a=>(a[a.Unknown=0]=\"Unknown\",a[a.Mvt=1]=\"Mvt\",a[a.Png=2]=\"Png\",a[a.Jpeg=3]=\"Jpeg\",a[a.Webp=4]=\"Webp\",a[a.Avif=5]=\"Avif\",a[a.Mlt=6]=\"Mlt\",a))(O||{});function _(o){return o===1?\".mvt\":o===2?\".png\":o===3?\".jpg\":o===4?\".webp\":o===5?\".avif\":o===6?\".mlt\":\"\"}l(_,\"tileTypeExt\");var Y=127;function Q(o,t){let e=0,r=o.length-1;for(;e<=r;){let n=r+e>>1,s=t-o[n].tileId;if(s>0)e=n+1;else if(s<0)r=n-1;else return o[n]}return r>=0&&(o[r].runLength===0||t-o[r].tileId<o[r].runLength)?o[r]:null}l(Q,\"findTile\");var A=class A{constructor(t){this.file=t}getKey(){return this.file.name}getBytes(t,e){return m(this,null,function*(){return{data:yield this.file.slice(t,t+e).arrayBuffer()}})}};l(A,\"FileSource\");var V=A,C=class C{constructor(t,e=new Headers){var i,a;this.url=t,this.customHeaders=e,this.mustReload=!1;let r=\"\";\"navigator\"in globalThis&&(r=(a=(i=globalThis.navigator)==null?void 0:i.userAgent)!=null?a:\"\");let n=r.indexOf(\"Windows\")>-1,s=/Chrome|Chromium|Edg|OPR|Brave/.test(r);this.chromeWindowsNoCache=!1,n&&s&&(this.chromeWindowsNoCache=!0)}getKey(){return this.url}setHeaders(t){this.customHeaders=t}getBytes(t,e,r,n){return m(this,null,function*(){let s,i;r?i=r:(s=new AbortController,i=s.signal);let a=new Headers(this.customHeaders);a.set(\"range\",`bytes=${t}-${t+e-1}`);let c;this.mustReload?c=\"reload\":this.chromeWindowsNoCache&&(c=\"no-store\");let u=yield fetch(this.url,{signal:i,cache:c,headers:a});if(t===0&&u.status===416){let y=u.headers.get(\"Content-Range\");if(!y||!y.startsWith(\"bytes */\"))throw new Error(\"Missing content-length on 416 response\");let f=+y.substr(8);u=yield fetch(this.url,{signal:i,cache:\"reload\",headers:{range:`bytes=0-${f-1}`}})}let d=u.headers.get(\"Etag\");if(d!=null&&d.startsWith(\"W/\")&&(d=null),u.status===416||n&&d&&d!==n)throw this.mustReload=!0,new v(`Server returned non-matching ETag ${n} after one retry. Check browser extensions and servers for issues that may affect correct ETag headers.`);if(u.status>=300)throw new Error(`Bad response code: ${u.status}`);let h=u.headers.get(\"Content-Length\");if(u.status===200&&(!h||+h>e))throw s&&s.abort(),new Error(\"Server returned no content-length header or content-length exceeding request. Check that your storage backend supports HTTP Byte Serving.\");return{data:yield u.arrayBuffer(),etag:d||void 0,cacheControl:u.headers.get(\"Cache-Control\")||void 0,expires:u.headers.get(\"Expires\")||void 0}})}};l(C,\"FetchSource\");var T=C;function g(o,t){let e=o.getUint32(t+4,!0),r=o.getUint32(t+0,!0);return e*B(2,32)+r}l(g,\"getUint64\");function X(o,t){let e=new DataView(o),r=e.getUint8(7);if(r>3)throw new Error(`Archive is spec version ${r} but this library supports up to spec version 3`);return{specVersion:r,rootDirectoryOffset:g(e,8),rootDirectoryLength:g(e,16),jsonMetadataOffset:g(e,24),jsonMetadataLength:g(e,32),leafDirectoryOffset:g(e,40),leafDirectoryLength:g(e,48),tileDataOffset:g(e,56),tileDataLength:g(e,64),numAddressedTiles:g(e,72),numTileEntries:g(e,80),numTileContents:g(e,88),clustered:e.getUint8(96)===1,internalCompression:e.getUint8(97),tileCompression:e.getUint8(98),tileType:e.getUint8(99),minZoom:e.getUint8(100),maxZoom:e.getUint8(101),minLon:e.getInt32(102,!0)/1e7,minLat:e.getInt32(106,!0)/1e7,maxLon:e.getInt32(110,!0)/1e7,maxLat:e.getInt32(114,!0)/1e7,centerZoom:e.getUint8(118),centerLon:e.getInt32(119,!0)/1e7,centerLat:e.getInt32(123,!0)/1e7,etag:t}}l(X,\"bytesToHeader\");function Z(o){let t={buf:new Uint8Array(o),pos:0},e=x(t),r=[],n=0;for(let s=0;s<e;s++){let i=x(t);r.push({tileId:n+i,offset:0,length:0,runLength:1}),n+=i}for(let s=0;s<e;s++)r[s].runLength=x(t);for(let s=0;s<e;s++)r[s].length=x(t);for(let s=0;s<e;s++){let i=x(t);i===0&&s>0?r[s].offset=r[s-1].offset+r[s-1].length:r[s].offset=i-1}return r}l(Z,\"deserializeIndex\");var U=class U extends Error{};l(U,\"EtagMismatch\");var v=U;function I(o,t){return m(this,null,function*(){let e=yield o.getBytes(0,16384);if(new DataView(e.data).getUint16(0,!0)!==19792)throw new Error(\"Wrong magic number for PMTiles archive\");let n=e.data.slice(0,Y),s=X(n,e.etag),i=e.data.slice(s.rootDirectoryOffset,s.rootDirectoryOffset+s.rootDirectoryLength),a=`${o.getKey()}|${s.etag||\"\"}|${s.rootDirectoryOffset}|${s.rootDirectoryLength}`,c=Z(yield t(i,s.internalCompression));return[s,[a,c.length,c]]})}l(I,\"getHeaderAndRoot\");function K(o,t,e,r,n){return m(this,null,function*(){let s=yield o.getBytes(e,r,void 0,n.etag),i=yield t(s.data,n.internalCompression),a=Z(i);if(a.length===0)throw new Error(\"Empty directory is invalid\");return a})}l(K,\"getDirectory\");var R=class R{constructor(t=100,e=!0,r=D){this.cache=new Map,this.maxCacheEntries=t,this.counter=1,this.decompress=r}getHeader(t){return m(this,null,function*(){let e=t.getKey(),r=this.cache.get(e);if(r)return r.lastUsed=this.counter++,r.data;let n=yield I(t,this.decompress);return n[1]&&this.cache.set(n[1][0],{lastUsed:this.counter++,data:n[1][2]}),this.cache.set(e,{lastUsed:this.counter++,data:n[0]}),this.prune(),n[0]})}getDirectory(t,e,r,n){return m(this,null,function*(){let s=`${t.getKey()}|${n.etag||\"\"}|${e}|${r}`,i=this.cache.get(s);if(i)return i.lastUsed=this.counter++,i.data;let a=yield K(t,this.decompress,e,r,n);return this.cache.set(s,{lastUsed:this.counter++,data:a}),this.prune(),a})}prune(){if(this.cache.size>this.maxCacheEntries){let t=1/0,e;this.cache.forEach((r,n)=>{r.lastUsed<t&&(t=r.lastUsed,e=n)}),e&&this.cache.delete(e)}}invalidate(t){return m(this,null,function*(){this.cache.delete(t.getKey())})}};l(R,\"ResolvedValueCache\");var $=R,M=class M{constructor(t=100,e=!0,r=D){this.cache=new Map,this.invalidations=new Map,this.maxCacheEntries=t,this.counter=1,this.decompress=r}getHeader(t){return m(this,null,function*(){let e=t.getKey(),r=this.cache.get(e);if(r)return r.lastUsed=this.counter++,yield r.data;let n=new Promise((s,i)=>{I(t,this.decompress).then(a=>{a[1]&&this.cache.set(a[1][0],{lastUsed:this.counter++,data:Promise.resolve(a[1][2])}),s(a[0]),this.prune()}).catch(a=>{i(a)})});return this.cache.set(e,{lastUsed:this.counter++,data:n}),n})}getDirectory(t,e,r,n){return m(this,null,function*(){let s=`${t.getKey()}|${n.etag||\"\"}|${e}|${r}`,i=this.cache.get(s);if(i)return i.lastUsed=this.counter++,yield i.data;let a=new Promise((c,u)=>{K(t,this.decompress,e,r,n).then(d=>{c(d),this.prune()}).catch(d=>{u(d)})});return this.cache.set(s,{lastUsed:this.counter++,data:a}),a})}prune(){if(this.cache.size>=this.maxCacheEntries){let t=1/0,e;this.cache.forEach((r,n)=>{r.lastUsed<t&&(t=r.lastUsed,e=n)}),e&&this.cache.delete(e)}}invalidate(t){return m(this,null,function*(){let e=t.getKey();if(this.invalidations.get(e))return yield this.invalidations.get(e);this.cache.delete(t.getKey());let r=new Promise((n,s)=>{this.getHeader(t).then(i=>{n(),this.invalidations.delete(e)}).catch(i=>{s(i)})});this.invalidations.set(e,r)})}};l(M,\"SharedPromiseCache\");var P=M,H=class H{constructor(t,e,r){typeof t==\"string\"?this.source=new T(t):this.source=t,r?this.decompress=r:this.decompress=D,e?this.cache=e:this.cache=new P}getHeader(){return m(this,null,function*(){return yield this.cache.getHeader(this.source)})}getZxyAttempt(t,e,r,n){return m(this,null,function*(){let s=q(t,e,r),i=yield this.cache.getHeader(this.source);if(t<i.minZoom||t>i.maxZoom)return;let a=i.rootDirectoryOffset,c=i.rootDirectoryLength;for(let u=0;u<=3;u++){let d=yield this.cache.getDirectory(this.source,a,c,i),h=Q(d,s);if(h){if(h.runLength>0){let p=yield this.source.getBytes(i.tileDataOffset+h.offset,h.length,n,i.etag);return{data:yield this.decompress(p.data,i.tileCompression),cacheControl:p.cacheControl,expires:p.expires}}a=i.leafDirectoryOffset+h.offset,c=h.length}else return}throw new Error(\"Maximum directory depth exceeded\")})}getZxy(t,e,r,n){return m(this,null,function*(){try{return yield this.getZxyAttempt(t,e,r,n)}catch(s){if(s instanceof v)return this.cache.invalidate(this.source),yield this.getZxyAttempt(t,e,r,n);throw s}})}getMetadataAttempt(){return m(this,null,function*(){let t=yield this.cache.getHeader(this.source),e=yield this.source.getBytes(t.jsonMetadataOffset,t.jsonMetadataLength,void 0,t.etag),r=yield this.decompress(e.data,t.internalCompression),n=new TextDecoder(\"utf-8\");return JSON.parse(n.decode(r))})}getMetadata(){return m(this,null,function*(){try{return yield this.getMetadataAttempt()}catch(t){if(t instanceof v)return this.cache.invalidate(this.source),yield this.getMetadataAttempt();throw t}})}getTileJson(t){return m(this,null,function*(){let e=yield this.getHeader(),r=yield this.getMetadata(),n=_(e.tileType);return{tilejson:\"3.0.0\",scheme:\"xyz\",tiles:[`${t}/{z}/{x}/{y}${n}`],vector_layers:r.vector_layers,attribution:r.attribution,description:r.description,name:r.name,version:r.version,bounds:[e.minLon,e.minLat,e.maxLon,e.maxLat],center:[e.centerLon,e.centerLat,e.centerZoom],minzoom:e.minZoom,maxzoom:e.maxZoom}})}};l(H,\"PMTiles\");var w=H;export{J as Compression,v as EtagMismatch,T as FetchSource,V as FileSource,w as PMTiles,S as Protocol,$ as ResolvedValueCache,P as SharedPromiseCache,O as TileType,X as bytesToHeader,Q as findTile,g as getUint64,re as leafletRasterLayer,x as readVarint,ie as tileIdToZxy,_ as tileTypeExt,q as zxyToTileId};\n//# sourceMappingURL=index.js.map","var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/index.ts\nimport {\n  default as DataTileSource\n} from \"ol/source/DataTile.js\";\nimport TileState from \"ol/TileState.js\";\nimport { MVT } from \"ol/format.js\";\nimport {\n  default as VectorTileSource\n} from \"ol/source/VectorTile.js\";\nimport { createXYZ, extentFromProjection } from \"ol/tilegrid.js\";\nimport { PMTiles } from \"pmtiles\";\nvar _PMTilesRasterSource = class _PMTilesRasterSource extends DataTileSource {\n  constructor(options) {\n    super(__spreadValues(__spreadValues({}, options), {\n      state: \"loading\"\n    }));\n    this.loadImage = /* @__PURE__ */ __name((src) => {\n      return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.addEventListener(\"load\", () => resolve(img));\n        img.addEventListener(\"error\", () => reject(new Error(\"load failed\")));\n        img.src = src;\n      });\n    }, \"loadImage\");\n    const p = new PMTiles(options.url);\n    p.getHeader().then((h) => {\n      const projection = options.projection === void 0 ? \"EPSG:3857\" : options.projection;\n      this.tileGrid = options.tileGrid || createXYZ({\n        extent: extentFromProjection(projection),\n        maxResolution: options.maxResolution,\n        minZoom: h.minZoom,\n        maxZoom: h.maxZoom,\n        tileSize: options.tileSize\n      });\n      this.setLoader((z, x, y) => __async(this, null, function* () {\n        const response = yield p.getZxy(z, x, y);\n        if (!response) {\n          return new Uint8Array();\n        }\n        const src = URL.createObjectURL(new Blob([response.data]));\n        const image = yield this.loadImage(src);\n        URL.revokeObjectURL(src);\n        return image;\n      }));\n      this.setState(\"ready\");\n    });\n  }\n};\n__name(_PMTilesRasterSource, \"PMTilesRasterSource\");\nvar PMTilesRasterSource = _PMTilesRasterSource;\nvar _PMTilesVectorSource = class _PMTilesVectorSource extends VectorTileSource {\n  constructor(options) {\n    super(__spreadValues(__spreadValues({}, options), {\n      state: \"loading\",\n      url: \"pmtiles://{z}/{x}/{y}\",\n      format: options.format || new MVT()\n    }));\n    this.tileLoadFunction = /* @__PURE__ */ __name((tile, url) => {\n      const vtile = tile;\n      const re = new RegExp(/pmtiles:\\/\\/(\\d+)\\/(\\d+)\\/(\\d+)/);\n      const result = url.match(re);\n      if (!(result && result.length >= 4)) {\n        throw Error(\"Could not parse tile URL\");\n      }\n      const z = +result[1];\n      const x = +result[2];\n      const y = +result[3];\n      vtile.setLoader(\n        (extent, resolution, projection) => {\n          this.pmtiles_.getZxy(z, x, y).then((tile_result) => {\n            if (tile_result) {\n              const format = vtile.getFormat();\n              vtile.setFeatures(\n                format.readFeatures(tile_result.data, {\n                  extent,\n                  featureProjection: projection\n                })\n              );\n              vtile.setState(TileState.LOADED);\n            } else {\n              vtile.setFeatures([]);\n              vtile.setState(TileState.EMPTY);\n            }\n          }).catch((err) => {\n            vtile.setFeatures([]);\n            vtile.setState(TileState.ERROR);\n          });\n        }\n      );\n    }, \"tileLoadFunction\");\n    this.pmtiles_ = new PMTiles(options.url);\n    this.pmtiles_.getHeader().then((h) => {\n      const projection = options.projection || \"EPSG:3857\";\n      const extent = options.extent || extentFromProjection(projection);\n      this.tileGrid = options.tileGrid || createXYZ({\n        extent,\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom !== void 0 ? options.maxZoom : h.maxZoom,\n        minZoom: h.minZoom,\n        tileSize: options.tileSize || 512\n      });\n      this.setTileLoadFunction(this.tileLoadFunction);\n      this.setState(\"ready\");\n    });\n  }\n};\n__name(_PMTilesVectorSource, \"PMTilesVectorSource\");\nvar PMTilesVectorSource = _PMTilesVectorSource;\nexport {\n  PMTilesRasterSource,\n  PMTilesVectorSource\n};\n//# sourceMappingURL=index.js.map","/**\n * @module ol/events/ErrorEvent\n */\nimport BaseEvent from 'ol/events/Event.js';\nimport EventType from 'ol/events/EventType.js';\n/**\n * @classdesc\n * Event emitted on configuration or loading error.\n * @api\n */\nclass ErrorEvent extends BaseEvent {\n    /**\n     * @param {Error} error error object.\n     * @api\n     */\n    constructor(error) {\n        super(EventType.ERROR);\n        /**\n         * @type {Error}\n         * @api\n         */\n        this.error = error;\n    }\n}\nexport default ErrorEvent;\n//# sourceMappingURL=ErrorEvent.js.map","/**\n * @module ol/util\n */\nimport VectorLayer from 'ol/layer/Vector.js';\nimport { isRegistered as isProj4Registered } from 'ol/proj/proj4.js';\nimport Circle from 'ol/style/Circle.js';\nimport Fill from 'ol/style/Fill.js';\nimport Stroke from 'ol/style/Stroke.js';\nimport Style from 'ol/style/Style.js';\nimport { STAC } from 'stac-js';\n/**\n * @typedef {import('ol/colorlike.js').ColorLike} ColorLike\n */\n/**\n * @typedef {import('ol/Collection.js').default} Collection\n * @template T\n */\n/**\n * @typedef {import('ol/Feature.js').default} Feature\n */\n/**\n * @typedef {import('ol/proj.js').Projection} Projection\n */\n/**\n * @typedef {import('ol/proj.js').ProjectionLike} ProjectionLike\n */\n/**\n * The pattern for the supported versions of the label extension.\n * @type {string}\n */\nexport const LABEL_EXTENSION = 'https://stac-extensions.github.io/label/v1.*/schema.json';\nconst transparentFill = new Fill({ color: 'rgba(0,0,0,0)' });\n/**\n * Creates a style for visualization.\n *\n * @param {ColorLike} strokeColor Stroke color\n * @param {number} strokeWidth Stroke with\n * @param {ColorLike} fillColor Fill color\n * @param {number} circleRadius Circle/Point radius\n * @return {Style} The style for visualization.\n * @api\n */\nexport function getStyle(strokeColor, strokeWidth, fillColor = 'rgba(255,255,255,0.4)', circleRadius = 5) {\n    let fill = transparentFill;\n    if (fillColor) {\n        fill = new Fill({\n            color: fillColor,\n        });\n    }\n    const stroke = new Stroke({\n        color: strokeColor,\n        width: strokeWidth,\n    });\n    return new Style({\n        image: new Circle({\n            fill,\n            stroke,\n            radius: circleRadius,\n        }),\n        fill,\n        stroke,\n    });\n}\n/**\n * The default style for rendering bounds of the STAC main entities.\n * @type {Style}\n * @api\n */\nexport const defaultBoundsStyle = getStyle('#3399CC', 3);\n/**\n * The default style for rendering collection list children.\n * @type {Style}\n * @api\n */\nexport const defaultCollectionStyle = getStyle('#ff9933', 2, null);\n/**\n * Get the STAC objects associated with this event, if any. Excludes API Collections.\n * @param {import('ol/MapBrowserEvent.js').default} event The asset to read the information from.\n * @param {STAC} [exclude] Excludes the given STAC entity from the list.\n * @param {Collection<Feature>} [selectedFeatures] A collection to add the selected features to.\n * @param {number} [hitTolerance] The hit tolerance in pixels.\n * @return {Promise<Array<STAC>>} A list of STAC objects\n * @api\n */\nexport async function getStacObjectsForEvent(event, exclude = null, selectedFeatures = null, hitTolerance = 0) {\n    const objects = new Set();\n    event.map.forEachFeatureAtPixel(event.pixel, \n    // Callback for all features that were found\n    (feature, layer) => {\n        if (selectedFeatures) {\n            selectedFeatures.push(feature);\n        }\n        objects.add(layer.get('stac'));\n    }, {\n        // Options for forEachFeatureAtPixel\n        hitTolerance,\n        // Filter the layers upfront, this ensures the presence of a STAC object\n        // so that we don't need to check in the callback above\n        layerFilter(layer) {\n            if (layer instanceof VectorLayer && layer.get('bounds') === true) {\n                const stac = layer.get('stac');\n                if (stac instanceof STAC && (!exclude || !stac.equals(exclude))) {\n                    return true;\n                }\n            }\n            return false;\n        },\n    });\n    return [...objects];\n}\n/**\n * Get the source info for the GeoTiff from the asset.\n * @param {import('stac-js').Asset} asset The asset to read the information from.\n * @param {Array<number>} selectedBands The (one-based) bands to show.\n * @return {import('ol/source/GeoTIFF.js').SourceInfo} The source info for the GeoTiff asset\n */\nexport function getGeoTiffSourceInfoFromAsset(asset, selectedBands) {\n    const sourceInfo = {\n        url: asset.getAbsoluteUrl(),\n    };\n    let source = asset;\n    let bands = asset.getBands();\n    // If there's just one band, we can also read the information from there.\n    if (bands.length === 1) {\n        source = bands[0];\n        bands = [];\n    }\n    // TODO: It would be useful if OL would allow min/max values per band\n    const { minimum, maximum } = source.getMinMaxValues();\n    if (typeof minimum === 'number') {\n        sourceInfo.min = minimum;\n    }\n    if (typeof maximum === 'number') {\n        sourceInfo.max = maximum;\n    }\n    if (typeof sourceInfo.min !== 'number' &&\n        typeof sourceInfo.max !== 'number' &&\n        bands.length > 1) {\n        // Read from bands as fallback and if available\n        for (const band of bands) {\n            const { minimum, maximum } = band.getMinMaxValues();\n            if (typeof minimum === 'number' &&\n                (typeof sourceInfo.min === 'undefined' || minimum < sourceInfo.min)) {\n                sourceInfo.min = minimum;\n            }\n            if (typeof maximum === 'number' &&\n                (typeof sourceInfo.max === 'undefined' || maximum > sourceInfo.max)) {\n                sourceInfo.max = maximum;\n            }\n        }\n    }\n    // TODO: It would be useful if OL would allow multiple no-data values\n    const nodata = source.getNoDataValues();\n    if (nodata.length > 0) {\n        sourceInfo.nodata = nodata[0];\n    }\n    else if (bands.length > 1) {\n        // Read from bands as fallback and if available\n        let nodata = undefined;\n        for (const band of bands) {\n            const bandNoData = band.getNoDataValues();\n            if (bandNoData.length > 0) {\n                if (typeof nodata === 'undefined') {\n                    nodata = bandNoData[0];\n                }\n                else if (nodata !== bandNoData[0]) {\n                    nodata = undefined;\n                    break;\n                }\n            }\n        }\n        if (typeof nodata !== 'undefined') {\n            sourceInfo.nodata = nodata;\n        }\n    }\n    if (selectedBands.length > 0) {\n        sourceInfo.bands = selectedBands;\n    }\n    else {\n        const visualBands = asset.findVisualBands();\n        if (visualBands) {\n            sourceInfo.bands = [\n                visualBands.red.getIndex() + 1,\n                visualBands.green.getIndex() + 1,\n                visualBands.blue.getIndex() + 1,\n            ];\n        }\n    }\n    return sourceInfo;\n}\n/**\n * Load the projection for the given projection code from the internet.\n *\n * @param {string} code Projection code, e.g. 'EPSG:1234'\n * @return {Promise<Projection|null>} The loaded projection\n */\nexport async function loadProjection(code) {\n    try {\n        // @ts-ignore - Support both old and new OpenLayers versions\n        const { fromProjectionCode, fromEPSGCode } = await import('ol/proj/proj4.js');\n        if (typeof fromProjectionCode === 'function') {\n            // Supported since ol v10.8.0\n            return await fromProjectionCode(code);\n        }\n        // Supported until ol v11.0.0\n        return await fromEPSGCode(code);\n    }\n    catch (_) {\n        return null;\n    }\n}\n/**\n * Gets the projection from the asset or link.\n * @param {import('stac-js').STACReference} reference The asset or link to read the information from.\n * @param {ProjectionLike} defaultProjection A default projection to use.\n * @return {Promise<ProjectionLike>} The projection, if any.\n */\nexport async function getProjection(reference, defaultProjection = undefined) {\n    let projection;\n    if (isProj4Registered()) {\n        // TODO: It would be great to handle WKT2 and PROJJSON, but is not supported yet by proj4js.\n        const code = reference.getMetadata('proj:code');\n        if (code) {\n            projection = await loadProjection(code);\n        }\n    }\n    return projection || defaultProjection;\n}\n/**\n * Returns the style for the footprint.\n * Removes the fill if anything is meant to be shown in the bounds.\n *\n * @param {Style} [originalStyle] The original style for the footprint.\n * @param {import('./layer/STAC.js').default} [layerGroup] The associated STAC layergroup to check.\n * @return {Style} The adapted style for the footprint.\n * @api\n */\nexport function getBoundsStyle(originalStyle, layerGroup) {\n    const style = originalStyle.clone();\n    if (!layerGroup.hasOnlyBounds()) {\n        style.setFill(transparentFill);\n    }\n    return style;\n}\n/**\n * Get a URL from a web-map-link that is specific enough, i.e.\n * replaces any occurances of {s} if possible, otherwise returns null.\n * @param {import('./layer/STAC.js').Link} link The web map link.\n * @return {string|null} Specific URL\n */\nexport function getSpecificWebMapUrl(link) {\n    let url = link.href;\n    if (url.includes('{s}')) {\n        if (Array.isArray(link['href:servers']) &&\n            link['href:servers'].length > 0) {\n            const i = (Math.random() * link['href:servers'].length) | 0;\n            url = url.replace('{s}', link['href:servers'][i]);\n        }\n        else {\n            return null;\n        }\n    }\n    return url;\n}\n/**\n * Checks whether the given value is a scalar (string, number, boolean).\n * @param {*} value The value to check\n * @return {boolean} `true` is the value is a scalar, `false` otherwise\n */\nexport function isScalar(value) {\n    return (typeof value === 'string' ||\n        typeof value === 'number' ||\n        typeof value === 'boolean');\n}\n//# sourceMappingURL=util.js.map","/**\n * @module ol/source/GeoTIFF\n */\nimport { Pool, fromBlob as tiffFromBlob, fromUrl as tiffFromUrl, fromUrls as tiffFromUrls, globals as geotiffGlobals, } from 'geotiff';\nimport { error as logError } from 'ol/console.js';\nimport { applyTransform, getCenter, getIntersection } from 'ol/extent.js';\nimport { clamp } from 'ol/math.js';\nimport { fromCode as unitsFromCode } from 'ol/proj/Units.js';\nimport { Projection, createTransformFromCoordinateTransform, get as getCachedProjection, toUserCoordinate, toUserExtent, } from 'ol/proj.js';\nimport DataTile from 'ol/source/DataTile.js';\nimport TileGrid from 'ol/tilegrid/TileGrid.js';\nimport { apply as applyMatrix, create as createMatrix, makeInverse, multiply as multiplyTransform, } from 'ol/transform.js';\nimport { loadProjection } from '../util.js';\n/**\n * Determine if an image type is a mask.\n * See https://www.awaresystems.be/imaging/tiff/tifftags/newsubfiletype.html\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} The image is a mask.\n */\nfunction isMask(image) {\n    const fileDirectory = image.fileDirectory;\n    const type = fileDirectory.NewSubfileType || 0;\n    return (type & 4) === 4;\n}\n/**\n * @param {true|false|'auto'} preference The convertToRGB option.\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} Use the `image.readRGB()` method.\n */\nfunction readRGB(preference, image) {\n    if (!preference) {\n        return false;\n    }\n    if (preference === true) {\n        return true;\n    }\n    if (image.getSamplesPerPixel() !== 3) {\n        return false;\n    }\n    const interpretation = image.fileDirectory.PhotometricInterpretation;\n    const interpretations = geotiffGlobals.photometricInterpretations;\n    return (interpretation === interpretations.CMYK ||\n        interpretation === interpretations.YCbCr ||\n        interpretation === interpretations.CIELab ||\n        interpretation === interpretations.ICCLab);\n}\n/**\n * @typedef {Object} SourceInfo\n * @property {string} [url] URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.\n * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n/**\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\n */\n/**\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\n */\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\nconst STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nconst STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\nconst defaultTileSize = 256;\n/**\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\n */\nlet workerPool;\nfunction getWorkerPool() {\n    if (!workerPool) {\n        workerPool = new Pool();\n    }\n    return workerPool;\n}\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\nfunction getBoundingBox(image) {\n    try {\n        return image.getBoundingBox(true);\n    }\n    catch (_a) {\n        return [0, 0, image.getWidth(), image.getHeight()];\n    }\n}\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\nfunction getOrigin(image) {\n    try {\n        return image.getOrigin().slice(0, 2);\n    }\n    catch (_a) {\n        return [0, image.getHeight()];\n    }\n}\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {Array<number>} The map x and y units per pixel.\n */\nfunction getResolutions(image, referenceImage) {\n    try {\n        return image.getResolution(referenceImage);\n    }\n    catch (_a) {\n        return [\n            referenceImage.getWidth() / image.getWidth(),\n            referenceImage.getHeight() / image.getHeight(),\n        ];\n    }\n}\n/**\n * @async\n * @param {Object<string, any>} geoKeys Geo keys object.\n * @param {string} geoKey The geo key to lookup.\n * @param {string} unitKey The unit key to lookup.\n * @param {boolean} loadMissingProjection Whether to load missing projections.\n * @return {Promise<Projection|null>} The projection.\n */\nasync function getProjectionFromKeys(geoKeys, geoKey, unitKey, loadMissingProjection) {\n    const value = geoKeys[geoKey];\n    if (value && value !== 32767) {\n        const code = 'EPSG:' + value;\n        let projection = getCachedProjection(code);\n        if (!projection && loadMissingProjection) {\n            projection = await loadProjection(code);\n        }\n        if (!projection) {\n            const units = unitsFromCode(geoKeys[unitKey]);\n            if (units) {\n                projection = new Projection({\n                    code: code,\n                    units: units,\n                });\n            }\n        }\n        return projection || null;\n    }\n}\n/**\n * @async\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @param {boolean} loadMissingProjection Whether to load missing projections.\n * @return {Promise<Projection|null>} The image projection.\n */\nasync function getProjection(image, loadMissingProjection) {\n    const geoKeys = image.geoKeys;\n    if (!geoKeys) {\n        return null;\n    }\n    const projection = await getProjectionFromKeys(geoKeys, 'ProjectedCSTypeGeoKey', 'ProjLinearUnitsGeoKey', loadMissingProjection);\n    if (projection) {\n        return projection;\n    }\n    return await getProjectionFromKeys(geoKeys, 'GeographicTypeGeoKey', 'GeogAngularUnitsGeoKey', loadMissingProjection);\n}\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForTIFF(tiff) {\n    return tiff.getImageCount().then(function (count) {\n        const requests = new Array(count);\n        for (let i = 0; i < count; ++i) {\n            requests[i] = tiff.getImage(i);\n        }\n        return Promise.all(requests);\n    });\n}\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @param {Object} options Options for the GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForSource(source, options) {\n    let request;\n    if (source.blob) {\n        request = tiffFromBlob(source.blob);\n    }\n    else if (source.overviews) {\n        request = tiffFromUrls(source.url, source.overviews, options);\n    }\n    else {\n        request = tiffFromUrl(source.url, options);\n    }\n    return request.then(getImagesForTIFF);\n}\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n    if (Array.isArray(expected)) {\n        const length = expected.length;\n        if (!Array.isArray(got) || length != got.length) {\n            const error = new Error(message);\n            rejector(error);\n            throw error;\n        }\n        for (let i = 0; i < length; ++i) {\n            assertEqual(expected[i], got[i], tolerance, message, rejector);\n        }\n        return;\n    }\n    got = /** @type {number} */ (got);\n    if (Math.abs(expected - got) > tolerance * expected) {\n        throw new Error(message);\n    }\n}\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\nfunction getMinForDataType(array) {\n    if (array instanceof Int8Array) {\n        return -128;\n    }\n    if (array instanceof Int16Array) {\n        return -32768;\n    }\n    if (array instanceof Int32Array) {\n        return -2147483648;\n    }\n    if (array instanceof Float32Array) {\n        return 1.2e-38;\n    }\n    return 0;\n}\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\nfunction getMaxForDataType(array) {\n    if (array instanceof Int8Array) {\n        return 127;\n    }\n    if (array instanceof Uint8Array) {\n        return 255;\n    }\n    if (array instanceof Uint8ClampedArray) {\n        return 255;\n    }\n    if (array instanceof Int16Array) {\n        return 32767;\n    }\n    if (array instanceof Uint16Array) {\n        return 65535;\n    }\n    if (array instanceof Int32Array) {\n        return 2147483647;\n    }\n    if (array instanceof Uint32Array) {\n        return 4294967295;\n    }\n    if (array instanceof Float32Array) {\n        return 3.4e38;\n    }\n    return 255;\n}\n/**\n * @typedef {Object} GeoTIFFSourceOptions\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\n * @property {string} [credentials] How credentials shall be handled. See\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\n * By default only a single range is used.\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\n * requested. Only use this when you know the source image to be small enough to fit in memory.\n * @property {number} [blockSize=65536] The block size to use.\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\n */\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\n * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,\n * CIELab, and ICCLab images will automatically be converted to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {import(\"ol/proj.js\").ProjectionLike} [projection] Source projection.  If not provided, the GeoTIFF metadata\n * will be read for projection information.\n * @property {boolean} [loadMissingProjection=false] Whether to attempt to load missing projection definitions.\n * Uses the configured EPSG lookup function, which can be set with {@link module:ol/proj/proj4.setEPSGLookup}.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * **Note for users of the full build**: The `GeoTIFF` source requires the\n * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.\n *\n * @api\n */\nclass GeoTIFFSource extends DataTile {\n    /**\n     * @param {Options} options Data tile options.\n     */\n    constructor(options) {\n        super({\n            state: 'loading',\n            tileGrid: null,\n            projection: options.projection || null,\n            transition: options.transition,\n            interpolate: options.interpolate !== false,\n            wrapX: options.wrapX,\n        });\n        /**\n         * @type {Array<SourceInfo>}\n         * @private\n         */\n        this.sourceInfo_ = options.sources;\n        const numSources = this.sourceInfo_.length;\n        /**\n         * @type {Object}\n         * @private\n         */\n        this.sourceOptions_ = options.sourceOptions;\n        /**\n         * @type {Array<Array<GeoTIFFImage>>}\n         * @private\n         */\n        this.sourceImagery_ = new Array(numSources);\n        /**\n         * @type {Array<Array<GeoTIFFImage>>}\n         * @private\n         */\n        this.sourceMasks_ = new Array(numSources);\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        this.resolutionFactors_ = new Array(numSources);\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        this.samplesPerPixel_;\n        /**\n         * @type {Array<Array<number>>}\n         * @private\n         */\n        this.nodataValues_;\n        /**\n         * @type {Array<Array<GDALMetadata>>}\n         * @private\n         */\n        this.metadata_;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.normalize_ = options.normalize !== false;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.addAlpha_ = false;\n        /**\n         * @type {Error}\n         * @private\n         */\n        this.error_ = null;\n        /**\n         * @type {true|false|'auto'}\n         * @private\n         */\n        this.convertToRGB_ = options.convertToRGB || false;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.loadMissingProjection_ = options.loadMissingProjection || false;\n        this.setKey(this.sourceInfo_.map((source) => source.url).join(','));\n        const self = this;\n        const requests = new Array(numSources);\n        for (let i = 0; i < numSources; ++i) {\n            requests[i] = getImagesForSource(this.sourceInfo_[i], this.sourceOptions_);\n        }\n        Promise.all(requests)\n            .then(function (sources) {\n            return self.configure_(sources);\n        })\n            .catch(function (error) {\n            logError(error);\n            self.error_ = error;\n            self.setState('error');\n        });\n    }\n    /**\n     * @return {Error} A source loading error. When the source state is `error`, use this function\n     * to get more information about the error. To debug a faulty configuration, you may want to use\n     * a listener like\n     * ```js\n     * geotiffSource.on('change', () => {\n     *   if (geotiffSource.getState() === 'error') {\n     *     console.error(geotiffSource.getError());\n     *   }\n     * });\n     * ```\n     */\n    getError() {\n        return this.error_;\n    }\n    /**\n     * Determine the projection of the images in this GeoTIFF.\n     * The default implementation looks at the ProjectedCSTypeGeoKey and the GeographicTypeGeoKey\n     * of each image in turn.\n     * You can override this method in a subclass to support more projections.\n     *\n     * @async\n     * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n     * from a single GeoTIFF.\n     */\n    async determineProjection(sources) {\n        const firstSource = sources[0];\n        for (let i = firstSource.length - 1; i >= 0; --i) {\n            const image = firstSource[i];\n            const projection = await getProjection(image, this.loadMissingProjection_);\n            if (projection) {\n                this.projection = projection;\n                break;\n            }\n        }\n    }\n    /**\n     * Determine any transform matrix for the images in this GeoTIFF.\n     *\n     * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n     * from a single GeoTIFF.\n     */\n    determineTransformMatrix(sources) {\n        const firstSource = sources[0];\n        for (let i = firstSource.length - 1; i >= 0; --i) {\n            const image = firstSource[i];\n            const modelTransformation = image.fileDirectory.ModelTransformation;\n            if (modelTransformation) {\n                // eslint-disable-next-line no-unused-vars\n                const [a, b, c, d, e, f, g, h] = modelTransformation;\n                const matrix = multiplyTransform(multiplyTransform([\n                    1 / Math.sqrt(a * a + e * e),\n                    0,\n                    0,\n                    -1 / Math.sqrt(b * b + f * f),\n                    d,\n                    h,\n                ], [a, e, b, f, 0, 0]), [1, 0, 0, 1, -d, -h]);\n                this.transformMatrix = matrix;\n                this.addAlpha_ = true;\n                break;\n            }\n        }\n    }\n    /**\n     * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n     * must have the same internal tiled structure.\n     * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n     * from a single GeoTIFF.\n     * @private\n     * @async\n     */\n    async configure_(sources) {\n        let extent;\n        let origin;\n        let commonRenderTileSizes;\n        let commonSourceTileSizes;\n        let resolutions;\n        const samplesPerPixel = new Array(sources.length);\n        const nodataValues = new Array(sources.length);\n        const metadata = new Array(sources.length);\n        let minZoom = 0;\n        const sourceCount = sources.length;\n        for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n            const images = [];\n            const masks = [];\n            sources[sourceIndex].forEach((item) => {\n                if (isMask(item)) {\n                    masks.push(item);\n                }\n                else {\n                    images.push(item);\n                }\n            });\n            const imageCount = images.length;\n            if (masks.length > 0 && masks.length !== imageCount) {\n                throw new Error(`Expected one mask per image found ${masks.length} masks and ${imageCount} images`);\n            }\n            let sourceExtent;\n            let sourceOrigin;\n            const sourceTileSizes = new Array(imageCount);\n            const renderTileSizes = new Array(imageCount);\n            const sourceResolutions = new Array(imageCount);\n            nodataValues[sourceIndex] = new Array(imageCount);\n            metadata[sourceIndex] = new Array(imageCount);\n            for (let imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\n                const image = images[imageIndex];\n                const nodataValue = image.getGDALNoData();\n                metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\n                nodataValues[sourceIndex][imageIndex] = nodataValue;\n                const wantedSamples = this.sourceInfo_[sourceIndex].bands;\n                samplesPerPixel[sourceIndex] = wantedSamples\n                    ? wantedSamples.length\n                    : image.getSamplesPerPixel();\n                const level = imageCount - (imageIndex + 1);\n                if (!sourceExtent) {\n                    sourceExtent = getBoundingBox(image);\n                }\n                if (!sourceOrigin) {\n                    sourceOrigin = getOrigin(image);\n                }\n                const imageResolutions = getResolutions(image, images[0]);\n                sourceResolutions[level] = imageResolutions[0];\n                const sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\n                // request larger blocks for untiled layouts\n                if (sourceTileSize[0] !== sourceTileSize[1] &&\n                    sourceTileSize[1] < defaultTileSize) {\n                    sourceTileSize[0] = defaultTileSize;\n                    sourceTileSize[1] = defaultTileSize;\n                }\n                sourceTileSizes[level] = sourceTileSize;\n                const aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\n                renderTileSizes[level] = [\n                    sourceTileSize[0],\n                    sourceTileSize[1] / aspectRatio,\n                ];\n            }\n            if (!extent) {\n                extent = sourceExtent;\n            }\n            else {\n                getIntersection(extent, sourceExtent, extent);\n            }\n            if (!origin) {\n                origin = sourceOrigin;\n            }\n            else {\n                const message = `Origin mismatch for source ${sourceIndex}, got [${sourceOrigin}] but expected [${origin}]`;\n                assertEqual(origin, sourceOrigin, 0, message, this.viewRejector);\n            }\n            if (!resolutions) {\n                resolutions = sourceResolutions;\n                this.resolutionFactors_[sourceIndex] = 1;\n            }\n            else {\n                if (resolutions.length - minZoom > sourceResolutions.length) {\n                    minZoom = resolutions.length - sourceResolutions.length;\n                }\n                const resolutionFactor = resolutions[resolutions.length - 1] /\n                    sourceResolutions[sourceResolutions.length - 1];\n                this.resolutionFactors_[sourceIndex] = resolutionFactor;\n                const scaledSourceResolutions = sourceResolutions.map((resolution) => (resolution *= resolutionFactor));\n                const message = `Resolution mismatch for source ${sourceIndex}, got [${scaledSourceResolutions}] but expected [${resolutions}]`;\n                assertEqual(resolutions.slice(minZoom, resolutions.length), scaledSourceResolutions, 0.02, message, this.viewRejector);\n            }\n            if (!commonRenderTileSizes) {\n                commonRenderTileSizes = renderTileSizes;\n            }\n            else {\n                assertEqual(commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length), renderTileSizes, 0.01, `Tile size mismatch for source ${sourceIndex}`, this.viewRejector);\n            }\n            if (!commonSourceTileSizes) {\n                commonSourceTileSizes = sourceTileSizes;\n            }\n            else {\n                assertEqual(commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length), sourceTileSizes, 0, `Tile size mismatch for source ${sourceIndex}`, this.viewRejector);\n            }\n            this.sourceImagery_[sourceIndex] = images.reverse();\n            this.sourceMasks_[sourceIndex] = masks.reverse();\n        }\n        for (let i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n            const sourceImagery = this.sourceImagery_[i];\n            while (sourceImagery.length < resolutions.length) {\n                sourceImagery.unshift(undefined);\n            }\n        }\n        if (!this.getProjection()) {\n            await this.determineProjection(sources);\n        }\n        this.determineTransformMatrix(sources);\n        this.samplesPerPixel_ = samplesPerPixel;\n        this.nodataValues_ = nodataValues;\n        this.metadata_ = metadata;\n        // decide if we need to add an alpha band to handle nodata\n        outer: for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n            // option 1: source is configured with a nodata value\n            if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\n                this.addAlpha_ = true;\n                break;\n            }\n            if (this.sourceMasks_[sourceIndex].length) {\n                this.addAlpha_ = true;\n                break;\n            }\n            const values = nodataValues[sourceIndex];\n            // option 2: check image metadata for limited bands\n            const bands = this.sourceInfo_[sourceIndex].bands;\n            if (bands) {\n                for (let i = 0; i < bands.length; ++i) {\n                    if (values[bands[i] - 1] !== null) {\n                        this.addAlpha_ = true;\n                        break outer;\n                    }\n                }\n                continue;\n            }\n            // option 3: check image metadata for all bands\n            for (let imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n                if (values[imageIndex] !== null) {\n                    this.addAlpha_ = true;\n                    break outer;\n                }\n            }\n        }\n        let bandCount = this.addAlpha_ ? 1 : 0;\n        for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n            bandCount += samplesPerPixel[sourceIndex];\n        }\n        this.bandCount = bandCount;\n        const tileGrid = new TileGrid({\n            extent: extent,\n            minZoom: minZoom,\n            origin: origin,\n            resolutions: resolutions,\n            tileSizes: commonRenderTileSizes,\n        });\n        this.tileGrid = tileGrid;\n        this.setTileSizes(commonSourceTileSizes);\n        this.setLoader(this.loadTile_.bind(this));\n        this.setState('ready');\n        const zoom = 1;\n        if (resolutions.length === 2) {\n            resolutions = [resolutions[0], resolutions[1], resolutions[1] / 2];\n        }\n        else if (resolutions.length === 1) {\n            resolutions = [resolutions[0] * 2, resolutions[0], resolutions[0] / 2];\n        }\n        let viewExtent = extent;\n        if (this.transformMatrix) {\n            const matrix = makeInverse(createMatrix(), this.transformMatrix.slice());\n            const transformFn = createTransformFromCoordinateTransform((input) => applyMatrix(matrix, input));\n            viewExtent = applyTransform(extent, transformFn);\n        }\n        this.viewResolver({\n            showFullExtent: true,\n            projection: this.projection,\n            resolutions: resolutions,\n            center: toUserCoordinate(getCenter(viewExtent), this.projection),\n            extent: toUserExtent(viewExtent, this.projection),\n            zoom: zoom,\n        });\n    }\n    /**\n     * @param {number} z The z tile index.\n     * @param {number} x The x tile index.\n     * @param {number} y The y tile index.\n     * @param {import('ol/source/DataTile.js').LoaderOptions} options The loader options.\n     * @return {Promise} The composed tile data.\n     * @private\n     */\n    loadTile_(z, x, y, options) {\n        const sourceTileSize = this.getTileSize(z);\n        const sourceCount = this.sourceImagery_.length;\n        const requests = new Array(sourceCount * 2);\n        const nodataValues = this.nodataValues_;\n        const sourceInfo = this.sourceInfo_;\n        const pool = getWorkerPool();\n        for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n            const source = sourceInfo[sourceIndex];\n            const resolutionFactor = this.resolutionFactors_[sourceIndex];\n            const pixelBounds = [\n                Math.round(x * (sourceTileSize[0] * resolutionFactor)),\n                Math.round(y * (sourceTileSize[1] * resolutionFactor)),\n                Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)),\n                Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor)),\n            ];\n            const image = this.sourceImagery_[sourceIndex][z];\n            let samples;\n            if (source.bands) {\n                samples = source.bands.map(function (bandNumber) {\n                    return bandNumber - 1;\n                });\n            }\n            /** @type {number|Array<number>} */\n            let fillValue;\n            if ('nodata' in source && source.nodata !== null) {\n                fillValue = source.nodata;\n            }\n            else {\n                if (!samples) {\n                    fillValue = nodataValues[sourceIndex];\n                }\n                else {\n                    fillValue = samples.map(function (sampleIndex) {\n                        return nodataValues[sourceIndex][sampleIndex];\n                    });\n                }\n            }\n            const readOptions = {\n                window: pixelBounds,\n                width: sourceTileSize[0],\n                height: sourceTileSize[1],\n                samples: samples,\n                fillValue: fillValue,\n                pool: pool,\n                interleave: false,\n                signal: options.signal,\n            };\n            if (readRGB(this.convertToRGB_, image)) {\n                requests[sourceIndex] = image.readRGB(readOptions);\n            }\n            else {\n                requests[sourceIndex] = image.readRasters(readOptions);\n            }\n            // requests after `sourceCount` are for mask data (if any)\n            const maskIndex = sourceCount + sourceIndex;\n            const mask = this.sourceMasks_[sourceIndex][z];\n            if (!mask) {\n                requests[maskIndex] = Promise.resolve(null);\n                continue;\n            }\n            requests[maskIndex] = mask.readRasters({\n                window: pixelBounds,\n                width: sourceTileSize[0],\n                height: sourceTileSize[1],\n                samples: [0],\n                pool: pool,\n                interleave: false,\n            });\n        }\n        return Promise.all(requests)\n            .then(this.composeTile_.bind(this, sourceTileSize))\n            .catch(function (error) {\n            logError(error);\n            throw error;\n        });\n    }\n    /**\n     * @param {import(\"ol/size.js\").Size} sourceTileSize The source tile size.\n     * @param {Array} sourceSamples The source samples.\n     * @return {import(\"ol/DataTile.js\").Data} The composed tile data.\n     * @private\n     */\n    composeTile_(sourceTileSize, sourceSamples) {\n        const metadata = this.metadata_;\n        const sourceInfo = this.sourceInfo_;\n        const sourceCount = this.sourceImagery_.length;\n        const bandCount = this.bandCount;\n        const samplesPerPixel = this.samplesPerPixel_;\n        const nodataValues = this.nodataValues_;\n        const normalize = this.normalize_;\n        const addAlpha = this.addAlpha_;\n        const pixelCount = sourceTileSize[0] * sourceTileSize[1];\n        const dataLength = pixelCount * bandCount;\n        /** @type {Uint8Array|Float32Array} */\n        let data;\n        if (normalize) {\n            data = new Uint8Array(dataLength);\n        }\n        else {\n            data = new Float32Array(dataLength);\n        }\n        let dataIndex = 0;\n        for (let pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n            let transparent = addAlpha;\n            for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n                const source = sourceInfo[sourceIndex];\n                let min = source.min;\n                let max = source.max;\n                let gain, bias;\n                if (normalize) {\n                    const stats = metadata[sourceIndex][0];\n                    if (min === undefined) {\n                        if (stats && STATISTICS_MINIMUM in stats) {\n                            min = parseFloat(stats[STATISTICS_MINIMUM]);\n                        }\n                        else {\n                            min = getMinForDataType(sourceSamples[sourceIndex][0]);\n                        }\n                    }\n                    if (max === undefined) {\n                        if (stats && STATISTICS_MAXIMUM in stats) {\n                            max = parseFloat(stats[STATISTICS_MAXIMUM]);\n                        }\n                        else {\n                            max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n                        }\n                    }\n                    gain = 255 / (max - min);\n                    bias = -min * gain;\n                }\n                for (let sampleIndex = 0; sampleIndex < samplesPerPixel[sourceIndex]; ++sampleIndex) {\n                    const sourceValue = sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n                    let value;\n                    if (normalize) {\n                        value = clamp(gain * sourceValue + bias, 0, 255);\n                    }\n                    else {\n                        value = sourceValue;\n                    }\n                    if (!addAlpha) {\n                        data[dataIndex] = value;\n                    }\n                    else {\n                        let nodata = source.nodata;\n                        if (nodata === undefined) {\n                            let bandIndex;\n                            if (source.bands) {\n                                bandIndex = source.bands[sampleIndex] - 1;\n                            }\n                            else {\n                                bandIndex = sampleIndex;\n                            }\n                            nodata = nodataValues[sourceIndex][bandIndex];\n                        }\n                        const nodataIsNaN = isNaN(nodata);\n                        if ((!nodataIsNaN && sourceValue !== nodata) ||\n                            (nodataIsNaN && !isNaN(sourceValue))) {\n                            transparent = false;\n                            data[dataIndex] = value;\n                        }\n                    }\n                    dataIndex++;\n                }\n                if (!transparent) {\n                    const maskIndex = sourceCount + sourceIndex;\n                    const mask = sourceSamples[maskIndex];\n                    if (mask && !mask[0][pixelIndex]) {\n                        transparent = true;\n                    }\n                }\n            }\n            if (addAlpha) {\n                if (!transparent) {\n                    data[dataIndex] = 255;\n                }\n                dataIndex++;\n            }\n        }\n        return data;\n    }\n}\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"ol/View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\nGeoTIFFSource.prototype.getView;\nexport default GeoTIFFSource;\n//# sourceMappingURL=GeoTIFF.js.map","/**\n * @module ol/source/type\n */\n/**\n * @typedef {import(\"ol/source/GeoTIFF.js\").Options} GeoTIFFOptions\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_GeoTIFF-GeoTIFFSource.html}\n */\n/**\n * @typedef {import(\"ol/source/ImageStatic.js\").Options} ImageStaticOptions\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_ImageStatic-Static.html}\n */\n/**\n * @typedef {import(\"ol/source/TileJSON.js\").Options} TileJSONOptions\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_TileJSON-TileJSON.html}\n */\n/**\n * @typedef {import(\"ol/source/TileWMS.js\").Options} TileWMSOptions\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_TileWMS-TileWMS.html}\n */\n/**\n * @typedef {import(\"ol/source/WMTS.js\").Options} WMTSOptions\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_WMTS-WMTS.html}\n */\n/**\n * @typedef {import(\"ol/source/XYZ.js\").Options} XYZOptions\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_XYZ-XYZ.html}\n */\n/**\n * @typedef {GeoTIFFOptions|ImageStaticOptions|TileJSONOptions|TileWMSOptions|WMTSOptions|XYZOptions|Object<string, *>} SourceOptions\n */\n/**\n * @classdesc\n * The source type for `getSourceOptions`.\n * @api\n */\nclass SourceType {\n    /**\n     * Creates a new SourceType.\n     * @param {string} name The internal string identifier.\n     * @protected\n     * @api\n     */\n    constructor(name) {\n        this.name = name;\n    }\n    /**\n     * Converts to a string.\n     * @return {string} The internal string identifier.\n     * @api\n     */\n    toString() {\n        return this.name;\n    }\n}\n/**\n * GeoTiff\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_GeoTIFF.html}\n * @api\n */\nSourceType.GeoTIFF = new SourceType('GeoTIFF');\n/**\n * Static Image (`ImageStatic`)\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_ImageStatic.html}\n * @api\n */\nSourceType.ImageStatic = new SourceType('ImageStatic');\n/**\n * PMTilesRaster\n * @see {@link https://protomaps.com/docs/pmtiles/}\n * @api\n */\nSourceType.PMTilesRaster = new SourceType('PMTilesRaster');\n/**\n * GeoTiff\n * @see {@link https://protomaps.com/docs/pmtiles/}\n * @api\n */\nSourceType.PMTilesVector = new SourceType('PMTilesVector');\n/**\n * TileJSON\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_TileJSON.html}\n * @api\n */\nSourceType.TileJSON = new SourceType('TileJSON');\n/**\n * WMS (`TileWMS`)\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_TileWMS.html}\n * @api\n */\nSourceType.TileWMS = new SourceType('TileWMS');\n/**\n * WMTS\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_WMTS.html}\n * @api\n */\nSourceType.WMTS = new SourceType('WMTS');\n/**\n * XYZ\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_XYZ.html}\n * @api\n */\nSourceType.XYZ = new SourceType('XYZ');\nexport default SourceType;\n//# sourceMappingURL=type.js.map","/**\n * @module ol/layer/STAC\n */\nimport { isEmpty } from 'ol/extent.js';\nimport GeoJSON from 'ol/format/GeoJSON.js';\nimport WMTSCapabilities from 'ol/format/WMTSCapabilities.js';\nimport LayerGroup from 'ol/layer/Group.js';\nimport ImageLayer from 'ol/layer/Image.js';\nimport TileLayer from 'ol/layer/Tile.js';\nimport VectorLayer from 'ol/layer/Vector.js';\nimport VectorTileLayer from 'ol/layer/VectorTile.js';\nimport WebGLTileLayer from 'ol/layer/WebGLTile.js';\nimport { transformExtent } from 'ol/proj.js';\n// import GeoTIFF from 'ol/source/GeoTIFF.js';\nimport StaticImage from 'ol/source/ImageStatic.js';\nimport TileJSON from 'ol/source/TileJSON.js';\nimport WMS from 'ol/source/TileWMS.js';\nimport VectorSource from 'ol/source/Vector.js';\nimport VectorTileSource from 'ol/source/VectorTile.js';\nimport WMTS, { optionsFromCapabilities } from 'ol/source/WMTS.js';\nimport XYZ from 'ol/source/XYZ.js';\nimport { PMTilesRasterSource, PMTilesVectorSource } from 'ol-pmtiles';\nimport * as pmtiles from 'pmtiles';\nimport create, { APICollection, Asset, CollectionCollection, Item, ItemCollection, STAC, } from 'stac-js';\nimport { fixGeoJson, toGeoJSON, unionBoundingBox } from 'stac-js/src/geo.js';\nimport { geojsonMediaType } from 'stac-js/src/mediatypes.js';\nimport { isObject } from 'stac-js/src/utils.js';\nimport ErrorEvent from '../events/ErrorEvent.js';\n// todo: temporary fix for https://github.com/openlayers/openlayers/issues/17153\nimport GeoTIFF from '../source/GeoTIFF.js';\nimport SourceType from '../source/type.js';\nimport { LABEL_EXTENSION, defaultBoundsStyle, defaultCollectionStyle, getBoundsStyle, getGeoTiffSourceInfoFromAsset, getProjection, getSpecificWebMapUrl, isScalar, } from '../util.js';\n/**\n * @typedef {import(\"ol/extent.js\").Extent} Extent\n */\n/**\n * @typedef {import(\"ol/layer/Layer.js\").default} Layer\n */\n/**\n * @typedef {import(\"stac-js\").Link} Link\n */\n/**\n * @typedef {import(\"ol/Map.js\").default} Map\n */\n/**\n * @typedef {import('ol/style/Style.js').default} Style\n */\n/**\n * @typedef {import('../source/type.js').SourceOptions} SourceOptions\n */\n/**\n * @typedef {Object} Options\n * @property {string} [url] The STAC URL. Any of `url` and `data` must be provided.\n * Can also be used as url for data, if it is absolute and doesn't contain a self link.\n * Don't use this is you pass in a stac-js object as `data`, set the url manually through\n * `setAbsoluteUrl` on the stac-js object before passing it in.\n * @property {STAC|Asset|Object} [data] The STAC metadata. Any of `url` and `data` must be provided.\n * `data` take precedence over `url`.\n * @property {APICollection|Object|Array<STAC|Object>|null} [children=null] For STAC Catalogs and Collections, any child entites\n * to show. Can be STAC ItemCollections (as ItemCollection or GeoJSON FeatureCollection) or a list of STAC entities.\n * @property {Options} [childrenOptions={}] The the given children, apply the given options.\n * @property {Array<string|Asset>|null} [assets=null] The selector for the assets to be rendered,\n * only for STAC Items and Collections.\n * This can be an array of strings corresponding to asset keys or Asset objects.\n * null shows the default asset, an empty array shows no asset.\n * @property {Array<number>} [bands] The (one-based) bands to show.\n * @property {function(SourceType, SourceOptions, (Asset|Link)):(SourceOptions|Promise<SourceOptions>)} [getSourceOptions]\n * Optional function that can be used to configure the underlying sources. The function can do any additional work\n * and return the completed options or a promise for the same. The function will be called with the current source options\n * and the STAC Asset or Link.\n * This can be useful for adding auth information such as an API token, either via query parameter or HTTP headers.\n * Please be aware that sending HTTP headers may not be supported by all sources.\n * @property {boolean} [displayFootprint=true] Allows to hide the footprints (bounding box/geometry) of the STAC object\n * by default.\n * @property {boolean} [displayGeoTiffByDefault=false] Allow to choose non-cloud-optimized GeoTiffs as default image to show,\n * which might not work well for larger files or larger amounts of files.\n * @property {boolean} [displayPreview=false] Allow to display preview images that a browser can display (e.g. PNG, JPEG),\n * i.e. assets with any of the roles `thumbnail`, `overview`, or a link with relation type `preview`.\n * The previews are usually not covering the full extents and as such may be placed incorrectly on the map.\n * For performance reasons, it is recommended to enable this option if you pass in STAC API Items instead of `displayOverview`.\n * @property {boolean} [displayOverview=true] Allow to display COGs and, if `displayGeoTiffByDefault` is enabled, GeoTiffs,\n * usually an asset with role `overview` or `visual`.\n * @property {string|boolean|Array<Link|string>} [displayWebMapLink=false] Allow to display a layer\n * based on the information provided through the web map links extension.\n * If an array of links or link ids (property `id` in a Link Object) is provided, all corresponding layers will be shown.\n * If set to true or to a specific type of web map link (`pmtiles`, `tilejson`, `wms`, `wmts`, `xyz`),\n * it lets this library choose a web map link to show, but only if no other data is shown.\n * To disable the functionality set this to `false`.\n * @property {Style} [boundsStyle] The style for the overall bounds / footprint.\n * @property {Style} [collectionStyle] The style for individual children in a list of STAC Items or Collections.\n * @property {null|string} [crossOrigin] For thumbnails: The `crossOrigin` attribute for loaded images / tiles.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {function((Asset|Link)):Promise<string>|string|null} [buildTileUrlTemplate=null] A function that generates a URL template for a tile server (XYZ),\n * which will be used instead of the client-side GeoTIFF rendering (except if `useTileLayerAsFallback` is `true`).\n * The function provided can return a promise (i.e. be async) or a string.\n * @property {boolean} [useTileLayerAsFallback=false] Uses the given URL template only when the client-side GeoTIFF rendering fails.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`. `stac` and `bounds` are reserved and may be overridden.\n * @property {boolean} [disableMigration=false] Disable the migration of the STAC object to the latest version.\n * Only enable this if you are sure that the STAC object is already in the latest version.\n * @property {function(string,string):(*)} [httpRequestFn=null] Sets a custom function to make HTTP requests with.\n * The first parameter is the URL to request and the output is a promise that resolves with the response body.\n * The second parameter is the return type, either `json` (default) or `text`.\n */\n/**\n * @classdesc\n * Renders STAC entities such as STAC Items, Collectons or lists of them as returned by APIs.\n * The layers created by this LayerGroup all have a 'stac' value that can be retrieved using `layer.get('stac')`.\n *\n * @extends LayerGroup\n * @fires sourceready\n * @fires layersready\n * @fires ErorEvent#event:error\n * @api\n */\nclass STACLayer extends LayerGroup {\n    /**\n     * @param {Options} options Layer options.\n     * @api\n     */\n    constructor(options) {\n        const superOptions = {};\n        [\n            'opacity',\n            'visible',\n            'zIndex',\n            'minResolution',\n            'maxResolution',\n            'minZoom',\n            'maxZoom',\n            'properties',\n        ].forEach((key) => (superOptions[key] = options[key]));\n        super(superOptions);\n        /**\n         * @type {function(SourceType, SourceOptions, (Asset|Link)):(SourceOptions|Promise<SourceOptions>)}\n         * @private\n         */\n        this.getSourceOptions_ = options.getSourceOptions;\n        /**\n         * @type {Array<STAC>|null}\n         * @private\n         */\n        this.children_ = null;\n        /**\n         * @type {Options}\n         * @private\n         */\n        this.childrenOptions_ = options.childrenOptions || {};\n        /**\n         * @type {Array<Asset>|null}\n         * @private\n         */\n        this.assets_ = null;\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        this.bands_ = [];\n        /**\n         * @type {string|null}\n         * @private\n         */\n        this.crossOrigin_ = options.crossOrigin || null;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.displayFootprint_ = options.displayFootprint === false ? false : true;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.displayGeoTiffByDefault_ = Boolean(options.displayGeoTiffByDefault);\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.displayPreview_ = Boolean(options.displayPreview);\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.displayOverview_ = options.displayOverview === false ? false : true;\n        /**\n         * @type {string|boolean|Array<Link|string>}\n         */\n        this.displayWebMapLink_ = options.displayWebMapLink || false;\n        /**\n         * @type {function((Asset|Link)):Promise<string>|string|null}\n         * @private\n         */\n        this.buildTileUrlTemplate_ = options.buildTileUrlTemplate || null;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.useTileLayerAsFallback_ = options.useTileLayerAsFallback || false;\n        /**\n         * @type {Style}\n         * @private\n         */\n        this.boundsStyle_ = options.boundsStyle || defaultBoundsStyle;\n        /**\n         * @type {Style}\n         * @private\n         */\n        this.collectionStyle_ = options.collectionStyle || defaultCollectionStyle;\n        /**\n         * @type {VectorLayer|null}\n         * @private\n         */\n        this.boundsLayer_ = null;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.disableMigration_ = options.disableMigration || false;\n        /**\n         * @type {Map|null}\n         * @private\n         */\n        this.map_ = null;\n        /**\n         * @type {Array<string|ErrorEvent>}\n         * @private\n         */\n        this.eventQueue_ = [];\n        if (options.httpRequestFn) {\n            this.fetch_ = options.httpRequestFn;\n        }\n        if (options.data) {\n            try {\n                this.configure_(options.data, options.url, options.children, options.assets, options.bands);\n            }\n            catch (error) {\n                this.handleError_(error);\n            }\n            return;\n        }\n        if (!options.url) {\n            throw new Error('Either url or data must be provided');\n        }\n        this.fetch_(options.url)\n            .then((data) => this.configure_(data, options.url, options.children, options.assets, options.bands))\n            .catch((error) => this.handleError_(error));\n    }\n    /**\n     * Default function make HTTP requests with.\n     *\n     * @param {string} url The URL to request and the output is a promise that resolves with the response body.\n     * @param {string} responseType The return type, either `json` (default) or `text`.\n     * @return {Promise<*>} The (parsed) response body.\n     */\n    async fetch_(url, responseType = 'json') {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`Unexpected response from ${url}: ${response.status}`);\n        }\n        if (responseType === 'json') {\n            return await response.json();\n        }\n        if (responseType === 'text') {\n            return await response.text();\n        }\n        return null;\n    }\n    /**\n     * Returns the vector layer that visualizes the bounds / footprint.\n     * @return {VectorLayer|null} The vector layer for the bounds\n     * @api\n     */\n    getBoundsLayer() {\n        return this.boundsLayer_;\n    }\n    /**\n     * Returns `true` if the layer shows nothing.\n     *\n     * This method should be called after the layersready event only.\n     *\n     * @return {boolean} Is the layer empty?\n     * @api\n     */\n    isEmpty() {\n        var _a;\n        const count = this.getLayers().getLength();\n        if (count > 1) {\n            return false;\n        }\n        const bbox = (_a = this.getData()) === null || _a === void 0 ? void 0 : _a.getBoundingBox();\n        if (!bbox || isEmpty(bbox)) {\n            return true;\n        }\n        return !this.boundsLayer_ || !this.displayFootprint_;\n    }\n    /**\n     * @param {Error} error The error.\n     * @private\n     */\n    handleError_(error) {\n        /**\n         * Error event.\n         *\n         * @event ErorEvent#event:error\n         * @type {Object}\n         * @property {Error} error - Provides the original error.\n         */\n        this.dispatch_(new ErrorEvent(error));\n    }\n    /**\n     * @param {STAC|Asset|Object} data The STAC data.\n     * @param {string} url The url to the data.\n     * @param {APICollection|Object|Array<STAC>|string|null} children The child STAC entities to show.\n     * @param {Array<Asset|string>|null} assets The assets to show.\n     * @param {Array<number>} bands The (one-based) bands to show.\n     * @private\n     */\n    configure_(data, url = null, children = null, assets = null, bands = []) {\n        let stac;\n        if (data instanceof Asset || data instanceof STAC) {\n            stac = data;\n        }\n        else {\n            stac = create(data, !this.disableMigration_);\n            if (url && url.includes('://')) {\n                stac.setAbsoluteUrl(url);\n            }\n        }\n        this.set('stac', stac);\n        this.bands_ = bands;\n        this.boundsLayer_ = this.addFootprint_();\n        const updateBoundsStyle = () => {\n            if (this.boundsLayer_) {\n                this.boundsLayer_.setStyle(getBoundsStyle(this.boundsStyle_, this));\n            }\n        };\n        this.getLayers().on('add', updateBoundsStyle);\n        this.getLayers().on('remove', updateBoundsStyle);\n        const errorHandler = (error) => this.handleError_(error);\n        const promises = [];\n        if (children) {\n            promises.push(this.setChildren(children, null, false).catch(errorHandler));\n        }\n        if (assets) {\n            promises.push(this.setAssets(assets, false).catch(errorHandler));\n        }\n        Promise.all(promises).then(() => this.updateLayers().catch(errorHandler));\n        /**\n         * Invoked once the STAC entity is loaded and available.\n         *\n         * @event sourceready\n         */\n        this.dispatch_('sourceready');\n    }\n    /**\n     * Dispatch an event.\n     * Move it to the queue if the map is not yet set.\n     * This is necessary as otherwise some events would be\n     * dispatched before someone could listen to them.\n     *\n     * @param {string|ErrorEvent} event The event.\n     * @private\n     */\n    dispatch_(event) {\n        this.eventQueue_.push(event);\n        this.flush_();\n    }\n    /**\n     * Flush all events.\n     * @private\n     */\n    flush_() {\n        if (this.map_) {\n            for (const event of this.eventQueue_) {\n                this.dispatchEvent(event);\n            }\n            this.eventQueue_ = [];\n        }\n    }\n    /**\n     * Set the map and flush all events.\n     * The events should only be flushed once the map is set, otherwise some\n     * functions such as getExtent() return no meaningul values.\n     *\n     * @param {Map} map The map\n     */\n    setMap_(map) {\n        if (this.map_ === map) {\n            return;\n        }\n        this.map_ = map;\n        this.flush_();\n    }\n    /**\n     * @param {Array<STAC>} collection The list of STAC entities to show.\n     * @param {Options} [options] Options for the children.\n     * @return {Promise} Resolves when complete.\n     * @private\n     */\n    async addChildren_(collection, options = {}) {\n        const promises = collection.map((obj) => {\n            const defaultOptions = {\n                data: obj,\n                crossOrigin: this.crossOrigin_,\n                boundsStyle: this.collectionStyle_,\n                displayGeoTiffByDefault: this.displayGeoTiffByDefault_,\n                displayOverview: this.displayOverview_,\n                displayPreview: this.displayPreview_,\n                displayFootprint: this.displayFootprint_,\n                useTileLayerAsFallback: this.useTileLayerAsFallback_,\n                buildTileUrlTemplate: this.buildTileUrlTemplate_,\n            };\n            const subgroup = new STACLayer(Object.assign(defaultOptions, options));\n            // If no data is given, but items are provided, then we don't get a map from the\n            // footprint layer so we need to get it from this new STAC Layer so that extent\n            // calculations etc. work.\n            // @ts-ignore\n            subgroup.on('sourceready', () => {\n                if (subgroup.map_) {\n                    this.setMap_(subgroup.map_);\n                }\n            });\n            this.addLayer_(subgroup, null);\n            return subgroup;\n        });\n        return await Promise.all(promises);\n    }\n    /**\n     * @param {Asset|Link} [image] A STAC Link or Asset\n     * @return {Promise<ImageLayer|undefined>} Resolves with am ImageLayer or udnefined when complete.\n     * @private\n     */\n    async addPreviewImage_(image) {\n        const projection = await getProjection(image, 'EPSG:4326');\n        const bboxes = image.getContext().getBoundingBoxes();\n        if (bboxes.length !== 1) {\n            return;\n        }\n        const bbox = bboxes[0];\n        /**\n         * @type {import(\"ol/source/ImageStatic.js\").Options}\n         */\n        let options = {\n            url: image.getAbsoluteUrl(),\n            projection,\n            imageExtent: transformExtent(bbox, 'EPSG:4326', projection),\n            crossOrigin: this.crossOrigin_,\n        };\n        if (this.getSourceOptions_) {\n            // @ts-ignore\n            options = await this.getSourceOptions_(SourceType.ImageStatic, options, image);\n        }\n        const layer = new ImageLayer({\n            source: new StaticImage(options),\n        });\n        this.addLayer_(layer, image);\n        return layer;\n    }\n    /**\n     * Adds a layer for a link that implements the web-map-links extension.\n     * Supports: PMTiles, TileJSON, WMS, WMTS, XYZ\n     * @see https://github.com/stac-extensions/web-map-links\n     * @param {Link} link A web map link\n     * @return {Promise<Array<Layer>|undefined>} Resolves with a list of layers or undefined when complete.\n     * @api\n     */\n    async addLayerForLink(link) {\n        // Replace any occurances of {s} if possible, otherwise return\n        const url = getSpecificWebMapUrl(link);\n        if (!url) {\n            return;\n        }\n        const options = {\n            attributions: link.getMetadata('attribution') ||\n                this.getData().getMetadata('attribution'),\n            crossOrigin: this.crossOrigin_,\n            url,\n        };\n        const updateOptions = async (type, options) => {\n            if (this.getSourceOptions_) {\n                options = await this.getSourceOptions_(type, options, link);\n            }\n            return options;\n        };\n        const sources = [];\n        switch (link.rel) {\n            case 'pmtiles':\n                const p = new pmtiles.PMTiles(options.url);\n                const headers = await p.getHeader();\n                let source;\n                switch (headers.tileType) {\n                    case pmtiles.TileType.Mvt:\n                        source = new PMTilesVectorSource(await updateOptions(SourceType.PMTilesVector, options));\n                        break;\n                    case pmtiles.TileType.Avif:\n                    case pmtiles.TileType.Jpeg:\n                    case pmtiles.TileType.Png:\n                    case pmtiles.TileType.Webp:\n                        source = new PMTilesRasterSource(await updateOptions(SourceType.PMTilesRaster, options));\n                        break;\n                    default:\n                        return; // Unsupported\n                }\n                sources.push(source);\n                break;\n            case 'tilejson':\n                sources.push(new TileJSON(await updateOptions(SourceType.TileJSON, options)));\n                break;\n            case 'wms':\n                if (!Array.isArray(link['wms:layers'])) {\n                    break;\n                }\n                for (const i in link['wms:layers']) {\n                    const layers = link['wms:layers'][i] || '';\n                    let styles = '';\n                    if (Array.isArray(link['wms:styles']) &&\n                        typeof link['wms:styles'][i] === 'string') {\n                        styles = link['wms:styles'][i];\n                    }\n                    const params = Object.assign({\n                        LAYERS: layers,\n                        STYLES: styles,\n                    }, link['wms:dimensions']);\n                    if (typeof link['wms:transparent'] === 'boolean') {\n                        params.TRANSPARENT = String(link['wms:transparent']);\n                    }\n                    if (typeof link.type === 'string' && link.type.startsWith('image/')) {\n                        params.FORMAT = link.type;\n                    }\n                    const wmsOptions = await updateOptions(SourceType.TileWMS, Object.assign({}, options, { params }));\n                    sources.push(new WMS(wmsOptions));\n                }\n                break;\n            case 'wmts':\n                const wmtsCapabilities = await this.getWmtsCapabilities_(url, link['wmts:encoding']);\n                if (!wmtsCapabilities) {\n                    return;\n                }\n                let layers = [];\n                if (Array.isArray(link['wmts:layer'])) {\n                    layers = link['wmts:layer'];\n                }\n                else if (typeof link['wmts:layer'] === 'string') {\n                    layers = [link['wmts:layer']];\n                }\n                for (const layer of layers) {\n                    let wmtsOptions = Object.assign({}, options, {\n                        layer,\n                        requestEncoding: link['wmts:encoding'] === 'rest' ? 'REST' : 'KVP',\n                    });\n                    if (typeof link.type === 'string' && link.type.startsWith('image/')) {\n                        wmtsOptions.format = link.type;\n                    }\n                    wmtsOptions = await updateOptions(SourceType.WMTS, wmtsOptions);\n                    const opts = optionsFromCapabilities(wmtsCapabilities, wmtsOptions);\n                    if (opts === null) {\n                        continue;\n                    }\n                    if (typeof link.uriTemplate === 'string') {\n                        let uriTemplate = link.uriTemplate;\n                        const vars = isObject(link.variables) ? link.variables : {};\n                        for (const key in vars) {\n                            const schema = vars[key];\n                            let value;\n                            if (isScalar(schema.const)) {\n                                value = schema.const;\n                            }\n                            else if (isScalar(schema.default)) {\n                                value = schema.default;\n                            }\n                            else if (Array.isArray(schema.enum) && schema.enum.length > 0) {\n                                value = schema.enum[0];\n                            }\n                            if (typeof value !== 'undefined') {\n                                uriTemplate = uriTemplate.replaceAll(`{${key}}`, String(value));\n                            }\n                            else {\n                                continue; // We don't know which value to use, so we can't visualize the layer\n                            }\n                        }\n                        delete opts.urls;\n                        opts.url = uriTemplate;\n                    }\n                    sources.push(new WMTS(opts));\n                }\n                break;\n            case 'xyz':\n                sources.push(new XYZ(await updateOptions(SourceType.XYZ, options)));\n                break;\n            default:\n                return;\n        }\n        return sources.map((source) => {\n            let layer;\n            if (source instanceof VectorTileSource) {\n                layer = new VectorTileLayer({\n                    source,\n                    declutter: true,\n                });\n            }\n            else if (source instanceof PMTilesRasterSource) {\n                layer = new WebGLTileLayer({ source });\n            }\n            else {\n                layer = new TileLayer({ source });\n            }\n            this.addLayer_(layer, link);\n            return layer;\n        });\n    }\n    /**\n     * @param {Asset} [asset] A STAC Asset\n     * @return {Promise<Layer|undefined>} Resolves with a Layer or undefined when complete.\n     * @private\n     */\n    async addGeoTiff_(asset) {\n        if (this.buildTileUrlTemplate_ && !this.useTileLayerAsFallback_) {\n            return await this.addTileLayerForImagery_(asset);\n        }\n        const sourceInfo = getGeoTiffSourceInfoFromAsset(asset, this.bands_);\n        /**\n         * todo: temporary fix for https://github.com/openlayers/openlayers/issues/17153\n         * @type {import(\"../source/GeoTIFF.js\").Options}\n         */\n        let options = {\n            sources: [sourceInfo],\n            convertToRGB: 'auto',\n            loadMissingProjection: true,\n        };\n        const projection = await getProjection(asset);\n        if (projection) {\n            options.projection = projection;\n        }\n        if (this.getSourceOptions_) {\n            // @ts-ignore\n            options = await this.getSourceOptions_(SourceType.GeoTIFF, options, asset);\n        }\n        const source = new GeoTIFF(options);\n        const status = new Promise((resolve, reject) => {\n            source.on('error', reject);\n            source.on('change', () => {\n                // see https://github.com/openlayers/openlayers/issues/14926\n                if (source.getState() === 'error') {\n                    reject(source.getError());\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n        try {\n            await status;\n            const layer = new WebGLTileLayer({ source });\n            this.addLayer_(layer, asset);\n            return layer;\n        }\n        catch (error) {\n            if (this.useTileLayerAsFallback_) {\n                return await this.addTileLayerForImagery_(asset);\n            }\n            this.handleError_(error);\n        }\n    }\n    /**\n     * @param {Asset|Link} [data] A STAC Asset or Link\n     * @return {Promise<TileLayer>} Resolves with a TileLayer when complete.\n     * @private\n     */\n    async addTileLayerForImagery_(data) {\n        let url = this.buildTileUrlTemplate_(data);\n        if (url instanceof Promise) {\n            url = await url;\n        }\n        /**\n         * @type {import(\"ol/source/XYZ.js\").Options}\n         */\n        let options = {\n            crossOrigin: this.crossOrigin_,\n            url,\n        };\n        if (this.getSourceOptions_) {\n            options = await this.getSourceOptions_(SourceType.XYZ, options, data);\n        }\n        const layer = new TileLayer({\n            source: new XYZ(options),\n        });\n        this.addLayer_(layer, data);\n        return layer;\n    }\n    /**\n     * @param {Layer|LayerGroup} [layer] A Layer to add to the LayerGroup\n     * @param {import(\"stac-js\").STACObject} [data] The STAC object, can be any class exposed by stac-js\n     * @param {number} [zIndex] The z-index for the layer\n     * @private\n     */\n    addLayer_(layer, data = null, zIndex = 0) {\n        if (data) {\n            layer.set('stac', data);\n        }\n        layer.setZIndex(zIndex);\n        this.getLayers().push(layer);\n    }\n    /**\n     * @return {VectorLayer|null} The vector layer showing the geometry/bbox.\n     * @private\n     */\n    addFootprint_() {\n        let geojson = null;\n        const data = this.getData();\n        if (data.isItemCollection() || data.isCollectionCollection()) {\n            geojson = toGeoJSON(data.getBoundingBox());\n        }\n        else {\n            geojson = data.toGeoJSON();\n        }\n        if (geojson) {\n            const layer = this.createGeoJsonLayer_(geojson, getBoundsStyle(this.boundsStyle_, this), this.displayFootprint_);\n            layer.set('bounds', true);\n            layer.on('change', () => this.setMap_(layer.getMapInternal()));\n            this.addLayer_(layer, data, 1);\n            return layer;\n        }\n        return null;\n    }\n    /**\n     * @param {Asset} [asset] A STAC Asset\n     * @return {Promise<Layer|undefined>} Resolves with a Layer or undefined when complete.\n     * @private\n     */\n    async addGeoJson_(asset) {\n        try {\n            const geojson = await this.fetch_(asset.getAbsoluteUrl());\n            const layer = this.createGeoJsonLayer_(geojson);\n            this.addLayer_(layer, asset);\n            return layer;\n        }\n        catch (error) {\n            this.handleError_(error);\n        }\n    }\n    /**\n     * Creates a GeoJSON vector layer from the given GeoJSON object.\n     *\n     * @param {GeoJSON} [geojson] The GeoJSON object.\n     * @param {Style} [style] The style for the layer.\n     * @param {boolean} [visible] Whether the layer is visible.\n     * @return {VectorLayer} The new vector layer.\n     * @private\n     */\n    createGeoJsonLayer_(geojson, style = null, visible = true) {\n        const format = new GeoJSON();\n        const source = new VectorSource({\n            format,\n            loader: (extent, resolution, projection) => {\n                geojson = fixGeoJson(geojson);\n                const features = format.readFeatures(geojson, {\n                    featureProjection: projection,\n                });\n                source.addFeatures(features);\n            },\n        });\n        if (!style) {\n            style = defaultCollectionStyle;\n        }\n        return new VectorLayer({ source, style, visible });\n    }\n    /**\n     * Adds GeoJSON labels and GeoTIFF source imagery to the map based on the label extension.\n     *\n     * @return {Promise<Layer|undefined>} The layer added to the map.\n     * @private\n     */\n    async addLabelExtension_() {\n        const data = this.getData();\n        if (!(data instanceof Item)) {\n            return;\n        }\n        // determine the asset with the geojson labels\n        let assets = data.getAssetsWithRoles(['labels', 'labels-vector'], true);\n        let labelAsset;\n        if (assets.length > 1) {\n            labelAsset = assets.find((asset) => asset.roles.includes('labels-vector'));\n        }\n        if (!labelAsset) {\n            labelAsset = data.getAsset('vector_labels');\n        }\n        if (!labelAsset) {\n            assets = data\n                .getAssets()\n                .filter((asset) => asset.type === geojsonMediaType && !asset.roles);\n            if (assets.length === 1) {\n                labelAsset = assets[0];\n            }\n        }\n        // Add the source imagery\n        const sourceLinks = data.getLinksWithRels(['source']);\n        if (labelAsset && sourceLinks.length > 0) {\n            const promises = sourceLinks.map(async (link) => {\n                try {\n                    const response = await this.fetch_(link.getAbsoluteUrl());\n                    const stac = create(response);\n                    return stac;\n                }\n                catch (error) {\n                    this.handleError_(error);\n                    return null;\n                }\n            });\n            const items = (await Promise.all(promises)).filter((item) => item instanceof STAC);\n            await this.addChildren_(items, { displayFootprint: false });\n        }\n        // Add the GeoJSON labels\n        try {\n            await this.addGeoJson_(labelAsset);\n        }\n        catch (error) {\n            this.handleError_(error);\n        }\n    }\n    /**\n     * Update the layers shown manually based on the current configuration.\n     * Usually this doesn't need to be called manually.\n     * @param {boolean} [emit] Whether to emit the `layersready` event once the layers are updated.\n     * @return {Promise} Resolves once the layers are updated.\n     * @api\n     */\n    async updateLayers(emit = true) {\n        // Remove old layers\n        const oldLayers = this.getLayers();\n        for (let i = oldLayers.getLength() - 1; i >= 0; i--) {\n            const layer = oldLayers.item(i);\n            if (layer.get('stac') && !layer.get('bounds')) {\n                oldLayers.removeAt(i);\n            }\n        }\n        // Add layers by priority\n        const data = this.getData();\n        // Show the web map links provided by the user\n        if (Array.isArray(this.displayWebMapLink_)) {\n            const promises = this.getWebMapLinks().map(async (link) => await this.addLayerForLink(link));\n            await Promise.all(promises);\n        }\n        // Show children if provided\n        if (this.children_) {\n            await this.addChildren_(this.children_, this.childrenOptions_);\n        }\n        // Show the assets provided by the user\n        const assets = this.getAssets();\n        if (assets) {\n            const promises = assets.map(async (ref) => {\n                if (!ref) {\n                    return;\n                }\n                if (ref.type === geojsonMediaType) {\n                    return await this.addGeoJson_(ref);\n                }\n                if (ref.isGeoTIFF()) {\n                    return await this.addGeoTiff_(ref);\n                }\n                if (ref.canBrowserDisplayImage()) {\n                    return await this.addPreviewImage_(ref);\n                }\n            });\n            await Promise.all(promises);\n        }\n        // If the user didn't provide any specific asset/map link/children to show,\n        // choose a sensible default visualization\n        if (this.hasOnlyBounds()) {\n            // Show the ItemCollection/CollectionCollection entries\n            if (data instanceof APICollection) {\n                await this.addChildren_(data.getAll(), this.childrenOptions_);\n            }\n            else if (data instanceof STAC) {\n                // Show label extension\n                if (data.isItem() &&\n                    data.supportsExtension(LABEL_EXTENSION) &&\n                    data.getMetadata('label:type') === 'vector') {\n                    await this.addLabelExtension_();\n                    if (emit) {\n                        this.dispatch_('layersready');\n                    }\n                    return;\n                }\n                // Show web map links\n                const links = this.getWebMapLinks();\n                if (links.length > 0) {\n                    await this.addLayerForLink(links[0]);\n                }\n                else {\n                    // Find an asset that we can visualize\n                    const geotiff = data.getDefaultGeoTIFF(true, !this.displayGeoTiffByDefault_);\n                    let layer;\n                    // Try to visualize the default GeoTIFF first\n                    if (geotiff && this.displayOverview_) {\n                        layer = await this.addGeoTiff_(geotiff);\n                    }\n                    // If no GeoTIFF is available or it can't be shown (e.g. error),\n                    // try to visualize the default thumbnail\n                    if (this.displayPreview_ && (!geotiff || !layer)) {\n                        // This may return Links or Assets\n                        const thumbnails = data.getThumbnails(true, 'overview');\n                        if (thumbnails.length > 0) {\n                            await this.addPreviewImage_(thumbnails[0]);\n                        }\n                    }\n                }\n            }\n        }\n        if (emit) {\n            this.dispatch_('layersready');\n        }\n    }\n    /**\n     * Indicates whether the LayerGroup shows only the bounds layer (i.e. no imagery/tile layers).\n     * @return {boolean} `true` if only the bounds layer is shown, `false` otherwise.\n     * @api\n     */\n    hasOnlyBounds() {\n        const boundsLayer = this.getBoundsLayer();\n        const imgLayer = this.getLayersArray().find((layer) => layer !== boundsLayer);\n        return typeof imgLayer === 'undefined';\n    }\n    /**\n     * Returns all potential web map links based on the given value for `displayWebMapLink`.\n     * @return {Array<Link>} An array of links.\n     * @api\n     */\n    getWebMapLinks() {\n        const data = this.getData();\n        if (data instanceof Asset) {\n            return [];\n        }\n        let types = ['xyz', 'tilejson', 'pmtiles', 'wmts', 'wms']; // This also defines the priority\n        if (typeof this.displayWebMapLink_ === 'string') {\n            types = [this.displayWebMapLink_];\n        }\n        let mapLinks = data.getLinksWithRels(types);\n        if (Array.isArray(this.displayWebMapLink_)) {\n            mapLinks = this.displayWebMapLink_\n                .map((link) => {\n                if (typeof link === 'string') {\n                    const match = mapLinks.find((candidate) => candidate.id === link);\n                    if (match) {\n                        return match;\n                    }\n                    return null;\n                }\n                return link;\n            })\n                .filter((link) => !!link);\n        }\n        else {\n            mapLinks.sort((a, b) => {\n                const prioA = types.indexOf(a.rel);\n                const prioB = types.indexOf(b.rel);\n                return prioA - prioB;\n            });\n        }\n        return mapLinks;\n    }\n    /**\n     * Update the assets to be rendered.\n     * @param {Array<string|Asset>|null} assets The assets to show.\n     * @param {boolean} [updateLayers] Whether to update the layers right away.\n     * @return {Promise} Resolves when all assets are rendered.\n     * @api\n     */\n    async setAssets(assets, updateLayers = true) {\n        if (assets === this.assets_) {\n            return;\n        }\n        if (Array.isArray(assets)) {\n            const data = this.getData();\n            this.assets_ = assets.map((asset) => {\n                if (data instanceof STAC && typeof asset === 'string') {\n                    return data.getAsset(asset);\n                }\n                if (!(asset instanceof Asset)) {\n                    return new Asset(asset);\n                }\n                return asset;\n            });\n        }\n        else {\n            this.assets_ = null;\n        }\n        if (updateLayers) {\n            await this.updateLayers();\n        }\n    }\n    /**\n     * Updates the children STAC entities to be rendered.\n     *\n     * If an object is passed, it must be a GeoJSON FeatureCollection.\n     *\n     * @param {APICollection|Object|Array<STAC|Object>|null} childs The children to show.\n     * @param {Options|null} [options] Optionally, new STACLayer options for the children. Only applies if `children` are given.\n     * @param {boolean} [updateLayers] Whether to update the layers right away.\n     * @return {Promise} Resolves when all items are rendered.\n     * @api\n     */\n    async setChildren(childs, options = null, updateLayers = true) {\n        if (childs instanceof ItemCollection) {\n            this.children_ = childs.getAll();\n        }\n        else if (childs instanceof CollectionCollection) {\n            this.children_ = childs.getAll();\n        }\n        else if (isObject(childs) && childs.type === 'FeatureCollection') {\n            this.children_ = create(childs, !this.disableMigration_).getAll();\n        }\n        else if (Array.isArray(childs)) {\n            this.children_ = childs.map((child) => {\n                if (child instanceof STAC) {\n                    return child;\n                }\n                return create(child, !this.disableMigration_);\n            });\n        }\n        else {\n            this.children_ = null; // Invalid input\n        }\n        if (this.children_ && this.children_.length === 0) {\n            this.children_ = null;\n        }\n        if (this.children_ && isObject(options)) {\n            this.childrenOptions_ = options;\n        }\n        if (updateLayers) {\n            await this.updateLayers();\n        }\n    }\n    /**\n     * Get the STAC object.\n     *\n     * @return {STAC|Asset} The STAC object.\n     * @api\n     */\n    getData() {\n        return this.get('stac');\n    }\n    /**\n     * Get the children STAC entities.\n     *\n     * @return {Array<STAC>} The STAC child entities.\n     * @api\n     */\n    getChildren() {\n        return this.children_;\n    }\n    /**\n     * Get the STAC assets shown.\n     *\n     * @return {Array<Asset>} The STAC assets.\n     * @api\n     */\n    getAssets() {\n        return this.assets_;\n    }\n    /**\n     * Get the extent of the layer.\n     * If `displayFootprint` is set to `false`, the extent is always returned in\n     * EPSG:4326 instead of the map projection. Make sure to transform it with the\n     * ol.proj.transformExtent function if needed.\n     *\n     * @return {Extent|undefined} The layer extent.\n     * @api\n     */\n    getExtent() {\n        if (!this.map_) {\n            return;\n        }\n        const view = this.map_.getView();\n        if (!view) {\n            return;\n        }\n        // todo: In general it might be better to get the actual extent of the layers/sources.\n        // Unfortunately, the extent is requested before it is available\n        // at least for the footprint layer due to the use of the GeoJSON loader.\n        // So we stick to the bounding box of the STAC entity for now,\n        // which sometimes is too small.\n        // See https://github.com/radiantearth/stac-browser/issues/634 for details.\n        let bbox;\n        const data = this.getData();\n        if (data) {\n            bbox = data.getBoundingBox();\n        }\n        const items = this.getChildren();\n        if (items) {\n            const bboxes = items.map((item) => item.getBoundingBox());\n            bbox = unionBoundingBox(bboxes);\n        }\n        if (bbox) {\n            return transformExtent(bbox, 'EPSG:4326', view.getProjection());\n        }\n    }\n    getLayerState() {\n        const state = super.getLayerState();\n        // Fixes the issue that the view is clipped based on the extent of the layer.\n        // The extent is usually the bbox, but sometimes there are even items outside of the bbox.\n        // See https://github.com/radiantearth/stac-browser/issues/634 for details.\n        state.extent = undefined;\n        return state;\n    }\n    /**\n     * Get the attributions of the STAC entity assigned to this layer.\n     *\n     * @return {Array<string>} Attributions for this layer.\n     * @api\n     */\n    getAttributions() {\n        const attribution = [];\n        const stac = this.getData();\n        if (stac) {\n            const attribution = stac.getMetadata('attribution');\n            if (attribution) {\n                attribution.push(attribution);\n            }\n        }\n        return attribution;\n    }\n    /**\n     * Get the layer source.\n     * @return {SourceType|null} The layer source (or `null` if not yet set).\n     */\n    getSource() {\n        return null;\n    }\n    /**\n     * Gets the WMTS capabilities from the given web-map-links URL.\n     * @param {string} url Base URL for the WMTS\n     * @param {string} [encoding] The request encoding, either `kvp` (default) or `rest`.\n     * @return {Promise<Object|null>} Resolves with the WMTS Capabilities object\n     * @private\n     */\n    async getWmtsCapabilities_(url, encoding = 'kvp') {\n        try {\n            const urlObj = new URL(url);\n            if (encoding !== 'rest') {\n                urlObj.searchParams.set('service', 'wmts');\n                urlObj.searchParams.set('request', 'GetCapabilities');\n            }\n            const response = await this.fetch_(urlObj.toString(), 'text');\n            return new WMTSCapabilities().read(response);\n        }\n        catch (_) {\n            return null;\n        }\n    }\n}\nexport default STACLayer;\n//# sourceMappingURL=STAC.js.map","<template>\n  <div class=\"map-container\">\n    <div ref=\"map\" class=\"map\" :id=\"mapId\">\n      <!-- this will be filled by OpenLayers -->\n      <LayerControl :map=\"map\" :maxZoom=\"maxZoom\" />\n      <TextControl v-if=\"empty\" :map=\"map\" :text=\"$t('mapping.nodata')\" />\n      <TextControl v-else-if=\"!hasBasemap\" :map=\"map\" :text=\"$t('mapping.nobasemap')\" />\n    </div>\n    <div ref=\"target\" class=\"popover-target\" />\n    <b-popover\n      v-if=\"popover && selection\" show manual placement=\"auto\"\n      :target=\"selection.target\" :teleport-to=\"container\" class=\"map-popover\"\n      :boundary-padding=\"10\"\n    >\n      <section class=\"popover-children\">\n        <Items v-if=\"selection.type === 'items'\" :stac=\"stac\" :items=\"selection.children\" />\n        <Catalogs v-else-if=\"selection.type === 'collections'\" collectionsOnly enforceCards hideControls :stac=\"stac\" :catalogs=\"selection.children\" />\n        <Features v-else :features=\"selection.children\" />\n      </section>\n      <div class=\"text-center\">\n        <b-button variant=\"danger\" @click=\"resetSelection\">{{ $t('mapping.close') }}</b-button>\n      </div>\n    </b-popover>\n  </div>\n</template>\n\n<script>\nimport { defineAsyncComponent } from 'vue';\nimport MapMixin from './maps/MapMixin.js';\nimport LayerControl from './maps/LayerControl.vue';\nimport TextControl from './maps/TextControl.vue';\nimport { mapGetters } from 'vuex';\nimport Select from 'ol/interaction/Select';\nimport StacLayer from 'ol-stac';\nimport { getStacObjectsForEvent, getStyle } from 'ol-stac/util.js';\nimport { STACReference } from 'stac-js';\nimport MapUtils from './maps/mapUtils.js';\nimport GeoJSON from 'ol/format/GeoJSON.js';\n\nconst selectStyle = getStyle('#ff0000', 2, null);\nlet mapId = 0;\n\nexport default {\n  name: 'MapView',\n  components: {\n    BPopover: defineAsyncComponent(() => import('bootstrap-vue-next').then(m => m.BPopover)),\n    Features: defineAsyncComponent(() => import('../components/Features.vue')),\n    Catalogs: defineAsyncComponent(() => import('../components/Catalogs.vue')),\n    Items: defineAsyncComponent(() => import('../components/Items.vue')),\n    LayerControl,\n    TextControl\n  },\n  mixins: [\n    MapMixin\n  ],\n  props: {\n    stac: {\n      type: Object,\n      default: null\n    },\n    assets: {\n      type: Array,\n      default: null\n    },\n    children: {\n      type: Object,\n      default: null\n    },\n    onfocusOnly: {\n      type: Boolean,\n      default: false\n    },\n    popover: {\n      type: Boolean,\n      default: false\n    }\n  },\n  emits: ['empty', 'changed'],\n  data() {\n    return {\n      selection: null,\n      clickPosition: { x: 0, y: 0 },\n      empty: false,\n      selector: null,\n      mapId: `map-${++mapId}`,\n    };\n  },\n  computed: {\n    ...mapGetters(['getStac']),\n    container() {\n      if (this.isFullScreen) {\n        return '#' + this.mapId;\n      }\n      else {\n        return '#stac-browser';\n      }\n    },\n    childrenOptions() {\n      return {\n        displayPreview: this.children && this.children.isItemCollection()\n      };\n    }\n  },\n  watch: {\n    async stac() {\n      await this.showStacLayer();\n    },\n    async assets() {\n      if (!this.stacLayer) {\n        return;\n      }\n      await this.stacLayer.setAssets(this.assets);\n    },\n    async children() {\n      if (!this.stacLayer) {\n        return;\n      }\n      await this.stacLayer.setAssets(null, false);\n      await this.stacLayer.setChildren(this.children, this.childrenOptions, false);\n      await this.stacLayer.updateLayers();\n      this.fit();\n    },\n    empty(empty) {\n      if (empty) {\n        this.$emit('empty');\n      }\n    },\n    selection(selection) {\n      if (!selection && this.selector) {\n        this.selector.getFeatures().clear();\n      }\n    }\n  },\n  created() {\n    // This is created here and not in data() to avoid it being reactive\n    this.stacLayer = null;\n  },\n  async mounted() {\n    await this.showStacLayer();\n  },\n  methods: {\n    async showStacLayer() {\n      this.map = null;\n      this.stacLayer = null;\n\n      await this.createMap(this.$refs.map, this.stac, this.onfocusOnly);\n\n      if (this.stac) {\n        await this.addStacLayer();\n      }\n    },\n    async addStacLayer() {\n      let options = Object.assign({}, this.stacLayerOptions, {\n        // Don't set the URL here, as it is already set in the STAC object and is read-only.\n        // url: this.stac.getAbsoluteUrl(),\n        data: this.stac,\n        children: this.children,\n        assets: this.assets || null,\n        displayWebMapLink: true,\n        disableMigration: true,\n        childrenOptions: this.childrenOptions\n      });\n      this.stacLayer = new StacLayer(options);\n      this.stacLayer.on('error', error => {\n        console.warn(error);\n        this.fit();\n      });\n      this.stacLayer.on('sourceready', this.fit);\n      this.stacLayer.on('layersready', () => {\n        this.empty = this.stacLayer.isEmpty();\n        this.$emit('changed', this.getShownData());\n      });\n      this.map.addLayer(this.stacLayer);\n\n      if (this.popover) {\n        this.selector = new Select({\n          multi: true,\n          style: selectStyle,\n          layers: (layer) => {\n            if (this.children) {\n              // For item selection\n              return false;\n            }\n            else {\n              // For feature selection\n              const stac = layer.get('stac');\n              return stac && stac.isAsset();\n            }\n          }\n        });\n        this.selector.on('select', (event) => {\n          // For feature selection\n          this.selection = null;\n          this.setTargetPosition(event.mapBrowserEvent);\n          const features = this.selector.getFeatures();\n          if (features.getLength() > 0) {\n            const writer = new GeoJSON();\n            this.selection = {\n              target: this.$refs.target,\n              type: 'features',\n              items: features.getArray().map(f => writer.writeFeatureObject(f))\n            };\n          }\n        });\n        this.map.addInteraction(this.selector);\n        this.map.on('singleclick', async (event) => {\n          // For item selection\n          this.selection = null;\n          if (this.children) {\n            this.setTargetPosition(event);\n            this.selector.getFeatures().clear();\n            const features = this.selector.getFeatures();\n            const container = this.stacLayer.getData();\n            const objects = await getStacObjectsForEvent(event, container, features, 5);\n            if (objects.length > 0) {\n              this.selection = {\n                target: this.$refs.target,\n                type: this.children.isCollectionCollection() ? 'collections': 'items',\n                children: objects\n              };\n            }\n          }\n        });\n        this.map.on('change', () => this.selection = null);\n        this.map.on('movestart', () => this.selection = null);\n      }\n    },\n    setTargetPosition(event) {\n      // The event doesn't contain a target element for the popover to attach to.\n      // Thus we move a hidden target element to the click position and attach the popover to it.\n      // See also https://github.com/bootstrap-vue/bootstrap-vue/issues/5285\n      this.$refs.target.style.left = event.pixel[0] + 'px';\n      this.$refs.target.style.top = event.pixel[1] + 'px';\n    },\n    fit() {\n      const extent = this.stacLayer.getExtent();\n      if (extent) {\n        // Update the sizes, otherwise the fit will not work properly and compute a wrong zoom level\n        this.map.updateSize();\n        this.map.getView().fit(extent, { padding: [50,50,50,50], maxZoom: this.maxZoom });\n      }\n    },\n    resetSelection() {\n      this.selection = null;\n    },\n    getShownData() {\n      if (!this.stacLayer) {\n        return null;\n      }\n      return this.stacLayer.getLayers().getArray()\n        .filter(layer => MapUtils.isLayerVisible(layer))\n        .map(layer => layer.get('stac'))\n        .filter(stac => stac instanceof STACReference);\n    }\n  }\n};\n</script>\n\n<style lang=\"scss\">\n@import \"ol/ol.css\";\n\n#stac-browser {\n  .map-popover {\n    max-width: 400px;\n  }\n\n  .popover-target {\n    width: 1px;\n    height: 1px;\n    opacity: 0;\n    position: absolute;\n    top: -1px;\n    left: -1px;\n  }\n  \n  .popover-children {\n    max-height: 500px;\n    overflow: auto;\n    margin-top: -0.5rem;\n    margin-left: -0.75rem;\n    margin-right: -0.75rem;\n    padding: 0.5rem 0.75rem 0  0.75rem;\n\n    .items, .features, .catalogs {\n      margin-bottom: 0 !important;\n    }\n\n    .card-columns {\n      column-count: 1;\n    }\n  }\n}\n</style>\n"],"file":"MapView-D5tb0UHZ.js"}