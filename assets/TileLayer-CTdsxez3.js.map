{"version":3,"file":"TileLayer-CTdsxez3.js","sources":["../../node_modules/ol/renderer/canvas/TileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport DataTile, {asImageLike} from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {equivalent, fromUserExtent} from '../../proj.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport {toSize} from '../../size.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport {\n  createOrUpdate as createTileCoord,\n  getCacheKey,\n} from '../../tilecoord.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport CanvasLayerRenderer from './Layer.js';\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default|null}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default|null>}\n     * @private\n     */\n    this.sourceTileCache_ = null;\n\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getSourceTileCache() {\n    if (!this.sourceTileCache_) {\n      this.sourceTileCache_ = new LRUCache(512);\n    }\n    return this.sourceTileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource, tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      const projection = frameState.viewState.projection;\n      const sourceProjection = tileSource.getProjection();\n      tile = tileSource.getTile(\n        z,\n        x,\n        y,\n        frameState.pixelRatio,\n        projection,\n        !sourceProjection || equivalent(sourceProjection, projection)\n          ? undefined\n          : this.getSourceTileCache(),\n      );\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection) {\n      this.renderedProjection = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection) {\n      this.tileCache_.clear();\n      this.renderedProjection = frameState.viewState.projection;\n    }\n\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedSourceRevision_) {\n      this.renderedSourceRevision_ = sourceRevision;\n    } else if (this.renderedSourceRevision_ !== sourceRevision) {\n      this.renderedSourceRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n        this.sourceTileCache_?.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determine whether tiles for next extent should be enqueued for rendering.\n   * @return {boolean} Rendering tiles for next extent is supported.\n   * @protected\n   */\n  enqueueTilesForNextExtent() {\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    const rotation = viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          viewState.resolution,\n          rotation,\n          frameState.size,\n        )\n      : undefined;\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(\n        this.getLayer().getSource(),\n        staleKeys[i],\n        z,\n        x,\n        y,\n      );\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.peek(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.peek(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    this.renderComplete = true;\n    /**\n     * TODO:\n     *  maybe skip transition when not fully opaque\n     *  decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(\n        frameExtent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent && this.enqueueTilesForNextExtent()) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          renderExtent,\n          z - 1,\n          tilesByZ,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (tileState === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      if (tileState !== TileState.ERROR) {\n        this.renderComplete = false;\n      }\n\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tilesByZ,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tilesByZ,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (\n              intersects(\n                [x, y, x + w, y + h],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (this.renderComplete) {\n      /**\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = (map, frameState) => {\n        const tileSourceKey = getUid(tileSource);\n        const wantedTiles = frameState.wantedTiles[tileSourceKey];\n        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n        this.updateCacheSize(tilesCount);\n        this.tileCache_.expireCache();\n        this.sourceTileCache_?.expireCache();\n      };\n\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n\n    // this normally is `div.ol-layer` and is a mocked div in worker\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(\n      this.tileCache_.highWaterMark,\n      tileCount * 2,\n    );\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(\n        /** @type {import(\"../../ImageTile.js\").default} */ (tile),\n      );\n    }\n\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement|OffscreenCanvas} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|OffscreenCanvas|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n"],"names":["addTileToLookup","tilesByZ","tile","z","set","existing","removeTileFromLookup","getRenderExtent","frameState","extent","layerState","getIntersection","fromUserExtent","source","gridExtent","CanvasTileLayerRenderer","CanvasLayerRenderer","tileLayer","options","createEmpty","TileRange","createTileCoord","cacheSize","LRUCache","x","y","tileCache","tileSource","cacheKey","getCacheKey","projection","sourceProjection","equivalent","pixel","layer","coordinate","applyTransform","layerExtent","containsCoordinate","viewState","tileGrid","tilePixelRatio","tileCoord","TileState","tileOrigin","tileSize","toSize","tileResolution","image","ImageTile","ReprojTile","DataTile","asImageLike","col","row","gutter","sourceRevision","initialZ","preload","tileSourceKey","getUid","wantedTiles","map","minZ","rotation","viewport","getRotatedViewport","tileRange","tileQueueKey","staleKeys","i","altZ","covered","sourceKey","loaded","target","viewResolution","viewCenter","pixelRatio","frameExtent","width","height","dx","dy","canvasExtent","targetZ","nextExtent","renderExtent","uid","time","tileState","minZoom","parentZ","canvasScale","context","composeTransform","zs","ascending","currentClip","clips","clipZs","currentZ","currentTilePixelSize","currentScale","originTileCoord","getTopLeft","originTileExtent","origin","tileGutter","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","ii","clip","intersects","equals","postRenderFunction","tilesCount","tileCount","alpha","alphaChanged","usedTiles"],"mappings":"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","x_google_ignoreList":[0]}