{"version":3,"file":"GeoTIFF-BrhfFU_5.js","sources":["../../node_modules/ol/source/GeoTIFF.js"],"sourcesContent":["/**\n * @module ol/source/GeoTIFF\n */\nimport {\n  Pool,\n  fromBlob as tiffFromBlob,\n  fromUrl as tiffFromUrl,\n  fromUrls as tiffFromUrls,\n  globals as geotiffGlobals,\n} from 'geotiff';\nimport {error as logError} from '../console.js';\nimport {applyTransform, getCenter, getIntersection} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {fromCode as unitsFromCode} from '../proj/Units.js';\nimport {\n  Projection,\n  createTransformFromCoordinateTransform,\n  get as getCachedProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport {\n  apply as applyMatrix,\n  create as createMatrix,\n  makeInverse,\n  multiply as multiplyTransform,\n} from '../transform.js';\nimport DataTile from './DataTile.js';\n\n/**\n * Determine if an image type is a mask.\n * See https://www.awaresystems.be/imaging/tiff/tifftags/newsubfiletype.html\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} The image is a mask.\n */\nfunction isMask(image) {\n  const fileDirectory = image.fileDirectory;\n  const type = fileDirectory.NewSubfileType || 0;\n  return (type & 4) === 4;\n}\n\n/**\n * @param {true|false|'auto'} preference The convertToRGB option.\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} Use the `image.readRGB()` method.\n */\nfunction readRGB(preference, image) {\n  if (!preference) {\n    return false;\n  }\n  if (preference === true) {\n    return true;\n  }\n  if (image.getSamplesPerPixel() !== 3) {\n    return false;\n  }\n  const interpretation = image.fileDirectory.PhotometricInterpretation;\n  const interpretations = geotiffGlobals.photometricInterpretations;\n  return (\n    interpretation === interpretations.CMYK ||\n    interpretation === interpretations.YCbCr ||\n    interpretation === interpretations.CIELab ||\n    interpretation === interpretations.ICCLab\n  );\n}\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} [url] URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.\n * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\n */\n\n/**\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\n */\n\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\n\nconst STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nconst STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\n\nconst defaultTileSize = 256;\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\n */\n\nlet workerPool;\nfunction getWorkerPool() {\n  if (!workerPool) {\n    workerPool = new Pool();\n  }\n  return workerPool;\n}\n\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\nfunction getBoundingBox(image) {\n  try {\n    return image.getBoundingBox(true);\n  } catch {\n    return [0, 0, image.getWidth(), image.getHeight()];\n  }\n}\n\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\nfunction getOrigin(image) {\n  try {\n    return image.getOrigin().slice(0, 2);\n  } catch {\n    return [0, image.getHeight()];\n  }\n}\n\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {Array<number>} The map x and y units per pixel.\n */\nfunction getResolutions(image, referenceImage) {\n  try {\n    return image.getResolution(referenceImage);\n  } catch {\n    return [\n      referenceImage.getWidth() / image.getWidth(),\n      referenceImage.getHeight() / image.getHeight(),\n    ];\n  }\n}\n\n/**\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @return {import(\"../proj/Projection.js\").default} The image projection.\n */\nfunction getProjection(image) {\n  const geoKeys = image.geoKeys;\n  if (!geoKeys) {\n    return null;\n  }\n\n  if (\n    geoKeys.ProjectedCSTypeGeoKey &&\n    geoKeys.ProjectedCSTypeGeoKey !== 32767\n  ) {\n    const code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units,\n        });\n      }\n    }\n    return projection;\n  }\n\n  if (geoKeys.GeographicTypeGeoKey && geoKeys.GeographicTypeGeoKey !== 32767) {\n    const code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units,\n        });\n      }\n    }\n    return projection;\n  }\n\n  return null;\n}\n\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForTIFF(tiff) {\n  return tiff.getImageCount().then(function (count) {\n    const requests = new Array(count);\n    for (let i = 0; i < count; ++i) {\n      requests[i] = tiff.getImage(i);\n    }\n    return Promise.all(requests);\n  });\n}\n\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @param {Object} options Options for the GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForSource(source, options) {\n  let request;\n  if (source.blob) {\n    request = tiffFromBlob(source.blob);\n  } else if (source.overviews) {\n    request = tiffFromUrls(source.url, source.overviews, options);\n  } else {\n    request = tiffFromUrl(source.url, options);\n  }\n  return request.then(getImagesForTIFF);\n}\n\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n  if (Array.isArray(expected)) {\n    const length = expected.length;\n    if (!Array.isArray(got) || length != got.length) {\n      const error = new Error(message);\n      rejector(error);\n      throw error;\n    }\n    for (let i = 0; i < length; ++i) {\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\n    }\n    return;\n  }\n\n  got = /** @type {number} */ (got);\n  if (Math.abs(expected - got) > tolerance * expected) {\n    throw new Error(message);\n  }\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\nfunction getMinForDataType(array) {\n  if (array instanceof Int8Array) {\n    return -128;\n  }\n  if (array instanceof Int16Array) {\n    return -32768;\n  }\n  if (array instanceof Int32Array) {\n    return -2147483648;\n  }\n  if (array instanceof Float32Array) {\n    return 1.2e-38;\n  }\n  return 0;\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\nfunction getMaxForDataType(array) {\n  if (array instanceof Int8Array) {\n    return 127;\n  }\n  if (array instanceof Uint8Array) {\n    return 255;\n  }\n  if (array instanceof Uint8ClampedArray) {\n    return 255;\n  }\n  if (array instanceof Int16Array) {\n    return 32767;\n  }\n  if (array instanceof Uint16Array) {\n    return 65535;\n  }\n  if (array instanceof Int32Array) {\n    return 2147483647;\n  }\n  if (array instanceof Uint32Array) {\n    return 4294967295;\n  }\n  if (array instanceof Float32Array) {\n    return 3.4e38;\n  }\n  return 255;\n}\n\n/**\n * @typedef {Object} GeoTIFFSourceOptions\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\n * @property {string} [credentials] How credentials shall be handled. See\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\n * By default only a single range is used.\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\n * requested. Only use this when you know the source image to be small enough to fit in memory.\n * @property {number} [blockSize=65536] The block size to use.\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\n * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,\n * CIELab, and ICCLab images will automatically be converted to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Source projection.  If not provided, the GeoTIFF metadata\n * will be read for projection information.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * **Note for users of the full build**: The `GeoTIFF` source requires the\n * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.\n *\n * @api\n */\nclass GeoTIFFSource extends DataTile {\n  /**\n   * @param {Options} options Data tile options.\n   */\n  constructor(options) {\n    super({\n      state: 'loading',\n      tileGrid: null,\n      projection: options.projection || null,\n      transition: options.transition,\n      interpolate: options.interpolate !== false,\n      wrapX: options.wrapX,\n    });\n\n    /**\n     * @type {Array<SourceInfo>}\n     * @private\n     */\n    this.sourceInfo_ = options.sources;\n\n    const numSources = this.sourceInfo_.length;\n\n    /**\n     * @type {Object}\n     * @private\n     */\n    this.sourceOptions_ = options.sourceOptions;\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    this.sourceImagery_ = new Array(numSources);\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    this.sourceMasks_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.resolutionFactors_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.samplesPerPixel_;\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.nodataValues_;\n\n    /**\n     * @type {Array<Array<GDALMetadata>>}\n     * @private\n     */\n    this.metadata_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.normalize_ = options.normalize !== false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.addAlpha_ = false;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {true|false|'auto'}\n     * @private\n     */\n    this.convertToRGB_ = options.convertToRGB || false;\n\n    this.setKey(this.sourceInfo_.map((source) => source.url).join(','));\n\n    const self = this;\n    const requests = new Array(numSources);\n    for (let i = 0; i < numSources; ++i) {\n      requests[i] = getImagesForSource(\n        this.sourceInfo_[i],\n        this.sourceOptions_,\n      );\n    }\n    Promise.all(requests)\n      .then(function (sources) {\n        self.configure_(sources);\n      })\n      .catch(function (error) {\n        logError(error);\n        self.error_ = error;\n        self.setState('error');\n      });\n  }\n\n  /**\n   * @return {Error} A source loading error. When the source state is `error`, use this function\n   * to get more information about the error. To debug a faulty configuration, you may want to use\n   * a listener like\n   * ```js\n   * geotiffSource.on('change', () => {\n   *   if (geotiffSource.getState() === 'error') {\n   *     console.error(geotiffSource.getError());\n   *   }\n   * });\n   * ```\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Determine the projection of the images in this GeoTIFF.\n   * The default implementation looks at the ProjectedCSTypeGeoKey and the GeographicTypeGeoKey\n   * of each image in turn.\n   * You can override this method in a subclass to support more projections.\n   *\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   */\n  determineProjection(sources) {\n    const firstSource = sources[0];\n    for (let i = firstSource.length - 1; i >= 0; --i) {\n      const image = firstSource[i];\n      const projection = getProjection(image);\n      if (projection) {\n        this.projection = projection;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Determine any transform matrix for the images in this GeoTIFF.\n   *\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   */\n  determineTransformMatrix(sources) {\n    const firstSource = sources[0];\n    for (let i = firstSource.length - 1; i >= 0; --i) {\n      const image = firstSource[i];\n      const modelTransformation = image.fileDirectory.ModelTransformation;\n      if (modelTransformation) {\n        // eslint-disable-next-line no-unused-vars\n        const [a, b, c, d, e, f, g, h] = modelTransformation;\n        const matrix = multiplyTransform(\n          multiplyTransform(\n            [\n              1 / Math.sqrt(a * a + e * e),\n              0,\n              0,\n              -1 / Math.sqrt(b * b + f * f),\n              d,\n              h,\n            ],\n            [a, e, b, f, 0, 0],\n          ),\n          [1, 0, 0, 1, -d, -h],\n        );\n        this.transformMatrix = matrix;\n        this.addAlpha_ = true;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n   * must have the same internal tiled structure.\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   * @private\n   */\n  configure_(sources) {\n    let extent;\n    let origin;\n    let commonRenderTileSizes;\n    let commonSourceTileSizes;\n    let resolutions;\n    const samplesPerPixel = new Array(sources.length);\n    const nodataValues = new Array(sources.length);\n    const metadata = new Array(sources.length);\n    let minZoom = 0;\n\n    const sourceCount = sources.length;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const images = [];\n      const masks = [];\n      sources[sourceIndex].forEach((item) => {\n        if (isMask(item)) {\n          masks.push(item);\n        } else {\n          images.push(item);\n        }\n      });\n\n      const imageCount = images.length;\n      if (masks.length > 0 && masks.length !== imageCount) {\n        throw new Error(\n          `Expected one mask per image found ${masks.length} masks and ${imageCount} images`,\n        );\n      }\n\n      let sourceExtent;\n      let sourceOrigin;\n      const sourceTileSizes = new Array(imageCount);\n      const renderTileSizes = new Array(imageCount);\n      const sourceResolutions = new Array(imageCount);\n\n      nodataValues[sourceIndex] = new Array(imageCount);\n      metadata[sourceIndex] = new Array(imageCount);\n\n      for (let imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\n        const image = images[imageIndex];\n        const nodataValue = image.getGDALNoData();\n        metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\n        nodataValues[sourceIndex][imageIndex] = nodataValue;\n\n        const wantedSamples = this.sourceInfo_[sourceIndex].bands;\n        samplesPerPixel[sourceIndex] = wantedSamples\n          ? wantedSamples.length\n          : image.getSamplesPerPixel();\n        const level = imageCount - (imageIndex + 1);\n\n        if (!sourceExtent) {\n          sourceExtent = getBoundingBox(image);\n        }\n\n        if (!sourceOrigin) {\n          sourceOrigin = getOrigin(image);\n        }\n\n        const imageResolutions = getResolutions(image, images[0]);\n        sourceResolutions[level] = imageResolutions[0];\n\n        const sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\n\n        // request larger blocks for untiled layouts\n        if (\n          sourceTileSize[0] !== sourceTileSize[1] &&\n          sourceTileSize[1] < defaultTileSize\n        ) {\n          sourceTileSize[0] = defaultTileSize;\n          sourceTileSize[1] = defaultTileSize;\n        }\n\n        sourceTileSizes[level] = sourceTileSize;\n\n        const aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\n        renderTileSizes[level] = [\n          sourceTileSize[0],\n          sourceTileSize[1] / aspectRatio,\n        ];\n      }\n\n      if (!extent) {\n        extent = sourceExtent;\n      } else {\n        getIntersection(extent, sourceExtent, extent);\n      }\n\n      if (!origin) {\n        origin = sourceOrigin;\n      } else {\n        const message = `Origin mismatch for source ${sourceIndex}, got [${sourceOrigin}] but expected [${origin}]`;\n        assertEqual(origin, sourceOrigin, 0, message, this.viewRejector);\n      }\n\n      if (!resolutions) {\n        resolutions = sourceResolutions;\n        this.resolutionFactors_[sourceIndex] = 1;\n      } else {\n        if (resolutions.length - minZoom > sourceResolutions.length) {\n          minZoom = resolutions.length - sourceResolutions.length;\n        }\n        const resolutionFactor =\n          resolutions[resolutions.length - 1] /\n          sourceResolutions[sourceResolutions.length - 1];\n        this.resolutionFactors_[sourceIndex] = resolutionFactor;\n        const scaledSourceResolutions = sourceResolutions.map(\n          (resolution) => (resolution *= resolutionFactor),\n        );\n        const message = `Resolution mismatch for source ${sourceIndex}, got [${scaledSourceResolutions}] but expected [${resolutions}]`;\n        assertEqual(\n          resolutions.slice(minZoom, resolutions.length),\n          scaledSourceResolutions,\n          0.02,\n          message,\n          this.viewRejector,\n        );\n      }\n\n      if (!commonRenderTileSizes) {\n        commonRenderTileSizes = renderTileSizes;\n      } else {\n        assertEqual(\n          commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length),\n          renderTileSizes,\n          0.01,\n          `Tile size mismatch for source ${sourceIndex}`,\n          this.viewRejector,\n        );\n      }\n\n      if (!commonSourceTileSizes) {\n        commonSourceTileSizes = sourceTileSizes;\n      } else {\n        assertEqual(\n          commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length),\n          sourceTileSizes,\n          0,\n          `Tile size mismatch for source ${sourceIndex}`,\n          this.viewRejector,\n        );\n      }\n\n      this.sourceImagery_[sourceIndex] = images.reverse();\n      this.sourceMasks_[sourceIndex] = masks.reverse();\n    }\n\n    for (let i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n      const sourceImagery = this.sourceImagery_[i];\n      while (sourceImagery.length < resolutions.length) {\n        sourceImagery.unshift(undefined);\n      }\n    }\n\n    if (!this.getProjection()) {\n      this.determineProjection(sources);\n    }\n    this.determineTransformMatrix(sources);\n\n    this.samplesPerPixel_ = samplesPerPixel;\n    this.nodataValues_ = nodataValues;\n    this.metadata_ = metadata;\n\n    // decide if we need to add an alpha band to handle nodata\n    outer: for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      // option 1: source is configured with a nodata value\n      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\n        this.addAlpha_ = true;\n        break;\n      }\n      if (this.sourceMasks_[sourceIndex].length) {\n        this.addAlpha_ = true;\n        break;\n      }\n\n      const values = nodataValues[sourceIndex];\n\n      // option 2: check image metadata for limited bands\n      const bands = this.sourceInfo_[sourceIndex].bands;\n      if (bands) {\n        for (let i = 0; i < bands.length; ++i) {\n          if (values[bands[i] - 1] !== null) {\n            this.addAlpha_ = true;\n            break outer;\n          }\n        }\n        continue;\n      }\n\n      // option 3: check image metadata for all bands\n      for (let imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n        if (values[imageIndex] !== null) {\n          this.addAlpha_ = true;\n          break outer;\n        }\n      }\n    }\n\n    let bandCount = this.addAlpha_ ? 1 : 0;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      bandCount += samplesPerPixel[sourceIndex];\n    }\n    this.bandCount = bandCount;\n\n    const tileGrid = new TileGrid({\n      extent: extent,\n      minZoom: minZoom,\n      origin: origin,\n      resolutions: resolutions,\n      tileSizes: commonRenderTileSizes,\n    });\n\n    this.tileGrid = tileGrid;\n    this.setTileSizes(commonSourceTileSizes);\n\n    this.setLoader(this.loadTile_.bind(this));\n    this.setState('ready');\n\n    const zoom = 1;\n    if (resolutions.length === 2) {\n      resolutions = [resolutions[0], resolutions[1], resolutions[1] / 2];\n    } else if (resolutions.length === 1) {\n      resolutions = [resolutions[0] * 2, resolutions[0], resolutions[0] / 2];\n    }\n\n    let viewExtent = extent;\n    if (this.transformMatrix) {\n      const matrix = makeInverse(createMatrix(), this.transformMatrix.slice());\n      const transformFn = createTransformFromCoordinateTransform((input) =>\n        applyMatrix(matrix, input),\n      );\n      viewExtent = applyTransform(extent, transformFn);\n    }\n\n    this.viewResolver({\n      showFullExtent: true,\n      projection: this.projection,\n      resolutions: resolutions,\n      center: toUserCoordinate(getCenter(viewExtent), this.projection),\n      extent: toUserExtent(viewExtent, this.projection),\n      zoom: zoom,\n    });\n  }\n\n  /**\n   * @param {number} z The z tile index.\n   * @param {number} x The x tile index.\n   * @param {number} y The y tile index.\n   * @param {import('./DataTile.js').LoaderOptions} options The loader options.\n   * @return {Promise} The composed tile data.\n   * @private\n   */\n  loadTile_(z, x, y, options) {\n    const sourceTileSize = this.getTileSize(z);\n    const sourceCount = this.sourceImagery_.length;\n    const requests = new Array(sourceCount * 2);\n    const nodataValues = this.nodataValues_;\n    const sourceInfo = this.sourceInfo_;\n    const pool = getWorkerPool();\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const source = sourceInfo[sourceIndex];\n      const resolutionFactor = this.resolutionFactors_[sourceIndex];\n      const pixelBounds = [\n        Math.round(x * (sourceTileSize[0] * resolutionFactor)),\n        Math.round(y * (sourceTileSize[1] * resolutionFactor)),\n        Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)),\n        Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor)),\n      ];\n      const image = this.sourceImagery_[sourceIndex][z];\n      let samples;\n      if (source.bands) {\n        samples = source.bands.map(function (bandNumber) {\n          return bandNumber - 1;\n        });\n      }\n\n      /** @type {number|Array<number>} */\n      let fillValue;\n      if ('nodata' in source && source.nodata !== null) {\n        fillValue = source.nodata;\n      } else {\n        if (!samples) {\n          fillValue = nodataValues[sourceIndex];\n        } else {\n          fillValue = samples.map(function (sampleIndex) {\n            return nodataValues[sourceIndex][sampleIndex];\n          });\n        }\n      }\n\n      const readOptions = {\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: samples,\n        fillValue: fillValue,\n        pool: pool,\n        interleave: false,\n        signal: options.signal,\n      };\n      if (readRGB(this.convertToRGB_, image)) {\n        requests[sourceIndex] = image.readRGB(readOptions);\n      } else {\n        requests[sourceIndex] = image.readRasters(readOptions);\n      }\n\n      // requests after `sourceCount` are for mask data (if any)\n      const maskIndex = sourceCount + sourceIndex;\n      const mask = this.sourceMasks_[sourceIndex][z];\n      if (!mask) {\n        requests[maskIndex] = Promise.resolve(null);\n        continue;\n      }\n\n      requests[maskIndex] = mask.readRasters({\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: [0],\n        pool: pool,\n        interleave: false,\n      });\n    }\n\n    return Promise.all(requests)\n      .then(this.composeTile_.bind(this, sourceTileSize))\n      .catch(function (error) {\n        logError(error);\n        throw error;\n      });\n  }\n\n  /**\n   * @param {import(\"../size.js\").Size} sourceTileSize The source tile size.\n   * @param {Array} sourceSamples The source samples.\n   * @return {import(\"../DataTile.js\").Data} The composed tile data.\n   * @private\n   */\n  composeTile_(sourceTileSize, sourceSamples) {\n    const metadata = this.metadata_;\n    const sourceInfo = this.sourceInfo_;\n    const sourceCount = this.sourceImagery_.length;\n    const bandCount = this.bandCount;\n    const samplesPerPixel = this.samplesPerPixel_;\n    const nodataValues = this.nodataValues_;\n    const normalize = this.normalize_;\n    const addAlpha = this.addAlpha_;\n\n    const pixelCount = sourceTileSize[0] * sourceTileSize[1];\n    const dataLength = pixelCount * bandCount;\n\n    /** @type {Uint8Array|Float32Array} */\n    let data;\n    if (normalize) {\n      data = new Uint8Array(dataLength);\n    } else {\n      data = new Float32Array(dataLength);\n    }\n\n    let dataIndex = 0;\n    for (let pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n      let transparent = addAlpha;\n      for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n        const source = sourceInfo[sourceIndex];\n\n        let min = source.min;\n        let max = source.max;\n        let gain, bias;\n        if (normalize) {\n          const stats = metadata[sourceIndex][0];\n          if (min === undefined) {\n            if (stats && STATISTICS_MINIMUM in stats) {\n              min = parseFloat(stats[STATISTICS_MINIMUM]);\n            } else {\n              min = getMinForDataType(sourceSamples[sourceIndex][0]);\n            }\n          }\n          if (max === undefined) {\n            if (stats && STATISTICS_MAXIMUM in stats) {\n              max = parseFloat(stats[STATISTICS_MAXIMUM]);\n            } else {\n              max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n            }\n          }\n\n          gain = 255 / (max - min);\n          bias = -min * gain;\n        }\n\n        for (\n          let sampleIndex = 0;\n          sampleIndex < samplesPerPixel[sourceIndex];\n          ++sampleIndex\n        ) {\n          const sourceValue =\n            sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n\n          let value;\n          if (normalize) {\n            value = clamp(gain * sourceValue + bias, 0, 255);\n          } else {\n            value = sourceValue;\n          }\n\n          if (!addAlpha) {\n            data[dataIndex] = value;\n          } else {\n            let nodata = source.nodata;\n            if (nodata === undefined) {\n              let bandIndex;\n              if (source.bands) {\n                bandIndex = source.bands[sampleIndex] - 1;\n              } else {\n                bandIndex = sampleIndex;\n              }\n              nodata = nodataValues[sourceIndex][bandIndex];\n            }\n\n            const nodataIsNaN = isNaN(nodata);\n            if (\n              (!nodataIsNaN && sourceValue !== nodata) ||\n              (nodataIsNaN && !isNaN(sourceValue))\n            ) {\n              transparent = false;\n              data[dataIndex] = value;\n            }\n          }\n          dataIndex++;\n        }\n        if (!transparent) {\n          const maskIndex = sourceCount + sourceIndex;\n          const mask = sourceSamples[maskIndex];\n          if (mask && !mask[0][pixelIndex]) {\n            transparent = true;\n          }\n        }\n      }\n      if (addAlpha) {\n        if (!transparent) {\n          data[dataIndex] = 255;\n        }\n        dataIndex++;\n      }\n    }\n\n    return data;\n  }\n}\n\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\nGeoTIFFSource.prototype.getView;\n\nexport default GeoTIFFSource;\n"],"names":["isMask","image","readRGB","preference","interpretation","interpretations","geotiffGlobals.photometricInterpretations","STATISTICS_MAXIMUM","STATISTICS_MINIMUM","defaultTileSize","workerPool","getWorkerPool","Pool","getBoundingBox","getOrigin","getResolutions","referenceImage","getProjection","geoKeys","code","projection","getCachedProjection","units","unitsFromCode","Projection","getImagesForTIFF","tiff","count","requests","i","getImagesForSource","source","options","request","tiffFromBlob","tiffFromUrls","tiffFromUrl","assertEqual","expected","got","tolerance","message","rejector","length","error","getMinForDataType","array","getMaxForDataType","GeoTIFFSource","DataTile","numSources","self","sources","logError","firstSource","modelTransformation","a","b","c","d","e","f","g","h","matrix","multiplyTransform","extent","origin","commonRenderTileSizes","commonSourceTileSizes","resolutions","samplesPerPixel","nodataValues","metadata","minZoom","sourceCount","sourceIndex","images","masks","item","imageCount","sourceExtent","sourceOrigin","sourceTileSizes","renderTileSizes","sourceResolutions","imageIndex","nodataValue","wantedSamples","level","imageResolutions","sourceTileSize","aspectRatio","getIntersection","resolutionFactor","scaledSourceResolutions","resolution","ii","sourceImagery","outer","values","bands","bandCount","tileGrid","TileGrid","zoom","viewExtent","makeInverse","createMatrix","transformFn","createTransformFromCoordinateTransform","input","applyMatrix","applyTransform","toUserCoordinate","getCenter","toUserExtent","z","x","y","sourceInfo","pool","pixelBounds","samples","bandNumber","fillValue","sampleIndex","readOptions","maskIndex","mask","sourceSamples","normalize","addAlpha","pixelCount","dataLength","data","dataIndex","pixelIndex","transparent","min","max","gain","bias","stats","sourceValue","value","clamp","nodata","bandIndex","nodataIsNaN"],"mappings":"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","x_google_ignoreList":[0]}