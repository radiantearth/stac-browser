import{g as p,bp as N,br as G,c6 as b,A as O,o as D,p as k}from"./GeoJSON-BlyzYhKz.js";import{o as R,p as f,a as B,E as I,q as S,b as F}from"./compileUtil-l9W4qAYP.js";import{p as P,a as M,b as C,d as w}from"./RenderTarget-Fi-4iEgp.js";class A{constructor(){this.globalCounter_=0,this.refToFeature_=new Map,this.uidToRef_=new Map,this.freeGlobalRef_=[],this.polygonBatch={entries:{},geometriesCount:0,verticesCount:0,ringsCount:0},this.pointBatch={entries:{},geometriesCount:0},this.lineStringBatch={entries:{},geometriesCount:0,verticesCount:0}}addFeatures(t,e){for(let s=0;s<t.length;s++)this.addFeature(t[s],e)}addFeature(t,e){let s=t.getGeometry();s&&(e&&(s=s.clone(),s.applyTransform(e)),this.addGeometry_(s,t))}clearFeatureEntryInPointBatch_(t){const e=p(t),s=this.pointBatch.entries[e];if(s)return this.pointBatch.geometriesCount-=s.flatCoordss.length,delete this.pointBatch.entries[e],s}clearFeatureEntryInLineStringBatch_(t){const e=p(t),s=this.lineStringBatch.entries[e];if(s)return this.lineStringBatch.verticesCount-=s.verticesCount,this.lineStringBatch.geometriesCount-=s.flatCoordss.length,delete this.lineStringBatch.entries[e],s}clearFeatureEntryInPolygonBatch_(t){const e=p(t),s=this.polygonBatch.entries[e];if(s)return this.polygonBatch.verticesCount-=s.verticesCount,this.polygonBatch.ringsCount-=s.ringsCount,this.polygonBatch.geometriesCount-=s.flatCoordss.length,delete this.polygonBatch.entries[e],s}addGeometry_(t,e){const s=t.getType();switch(s){case"GeometryCollection":{const n=t.getGeometriesArray();for(const i of n)this.addGeometry_(i,e);break}case"MultiPolygon":{const n=t;this.addCoordinates_(s,n.getFlatCoordinates(),n.getEndss(),e,p(e),n.getStride());break}case"MultiLineString":{const n=t;this.addCoordinates_(s,n.getFlatCoordinates(),n.getEnds(),e,p(e),n.getStride());break}case"MultiPoint":{const n=t;this.addCoordinates_(s,n.getFlatCoordinates(),null,e,p(e),n.getStride());break}case"Polygon":{const n=t;this.addCoordinates_(s,n.getFlatCoordinates(),n.getEnds(),e,p(e),n.getStride());break}case"Point":{const n=t;this.addCoordinates_(s,n.getFlatCoordinates(),null,e,p(e),n.getStride());break}case"LineString":case"LinearRing":{const n=t,i=n.getStride();this.addCoordinates_(s,n.getFlatCoordinates(),null,e,p(e),i,n.getLayout?.());break}}}addCoordinates_(t,e,s,n,i,r,h){let o;switch(t){case"MultiPolygon":{const a=s;for(let u=0,g=a.length;u<g;u++){let c=a[u];const _=u>0?a[u-1]:null,m=_?_[_.length-1]:0,L=c[c.length-1];c=m>0?c.map(v=>v-m):c,this.addCoordinates_("Polygon",e.slice(m,L),c,n,i,r,h)}break}case"MultiLineString":{const a=s;for(let u=0,g=a.length;u<g;u++){const c=u>0?a[u-1]:0;this.addCoordinates_("LineString",e.slice(c,a[u]),null,n,i,r,h)}break}case"MultiPoint":for(let a=0,u=e.length;a<u;a+=r)this.addCoordinates_("Point",e.slice(a,a+2),null,n,i,null,null);break;case"Polygon":{const a=s;if(n instanceof N){const c=G(e,a);if(c.length>1){this.addCoordinates_("MultiPolygon",e,c,n,i,r,h);return}}this.polygonBatch.entries[i]||(this.polygonBatch.entries[i]=this.addRefToEntry_(i,{feature:n,flatCoordss:[],verticesCount:0,ringsCount:0,ringsVerticesCounts:[]})),o=e.length/r;const u=s.length,g=s.map((c,_,m)=>_>0?(c-m[_-1])/r:c/r);this.polygonBatch.verticesCount+=o,this.polygonBatch.ringsCount+=u,this.polygonBatch.geometriesCount++,this.polygonBatch.entries[i].flatCoordss.push(z(e,r)),this.polygonBatch.entries[i].ringsVerticesCounts.push(g),this.polygonBatch.entries[i].verticesCount+=o,this.polygonBatch.entries[i].ringsCount+=u;for(let c=0,_=a.length;c<_;c++){const m=c>0?a[c-1]:0;this.addCoordinates_("LinearRing",e.slice(m,a[c]),null,n,i,r,h)}break}case"Point":this.pointBatch.entries[i]||(this.pointBatch.entries[i]=this.addRefToEntry_(i,{feature:n,flatCoordss:[]})),this.pointBatch.geometriesCount++,this.pointBatch.entries[i].flatCoordss.push(e);break;case"LineString":case"LinearRing":this.lineStringBatch.entries[i]||(this.lineStringBatch.entries[i]=this.addRefToEntry_(i,{feature:n,flatCoordss:[],verticesCount:0})),o=e.length/r,this.lineStringBatch.verticesCount+=o,this.lineStringBatch.geometriesCount++,this.lineStringBatch.entries[i].flatCoordss.push(x(e,r,h)),this.lineStringBatch.entries[i].verticesCount+=o;break}}addRefToEntry_(t,e){const s=this.uidToRef_.get(t),n=s||this.freeGlobalRef_.pop()||++this.globalCounter_;return e.ref=n,s||(this.refToFeature_.set(n,e.feature),this.uidToRef_.set(t,n)),e}removeRef_(t,e){if(!t)throw new Error("This feature has no ref: "+e);this.refToFeature_.delete(t),this.uidToRef_.delete(e),this.freeGlobalRef_.push(t)}changeFeature(t,e){if(!this.uidToRef_.get(p(t)))return;this.removeFeature(t);let s=t.getGeometry();s&&(e&&(s=s.clone(),s.applyTransform(e)),this.addGeometry_(s,t))}removeFeature(t){let e=this.clearFeatureEntryInPointBatch_(t);e=this.clearFeatureEntryInPolygonBatch_(t)||e,e=this.clearFeatureEntryInLineStringBatch_(t)||e,e&&this.removeRef_(e.ref,p(e.feature))}clear(){this.polygonBatch.entries={},this.polygonBatch.geometriesCount=0,this.polygonBatch.verticesCount=0,this.polygonBatch.ringsCount=0,this.lineStringBatch.entries={},this.lineStringBatch.geometriesCount=0,this.lineStringBatch.verticesCount=0,this.pointBatch.entries={},this.pointBatch.geometriesCount=0,this.globalCounter_=0,this.freeGlobalRef_=[],this.refToFeature_.clear(),this.uidToRef_.clear()}getFeatureFromRef(t){return this.refToFeature_.get(t)}isEmpty(){return this.globalCounter_===0}filter(t){const e=new A;e.globalCounter_=this.globalCounter_,e.uidToRef_=this.uidToRef_,e.refToFeature_=this.refToFeature_;let s=!0;for(const n of this.refToFeature_.values())t(n)&&(e.addFeature(n),s=!1);return s?new A:e}}function z(l,t){return t===2?l:l.filter((e,s)=>s%t<2)}function x(l,t,e){return t===3&&e==="XYM"?l:t===4?l.filter((s,n)=>n%t!==2):t===3?l.map((s,n)=>n%t!==2?s:0):new Array(l.length*1.5).fill(0).map((s,n)=>n%3===2?0:l[Math.round(n/1.5)])}function T(l,t,e,s){let n=0;for(const i in t){const r=t[i],h=r.callback.call(e,e.feature);let o=h?.[0]??h;o===R&&console.warn('The "has" operator might return false positives.'),o===void 0?o=R:o===null&&(o=0),l[s+n++]=o,!(!r.size||r.size===1)&&(l[s+n++]=h[1],!(r.size<3)&&(l[s+n++]=h[2],!(r.size<4)&&(l[s+n++]=h[3])))}return n}function y(l){return Object.keys(l).reduce((t,e)=>t+(l[e].size||1),0)}function V(l,t,e,s){const n=(2+y(e))*l.geometriesCount;(!t||t.length!==n)&&(t=new Float32Array(n));const i=[];let r=0;for(const h in l.entries){const o=l.entries[h];for(let a=0,u=o.flatCoordss.length;a<u;a++)i[0]=o.flatCoordss[a][0],i[1]=o.flatCoordss[a][1],O(s,i),t[r++]=i[0],t[r++]=i[1],r+=T(t,e,o,r)}return t}function W(l,t,e,s){const n=3*l.verticesCount+(1+y(e))*l.geometriesCount;(!t||t.length!==n)&&(t=new Float32Array(n));const i=[];let r=0;for(const h in l.entries){const o=l.entries[h];for(let a=0,u=o.flatCoordss.length;a<u;a++){i.length=o.flatCoordss[a].length,b(o.flatCoordss[a],0,i.length,3,s,i,3),r+=T(t,e,o,r),t[r++]=i.length/3;for(let g=0,c=i.length;g<c;g+=3)t[r++]=i[g],t[r++]=i[g+1],t[r++]=i[g+2]}}return t}function j(l,t,e,s){const n=2*l.verticesCount+(1+y(e))*l.geometriesCount+l.ringsCount;(!t||t.length!==n)&&(t=new Float32Array(n));const i=[];let r=0;for(const h in l.entries){const o=l.entries[h];for(let a=0,u=o.flatCoordss.length;a<u;a++){i.length=o.flatCoordss[a].length,b(o.flatCoordss[a],0,i.length,2,s,i),r+=T(t,e,o,r),t[r++]=o.ringsVerticesCounts[a].length;for(let g=0,c=o.ringsVerticesCounts[a].length;g<c;g++)t[r++]=o.ringsVerticesCounts[a][g];for(let g=0,c=i.length;g<c;g+=2)t[r++]=i[g],t[r++]=i[g+1]}}return t}const H=[];let E;function Y(){return E||(E=w()),E}let X=0;const d={POSITION:"a_position",LOCAL_POSITION:"a_localPosition",SEGMENT_START:"a_segmentStart",SEGMENT_END:"a_segmentEnd",MEASURE_START:"a_measureStart",MEASURE_END:"a_measureEnd",ANGLE_TANGENT_SUM:"a_angleTangentSum",JOIN_ANGLES:"a_joinAngles",DISTANCE_LOW:"a_distanceLow",DISTANCE_HIGH:"a_distanceHigh"};class U{constructor(t,e,s,n){this.helper_,this.hitDetectionEnabled_=!!n,this.styleShaders=J(t,e),this.customAttributes_={},this.uniforms_={},this.hitDetectionEnabled_&&(this.customAttributes_.hitColor={callback(){return M(this.ref,H)},size:2});for(const i of this.styleShaders){for(const r in i.attributes)r in this.customAttributes_||(this.customAttributes_[r]=i.attributes[r]);for(const r in i.uniforms)r in this.uniforms_||(this.uniforms_[r]=i.uniforms[r])}this.renderPasses_=this.styleShaders.map(i=>{const r={},h=Object.entries(this.customAttributes_).map(([o,a])=>({name:o in i.attributes||o==="hitColor"?`a_${o}`:null,size:a.size||1,type:f.FLOAT}));return i.builder.getFillVertexShader()&&(r.fillRenderPass={vertexShader:i.builder.getFillVertexShader(),fragmentShader:i.builder.getFillFragmentShader(),attributesDesc:[{name:d.POSITION,size:2,type:f.FLOAT},...h],instancedAttributesDesc:[],instancePrimitiveVertexCount:3}),i.builder.getStrokeVertexShader()&&(r.strokeRenderPass={vertexShader:i.builder.getStrokeVertexShader(),fragmentShader:i.builder.getStrokeFragmentShader(),attributesDesc:[{name:d.LOCAL_POSITION,size:2,type:f.FLOAT}],instancedAttributesDesc:[{name:d.SEGMENT_START,size:2,type:f.FLOAT},{name:d.MEASURE_START,size:1,type:f.FLOAT},{name:d.SEGMENT_END,size:2,type:f.FLOAT},{name:d.MEASURE_END,size:1,type:f.FLOAT},{name:d.JOIN_ANGLES,size:2,type:f.FLOAT},{name:d.DISTANCE_LOW,size:1,type:f.FLOAT},{name:d.DISTANCE_HIGH,size:1,type:f.FLOAT},{name:d.ANGLE_TANGENT_SUM,size:1,type:f.FLOAT},...h],instancePrimitiveVertexCount:6}),i.builder.getSymbolVertexShader()&&(r.symbolRenderPass={vertexShader:i.builder.getSymbolVertexShader(),fragmentShader:i.builder.getSymbolFragmentShader(),attributesDesc:[{name:d.LOCAL_POSITION,size:2,type:f.FLOAT}],instancedAttributesDesc:[{name:d.POSITION,size:2,type:f.FLOAT},...h],instancePrimitiveVertexCount:6}),r}),this.hasFill_=this.renderPasses_.some(i=>i.fillRenderPass),this.hasStroke_=this.renderPasses_.some(i=>i.strokeRenderPass),this.hasSymbol_=this.renderPasses_.some(i=>i.symbolRenderPass),this.setHelper(s)}async generateBuffers(t,e){if(t.isEmpty())return null;const s=this.generateRenderInstructions_(t,e),[n,i,r]=await Promise.all([this.generateBuffersForType_(s.polygonInstructions,"Polygon",e),this.generateBuffersForType_(s.lineStringInstructions,"LineString",e),this.generateBuffersForType_(s.pointInstructions,"Point",e)]),h=D(k(),e);return{polygonBuffers:n,lineStringBuffers:i,pointBuffers:r,invertVerticesTransform:h}}generateRenderInstructions_(t,e){const s=this.hasFill_?j(t.polygonBatch,new Float32Array(0),this.customAttributes_,e):null,n=this.hasStroke_?W(t.lineStringBatch,new Float32Array(0),this.customAttributes_,e):null,i=this.hasSymbol_?V(t.pointBatch,new Float32Array(0),this.customAttributes_,e):null;return{polygonInstructions:s,lineStringInstructions:n,pointInstructions:i}}generateBuffersForType_(t,e,s){if(t===null)return null;const n=X++;let i;switch(e){case"Polygon":i=C.GENERATE_POLYGON_BUFFERS;break;case"LineString":i=C.GENERATE_LINE_STRING_BUFFERS;break;case"Point":i=C.GENERATE_POINT_BUFFERS;break}const r={id:n,type:i,renderInstructions:t.buffer,renderInstructionsTransform:s,customAttributesSize:y(this.customAttributes_)},h=Y();return h.postMessage(r,[t.buffer]),t=null,new Promise(o=>{const a=u=>{const g=u.data;if(g.id!==n||(h.removeEventListener("message",a),!this.helper_.getGL()))return;const c=new B(I,S).fromArrayBuffer(g.indicesBuffer),_=new B(F,S).fromArrayBuffer(g.vertexAttributesBuffer),m=new B(F,S).fromArrayBuffer(g.instanceAttributesBuffer);this.helper_.flushBufferData(c),this.helper_.flushBufferData(_),this.helper_.flushBufferData(m),o([c,_,m])};h.addEventListener("message",a)})}render(t,e,s){for(const n of this.renderPasses_)n.fillRenderPass&&this.renderInternal_(t.polygonBuffers[0],t.polygonBuffers[1],t.polygonBuffers[2],n.fillRenderPass,e,s),n.strokeRenderPass&&this.renderInternal_(t.lineStringBuffers[0],t.lineStringBuffers[1],t.lineStringBuffers[2],n.strokeRenderPass,e,s),n.symbolRenderPass&&this.renderInternal_(t.pointBuffers[0],t.pointBuffers[1],t.pointBuffers[2],n.symbolRenderPass,e,s)}renderInternal_(t,e,s,n,i,r){const h=t.getSize();if(h===0)return;const o=n.instancedAttributesDesc.length;if(this.helper_.useProgram(n.program,i),this.helper_.bindBuffer(e),this.helper_.bindBuffer(t),this.helper_.enableAttributes(n.attributesDesc),this.helper_.bindBuffer(s),this.helper_.enableAttributesInstanced(n.instancedAttributesDesc),r(),o){const a=n.instancedAttributesDesc.reduce((g,c)=>g+(c.size||1),0),u=s.getSize()/a;this.helper_.drawElementsInstanced(0,h,u)}else this.helper_.drawElements(0,h)}setHelper(t,e=null){this.helper_=t;for(const s of this.renderPasses_)s.fillRenderPass&&(s.fillRenderPass.program=this.helper_.getProgram(s.fillRenderPass.fragmentShader,s.fillRenderPass.vertexShader)),s.strokeRenderPass&&(s.strokeRenderPass.program=this.helper_.getProgram(s.strokeRenderPass.fragmentShader,s.strokeRenderPass.vertexShader)),s.symbolRenderPass&&(s.symbolRenderPass.program=this.helper_.getProgram(s.symbolRenderPass.fragmentShader,s.symbolRenderPass.vertexShader));this.helper_.addUniforms(this.uniforms_),e&&(e.polygonBuffers&&(this.helper_.flushBufferData(e.polygonBuffers[0]),this.helper_.flushBufferData(e.polygonBuffers[1]),this.helper_.flushBufferData(e.polygonBuffers[2])),e.lineStringBuffers&&(this.helper_.flushBufferData(e.lineStringBuffers[0]),this.helper_.flushBufferData(e.lineStringBuffers[1]),this.helper_.flushBufferData(e.lineStringBuffers[2])),e.pointBuffers&&(this.helper_.flushBufferData(e.pointBuffers[0]),this.helper_.flushBufferData(e.pointBuffers[1]),this.helper_.flushBufferData(e.pointBuffers[2])))}}function J(l,t){const e=Array.isArray(l)?l:[l];if("style"in e[0]){const s=[],n=e,i=[];for(const r of n){const h=Array.isArray(r.style)?r.style:[r.style];let o=r.filter;r.else&&i.length&&(o=["all",...i.map(u=>["!",u])],r.filter&&o.push(r.filter),o.length<3&&(o=o[1])),r.filter&&i.push(r.filter);const a=h.map(u=>P(u,t,o));s.push(...a)}return s}return"builder"in e[0]?e:e.map(s=>P(s,t,null))}export{A as M,U as V,J as c};
//# sourceMappingURL=VectorStyleRenderer-DZuyQVTl.js.map
