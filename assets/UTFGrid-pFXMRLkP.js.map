{"version":3,"file":"UTFGrid-pFXMRLkP.js","sources":["../../node_modules/ol/source/UTFGrid.js"],"sourcesContent":["/**\n * @module ol/source/UTFGrid\n */\n\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport EventType from '../events/EventType.js';\nimport {listenOnce} from '../events.js';\nimport {applyTransform, intersects} from '../extent.js';\nimport {jsonp as requestJSONP} from '../net.js';\nimport {get as getProjection, getTransformFromProjections} from '../proj.js';\nimport LRUCache from '../structs/LRUCache.js';\nimport {getKeyZXY} from '../tilecoord.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\nimport {createFromTemplates, nullTileUrlFunction} from '../tileurlfunction.js';\nimport TileSource from './Tile.js';\n\n/**\n * @typedef {Object} UTFGridJSON\n * @property {Array<string>} grid The grid.\n * @property {Array<string>} keys The keys.\n * @property {Object<string, Object>} [data] Optional data.\n */\n\nexport class CustomTile extends Tile {\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {import(\"../extent.js\").Extent} extent Extent of the tile.\n   * @param {boolean} preemptive Load the tile when visible (before it's needed).\n   * @param {boolean} jsonp Load the tile as a script.\n   */\n  constructor(tileCoord, state, src, extent, preemptive, jsonp) {\n    super(tileCoord, state);\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = extent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ = preemptive;\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.grid_ = null;\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.keys_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, Object>|undefined}\n     */\n    this.data_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = jsonp;\n  }\n\n  /**\n   * Get the image element for this tile.\n   * @return {HTMLImageElement} Image.\n   */\n  getImage() {\n    return null;\n  }\n\n  /**\n   * Synchronously returns data at given coordinate (if available).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {*} The data.\n   */\n  getData(coordinate) {\n    if (!this.grid_ || !this.keys_) {\n      return null;\n    }\n    const xRelative =\n      (coordinate[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]);\n    const yRelative =\n      (coordinate[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]);\n\n    const row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];\n\n    if (typeof row !== 'string') {\n      return null;\n    }\n\n    let code = row.charCodeAt(Math.floor(xRelative * row.length));\n    if (code >= 93) {\n      code--;\n    }\n    if (code >= 35) {\n      code--;\n    }\n    code -= 32;\n\n    let data = null;\n    if (code in this.keys_) {\n      const id = this.keys_[code];\n      if (this.data_ && id in this.data_) {\n        data = this.data_[id];\n      } else {\n        data = id;\n      }\n    }\n    return data;\n  }\n\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate (or `null` if not yet loaded).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean} [request] If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   */\n  forDataAtCoordinate(coordinate, callback, request) {\n    if (this.state == TileState.EMPTY && request === true) {\n      this.state = TileState.IDLE;\n      listenOnce(this, EventType.CHANGE, (e) => {\n        callback(this.getData(coordinate));\n      });\n      this.loadInternal_();\n    } else {\n      if (request === true) {\n        setTimeout(() => {\n          callback(this.getData(coordinate));\n        }, 0);\n      } else {\n        callback(this.getData(coordinate));\n      }\n    }\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   * @override\n   */\n  getKey() {\n    return this.src_;\n  }\n\n  /**\n   * @private\n   */\n  handleError_() {\n    this.state = TileState.ERROR;\n    this.changed();\n  }\n\n  /**\n   * @param {!UTFGridJSON} json UTFGrid data.\n   * @private\n   */\n  handleLoad_(json) {\n    this.grid_ = json['grid'];\n    this.keys_ = json['keys'];\n    this.data_ = json['data'];\n\n    this.state = TileState.LOADED;\n    this.changed();\n  }\n\n  /**\n   * @private\n   */\n  loadInternal_() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      if (this.jsonp_) {\n        requestJSONP(\n          this.src_,\n          this.handleLoad_.bind(this),\n          this.handleError_.bind(this),\n        );\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', this.src_);\n        client.send();\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {!UTFGridJSON} */ (\n          JSON.parse(client.responseText)\n        );\n      } catch {\n        this.handleError_();\n        return;\n      }\n      this.handleLoad_(response);\n    } else {\n      this.handleError_();\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleError_();\n  }\n\n  /**\n   * @override\n   */\n  load() {\n    if (this.preemptive_) {\n      this.loadInternal_();\n    } else {\n      this.setState(TileState.EMPTY);\n    }\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [preemptive=true]\n * If `true` the UTFGrid source loads the tiles based on their \"visibility\".\n * This improves the speed of response, but increases traffic.\n * Note that if set to `false` (lazy loading), you need to pass `true` as\n * `request` to the `forDataAtCoordinateAndResolution` method otherwise no\n * data will ever be loaded.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {import(\"./TileJSON.js\").Config} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {string} [url] TileJSON endpoint that provides the configuration for this source.\n * Request will be made through JSONP. If not provided, `tileJSON` must be configured.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for UTFGrid interaction data loaded from TileJSON format.\n * @api\n */\nclass UTFGrid extends TileSource {\n  /**\n   * @param {Options} options Source options.\n   */\n  constructor(options) {\n    super({\n      projection: getProjection('EPSG:3857'),\n      state: 'loading',\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ =\n      options.preemptive !== undefined ? options.preemptive : true;\n\n    /**\n     * @private\n     * @type {!import(\"../Tile.js\").UrlFunction}\n     */\n    this.tileUrlFunction_ = nullTileUrlFunction;\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.template_ = undefined;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = options.jsonp || false;\n\n    /**\n     * @private\n     * @type {LRUCache}\n     */\n    this.tileCache_ = new LRUCache(512);\n\n    if (options.url) {\n      if (this.jsonp_) {\n        requestJSONP(\n          options.url,\n          this.handleTileJSONResponse.bind(this),\n          this.handleTileJSONError.bind(this),\n        );\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', options.url);\n        client.send();\n      }\n    } else if (options.tileJSON) {\n      this.handleTileJSONResponse(options.tileJSON);\n    } else {\n      throw new Error('Either `url` or `tileJSON` options must be provided');\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {import(\"./TileJSON.js\").Config} */ (\n          JSON.parse(client.responseText)\n        );\n      } catch {\n        this.handleTileJSONError();\n        return;\n      }\n      this.handleTileJSONResponse(response);\n    } else {\n      this.handleTileJSONError();\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleTileJSONError();\n  }\n\n  /**\n   * Return the template from TileJSON.\n   * @return {string|undefined} The template from TileJSON.\n   * @api\n   */\n  getTemplate() {\n    return this.template_;\n  }\n\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate and resolution (or `null` if not yet loaded or\n   * in case of an error).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean} [request] If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   * @api\n   */\n  forDataAtCoordinateAndResolution(coordinate, resolution, callback, request) {\n    if (this.tileGrid) {\n      const z = this.tileGrid.getZForResolution(resolution, this.zDirection);\n      const tileCoord = this.tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = /** @type {!CustomTile} */ (\n        this.getTile(\n          tileCoord[0],\n          tileCoord[1],\n          tileCoord[2],\n          1,\n          this.getProjection(),\n        )\n      );\n      if (tile.getState() == TileState.IDLE) {\n        tile.load();\n      }\n      tile.forDataAtCoordinate(coordinate, callback, request);\n    } else {\n      if (request === true) {\n        setTimeout(function () {\n          callback(null);\n        }, 0);\n      } else {\n        callback(null);\n      }\n    }\n  }\n\n  /**\n   * @protected\n   */\n  handleTileJSONError() {\n    this.setState('error');\n  }\n\n  /**\n   * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse\n   * @protected\n   * @param {import(\"./TileJSON.js\").Config} tileJSON Tile JSON.\n   */\n  handleTileJSONResponse(tileJSON) {\n    const epsg4326Projection = getProjection('EPSG:4326');\n\n    const sourceProjection = this.getProjection();\n    let extent;\n    if (tileJSON['bounds'] !== undefined) {\n      const transform = getTransformFromProjections(\n        epsg4326Projection,\n        sourceProjection,\n      );\n      extent = applyTransform(tileJSON['bounds'], transform);\n    }\n\n    const gridExtent = extentFromProjection(sourceProjection);\n    const minZoom = tileJSON['minzoom'] || 0;\n    const maxZoom = tileJSON['maxzoom'] || 22;\n    const tileGrid = createXYZ({\n      extent: gridExtent,\n      maxZoom: maxZoom,\n      minZoom: minZoom,\n    });\n    this.tileGrid = tileGrid;\n\n    this.template_ = tileJSON['template'];\n\n    const grids = tileJSON['grids'];\n    if (!grids) {\n      this.setState('error');\n      return;\n    }\n\n    this.tileUrlFunction_ = createFromTemplates(grids, tileGrid);\n\n    if (tileJSON['attribution']) {\n      const attributionExtent = extent !== undefined ? extent : gridExtent;\n      this.setAttributions(function (frameState) {\n        if (intersects(attributionExtent, frameState.extent)) {\n          return [tileJSON['attribution']];\n        }\n        return null;\n      });\n    }\n\n    this.setState('ready');\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!CustomTile} Tile.\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tileCoord = [z, x, y];\n    const urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection,\n    );\n    const tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);\n    const tileKey = `${this.getKey()},${getKeyZXY(z, x, y)}`;\n    if (this.tileCache_.containsKey(tileKey)) {\n      return this.tileCache_.get(tileKey);\n    }\n    this.tileCache_.expireCache();\n    const tile = new CustomTile(\n      tileCoord,\n      tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\n      tileUrl !== undefined ? tileUrl : '',\n      this.tileGrid.getTileCoordExtent(tileCoord),\n      this.preemptive_,\n      this.jsonp_,\n    );\n    this.tileCache_.set(tileKey, tile);\n    return tile;\n  }\n}\n\nexport default UTFGrid;\n"],"names":["CustomTile","Tile","tileCoord","state","src","extent","preemptive","jsonp","coordinate","xRelative","yRelative","row","code","data","id","callback","request","TileState","listenOnce","EventType","e","json","requestJSONP","client","event","response","UTFGrid","TileSource","options","getProjection","nullTileUrlFunction","LRUCache","resolution","z","tile","tileJSON","epsg4326Projection","sourceProjection","transform","getTransformFromProjections","applyTransform","gridExtent","extentFromProjection","minZoom","maxZoom","tileGrid","createXYZ","grids","createFromTemplates","attributionExtent","frameState","intersects","x","y","pixelRatio","projection","urlTileCoord","tileUrl","tileKey","getKeyZXY"],"mappings":"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","x_google_ignoreList":[0]}