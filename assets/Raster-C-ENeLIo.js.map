{"version":3,"file":"Raster-C-ENeLIo.js","sources":["../../node_modules/ol/source/Raster.js"],"sourcesContent":["/**\n * @module ol/source/Raster\n */\nimport Disposable from '../Disposable.js';\nimport ImageCanvas from '../ImageCanvas.js';\nimport TileQueue from '../TileQueue.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport {equals, getCenter, getHeight, getWidth} from '../extent.js';\nimport ImageLayer from '../layer/Image.js';\nimport TileLayer from '../layer/Tile.js';\nimport {create as createTransform} from '../transform.js';\nimport {getUid} from '../util.js';\nimport ImageSource from './Image.js';\nimport Source from './Source.js';\nimport TileSource from './Tile.js';\n\n/**\n * @typedef {Object} MinionData\n * @property {Array<ArrayBuffer>} buffers Array of buffers.\n * @property {Object} meta Operation metadata.\n * @property {boolean} imageOps The operation is an image operation.\n * @property {number} width The width of the image.\n * @property {number} height The height of the image.\n */\n\n/* istanbul ignore next */\n/**\n * Create a function for running operations.  This function is serialized for\n * use in a worker.\n * @param {function(Array, Object):*} operation The operation.\n * @return {function(MinionData):ArrayBuffer} A function that takes an object with\n * buffers, meta, imageOps, width, and height properties and returns an array\n * buffer.\n */\nfunction createMinion(operation) {\n  return function (data) {\n    // bracket notation for minification support\n    const buffers = data['buffers'];\n    const meta = data['meta'];\n    const imageOps = data['imageOps'];\n    const width = data['width'];\n    const height = data['height'];\n\n    const numBuffers = buffers.length;\n    const numBytes = buffers[0].byteLength;\n\n    if (imageOps) {\n      const images = new Array(numBuffers);\n      for (let b = 0; b < numBuffers; ++b) {\n        images[b] = new ImageData(\n          new Uint8ClampedArray(buffers[b]),\n          width,\n          height,\n        );\n      }\n      const output = operation(images, meta).data;\n      return output.buffer;\n    }\n\n    const output = new Uint8ClampedArray(numBytes);\n    const arrays = new Array(numBuffers);\n    const pixels = new Array(numBuffers);\n    for (let b = 0; b < numBuffers; ++b) {\n      arrays[b] = new Uint8ClampedArray(buffers[b]);\n      pixels[b] = [0, 0, 0, 0];\n    }\n    for (let i = 0; i < numBytes; i += 4) {\n      for (let j = 0; j < numBuffers; ++j) {\n        const array = arrays[j];\n        pixels[j][0] = array[i];\n        pixels[j][1] = array[i + 1];\n        pixels[j][2] = array[i + 2];\n        pixels[j][3] = array[i + 3];\n      }\n      const pixel = operation(pixels, meta);\n      output[i] = pixel[0];\n      output[i + 1] = pixel[1];\n      output[i + 2] = pixel[2];\n      output[i + 3] = pixel[3];\n    }\n    return output.buffer;\n  };\n}\n\n/**\n * Create a worker for running operations.\n * @param {ProcessorOptions} config Processor options.\n * @param {function(MessageEvent): void} onMessage Called with a message event.\n * @return {Worker} The worker.\n */\nfunction createWorker(config, onMessage) {\n  const lib = Object.keys(config.lib || {}).map(function (name) {\n    return 'const ' + name + ' = ' + config.lib[name].toString() + ';';\n  });\n\n  const lines = lib.concat([\n    'const __minion__ = (' + createMinion.toString() + ')(',\n    config.operation.toString(),\n    ');',\n    'self.addEventListener(\"message\", function(event) {',\n    '  const buffer = __minion__(event.data);',\n    '  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);',\n    '});',\n  ]);\n\n  const worker = new Worker(\n    typeof Blob === 'undefined'\n      ? 'data:text/javascript;base64,' +\n        Buffer.from(lines.join('\\n'), 'binary').toString('base64')\n      : URL.createObjectURL(new Blob(lines, {type: 'text/javascript'})),\n  );\n  worker.addEventListener('message', onMessage);\n  return worker;\n}\n\n/**\n * @typedef {Object} FauxMessageEvent\n * @property {Object} data Message data.\n */\n\n/**\n * Create a faux worker for running operations.\n * @param {ProcessorOptions} config Configuration.\n * @param {function(FauxMessageEvent): void} onMessage Called with a message event.\n * @return {Object} The faux worker.\n */\nfunction createFauxWorker(config, onMessage) {\n  const minion = createMinion(config.operation);\n  let terminated = false;\n  return {\n    postMessage: function (data) {\n      setTimeout(function () {\n        if (terminated) {\n          return;\n        }\n        onMessage({data: {buffer: minion(data), meta: data['meta']}});\n      }, 0);\n    },\n    terminate: function () {\n      terminated = true;\n    },\n  };\n}\n\n/**\n * @typedef {function(Error, ImageData, (Object|Array<Object>)): void} JobCallback\n */\n\n/**\n * @typedef {Object} Job\n * @property {Object} meta Job metadata.\n * @property {Array<ImageData>} inputs Array of input data.\n * @property {JobCallback} callback Called when the job is complete.\n */\n\n/**\n * @typedef {Object} ProcessorOptions\n * @property {number} threads Number of workers to spawn.\n * @property {Operation} operation The operation.\n * @property {Object<string, Function>} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} queue The number of queued jobs to allow.\n * @property {boolean} [imageOps=false] Pass all the image data to the operation instead of a single pixel.\n */\n\n/**\n * @classdesc\n * A processor runs pixel or image operations in workers.\n */\nexport class Processor extends Disposable {\n  /**\n   * @param {ProcessorOptions} config Configuration.\n   */\n  constructor(config) {\n    super();\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.imageOps_ = !!config.imageOps;\n    let threads;\n    if (config.threads === 0) {\n      threads = 0;\n    } else if (this.imageOps_) {\n      threads = 1;\n    } else {\n      threads = config.threads || 1;\n    }\n\n    /**\n     * @type {Array<Worker>}\n     */\n    const workers = new Array(threads);\n    if (threads) {\n      for (let i = 0; i < threads; ++i) {\n        workers[i] = createWorker(config, this.onWorkerMessage_.bind(this, i));\n      }\n    } else {\n      workers[0] = createFauxWorker(\n        config,\n        this.onWorkerMessage_.bind(this, 0),\n      );\n    }\n    /**\n     * @type {Array<Worker>}\n     * @private\n     */\n    this.workers_ = workers;\n\n    /**\n     * @type {Array<Job>}\n     * @private\n     */\n    this.queue_ = [];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxQueueLength_ = config.queue || Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    this.running_ = 0;\n\n    /**\n     * @type {Object<number, any>}\n     * @private\n     */\n    this.dataLookup_ = {};\n\n    /**\n     * @type {Job|null}\n     * @private\n     */\n    this.job_ = null;\n  }\n\n  /**\n   * Run operation on input data.\n   * @param {Array<ImageData>} inputs Array of image data.\n   * @param {Object} meta A user data object.  This is passed to all operations\n   *     and must be serializable.\n   * @param {function(Error, ImageData, Object): void} callback Called when work\n   *     completes.  The first argument is any error.  The second is the ImageData\n   *     generated by operations.  The third is the user data object.\n   */\n  process(inputs, meta, callback) {\n    this.enqueue_({\n      inputs: inputs,\n      meta: meta,\n      callback: callback,\n    });\n    this.dispatch_();\n  }\n\n  /**\n   * Add a job to the queue.\n   * @param {Job} job The job.\n   */\n  enqueue_(job) {\n    this.queue_.push(job);\n    while (this.queue_.length > this.maxQueueLength_) {\n      this.queue_.shift().callback(null, null);\n    }\n  }\n\n  /**\n   * Dispatch a job.\n   */\n  dispatch_() {\n    if (this.running_ || this.queue_.length === 0) {\n      return;\n    }\n\n    const job = this.queue_.shift();\n    this.job_ = job;\n    const width = job.inputs[0].width;\n    const height = job.inputs[0].height;\n    const buffers = job.inputs.map(function (input) {\n      return input.data.buffer;\n    });\n    const threads = this.workers_.length;\n    this.running_ = threads;\n    if (threads === 1) {\n      this.workers_[0].postMessage(\n        {\n          buffers: buffers,\n          meta: job.meta,\n          imageOps: this.imageOps_,\n          width: width,\n          height: height,\n        },\n        buffers,\n      );\n      return;\n    }\n\n    const length = job.inputs[0].data.length;\n    const segmentLength = 4 * Math.ceil(length / 4 / threads);\n    for (let i = 0; i < threads; ++i) {\n      const offset = i * segmentLength;\n      const slices = [];\n      for (let j = 0, jj = buffers.length; j < jj; ++j) {\n        slices.push(buffers[j].slice(offset, offset + segmentLength));\n      }\n      this.workers_[i].postMessage(\n        {\n          buffers: slices,\n          meta: job.meta,\n          imageOps: this.imageOps_,\n          width: width,\n          height: height,\n        },\n        slices,\n      );\n    }\n  }\n\n  /**\n   * Handle messages from the worker.\n   * @param {number} index The worker index.\n   * @param {MessageEvent} event The message event.\n   */\n  onWorkerMessage_(index, event) {\n    if (this.disposed) {\n      return;\n    }\n    this.dataLookup_[index] = event.data;\n    --this.running_;\n    if (this.running_ === 0) {\n      this.resolveJob_();\n    }\n  }\n\n  /**\n   * Resolve a job.  If there are no more worker threads, the processor callback\n   * will be called.\n   */\n  resolveJob_() {\n    const job = this.job_;\n    const threads = this.workers_.length;\n    let data, meta;\n    if (threads === 1) {\n      data = new Uint8ClampedArray(this.dataLookup_[0]['buffer']);\n      meta = this.dataLookup_[0]['meta'];\n    } else {\n      const length = job.inputs[0].data.length;\n      data = new Uint8ClampedArray(length);\n      meta = new Array(threads);\n      const segmentLength = 4 * Math.ceil(length / 4 / threads);\n      for (let i = 0; i < threads; ++i) {\n        const buffer = this.dataLookup_[i]['buffer'];\n        const offset = i * segmentLength;\n        data.set(new Uint8ClampedArray(buffer), offset);\n        meta[i] = this.dataLookup_[i]['meta'];\n      }\n    }\n    this.job_ = null;\n    this.dataLookup_ = {};\n    job.callback(\n      null,\n      new ImageData(data, job.inputs[0].width, job.inputs[0].height),\n      meta,\n    );\n    this.dispatch_();\n  }\n\n  /**\n   * Terminate all workers associated with the processor.\n   * @override\n   */\n  disposeInternal() {\n    for (let i = 0; i < this.workers_.length; ++i) {\n      this.workers_[i].terminate();\n    }\n    this.workers_.length = 0;\n  }\n}\n\n/**\n * A function that takes an array of input data, performs some operation, and\n * returns an array of output data.\n * For `pixel` type operations, the function will be called with an array of\n * pixels, where each pixel is an array of four numbers (`[r, g, b, a]`) in the\n * range of 0 - 255. It should return a single pixel array.\n * For `'image'` type operations, functions will be called with an array of\n * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData)\n * and should return a single\n * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).\n * The operations\n * are called with a second \"data\" argument, which can be used for storage.  The\n * data object is accessible from raster events, where it can be initialized in\n * \"beforeoperations\" and accessed again in \"afteroperations\".\n *\n * @typedef {function((Array<Array<number>>|Array<ImageData>), Object):\n *     (Array<number>|ImageData)} Operation\n */\n\n/**\n * @enum {string}\n */\nconst RasterEventType = {\n  /**\n   * Triggered before operations are run.  Listeners will receive an event object with\n   * a `data` property that can be used to make data available to operations.\n   * @event module:ol/source/Raster.RasterSourceEvent#beforeoperations\n   * @api\n   */\n  BEFOREOPERATIONS: 'beforeoperations',\n\n  /**\n   * Triggered after operations are run.  Listeners will receive an event object with\n   * a `data` property.  If more than one thread is used, `data` will be an array of\n   * objects.  If a single thread is used, `data` will be a single object.\n   * @event module:ol/source/Raster.RasterSourceEvent#afteroperations\n   * @api\n   */\n  AFTEROPERATIONS: 'afteroperations',\n};\n\n/**\n * @typedef {'pixel' | 'image'} RasterOperationType\n * Raster operation type. Supported values are `'pixel'` and `'image'`.\n */\n\n/**\n * @typedef {import(\"./Image.js\").ImageSourceEventTypes|'beforeoperations'|'afteroperations'} RasterSourceEventTypes\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Raster~RasterSource} instances are instances of this\n * type.\n */\nexport class RasterSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n   * @param {Object|Array<Object>} data An object made available to operations.  For \"afteroperations\" evenets\n   * this will be an array of objects if more than one thread is used.\n   */\n  constructor(type, frameState, data) {\n    super(type);\n\n    /**\n     * The raster extent.\n     * @type {import(\"../extent.js\").Extent}\n     * @api\n     */\n    this.extent = frameState.extent;\n\n    /**\n     * The pixel resolution (map units per pixel).\n     * @type {number}\n     * @api\n     */\n    this.resolution = frameState.viewState.resolution / frameState.pixelRatio;\n\n    /**\n     * An object made available to all operations.  This can be used by operations\n     * as a storage object (e.g. for calculating statistics).\n     * @type {Object}\n     * @api\n     */\n    this.data = data;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources Input\n * sources or layers.  For vector data, use an VectorImage layer.\n * @property {Operation} [operation] Raster operation.\n * The operation will be called with data from input sources\n * and the output will be assigned to the raster source.\n * @property {Object} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} [threads] By default, operations will be run in a single worker thread.\n * To avoid using workers altogether, set `threads: 0`.  For pixel operations, operations can\n * be run in multiple worker threads.  Note that there is additional overhead in\n * transferring data to multiple workers, and that depending on the user's\n * system, it may not be possible to parallelize the work.\n * @property {RasterOperationType} [operationType='pixel'] Operation type.\n * Supported values are `'pixel'` and `'image'`.  By default,\n * `'pixel'` operations are assumed, and operations will be called with an\n * array of pixels from input sources.  If set to `'image'`, operations will\n * be called with an array of ImageData objects from input sources.\n * @property {Array<number>|null} [resolutions] Resolutions. If specified, raster operations will only\n * be run at the given resolutions.  By default, the resolutions of the first source with resolutions\n * specified will be used, if any. Set to `null` to use any view resolution instead.\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Image.js\").ImageSourceEventTypes, import(\"./Image.js\").ImageSourceEvent, Return> &\n *   import(\"../Observable\").OnSignature<RasterSourceEventTypes, RasterSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types\n *     |RasterSourceEventTypes, Return>} RasterSourceOnSignature\n */\n\n/**\n * @classdesc\n * A source that transforms data from any number of input sources using an\n * {@link module:ol/source/Raster~Operation} function to transform input pixel values into\n * output pixel values.\n *\n * @fires module:ol/source/Raster.RasterSourceEvent\n * @api\n */\nclass RasterSource extends ImageSource {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    super({\n      projection: null,\n    });\n\n    /***\n     * @type {RasterSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {RasterSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {RasterSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {Processor}\n     */\n    this.processor_ = null;\n\n    /**\n     * @private\n     * @type {RasterOperationType}\n     */\n    this.operationType_ =\n      options.operationType !== undefined ? options.operationType : 'pixel';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.threads_ = options.threads !== undefined ? options.threads : 1;\n\n    /**\n     * @private\n     * @type {Array<import(\"../layer/Layer.js\").default>}\n     */\n    this.layers_ = createLayers(options.sources);\n\n    const changed = this.changed.bind(this);\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      this.layers_[i].addEventListener(EventType.CHANGE, changed);\n    }\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.useResolutions_ = options.resolutions !== null;\n\n    /**\n     * @private\n     * @type {import(\"../TileQueue.js\").default}\n     */\n    this.tileQueue_ = new TileQueue(function () {\n      return 1;\n    }, this.processSources_.bind(this));\n\n    /**\n     * The most recently requested frame state.\n     * @type {import(\"../Map.js\").FrameState}\n     * @private\n     */\n    this.requestedFrameState_;\n\n    /**\n     * The most recently rendered image canvas.\n     * @type {import(\"../ImageCanvas.js\").default}\n     * @private\n     */\n    this.renderedImageCanvas_ = null;\n\n    /**\n     * The most recently rendered revision.\n     * @type {number}\n     * @private\n     */\n    this.renderedRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").FrameState}\n     */\n    this.frameState_ = {\n      animate: false,\n      coordinateToPixelTransform: createTransform(),\n      declutter: null,\n      extent: null,\n      index: 0,\n      layerIndex: 0,\n      layerStatesArray: getLayerStatesArray(this.layers_),\n      pixelRatio: 1,\n      pixelToCoordinateTransform: createTransform(),\n      postRenderFunctions: [],\n      size: [0, 0],\n      tileQueue: this.tileQueue_,\n      time: Date.now(),\n      usedTiles: {},\n      viewState: /** @type {import(\"../View.js\").State} */ ({\n        rotation: 0,\n      }),\n      viewHints: [],\n      wantedTiles: {},\n      mapId: getUid(this),\n      renderTargets: {},\n    };\n\n    this.setAttributions(function (frameState) {\n      /** @type {Array<string>} */\n      const attributions = [];\n      for (let i = 0, iMax = options.sources.length; i < iMax; ++i) {\n        const sourceOrLayer = options.sources[i];\n        const source =\n          sourceOrLayer instanceof Source\n            ? sourceOrLayer\n            : sourceOrLayer.getSource();\n        if (!source) {\n          continue;\n        }\n        const sourceAttributions = source.getAttributions()?.(frameState);\n        if (typeof sourceAttributions === 'string') {\n          attributions.push(sourceAttributions);\n        } else if (sourceAttributions !== undefined) {\n          attributions.push(...sourceAttributions);\n        }\n      }\n      return attributions;\n    });\n\n    if (options.operation !== undefined) {\n      this.setOperation(options.operation, options.lib);\n    }\n  }\n\n  /**\n   * Set the operation.\n   * @param {Operation} operation New operation.\n   * @param {Object} [lib] Functions that will be available to operations run\n   *     in a worker.\n   * @api\n   */\n  setOperation(operation, lib) {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n\n    this.processor_ = new Processor({\n      operation: operation,\n      imageOps: this.operationType_ === 'image',\n      queue: 1,\n      lib: lib,\n      threads: this.threads_,\n    });\n    this.changed();\n  }\n\n  /**\n   * Update the stored frame state.\n   * @param {import(\"../extent.js\").Extent} extent The view extent (in map units).\n   * @param {number} resolution The view resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n   * @return {import(\"../Map.js\").FrameState} The updated frame state.\n   * @private\n   */\n  updateFrameState_(extent, resolution, projection) {\n    const frameState = /** @type {import(\"../Map.js\").FrameState} */ (\n      Object.assign({}, this.frameState_)\n    );\n\n    frameState.viewState = /** @type {import(\"../View.js\").State} */ (\n      Object.assign({}, frameState.viewState)\n    );\n\n    const center = getCenter(extent);\n\n    frameState.size[0] = Math.ceil(getWidth(extent) / resolution);\n    frameState.size[1] = Math.ceil(getHeight(extent) / resolution);\n    frameState.extent = [\n      center[0] - (frameState.size[0] * resolution) / 2,\n      center[1] - (frameState.size[1] * resolution) / 2,\n      center[0] + (frameState.size[0] * resolution) / 2,\n      center[1] + (frameState.size[1] * resolution) / 2,\n    ];\n    frameState.time = Date.now();\n\n    const viewState = frameState.viewState;\n    viewState.center = center;\n    viewState.projection = projection;\n    viewState.resolution = resolution;\n    return frameState;\n  }\n\n  /**\n   * Determine if all sources are ready.\n   * @return {boolean} All sources are ready.\n   * @private\n   */\n  allSourcesReady_() {\n    let ready = true;\n    let source;\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      source = this.layers_[i].getSource();\n      if (!source || source.getState() !== 'ready') {\n        ready = false;\n        break;\n      }\n    }\n    return ready;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../ImageCanvas.js\").default} Single image.\n   * @override\n   */\n  getImage(extent, resolution, pixelRatio, projection) {\n    if (!this.allSourcesReady_()) {\n      return null;\n    }\n\n    this.tileQueue_.loadMoreTiles(16, 16);\n\n    resolution = this.findNearestResolution(resolution);\n    const frameState = this.updateFrameState_(extent, resolution, projection);\n    this.requestedFrameState_ = frameState;\n\n    // check if we can't reuse the existing ol/ImageCanvas\n    if (this.renderedImageCanvas_) {\n      const renderedResolution = this.renderedImageCanvas_.getResolution();\n      const renderedExtent = this.renderedImageCanvas_.getExtent();\n      if (\n        resolution !== renderedResolution ||\n        !equals(frameState.extent, renderedExtent)\n      ) {\n        this.renderedImageCanvas_ = null;\n      }\n    }\n\n    if (\n      !this.renderedImageCanvas_ ||\n      this.getRevision() !== this.renderedRevision_\n    ) {\n      this.processSources_();\n    }\n\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    }\n\n    return this.renderedImageCanvas_;\n  }\n\n  /**\n   * Start processing source data.\n   * @private\n   */\n  processSources_() {\n    const frameState = this.requestedFrameState_;\n    const len = this.layers_.length;\n    const imageDatas = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      frameState.layerIndex = i;\n      frameState.renderTargets = {};\n      const imageData = getImageData(this.layers_[i], frameState);\n      if (imageData) {\n        imageDatas[i] = imageData;\n      } else {\n        return;\n      }\n    }\n\n    const data = {};\n    this.dispatchEvent(\n      new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data),\n    );\n    this.processor_.process(\n      imageDatas,\n      data,\n      this.onWorkerComplete_.bind(this, frameState),\n    );\n  }\n\n  /**\n   * Called when pixel processing is complete.\n   * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n   * @param {Error} err Any error during processing.\n   * @param {ImageData} output The output image data.\n   * @param {Object|Array<Object>} data The user data (or an array if more than one thread).\n   * @private\n   */\n  onWorkerComplete_(frameState, err, output, data) {\n    if (err || !output) {\n      return;\n    }\n\n    // do nothing if extent or resolution changed\n    const extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    if (\n      resolution !== this.requestedFrameState_.viewState.resolution ||\n      !equals(extent, this.requestedFrameState_.extent)\n    ) {\n      return;\n    }\n\n    let context;\n    if (this.renderedImageCanvas_) {\n      context =\n        /** @type {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} */ (\n          this.renderedImageCanvas_.getImage().getContext('2d')\n        );\n    } else {\n      const width = Math.round(getWidth(extent) / resolution);\n      const height = Math.round(getHeight(extent) / resolution);\n      context = createCanvasContext2D(width, height);\n      this.renderedImageCanvas_ = new ImageCanvas(\n        extent,\n        resolution,\n        1,\n        context.canvas,\n      );\n    }\n    context.putImageData(output, 0, 0);\n\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    } else {\n      this.changed();\n    }\n    this.renderedRevision_ = this.getRevision();\n\n    this.dispatchEvent(\n      new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data),\n    );\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   * @override\n   */\n  getResolutions(projection) {\n    if (!this.useResolutions_) {\n      return null;\n    }\n    let resolutions = super.getResolutions();\n    if (!resolutions) {\n      for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n        const source = this.layers_[i].getSource();\n        resolutions = source.getResolutions(projection);\n        if (resolutions) {\n          break;\n        }\n      }\n    }\n    return resolutions;\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n    super.disposeInternal();\n  }\n}\n\n/**\n * Clean up and unregister the worker.\n * @function\n * @api\n */\nRasterSource.prototype.dispose;\n\n/**\n * A reusable canvas context.\n * @type {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D}\n * @private\n */\nlet sharedContext = null;\n\n/**\n * Get image data from a layer.\n * @param {import(\"../layer/Layer.js\").default} layer Layer to render.\n * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n * @return {ImageData} The image data.\n */\nfunction getImageData(layer, frameState) {\n  const renderer = layer.getRenderer();\n  if (!renderer) {\n    throw new Error('Unsupported layer type: ' + layer);\n  }\n\n  if (!renderer.prepareFrame(frameState)) {\n    return null;\n  }\n  const width = frameState.size[0];\n  const height = frameState.size[1];\n  if (width === 0 || height === 0) {\n    return null;\n  }\n  const container = renderer.renderFrame(frameState, null);\n  let element;\n  if (container instanceof HTMLCanvasElement) {\n    element = container;\n  } else {\n    if (container) {\n      element = container.firstElementChild;\n    }\n    if (!(element instanceof HTMLCanvasElement)) {\n      throw new Error('Unsupported rendered element: ' + element);\n    }\n    if (element.width === width && element.height === height) {\n      const context = element.getContext('2d');\n      return context.getImageData(0, 0, width, height);\n    }\n  }\n\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(width, height, undefined, {\n      willReadFrequently: true,\n    });\n  } else {\n    const canvas = sharedContext.canvas;\n    if (canvas.width !== width || canvas.height !== height) {\n      sharedContext = createCanvasContext2D(width, height, undefined, {\n        willReadFrequently: true,\n      });\n    } else {\n      sharedContext.clearRect(0, 0, width, height);\n    }\n  }\n  sharedContext.drawImage(element, 0, 0, width, height);\n  return sharedContext.getImageData(0, 0, width, height);\n}\n\n/**\n * Get a list of layer states from a list of layers.\n * @param {Array<import(\"../layer/Layer.js\").default>} layers Layers.\n * @return {Array<import(\"../layer/Layer.js\").State>} The layer states.\n */\nfunction getLayerStatesArray(layers) {\n  return layers.map(function (layer) {\n    return layer.getLayerState();\n  });\n}\n\n/**\n * Create layers for all sources.\n * @param {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources The sources.\n * @return {Array<import(\"../layer/Layer.js\").default>} Array of layers.\n */\nfunction createLayers(sources) {\n  const len = sources.length;\n  const layers = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    layers[i] = createLayer(sources[i]);\n  }\n  return layers;\n}\n\n/**\n * Create a layer for the provided source.\n * @param {import(\"./Source.js\").default|import(\"../layer/Layer.js\").default} layerOrSource The layer or source.\n * @return {import(\"../layer/Layer.js\").default} The layer.\n */\nfunction createLayer(layerOrSource) {\n  // @type {import(\"../layer/Layer.js\").default}\n  let layer;\n  if (layerOrSource instanceof Source) {\n    if (layerOrSource instanceof TileSource) {\n      layer = new TileLayer({source: layerOrSource});\n    } else if (layerOrSource instanceof ImageSource) {\n      layer = new ImageLayer({source: layerOrSource});\n    }\n  } else {\n    layer = layerOrSource;\n  }\n  return layer;\n}\n\nexport default RasterSource;\n"],"names":["createMinion","operation","data","buffers","meta","imageOps","width","height","numBuffers","numBytes","images","b","output","arrays","pixels","i","j","array","pixel","createWorker","config","onMessage","lines","name","worker","Buffer","createFauxWorker","minion","terminated","Processor","Disposable","threads","workers","inputs","callback","job","input","length","segmentLength","offset","slices","jj","index","event","buffer","RasterEventType","RasterSourceEvent","Event","type","frameState","RasterSource","ImageSource","options","createLayers","changed","ii","EventType","TileQueue","createTransform","getLayerStatesArray","getUid","attributions","iMax","sourceOrLayer","source","Source","sourceAttributions","lib","extent","resolution","projection","center","getCenter","getWidth","getHeight","viewState","ready","pixelRatio","renderedResolution","renderedExtent","equals","len","imageDatas","imageData","getImageData","err","context","createCanvasContext2D","ImageCanvas","resolutions","sharedContext","layer","renderer","container","element","canvas","layers","sources","createLayer","layerOrSource","TileSource","TileLayer","ImageLayer"],"mappings":"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","x_google_ignoreList":[0]}