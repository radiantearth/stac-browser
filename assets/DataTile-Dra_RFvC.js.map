{"version":3,"file":"DataTile-Dra_RFvC.js","sources":["../../node_modules/ol/webgl/Canvas.js","../../node_modules/ol/reproj/glreproj.js","../../node_modules/ol/reproj/DataTile.js","../../node_modules/ol/source/DataTile.js"],"sourcesContent":["import * as mat4 from '../vec/mat4.js';\n\n/**\n * @module ol/webgl/Canvas\n */\n\nconst VERTEX_SHADER = `\n  attribute vec4 a_position;\n  attribute vec4 a_texcoord;\n\n  uniform mat4 u_matrix;\n  uniform mat4 u_textureMatrix;\n\n  varying vec2 v_texcoord;\n\n  void main() {\n    gl_Position = u_matrix * a_position;\n    vec2 texcoord = (u_textureMatrix * a_texcoord).xy;\n    v_texcoord = texcoord;\n  }\n`;\n\nconst FRAGMENT_SHADER = `\n  precision mediump float;\n\n  varying vec2 v_texcoord;\n\n  uniform sampler2D u_texture;\n\n  void main() {\n    if (\n      v_texcoord.x < 0.0 ||\n      v_texcoord.y < 0.0 ||\n      v_texcoord.x > 1.0 ||\n      v_texcoord.y > 1.0\n    ) {\n      discard;\n    }\n    gl_FragColor = texture2D(u_texture, v_texcoord);\n  }\n`;\n\n/** @typedef {import(\"../transform.js\").Transform} Matrix */\n\n/**\n * Canvas-like operations implemented in webgl.\n */\nexport class Canvas {\n  /**\n   * @param {WebGLRenderingContext} gl Context to render in.\n   */\n  constructor(gl) {\n    /**\n     * @private\n     * @type {WebGLRenderingContext}\n     */\n    this.gl_ = gl;\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.program_ = createProgram(gl, FRAGMENT_SHADER, VERTEX_SHADER);\n\n    this.positionLocation = gl.getAttribLocation(this.program_, 'a_position');\n    this.texcoordLocation = gl.getAttribLocation(this.program_, 'a_texcoord');\n\n    this.matrixLocation = gl.getUniformLocation(this.program_, 'u_matrix');\n    this.textureMatrixLocation = gl.getUniformLocation(\n      this.program_,\n      'u_textureMatrix',\n    );\n    this.textureLocation = gl.getUniformLocation(this.program_, 'u_texture');\n\n    this.positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n\n    this.positions = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array(this.positions),\n      gl.STATIC_DRAW,\n    );\n\n    this.texcoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);\n\n    this.texcoords = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array(this.texcoords),\n      gl.STATIC_DRAW,\n    );\n  }\n\n  /**\n   * 2dContext drawImage call implemented in webgl.\n   * Unlike images, textures do not have a width and height associated\n   * with them so we'll pass in the width and height of the texture.\n   *\n   * @param {WebGLTexture} tex Image to draw.\n   * @param {number} texWidth Image width.\n   * @param {number} texHeight Image height.\n   * @param {number} srcX Top-left x-point to read src image.\n   * @param {number} srcY Top-left y-point to read src image.\n   * @param {number} [srcWidth] Width of source to read.\n   * @param {number} [srcHeight] Height of source to read.\n   * @param {number} [dstX] Top-left x-point of destination.\n   * @param {number} [dstY] Top-left y-point of destination.\n   * @param {number} [dstWidth] Width of written image in destination.\n   * @param {number} [dstHeight] Height of written image in destination.\n   * @param {number} [width] Width of canvas.\n   * @param {number} [height] Height of canvas.\n   */\n  drawImage(\n    tex,\n    texWidth,\n    texHeight,\n    srcX,\n    srcY,\n    srcWidth,\n    srcHeight,\n    dstX,\n    dstY,\n    dstWidth,\n    dstHeight,\n    width,\n    height,\n  ) {\n    const gl = this.gl_;\n\n    if (dstX === undefined) {\n      dstX = srcX;\n    }\n    if (dstY === undefined) {\n      dstY = srcY;\n    }\n    if (srcWidth === undefined) {\n      srcWidth = texWidth;\n    }\n    if (srcHeight === undefined) {\n      srcHeight = texHeight;\n    }\n    if (dstWidth === undefined) {\n      dstWidth = srcWidth;\n    }\n    if (dstHeight === undefined) {\n      dstHeight = srcHeight;\n    }\n    if (width === undefined) {\n      width = gl.canvas.width;\n    }\n    if (height === undefined) {\n      height = gl.canvas.height;\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n\n    gl.useProgram(this.program_);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n    gl.enableVertexAttribArray(this.positionLocation);\n    gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);\n    gl.enableVertexAttribArray(this.texcoordLocation);\n    gl.vertexAttribPointer(this.texcoordLocation, 2, gl.FLOAT, false, 0, 0);\n\n    // matrix for converting pixels to clip space\n    let matrix = mat4.orthographic(0, width, 0, height, -1, 1);\n    matrix = mat4.translate(matrix, dstX, dstY, 0);\n    matrix = mat4.scale(matrix, dstWidth, dstHeight, 1);\n    gl.uniformMatrix4fv(this.matrixLocation, false, matrix);\n\n    let texMatrix = mat4.translation(srcX / texWidth, srcY / texHeight, 0);\n    texMatrix = mat4.scale(\n      texMatrix,\n      srcWidth / texWidth,\n      srcHeight / texHeight,\n      1,\n    );\n\n    gl.uniformMatrix4fv(this.textureMatrixLocation, false, texMatrix);\n    gl.uniform1i(this.textureLocation, 0);\n    gl.drawArrays(gl.TRIANGLES, 0, this.positions.length / 2);\n  }\n}\n\n/**\n * @param {WebGLRenderingContext} gl Rendering Context.\n * @param {GLenum} type Type of shader.\n * @param {string} source source of shader.\n * @return {WebGLShader} [progam] The program.\n */\nfunction createShader(gl, type, source) {\n  const shader = gl.createShader(type);\n\n  if (shader === null) {\n    throw new Error('Shader compilation failed');\n  }\n\n  gl.shaderSource(shader, source);\n\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    const log = gl.getShaderInfoLog(shader);\n    if (log === null) {\n      throw new Error('Shader info log creation failed');\n    }\n    throw new Error(log);\n  }\n\n  return shader;\n}\n\n/**\n * @param {WebGLRenderingContext} gl Rendering Context.\n * @param {string} fragmentSource Fragment shader source.\n * @param {string} vertexSource Vertex shader source.\n * @return {WebGLProgram} [progam] The program.\n */\nexport function createProgram(gl, fragmentSource, vertexSource) {\n  const program = gl.createProgram();\n\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\n  if (program === null) {\n    throw new Error('Program creation failed');\n  }\n\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    const log = gl.getProgramInfoLog(program);\n    if (log === null) {\n      throw new Error('Program info log creation failed');\n    }\n    throw new Error();\n  }\n  return program;\n}\n","/**\n * @module ol/reproj/glreproj\n */\nimport {\n  createEmpty,\n  extend,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from '../extent.js';\nimport {WORKER_OFFSCREEN_CANVAS} from '../has.js';\nimport * as mat4 from '../vec/mat4.js';\nimport {Canvas as WebGLCanvas, createProgram} from '../webgl/Canvas.js';\n\nconst EDGE_VERTEX_SHADER = `\n  attribute vec4 a_position;\n\n  uniform mat4 u_matrix;\n\n  void main() {\n     gl_Position = u_matrix * a_position;\n  }\n`;\nconst EDGE_FRAGMENT_SHADER = `\n  precision mediump float;\n\n  uniform vec4 u_val;\n  void main() {\n     gl_FragColor = u_val;\n  }\n`;\n\nconst TRIANGLE_VERTEX_SHADER = `\n  attribute vec4 a_position;\n  attribute vec2 a_texcoord;\n\n  varying vec2 v_texcoord;\n\n  uniform mat4 u_matrix;\n\n  void main() {\n     gl_Position = u_matrix * a_position;\n     v_texcoord = a_texcoord;\n  }\n`;\nconst TRIANGLE_FRAGMENT_SHADER = `\n  precision mediump float;\n\n  varying vec2 v_texcoord;\n\n  uniform sampler2D u_texture;\n\n  void main() {\n    if (v_texcoord.x < 0.0 || v_texcoord.x > 1.0 || v_texcoord.y < 0.0 || v_texcoord.y > 1.0) {\n      discard;\n    }\n    gl_FragColor = texture2D(u_texture, v_texcoord);\n  }\n`;\n\n/**\n * Create an html canvas element and returns its webgl context.\n * @param {number} [width] Canvas width.\n * @param {number} [height] Canvas height.\n * @param {Array<HTMLCanvasElement | OffscreenCanvas>} [canvasPool] Canvas pool to take existing canvas from.\n * @param {WebGLContextAttributes} [settings] CanvasRenderingContext2DSettings\n * @return {WebGLRenderingContext} The context.\n */\nexport function createCanvasContextWebGL(width, height, canvasPool, settings) {\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\n  let canvas;\n  if (canvasPool && canvasPool.length) {\n    canvas = /** @type {HTMLCanvasElement} */ (canvasPool.shift());\n  } else if (WORKER_OFFSCREEN_CANVAS) {\n    canvas = new OffscreenCanvas(width || 300, height || 300);\n  } else {\n    canvas = document.createElement('canvas');\n  }\n  if (width) {\n    canvas.width = width;\n  }\n  if (height) {\n    canvas.height = height;\n  }\n  //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n  return /** @type {WebGLRenderingContext} */ (\n    canvas.getContext('webgl', settings)\n  );\n}\n\n/**\n * Releases canvas memory to avoid exceeding memory limits in Safari.\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\n * @param {WebGLRenderingContext} gl Context.\n */\nexport function releaseGLCanvas(gl) {\n  const canvas = gl.canvas;\n  canvas.width = 1;\n  canvas.height = 1;\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n}\n\n/**\n * @type {Array<HTMLCanvasElement | OffscreenCanvas>}\n */\nexport const canvasGLPool = [];\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"../extent.js\").Extent} extent Extent.\n * @property {import(\"../extent.js\").Extent} [clipExtent] Clip extent.\n * @property {WebGLTexture} texture Texture.\n * @property {number} width Width of texture.\n * @property {number} height Height of texture.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {WebGLRenderingContext} gl the context to render in.\n * @param {number} width_ Width of the canvas.\n * @param {number} height_ Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"../extent.js\").Extent} targetExtent Target extent (tile).\n * @param {import(\"../reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {number} dataType What kind of data is the textures, must be gl.FLOAT or gl.UNSIGNED_BYTE\n * TODO: Allow setting renderEdges value in the data as this is done in \"data-space\".\n * @param {boolean | Array<number>} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @param {boolean} [drawSingle] Draw single source images directly without stitchTexture.\n * @return {{framebuffer: WebGLFramebuffer, width: number, height: number, texture: WebGLTexture}} Canvas with reprojected data.\n */\nexport function render(\n  gl,\n  width_,\n  height_,\n  pixelRatio,\n  sourceResolution,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  dataType,\n  renderEdges,\n  interpolate,\n  drawSingle,\n) {\n  const width = Math.round(pixelRatio * width_);\n  const height = Math.round(pixelRatio * height_);\n  gl.canvas.width = width;\n  gl.canvas.height = height;\n\n  /** @type {WebGLFramebuffer | null} */\n  let resultFrameBuffer;\n  /** @type {WebGLTexture | null} */\n  let resultTexture;\n  {\n    resultTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, resultTexture);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    if (interpolate) {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    } else {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    }\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      width,\n      height,\n      0,\n      gl.RGBA,\n      dataType,\n      null,\n    );\n\n    resultFrameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      resultTexture,\n      0,\n    );\n  }\n\n  if (resultFrameBuffer === null) {\n    throw new Error('Could not create framebuffer');\n  }\n  if (resultTexture === null) {\n    throw new Error('Could not create texture');\n  }\n\n  if (sources.length === 0) {\n    return {\n      width,\n      height,\n      framebuffer: resultFrameBuffer,\n      texture: resultTexture,\n    };\n  }\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  /** @type {WebGLTexture | null} */\n  let stitchTexture;\n  /** @type {number} */\n  let stitchWidth;\n  /** @type {number} */\n  let stitchHeight;\n  const stitchScale = 1 / sourceResolution;\n\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\n    stitchTexture = gl.createTexture();\n    if (resultTexture === null) {\n      throw new Error('Could not create texture');\n    }\n    stitchWidth = Math.round(getWidth(sourceDataExtent) * stitchScale);\n    stitchHeight = Math.round(getHeight(sourceDataExtent) * stitchScale);\n\n    // Make sure we do not exceed the max texture size by lowering the resolution for this image.\n    // https://github.com/openlayers/openlayers/pull/15860#issuecomment-2254123580\n    const maxTexSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    const largeSide = Math.max(stitchWidth, stitchHeight);\n    const scaleFactor = largeSide > maxTexSize ? maxTexSize / largeSide : 1;\n    const stitchWidthFixed = Math.round(stitchWidth * scaleFactor);\n    const stitchHeightFixed = Math.round(stitchHeight * scaleFactor);\n\n    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    if (interpolate) {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    } else {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    }\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      stitchWidthFixed,\n      stitchHeightFixed,\n      0,\n      gl.RGBA,\n      dataType,\n      null,\n    );\n\n    const fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      stitchTexture,\n      0,\n    );\n    const webGLCanvas = new WebGLCanvas(gl);\n\n    sources.forEach(function (src, i, arr) {\n      const xPos =\n        (src.extent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;\n      const yPos =\n        -(src.extent[3] - sourceDataExtent[3]) * stitchScale * scaleFactor;\n      const srcWidth = getWidth(src.extent) * stitchScale * scaleFactor;\n      const srcHeight = getHeight(src.extent) * stitchScale * scaleFactor;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n      gl.viewport(0, 0, stitchWidthFixed, stitchHeightFixed);\n\n      if (src.clipExtent) {\n        const xPos =\n          (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;\n        const yPos =\n          -(src.clipExtent[3] - sourceDataExtent[3]) *\n          stitchScale *\n          scaleFactor;\n        const width = getWidth(src.clipExtent) * stitchScale * scaleFactor;\n        const height = getHeight(src.clipExtent) * stitchScale * scaleFactor;\n        gl.enable(gl.SCISSOR_TEST);\n        gl.scissor(\n          interpolate ? xPos : Math.round(xPos),\n          interpolate ? yPos : Math.round(yPos),\n          interpolate ? width : Math.round(xPos + width) - Math.round(xPos),\n          interpolate ? height : Math.round(yPos + height) - Math.round(yPos),\n        );\n      }\n\n      webGLCanvas.drawImage(\n        src.texture,\n        src.width,\n        src.height,\n        gutter,\n        gutter,\n        src.width - 2 * gutter,\n        src.height - 2 * gutter,\n        interpolate ? xPos : Math.round(xPos),\n        interpolate ? yPos : Math.round(yPos),\n        interpolate ? srcWidth : Math.round(xPos + srcWidth) - Math.round(xPos),\n        interpolate\n          ? srcHeight\n          : Math.round(yPos + srcHeight) - Math.round(yPos),\n        stitchWidthFixed,\n        stitchHeightFixed,\n      );\n\n      gl.disable(gl.SCISSOR_TEST);\n    });\n    gl.deleteFramebuffer(fb);\n  } else {\n    stitchTexture = sources[0].texture;\n    stitchWidth = sources[0].width;\n    stitchHeight = sources[0].width;\n  }\n\n  const targetTopLeft = getTopLeft(targetExtent);\n  const sourceTopLeft = getTopLeft(sourceDataExtent);\n\n  const getUVs = (\n    /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ target,\n  ) => {\n    const u0 =\n      ((target[0][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\n    const v0 =\n      (-(target[0][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\n    const u1 =\n      ((target[1][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\n    const v1 =\n      (-(target[1][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\n    const u2 =\n      ((target[2][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\n    const v2 =\n      (-(target[2][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\n    return {u1, v1, u0, v0, u2, v2};\n  };\n\n  gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);\n  gl.viewport(0, 0, width, height);\n\n  // Draw source to reprojtile\n  {\n    /** @type {Array<number>} */\n    const vertices = [];\n    /** @type {Array<number>} */\n    const texcoords = [];\n\n    const triProgram = createProgram(\n      gl,\n      TRIANGLE_FRAGMENT_SHADER,\n      TRIANGLE_VERTEX_SHADER,\n    );\n    gl.useProgram(triProgram);\n\n    // Bind image\n    const textureLocation = gl.getUniformLocation(triProgram, 'u_texture');\n    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);\n\n    // Tell the shader to get the texture from texture unit 0\n    gl.uniform1i(textureLocation, 0);\n\n    // Calculate vert and tex coordinates.\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const source = triangle.source;\n      const target = triangle.target;\n      // Make sure that everything is on pixel boundaries\n      const {u1, v1, u0, v0, u2, v2} = getUVs(target);\n\n      const su0 =\n        (source[0][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv0 =\n        -(source[0][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n      const su1 =\n        (source[1][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv1 =\n        -(source[1][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n      const su2 =\n        (source[2][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv2 =\n        -(source[2][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n\n      vertices.push(u1, v1, u0, v0, u2, v2);\n      texcoords.push(su1, sv1, su0, sv0, su2, sv2);\n    });\n\n    // Convert pixel space to clip space.\n    const matrix = mat4.orthographic(0, width, height, 0, -1, 1);\n    const matrixLocation = gl.getUniformLocation(triProgram, 'u_matrix');\n    gl.uniformMatrix4fv(matrixLocation, false, matrix);\n\n    const positionLocation = gl.getAttribLocation(triProgram, 'a_position');\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(positionLocation);\n\n    const texcoordLocation = gl.getAttribLocation(triProgram, 'a_texcoord');\n    const texcoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(texcoordLocation);\n\n    gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);\n  }\n\n  if (renderEdges) {\n    const edgeProgram = createProgram(\n      gl,\n      EDGE_FRAGMENT_SHADER,\n      EDGE_VERTEX_SHADER,\n    );\n    gl.useProgram(edgeProgram);\n    const matrix = mat4.orthographic(0, width, height, 0, -1, 1);\n    const matrixLocation = gl.getUniformLocation(edgeProgram, 'u_matrix');\n    gl.uniformMatrix4fv(matrixLocation, false, matrix);\n\n    const burnval = Array.isArray(renderEdges) ? renderEdges : [0, 0, 0, 255];\n    const burnvalLocation = gl.getUniformLocation(edgeProgram, 'u_val');\n    const isFloat = true;\n    if (isFloat) {\n      gl.uniform4fv(burnvalLocation, burnval);\n    } else {\n      gl.uniform4iv(burnvalLocation, burnval);\n    }\n\n    const positionLocation = gl.getAttribLocation(edgeProgram, 'a_position');\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(positionLocation);\n\n    /** @type {Array<number>} */\n    const lines = triangulation.getTriangles().reduce(function (\n      /** @type {Array<number>} */ lines,\n      triangle,\n    ) {\n      const target = triangle.target;\n      const {u1, v1, u0, v0, u2, v2} = getUVs(target);\n\n      return lines.concat([u1, v1, u0, v0, u0, v0, u2, v2, u2, v2, u1, v1]);\n    }, []);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lines), gl.STATIC_DRAW);\n    gl.drawArrays(gl.LINES, 0, lines.length / 2);\n  }\n\n  return {\n    width,\n    height,\n    framebuffer: resultFrameBuffer,\n    texture: resultTexture,\n  };\n}\n","/**\n * @module ol/reproj/DataTile\n */\n\nimport DataTile, {asArrayLike, asImageLike, toArray} from '../DataTile.js';\nimport TileState from '../TileState.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport EventType from '../events/EventType.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {calculateSourceExtentResolution} from '../reproj.js';\nimport Triangulation from './Triangulation.js';\nimport {ERROR_THRESHOLD} from './common.js';\nimport {\n  canvasGLPool,\n  createCanvasContextWebGL,\n  releaseGLCanvas,\n  render as renderReprojected,\n} from './glreproj.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {DataTile} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\n * @property {number} pixelRatio Pixel ratio.\n * @property {number} gutter Gutter of the source tiles.\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {import(\"../transform.js\").Transform} [transformMatrix] Source transform matrix.\n * @property {boolean} [renderEdges] Render reprojection edges.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected data tile.\n * See {@link module:ol/source/DataTile~DataTileSource}.\n *\n */\nclass ReprojDataTile extends DataTile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    super({\n      tileCoord: options.tileCoord,\n      loader: () => Promise.resolve(new Uint8ClampedArray(4)),\n      interpolate: options.interpolate,\n      transition: options.transition,\n    });\n\n    /**\n     * @private\n     * @type {boolean | Array<number>}\n     */\n    this.renderEdges_ =\n      options.renderEdges !== undefined ? options.renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter;\n\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     * @private\n     */\n    this.reprojData_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.reprojError_ = null;\n\n    /**\n     * @type {import('../size.js').Size}\n     * @private\n     */\n    this.reprojSize_ = undefined;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = options.sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = options.targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const sourceProj = options.sourceProj;\n    const sourceProjExtent = sourceProj.getExtent();\n    const sourceTileGridExtent = options.sourceTileGrid.getExtent();\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceTileGridExtent\n        ? getIntersection(sourceProjExtent, sourceTileGridExtent)\n        : sourceProjExtent\n      : sourceTileGridExtent;\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = this.targetTileGrid_.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const targetProj = options.targetProj;\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      options.errorThreshold !== undefined\n        ? options.errorThreshold\n        : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n      options.transformMatrix,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n        const getTile = options.getTileFunction;\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('../size.js').Size} Tile size.\n   * @override\n   */\n  getSize() {\n    return this.reprojSize_;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {import(\"../DataTile.js\").Data} Tile data.\n   * @override\n   */\n  getData() {\n    return this.reprojData_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @override\n   */\n  getError() {\n    return this.reprojError_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const dataSources = [];\n    let imageLike = false;\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const size = tile.getSize();\n      const gutter = this.gutter_;\n      /**\n       * @type {import(\"../DataTile.js\").ArrayLike}\n       */\n      let tileData;\n      const arrayData = asArrayLike(tile.getData());\n      if (arrayData) {\n        tileData = arrayData;\n      } else {\n        imageLike = true;\n        tileData = toArray(asImageLike(tile.getData()));\n      }\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\n      const isFloat = tileData instanceof Float32Array;\n      const pixelCount = pixelSize[0] * pixelSize[1];\n      const DataType = isFloat ? Float32Array : Uint8ClampedArray;\n      const tileDataR = new DataType(\n        /** @type {ArrayBuffer} */ (tileData.buffer),\n      );\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n      const bytesPerPixel = (bytesPerElement * tileDataR.length) / pixelCount;\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\n      const bandCount = Math.floor(\n        bytesPerRow / bytesPerElement / pixelSize[0],\n      );\n      const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n      extent[0] += source.offset;\n      extent[2] += source.offset;\n      const clipExtent = this.clipExtent_?.slice();\n      if (clipExtent) {\n        clipExtent[0] += source.offset;\n        clipExtent[2] += source.offset;\n      }\n      dataSources.push({\n        extent: extent,\n        clipExtent: clipExtent,\n        data: tileDataR,\n        dataType: DataType,\n        bytesPerPixel: bytesPerPixel,\n        pixelSize: pixelSize,\n        bandCount: bandCount,\n      });\n    });\n    this.sourceTiles_.length = 0;\n\n    if (dataSources.length === 0) {\n      this.state = TileState.ERROR;\n      this.changed();\n      return;\n    }\n\n    const z = this.wrappedTileCoord_[0];\n    const size = this.targetTileGrid_.getTileSize(z);\n    const targetWidth = typeof size === 'number' ? size : size[0];\n    const targetHeight = typeof size === 'number' ? size : size[1];\n    const outWidth = Math.round(targetWidth * this.pixelRatio_);\n    const outHeight = Math.round(targetHeight * this.pixelRatio_);\n    const targetResolution = this.targetTileGrid_.getResolution(z);\n    const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n\n    const bandCount = dataSources[0].bandCount;\n    const dataR = new dataSources[0].dataType(bandCount * outWidth * outHeight);\n\n    const gl = createCanvasContextWebGL(outWidth, outHeight, canvasGLPool, {\n      premultipliedAlpha: false,\n      antialias: false,\n    });\n\n    let willInterpolate;\n    const format = gl.RGBA;\n    let textureType;\n    if (dataSources[0].dataType == Float32Array) {\n      textureType = gl.FLOAT;\n      gl.getExtension('WEBGL_color_buffer_float');\n      gl.getExtension('OES_texture_float');\n      gl.getExtension('EXT_float_blend');\n      const extension = gl.getExtension('OES_texture_float_linear');\n      const canInterpolate = extension !== null;\n      willInterpolate = canInterpolate && this.interpolate;\n    } else {\n      textureType = gl.UNSIGNED_BYTE;\n      willInterpolate = this.interpolate;\n    }\n\n    const BANDS_PR_REPROJ = 4;\n    const reprojs = Math.ceil(bandCount / BANDS_PR_REPROJ);\n    for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\n      const sources = [];\n      for (let i = 0, len = dataSources.length; i < len; ++i) {\n        const dataSource = dataSources[i];\n\n        const pixelSize = dataSource.pixelSize;\n        const width = pixelSize[0];\n        const height = pixelSize[1];\n\n        const data = new dataSource.dataType(BANDS_PR_REPROJ * width * height);\n        const dataS = dataSource.data;\n        let offset = reproj * BANDS_PR_REPROJ;\n        for (let j = 0, len = data.length; j < len; j += BANDS_PR_REPROJ) {\n          data[j] = dataS[offset];\n          data[j + 1] = dataS[offset + 1];\n          data[j + 2] = dataS[offset + 2];\n          data[j + 3] = dataS[offset + 3];\n          offset += bandCount;\n        }\n\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        if (willInterpolate) {\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        } else {\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        }\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texImage2D(\n          gl.TEXTURE_2D,\n          0,\n          format,\n          width,\n          height,\n          0,\n          format,\n          textureType,\n          data,\n        );\n\n        sources.push({\n          extent: dataSource.extent,\n          clipExtent: dataSource.clipExtent,\n          texture: texture,\n          width: width,\n          height: height,\n        });\n      }\n\n      const {framebuffer, width, height} = renderReprojected(\n        gl,\n        targetWidth,\n        targetHeight,\n        this.pixelRatio_,\n        sourceResolution,\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        textureType,\n        this.renderEdges_,\n        willInterpolate,\n      );\n\n      // The texture is always RGBA.\n      const rows = width;\n      const cols = height * BANDS_PR_REPROJ;\n      const data = new dataSources[0].dataType(rows * cols);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n      gl.readPixels(0, 0, width, height, gl.RGBA, textureType, data);\n\n      let offset = reproj * BANDS_PR_REPROJ;\n      for (let i = 0, len = data.length; i < len; i += BANDS_PR_REPROJ) {\n        // The data read by `readPixels` is flipped in the y-axis so flip it again.\n        const flipY = (rows - 1 - ((i / cols) | 0)) * cols + (i % cols);\n        dataR[offset] = data[flipY];\n        dataR[offset + 1] = data[flipY + 1];\n        dataR[offset + 2] = data[flipY + 2];\n        dataR[offset + 3] = data[flipY + 3];\n        offset += bandCount;\n      }\n    }\n\n    releaseGLCanvas(gl);\n    canvasGLPool.push(gl.canvas);\n\n    if (imageLike) {\n      const context = createCanvasContext2D(targetWidth, targetHeight);\n      const imageData = new ImageData(dataR, targetWidth);\n      context.putImageData(imageData, 0, 0);\n      this.reprojData_ = context.canvas;\n    } else {\n      this.reprojData_ = dataR;\n    }\n    this.reprojSize_ = [outWidth, outHeight];\n    this.state = TileState.LOADED;\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    let leftToLoad = 0;\n\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach(({tile}) => {\n      const state = tile.getState();\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\n        return;\n      }\n      leftToLoad++;\n\n      const sourceListenKey = listen(tile, EventType.CHANGE, () => {\n        const state = tile.getState();\n        if (\n          state == TileState.LOADED ||\n          state == TileState.ERROR ||\n          state == TileState.EMPTY\n        ) {\n          unlistenByKey(sourceListenKey);\n          leftToLoad--;\n          if (leftToLoad === 0) {\n            this.unlistenSources_();\n            this.reproject_();\n          }\n        }\n      });\n      this.sourcesListenerKeys_.push(sourceListenKey);\n    });\n\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    } else {\n      this.sourceTiles_.forEach(function ({tile}) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\n\nexport default ReprojDataTile;\n","/**\n * @module ol/source/DataTile\n */\nimport DataTile from '../DataTile.js';\nimport TileState from '../TileState.js';\nimport EventType from '../events/EventType.js';\nimport {toPromise} from '../functions.js';\nimport {equivalent, get as getProjection} from '../proj.js';\nimport ReprojDataTile from '../reproj/DataTile.js';\nimport {toSize} from '../size.js';\nimport {getCacheKey} from '../tilecoord.js';\nimport {\n  createXYZ,\n  extentFromProjection,\n  getForProjection as getTileGridForProjection,\n} from '../tilegrid.js';\nimport {getUid} from '../util.js';\nimport TileSource, {TileSourceEvent} from './Tile.js';\nimport TileEventType from './TileEventType.js';\n\n/**\n * @typedef {'anonymous'|'use-credentials'} CrossOriginAttribute\n */\n\n/**\n * @typedef {Object} LoaderOptions\n * @property {AbortSignal} signal An abort controller signal.\n * @property {CrossOriginAttribute} [crossOrigin] The cross-origin attribute for images.\n * @property {number} [maxY] The maximum y coordinate at the given z level.  Will be undefined if the\n * underlying tile grid does not have a known extent.\n */\n\n/**\n * Data tile loading function.  The function is called with z, x, and y tile coordinates and\n * returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * @typedef {function(number, number, number, LoaderOptions) : (import(\"../DataTile.js\").Data|Promise<import(\"../DataTile.js\").Data>)} Loader\n */\n\n/**\n * @typedef {Object} Options\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\n * Returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * For loaders that generate images, the promise should not resolve until the image is loaded.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.\n * This may be different than the rendered pixel size if a `tileGrid` is provided.\n * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.\n * This allows artifacts of rendering at tile edges to be ignored.\n * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"./Source.js\").State} [state] The source state.\n * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.\n * @property {number} [transition] Transition time when fading in new tiles (in milliseconds).\n * @property {number} [bandCount=4] Number of bands represented in the data.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {CrossOriginAttribute} [crossOrigin='anonymous'] The crossOrigin property to pass to loaders for image data.\n * @property {string} [key] Key for use in caching tiles.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * A source for typed array data tiles.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @template {import(\"../Tile.js\").default} [TileType=DataTile]\n * @extends TileSource<TileType>\n * @api\n */\nclass DataTileSource extends TileSource {\n  /**\n   * @param {Options} options DataTile source options.\n   */\n  constructor(options) {\n    const projection =\n      options.projection === undefined ? 'EPSG:3857' : options.projection;\n\n    let tileGrid = options.tileGrid;\n    if (tileGrid === undefined && projection) {\n      tileGrid = createXYZ({\n        extent: extentFromProjection(projection),\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize,\n      });\n    }\n\n    super({\n      cacheSize: 0.1, // don't cache on the source\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: projection,\n      tileGrid: tileGrid,\n      state: options.state,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate,\n      key: options.key,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\n\n    /**\n     * @private\n     * @type {import('../size.js').Size|null}\n     */\n    this.tileSize_ = options.tileSize ? toSize(options.tileSize) : null;\n\n    /**\n     * @private\n     * @type {Array<import('../size.js').Size>|null}\n     */\n    this.tileSizes_ = null;\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n\n    /**\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @private\n     */\n    this.handleTileChange_ = this.handleTileChange_.bind(this);\n\n    /**\n     * @type {number}\n     */\n    this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGridForProjection_ = {};\n\n    /**\n     * @private\n     * @type {CrossOriginAttribute}\n     */\n    this.crossOrigin_ = options.crossOrigin || 'anonymous';\n\n    /**\n     * @type {import(\"../transform.js\").Transform|null}\n     */\n    this.transformMatrix = null;\n  }\n\n  /**\n   * Set the source tile sizes.  The length of the array is expected to match the number of\n   * levels in the tile grid.\n   * @protected\n   * @param {Array<import('../size.js').Size>} tileSizes An array of tile sizes.\n   */\n  setTileSizes(tileSizes) {\n    this.tileSizes_ = tileSizes;\n  }\n\n  /**\n   * Get the source tile size at the given zoom level.  This may be different than the rendered tile\n   * size.\n   * @protected\n   * @param {number} z Tile zoom level.\n   * @return {import('../size.js').Size} The source tile size.\n   */\n  getTileSize(z) {\n    if (this.tileSizes_) {\n      return this.tileSizes_[z];\n    }\n    if (this.tileSize_) {\n      return this.tileSize_;\n    }\n    const tileGrid = this.getTileGrid();\n    return tileGrid ? toSize(tileGrid.getTileSize(z)) : [256, 256];\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   * @override\n   */\n  getGutterForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (\n      (!thisProj || equivalent(thisProj, projection)) &&\n      !this.transformMatrix\n    ) {\n      return this.gutter_;\n    }\n\n    return 0;\n  }\n\n  /**\n   * @param {Loader} loader The data loader.\n   * @protected\n   */\n  setLoader(loader) {\n    this.loader_ = loader;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} targetProj The output projection.\n   * @param {import(\"../proj/Projection.js\").default} sourceProj The input projection.\n   * @param {import(\"../structs/LRUCache.js\").default<import(\"../Tile.js\").default>} [tileCache] Tile cache.\n   * @return {!TileType} Tile.\n   */\n  getReprojTile_(z, x, y, targetProj, sourceProj, tileCache) {\n    const sourceTileGrid =\n      this.tileGrid || this.getTileGridForProjection(sourceProj || targetProj);\n    const reprojTilePixelRatio = Math.max.apply(\n      null,\n      sourceTileGrid.getResolutions().map((r, z) => {\n        const tileSize = toSize(sourceTileGrid.getTileSize(z));\n        const textureSize = this.getTileSize(z);\n        return Math.max(\n          textureSize[0] / tileSize[0],\n          textureSize[1] / tileSize[1],\n        );\n      }),\n    );\n\n    const targetTileGrid = this.getTileGridForProjection(targetProj);\n    const tileCoord = [z, x, y];\n    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      targetProj,\n    );\n\n    const options = Object.assign(\n      {\n        sourceProj: sourceProj || targetProj,\n        sourceTileGrid,\n        targetProj,\n        targetTileGrid,\n        tileCoord,\n        wrappedTileCoord,\n        pixelRatio: reprojTilePixelRatio,\n        gutter: this.gutter_,\n        getTileFunction: (z, x, y, pixelRatio) =>\n          this.getTile(z, x, y, pixelRatio, undefined, tileCache),\n        transformMatrix: this.transformMatrix,\n      },\n      /** @type {import(\"../reproj/DataTile.js\").Options} */ (this.tileOptions),\n    );\n    const tile = /** @type {TileType} */ (\n      /** @type {*} */ (new ReprojDataTile(options))\n    );\n    tile.key = this.getKey();\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\n   * @param {import(\"../structs/LRUCache.js\").default<import(\"../Tile.js\").default>} [tileCache] Tile cache.\n   * @return {TileType|null} Tile (or null if outside source extent).\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection, tileCache) {\n    const sourceProjection = this.getProjection();\n    if (\n      projection &&\n      ((sourceProjection && !equivalent(sourceProjection, projection)) ||\n        this.transformMatrix)\n    ) {\n      return this.getReprojTile_(\n        z,\n        x,\n        y,\n        projection,\n        sourceProjection,\n        tileCache,\n      );\n    }\n\n    const size = this.getTileSize(z);\n\n    const sourceLoader = this.loader_;\n\n    const controller = new AbortController();\n\n    /**\n     * @type {LoaderOptions}\n     */\n    const loaderOptions = {\n      signal: controller.signal,\n      crossOrigin: this.crossOrigin_,\n    };\n\n    const tileCoord = this.getTileCoordForTileUrlFunction([z, x, y]);\n    if (!tileCoord) {\n      return null;\n    }\n\n    const key = this.getKey();\n    const cacheKey = getCacheKey(this, key, z, x, y);\n    if (tileCache && tileCache.containsKey(cacheKey)) {\n      return /** @type {TileType} */ (tileCache.get(cacheKey));\n    }\n\n    const requestZ = tileCoord[0];\n    const requestX = tileCoord[1];\n    const requestY = tileCoord[2];\n    const range = this.getTileGrid()?.getFullTileRange(requestZ);\n    if (range) {\n      loaderOptions.maxY = range.getHeight() - 1;\n    }\n    function loader() {\n      return toPromise(function () {\n        return sourceLoader(requestZ, requestX, requestY, loaderOptions);\n      });\n    }\n\n    /**\n     * @type {import(\"../DataTile.js\").Options}\n     */\n    const options = Object.assign(\n      {\n        tileCoord: [z, x, y],\n        loader: loader,\n        size: size,\n        controller: controller,\n      },\n      this.tileOptions,\n    );\n\n    const tile = /** @type {TileType} */ (\n      /** @type {*} */ (new DataTile(options))\n    );\n    tile.key = this.getKey();\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\n\n    tileCache?.set(cacheKey, tile);\n    return tile;\n  }\n\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   */\n  handleTileChange_(event) {\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n    const uid = getUid(tile);\n    const tileState = tile.getState();\n    let type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type =\n        tileState == TileState.ERROR\n          ? TileEventType.TILELOADERROR\n          : tileState == TileState.LOADED\n            ? TileEventType.TILELOADEND\n            : undefined;\n    }\n    if (type) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @override\n   */\n  getTileGridForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (\n      this.tileGrid &&\n      (!thisProj || equivalent(thisProj, projection)) &&\n      !this.transformMatrix\n    ) {\n      return this.tileGrid;\n    }\n\n    const projKey = getUid(projection);\n    if (!(projKey in this.tileGridForProjection_)) {\n      this.tileGridForProjection_[projKey] =\n        getTileGridForProjection(projection);\n    }\n    return this.tileGridForProjection_[projKey];\n  }\n\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  setTileGridForProjection(projection, tilegrid) {\n    const proj = getProjection(projection);\n    if (proj) {\n      const projKey = getUid(proj);\n      if (!(projKey in this.tileGridForProjection_)) {\n        this.tileGridForProjection_[projKey] = tilegrid;\n      }\n    }\n  }\n}\n\nexport default DataTileSource;\n"],"names":["VERTEX_SHADER","FRAGMENT_SHADER","Canvas","gl","createProgram","tex","texWidth","texHeight","srcX","srcY","srcWidth","srcHeight","dstX","dstY","dstWidth","dstHeight","width","height","matrix","mat4.orthographic","mat4.translate","mat4.scale","texMatrix","mat4.translation","createShader","type","source","shader","log","fragmentSource","vertexSource","program","vertexShader","fragmentShader","EDGE_VERTEX_SHADER","EDGE_FRAGMENT_SHADER","TRIANGLE_VERTEX_SHADER","TRIANGLE_FRAGMENT_SHADER","createCanvasContextWebGL","canvasPool","settings","canvas","WORKER_OFFSCREEN_CANVAS","releaseGLCanvas","canvasGLPool","render","width_","height_","pixelRatio","sourceResolution","targetResolution","targetExtent","triangulation","sources","gutter","dataType","renderEdges","interpolate","drawSingle","resultFrameBuffer","resultTexture","sourceDataExtent","createEmpty","src","i","arr","extend","stitchTexture","stitchWidth","stitchHeight","stitchScale","getWidth","getHeight","maxTexSize","largeSide","scaleFactor","stitchWidthFixed","stitchHeightFixed","fb","webGLCanvas","WebGLCanvas","xPos","yPos","targetTopLeft","getTopLeft","sourceTopLeft","getUVs","target","u0","v0","u1","v1","u2","v2","vertices","texcoords","triProgram","textureLocation","triangle","su0","sv0","su1","sv1","su2","sv2","matrixLocation","positionLocation","positionBuffer","texcoordLocation","texcoordBuffer","edgeProgram","burnval","burnvalLocation","lines","ReprojDataTile","DataTile","options","sourceProj","sourceProjExtent","sourceTileGridExtent","getIntersection","maxTargetExtent","maxSourceExtent","limitedTargetExtent","getArea","TileState","targetProj","calculateSourceExtentResolution","errorThresholdInPixels","ERROR_THRESHOLD","Triangulation","sourceExtent","clamp","worldWidth","worldsAway","wrapAndSliceX","extent","sourceRange","getTile","tile","offset","dataSources","imageLike","size","tileData","arrayData","asArrayLike","toArray","asImageLike","pixelSize","isFloat","pixelCount","DataType","tileDataR","bytesPerElement","bytesPerPixel","bytesPerRow","bandCount","clipExtent","z","targetWidth","targetHeight","outWidth","outHeight","dataR","willInterpolate","format","textureType","BANDS_PR_REPROJ","reprojs","reproj","len","dataSource","data","dataS","j","texture","framebuffer","renderReprojected","rows","cols","flipY","context","createCanvasContext2D","imageData","leftToLoad","state","sourceListenKey","listen","EventType","unlistenByKey","DataTileSource","TileSource","projection","tileGrid","createXYZ","extentFromProjection","toSize","tileSizes","thisProj","equivalent","loader","x","y","tileCache","sourceTileGrid","reprojTilePixelRatio","tileSize","textureSize","targetTileGrid","tileCoord","wrappedTileCoord","sourceProjection","sourceLoader","controller","loaderOptions","key","cacheKey","getCacheKey","requestZ","requestX","requestY","range","toPromise","event","uid","getUid","tileState","TileEventType","TileSourceEvent","projKey","getTileGridForProjection","tilegrid","proj","getProjection"],"mappings":"q8BAMA,MAAMA,GAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBhBC,GAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyBjB,MAAMC,EAAO,CAIlB,YAAYC,EAAI,CAKd,KAAK,IAAMA,EAMX,KAAK,SAAWC,EAAcD,EAAIF,GAAiBD,EAAa,EAEhE,KAAK,iBAAmBG,EAAG,kBAAkB,KAAK,SAAU,YAAY,EACxE,KAAK,iBAAmBA,EAAG,kBAAkB,KAAK,SAAU,YAAY,EAExE,KAAK,eAAiBA,EAAG,mBAAmB,KAAK,SAAU,UAAU,EACrE,KAAK,sBAAwBA,EAAG,mBAC9B,KAAK,SACL,iBACN,EACI,KAAK,gBAAkBA,EAAG,mBAAmB,KAAK,SAAU,WAAW,EAEvE,KAAK,eAAiBA,EAAG,aAAY,EACrCA,EAAG,WAAWA,EAAG,aAAc,KAAK,cAAc,EAElD,KAAK,UAAY,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EACpDA,EAAG,WACDA,EAAG,aACH,IAAI,aAAa,KAAK,SAAS,EAC/BA,EAAG,WACT,EAEI,KAAK,eAAiBA,EAAG,aAAY,EACrCA,EAAG,WAAWA,EAAG,aAAc,KAAK,cAAc,EAElD,KAAK,UAAY,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EACpDA,EAAG,WACDA,EAAG,aACH,IAAI,aAAa,KAAK,SAAS,EAC/BA,EAAG,WACT,CACE,CAqBA,UACEE,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACA,CACA,MAAMd,EAAK,KAAK,IAEZS,IAAS,SACXA,EAAOJ,GAELK,IAAS,SACXA,EAAOJ,GAELC,IAAa,SACfA,EAAWJ,GAETK,IAAc,SAChBA,EAAYJ,GAEVO,IAAa,SACfA,EAAWJ,GAETK,IAAc,SAChBA,EAAYJ,GAEVK,IAAU,SACZA,EAAQb,EAAG,OAAO,OAEhBc,IAAW,SACbA,EAASd,EAAG,OAAO,QAGrBA,EAAG,YAAYA,EAAG,WAAYE,CAAG,EAEjCF,EAAG,WAAW,KAAK,QAAQ,EAE3BA,EAAG,WAAWA,EAAG,aAAc,KAAK,cAAc,EAClDA,EAAG,wBAAwB,KAAK,gBAAgB,EAChDA,EAAG,oBAAoB,KAAK,iBAAkB,EAAGA,EAAG,MAAO,GAAO,EAAG,CAAC,EACtEA,EAAG,WAAWA,EAAG,aAAc,KAAK,cAAc,EAClDA,EAAG,wBAAwB,KAAK,gBAAgB,EAChDA,EAAG,oBAAoB,KAAK,iBAAkB,EAAGA,EAAG,MAAO,GAAO,EAAG,CAAC,EAGtE,IAAIe,EAASC,EAAkB,EAAGH,EAAO,EAAGC,EAAQ,GAAI,CAAC,EACzDC,EAASE,GAAeF,EAAQN,EAAMC,EAAM,CAAC,EAC7CK,EAASG,GAAWH,EAAQJ,EAAUC,EAAW,CAAC,EAClDZ,EAAG,iBAAiB,KAAK,eAAgB,GAAOe,CAAM,EAEtD,IAAII,EAAYC,GAAiBf,EAAOF,EAAUG,EAAOF,EAAW,CAAC,EACrEe,EAAYD,GACVC,EACAZ,EAAWJ,EACXK,EAAYJ,EACZ,CACN,EAEIJ,EAAG,iBAAiB,KAAK,sBAAuB,GAAOmB,CAAS,EAChEnB,EAAG,UAAU,KAAK,gBAAiB,CAAC,EACpCA,EAAG,WAAWA,EAAG,UAAW,EAAG,KAAK,UAAU,OAAS,CAAC,CAC1D,CACF,CAQA,SAASqB,GAAarB,EAAIsB,EAAMC,EAAQ,CACtC,MAAMC,EAASxB,EAAG,aAAasB,CAAI,EAEnC,GAAIE,IAAW,KACb,MAAM,IAAI,MAAM,2BAA2B,EAM7C,GAHAxB,EAAG,aAAawB,EAAQD,CAAM,EAE9BvB,EAAG,cAAcwB,CAAM,EACnB,CAACxB,EAAG,mBAAmBwB,EAAQxB,EAAG,cAAc,EAAG,CACrD,MAAMyB,EAAMzB,EAAG,iBAAiBwB,CAAM,EACtC,MAAIC,IAAQ,KACJ,IAAI,MAAM,iCAAiC,EAE7C,IAAI,MAAMA,CAAG,CACrB,CAEA,OAAOD,CACT,CAQO,SAASvB,EAAcD,EAAI0B,EAAgBC,EAAc,CAC9D,MAAMC,EAAU5B,EAAG,cAAa,EAE1B6B,EAAeR,GAAarB,EAAIA,EAAG,cAAe2B,CAAY,EAC9DG,EAAiBT,GAAarB,EAAIA,EAAG,gBAAiB0B,CAAc,EAC1E,GAAIE,IAAY,KACd,MAAM,IAAI,MAAM,yBAAyB,EAO3C,GAJA5B,EAAG,aAAa4B,EAASC,CAAY,EACrC7B,EAAG,aAAa4B,EAASE,CAAc,EAEvC9B,EAAG,YAAY4B,CAAO,EAClB,CAAC5B,EAAG,oBAAoB4B,EAAS5B,EAAG,WAAW,EAEjD,MADYA,EAAG,kBAAkB4B,CAAO,IAC5B,KACJ,IAAI,MAAM,kCAAkC,EAE9C,IAAI,MAEZ,OAAOA,CACT,CCnOA,MAAMG,GAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASrBC,GAAuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASvBC,GAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAazBC,GAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuB1B,SAASC,GAAyBtB,EAAOC,EAAQsB,EAAYC,EAAU,CAE5E,IAAIC,EACJ,OAAIF,GAAcA,EAAW,OAC3BE,EAA2CF,EAAW,QAC7CG,GACTD,EAAS,IAAI,gBAAgBzB,GAAS,IAAKC,GAAU,GAAG,EAExDwB,EAAS,SAAS,cAAc,QAAQ,EAEtCzB,IACFyB,EAAO,MAAQzB,GAEbC,IACFwB,EAAO,OAASxB,GAIhBwB,EAAO,WAAW,QAASD,CAAQ,CAEvC,CAOO,SAASG,GAAgBxC,EAAI,CAClC,MAAMsC,EAAStC,EAAG,OAClBsC,EAAO,MAAQ,EACfA,EAAO,OAAS,EAChBtC,EAAG,MAAMA,EAAG,iBAAmBA,EAAG,iBAAmBA,EAAG,kBAAkB,CAC5E,CAKO,MAAMyC,GAAe,CAAA,EA+BrB,SAASC,GACd1C,EACA2C,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACA,CACA,MAAM1C,EAAQ,KAAK,MAAMgC,EAAaF,CAAM,EACtC7B,EAAS,KAAK,MAAM+B,EAAaD,CAAO,EAC9C5C,EAAG,OAAO,MAAQa,EAClBb,EAAG,OAAO,OAASc,EAGnB,IAAI0C,EAEAC,EAqCJ,GAnCEA,EAAgBzD,EAAG,cAAa,EAChCA,EAAG,YAAYA,EAAG,WAAYyD,CAAa,EAE3CzD,EAAG,cAAcA,EAAG,WAAYA,EAAG,eAAgBA,EAAG,aAAa,EACnEA,EAAG,cAAcA,EAAG,WAAYA,EAAG,eAAgBA,EAAG,aAAa,EAC/DsD,GACFtD,EAAG,cAAcA,EAAG,WAAYA,EAAG,mBAAoBA,EAAG,MAAM,EAChEA,EAAG,cAAcA,EAAG,WAAYA,EAAG,mBAAoBA,EAAG,MAAM,IAEhEA,EAAG,cAAcA,EAAG,WAAYA,EAAG,mBAAoBA,EAAG,OAAO,EACjEA,EAAG,cAAcA,EAAG,WAAYA,EAAG,mBAAoBA,EAAG,OAAO,GAEnEA,EAAG,WACDA,EAAG,WACH,EACAA,EAAG,KACHa,EACAC,EACA,EACAd,EAAG,KACHoD,EACA,IACN,EAEII,EAAoBxD,EAAG,kBAAiB,EACxCA,EAAG,gBAAgBA,EAAG,YAAawD,CAAiB,EACpDxD,EAAG,qBACDA,EAAG,YACHA,EAAG,kBACHA,EAAG,WACHyD,EACA,CACN,EAGMD,IAAsB,KACxB,MAAM,IAAI,MAAM,8BAA8B,EAEhD,GAAIC,IAAkB,KACpB,MAAM,IAAI,MAAM,0BAA0B,EAG5C,GAAIP,EAAQ,SAAW,EACrB,MAAO,CACL,MAAArC,EACA,OAAAC,EACA,YAAa0C,EACb,QAASC,CACf,EAGE,MAAMC,EAAmBC,GAAW,EACpCT,EAAQ,QAAQ,SAAUU,EAAKC,EAAGC,EAAK,CACrCC,GAAOL,EAAkBE,EAAI,MAAM,CACrC,CAAC,EAGD,IAAII,EAEAC,EAEAC,EACJ,MAAMC,EAAc,EAAIrB,EAEiC,CAEvD,GADAkB,EAAgBhE,EAAG,cAAa,EAC5ByD,IAAkB,KACpB,MAAM,IAAI,MAAM,0BAA0B,EAE5CQ,EAAc,KAAK,MAAMG,EAASV,CAAgB,EAAIS,CAAW,EACjED,EAAe,KAAK,MAAMG,EAAUX,CAAgB,EAAIS,CAAW,EAInE,MAAMG,EAAatE,EAAG,aAAaA,EAAG,gBAAgB,EAChDuE,EAAY,KAAK,IAAIN,EAAaC,CAAY,EAC9CM,EAAcD,EAAYD,EAAaA,EAAaC,EAAY,EAChEE,EAAmB,KAAK,MAAMR,EAAcO,CAAW,EACvDE,EAAoB,KAAK,MAAMR,EAAeM,CAAW,EAE/DxE,EAAG,YAAYA,EAAG,WAAYgE,CAAa,EAE3ChE,EAAG,cAAcA,EAAG,WAAYA,EAAG,eAAgBA,EAAG,aAAa,EACnEA,EAAG,cAAcA,EAAG,WAAYA,EAAG,eAAgBA,EAAG,aAAa,EAC/DsD,GACFtD,EAAG,cAAcA,EAAG,WAAYA,EAAG,mBAAoBA,EAAG,MAAM,EAChEA,EAAG,cAAcA,EAAG,WAAYA,EAAG,mBAAoBA,EAAG,MAAM,IAEhEA,EAAG,cAAcA,EAAG,WAAYA,EAAG,mBAAoBA,EAAG,OAAO,EACjEA,EAAG,cAAcA,EAAG,WAAYA,EAAG,mBAAoBA,EAAG,OAAO,GAEnEA,EAAG,WACDA,EAAG,WACH,EACAA,EAAG,KACHyE,EACAC,EACA,EACA1E,EAAG,KACHoD,EACA,IACN,EAEI,MAAMuB,EAAK3E,EAAG,kBAAiB,EAC/BA,EAAG,gBAAgBA,EAAG,YAAa2E,CAAE,EACrC3E,EAAG,qBACDA,EAAG,YACHA,EAAG,kBACHA,EAAG,WACHgE,EACA,CACN,EACI,MAAMY,EAAc,IAAIC,GAAY7E,CAAE,EAEtCkD,EAAQ,QAAQ,SAAUU,EAAKC,EAAGC,EAAK,CACrC,MAAMgB,GACHlB,EAAI,OAAO,CAAC,EAAIF,EAAiB,CAAC,GAAKS,EAAcK,EAClDO,EACJ,EAAEnB,EAAI,OAAO,CAAC,EAAIF,EAAiB,CAAC,GAAKS,EAAcK,EACnDjE,EAAW6D,EAASR,EAAI,MAAM,EAAIO,EAAcK,EAChDhE,EAAY6D,EAAUT,EAAI,MAAM,EAAIO,EAAcK,EAIxD,GAHAxE,EAAG,gBAAgBA,EAAG,YAAa2E,CAAE,EACrC3E,EAAG,SAAS,EAAG,EAAGyE,EAAkBC,CAAiB,EAEjDd,EAAI,WAAY,CAClB,MAAMkB,GACHlB,EAAI,WAAW,CAAC,EAAIF,EAAiB,CAAC,GAAKS,EAAcK,EACtDO,EACJ,EAAEnB,EAAI,WAAW,CAAC,EAAIF,EAAiB,CAAC,GACxCS,EACAK,EACI3D,EAAQuD,EAASR,EAAI,UAAU,EAAIO,EAAcK,EACjD1D,EAASuD,EAAUT,EAAI,UAAU,EAAIO,EAAcK,EACzDxE,EAAG,OAAOA,EAAG,YAAY,EACzBA,EAAG,QACDsD,EAAcwB,EAAO,KAAK,MAAMA,CAAI,EACpCxB,EAAcyB,EAAO,KAAK,MAAMA,CAAI,EACpCzB,EAAczC,EAAQ,KAAK,MAAMiE,EAAOjE,CAAK,EAAI,KAAK,MAAMiE,CAAI,EAChExB,EAAcxC,EAAS,KAAK,MAAMiE,EAAOjE,CAAM,EAAI,KAAK,MAAMiE,CAAI,CAC5E,CACM,CAEAH,EAAY,UACVhB,EAAI,QACJA,EAAI,MACJA,EAAI,OACJT,EACAA,EACAS,EAAI,MAAQ,EAAIT,EAChBS,EAAI,OAAS,EAAIT,EACjBG,EAAcwB,EAAO,KAAK,MAAMA,CAAI,EACpCxB,EAAcyB,EAAO,KAAK,MAAMA,CAAI,EACpCzB,EAAc/C,EAAW,KAAK,MAAMuE,EAAOvE,CAAQ,EAAI,KAAK,MAAMuE,CAAI,EACtExB,EACI9C,EACA,KAAK,MAAMuE,EAAOvE,CAAS,EAAI,KAAK,MAAMuE,CAAI,EAClDN,EACAC,CACR,EAEM1E,EAAG,QAAQA,EAAG,YAAY,CAC5B,CAAC,EACDA,EAAG,kBAAkB2E,CAAE,CACzB,CAMA,MAAMK,EAAgBC,GAAWjC,CAAY,EACvCkC,EAAgBD,GAAWvB,CAAgB,EAE3CyB,EACwDC,GACzD,CACH,MAAMC,GACFD,EAAO,CAAC,EAAE,CAAC,EAAIJ,EAAc,CAAC,GAAKjC,EAAoBF,EACrDyC,EACH,EAAEF,EAAO,CAAC,EAAE,CAAC,EAAIJ,EAAc,CAAC,GAAKjC,EAAoBF,EACtD0C,GACFH,EAAO,CAAC,EAAE,CAAC,EAAIJ,EAAc,CAAC,GAAKjC,EAAoBF,EACrD2C,EACH,EAAEJ,EAAO,CAAC,EAAE,CAAC,EAAIJ,EAAc,CAAC,GAAKjC,EAAoBF,EACtD4C,GACFL,EAAO,CAAC,EAAE,CAAC,EAAIJ,EAAc,CAAC,GAAKjC,EAAoBF,EACrD6C,EACH,EAAEN,EAAO,CAAC,EAAE,CAAC,EAAIJ,EAAc,CAAC,GAAKjC,EAAoBF,EAC5D,MAAO,CAAC,GAAA0C,EAAI,GAAAC,EAAI,GAAAH,EAAI,GAAAC,EAAI,GAAAG,EAAI,GAAAC,CAAE,CAChC,EAEA1F,EAAG,gBAAgBA,EAAG,YAAawD,CAAiB,EACpDxD,EAAG,SAAS,EAAG,EAAGa,EAAOC,CAAM,EAG/B,CAEE,MAAM6E,EAAW,CAAA,EAEXC,EAAY,CAAA,EAEZC,EAAa5F,EACjBD,EACAkC,GACAD,EACN,EACIjC,EAAG,WAAW6F,CAAU,EAGxB,MAAMC,EAAkB9F,EAAG,mBAAmB6F,EAAY,WAAW,EACrE7F,EAAG,YAAYA,EAAG,WAAYgE,CAAa,EAG3ChE,EAAG,UAAU8F,EAAiB,CAAC,EAG/B7C,EAAc,aAAY,EAAG,QAAQ,SAAU8C,EAAUlC,EAAGC,EAAK,CAC/D,MAAMvC,EAASwE,EAAS,OAClBX,EAASW,EAAS,OAElB,CAAC,GAAAR,EAAI,GAAAC,EAAI,GAAAH,EAAI,GAAAC,GAAI,GAAAG,GAAI,GAAAC,EAAE,EAAIP,EAAOC,CAAM,EAExCY,IACHzE,EAAO,CAAC,EAAE,CAAC,EAAI2D,EAAc,CAAC,GAAKpC,EAAmBmB,EACnDgC,GACJ,EAAE1E,EAAO,CAAC,EAAE,CAAC,EAAI2D,EAAc,CAAC,GAAKpC,EAAmBoB,EACpDgC,IACH3E,EAAO,CAAC,EAAE,CAAC,EAAI2D,EAAc,CAAC,GAAKpC,EAAmBmB,EACnDkC,GACJ,EAAE5E,EAAO,CAAC,EAAE,CAAC,EAAI2D,EAAc,CAAC,GAAKpC,EAAmBoB,EACpDkC,IACH7E,EAAO,CAAC,EAAE,CAAC,EAAI2D,EAAc,CAAC,GAAKpC,EAAmBmB,EACnDoC,GACJ,EAAE9E,EAAO,CAAC,EAAE,CAAC,EAAI2D,EAAc,CAAC,GAAKpC,EAAmBoB,EAE1DyB,EAAS,KAAKJ,EAAIC,EAAIH,EAAIC,GAAIG,GAAIC,EAAE,EACpCE,EAAU,KAAKM,GAAKC,GAAKH,GAAKC,GAAKG,GAAKC,EAAG,CAC7C,CAAC,EAGD,MAAMtF,EAASC,EAAkB,EAAGH,EAAOC,EAAQ,EAAG,GAAI,CAAC,EACrDwF,EAAiBtG,EAAG,mBAAmB6F,EAAY,UAAU,EACnE7F,EAAG,iBAAiBsG,EAAgB,GAAOvF,CAAM,EAEjD,MAAMwF,EAAmBvG,EAAG,kBAAkB6F,EAAY,YAAY,EAChEW,EAAiBxG,EAAG,aAAY,EACtCA,EAAG,WAAWA,EAAG,aAAcwG,CAAc,EAC7CxG,EAAG,WAAWA,EAAG,aAAc,IAAI,aAAa2F,CAAQ,EAAG3F,EAAG,WAAW,EACzEA,EAAG,oBAAoBuG,EAAkB,EAAGvG,EAAG,MAAO,GAAO,EAAG,CAAC,EACjEA,EAAG,wBAAwBuG,CAAgB,EAE3C,MAAME,EAAmBzG,EAAG,kBAAkB6F,EAAY,YAAY,EAChEa,EAAiB1G,EAAG,aAAY,EACtCA,EAAG,WAAWA,EAAG,aAAc0G,CAAc,EAC7C1G,EAAG,WAAWA,EAAG,aAAc,IAAI,aAAa4F,CAAS,EAAG5F,EAAG,WAAW,EAC1EA,EAAG,oBAAoByG,EAAkB,EAAGzG,EAAG,MAAO,GAAO,EAAG,CAAC,EACjEA,EAAG,wBAAwByG,CAAgB,EAE3CzG,EAAG,WAAWA,EAAG,UAAW,EAAG2F,EAAS,OAAS,CAAC,CACpD,CAEA,GAAItC,EAAa,CACf,MAAMsD,EAAc1G,EAClBD,EACAgC,GACAD,EACN,EACI/B,EAAG,WAAW2G,CAAW,EACzB,MAAM5F,EAASC,EAAkB,EAAGH,EAAOC,EAAQ,EAAG,GAAI,CAAC,EACrDwF,EAAiBtG,EAAG,mBAAmB2G,EAAa,UAAU,EACpE3G,EAAG,iBAAiBsG,EAAgB,GAAOvF,CAAM,EAEjD,MAAM6F,EAAU,MAAM,QAAQvD,CAAW,EAAIA,EAAc,CAAC,EAAG,EAAG,EAAG,GAAG,EAClEwD,EAAkB7G,EAAG,mBAAmB2G,EAAa,OAAO,EAGhE3G,EAAG,WAAW6G,EAAiBD,CAAO,EAKxC,MAAML,EAAmBvG,EAAG,kBAAkB2G,EAAa,YAAY,EACjEH,EAAiBxG,EAAG,aAAY,EACtCA,EAAG,WAAWA,EAAG,aAAcwG,CAAc,EAC7CxG,EAAG,oBAAoBuG,EAAkB,EAAGvG,EAAG,MAAO,GAAO,EAAG,CAAC,EACjEA,EAAG,wBAAwBuG,CAAgB,EAG3C,MAAMO,EAAQ7D,EAAc,aAAY,EAAG,OAAO,SACnB6D,EAC7Bf,EACA,CACA,MAAMX,EAASW,EAAS,OAClB,CAAC,GAAAR,EAAI,GAAAC,EAAI,GAAAH,EAAI,GAAAC,EAAI,GAAAG,EAAI,GAAAC,CAAE,EAAIP,EAAOC,CAAM,EAE9C,OAAO0B,EAAM,OAAO,CAACvB,EAAIC,EAAIH,EAAIC,EAAID,EAAIC,EAAIG,EAAIC,EAAID,EAAIC,EAAIH,EAAIC,CAAE,CAAC,CACtE,EAAG,CAAA,CAAE,EACLxF,EAAG,WAAWA,EAAG,aAAc,IAAI,aAAa8G,CAAK,EAAG9G,EAAG,WAAW,EACtEA,EAAG,WAAWA,EAAG,MAAO,EAAG8G,EAAM,OAAS,CAAC,CAC7C,CAEA,MAAO,CACL,MAAAjG,EACA,OAAAC,EACA,YAAa0C,EACb,QAASC,CACb,CACA,CC3ZA,MAAMsD,WAAuBC,EAAS,CAIpC,YAAYC,EAAS,CACnB,MAAM,CACJ,UAAWA,EAAQ,UACnB,OAAQ,IAAM,QAAQ,QAAQ,IAAI,kBAAkB,CAAC,CAAC,EACtD,YAAaA,EAAQ,YACrB,WAAYA,EAAQ,UAC1B,CAAK,EAMD,KAAK,aACHA,EAAQ,cAAgB,OAAYA,EAAQ,YAAc,GAM5D,KAAK,YAAcA,EAAQ,WAM3B,KAAK,QAAUA,EAAQ,OAMvB,KAAK,YAAc,KAMnB,KAAK,aAAe,KAMpB,KAAK,YAAc,OAMnB,KAAK,gBAAkBA,EAAQ,eAM/B,KAAK,gBAAkBA,EAAQ,eAM/B,KAAK,kBAAoBA,EAAQ,kBAAoBA,EAAQ,UAM7D,KAAK,aAAe,CAAA,EAMpB,KAAK,qBAAuB,KAM5B,KAAK,SAAW,EAEhB,MAAMC,EAAaD,EAAQ,WACrBE,EAAmBD,EAAW,UAAS,EACvCE,EAAuBH,EAAQ,eAAe,UAAS,EAM7D,KAAK,YAAcC,EAAW,SAAQ,EAClCE,EACEC,EAAgBF,EAAkBC,CAAoB,EACtDD,EACFC,EAEJ,MAAMpE,EAAe,KAAK,gBAAgB,mBACxC,KAAK,iBACX,EACUsE,EAAkB,KAAK,gBAAgB,UAAS,EACtD,IAAIC,EAAkB,KAAK,gBAAgB,UAAS,EAEpD,MAAMC,EAAsBF,EACxBD,EAAgBrE,EAAcsE,CAAe,EAC7CtE,EAEJ,GAAIyE,GAAQD,CAAmB,IAAM,EAAG,CAGtC,KAAK,MAAQE,EAAU,MACvB,MACF,CAEIP,IACGI,EAGHA,EAAkBF,EAAgBE,EAAiBJ,CAAgB,EAFnEI,EAAkBJ,GAMtB,MAAMpE,EAAmB,KAAK,gBAAgB,cAC5C,KAAK,kBAAkB,CAAC,CAC9B,EAEU4E,EAAaV,EAAQ,WACrBnE,EAAmB8E,GACvBV,EACAS,EACAH,EACAzE,CACN,EAEI,GAAI,CAAC,SAASD,CAAgB,GAAKA,GAAoB,EAAG,CAGxD,KAAK,MAAQ4E,EAAU,MACvB,MACF,CAEA,MAAMG,EACJZ,EAAQ,iBAAmB,OACvBA,EAAQ,eACRa,GAgBN,GAVA,KAAK,eAAiB,IAAIC,GACxBb,EACAS,EACAH,EACAD,EACAzE,EAAmB+E,EACnB9E,EACAkE,EAAQ,eACd,EAEQ,KAAK,eAAe,aAAY,EAAG,SAAW,EAAG,CAEnD,KAAK,MAAQS,EAAU,MACvB,MACF,CAEA,KAAK,SAAW,KAAK,gBAAgB,kBAAkB5E,CAAgB,EACvE,IAAIkF,EAAe,KAAK,eAAe,sBAAqB,EAmB5D,GAjBIT,IACEL,EAAW,YACbc,EAAa,CAAC,EAAIC,GAChBD,EAAa,CAAC,EACdT,EAAgB,CAAC,EACjBA,EAAgB,CAAC,CAC3B,EACQS,EAAa,CAAC,EAAIC,GAChBD,EAAa,CAAC,EACdT,EAAgB,CAAC,EACjBA,EAAgB,CAAC,CAC3B,GAEQS,EAAeX,EAAgBW,EAAcT,CAAe,GAI5D,CAACE,GAAQO,CAAY,EACvB,KAAK,MAAQN,EAAU,UAClB,CACL,IAAIQ,EAAa,EACbC,EAAa,EACbjB,EAAW,aACbgB,EAAa9D,EAAS+C,CAAgB,EACtCgB,EAAa,KAAK,OACfH,EAAa,CAAC,EAAIb,EAAiB,CAAC,GAAKe,CACpD,GAG4BE,GACpBJ,EAAa,MAAK,EAClBd,EACA,EACR,EACoB,QAASmB,GAAW,CAChC,MAAMC,EAAc,KAAK,gBAAgB,0BACvCD,EACA,KAAK,QACf,EACcE,EAAUtB,EAAQ,gBACxB,QAAS5G,EAAOiI,EAAY,KAAMjI,GAAQiI,EAAY,KAAMjI,IAC1D,QAASC,EAAOgI,EAAY,KAAMhI,GAAQgI,EAAY,KAAMhI,IAAQ,CAClE,MAAMkI,EAAOD,EAAQ,KAAK,SAAUlI,EAAMC,EAAM,KAAK,WAAW,EAChE,GAAIkI,EAAM,CACR,MAAMC,EAASN,EAAaD,EAC5B,KAAK,aAAa,KAAK,CAAC,KAAAM,EAAM,OAAAC,CAAM,CAAC,CACvC,CACF,CAEF,EAAEN,CACJ,CAAC,EAEG,KAAK,aAAa,SAAW,IAC/B,KAAK,MAAQT,EAAU,MAE3B,CACF,CAOA,SAAU,CACR,OAAO,KAAK,WACd,CAOA,SAAU,CACR,OAAO,KAAK,WACd,CAOA,UAAW,CACT,OAAO,KAAK,YACd,CAKA,YAAa,CACX,MAAMgB,EAAc,CAAA,EACpB,IAAIC,EAAY,GAoDhB,GAnDA,KAAK,aAAa,QAASpH,GAAW,CACpC,MAAMiH,EAAOjH,EAAO,KACpB,GAAI,CAACiH,GAAQA,EAAK,SAAQ,IAAOd,EAAU,OACzC,OAEF,MAAMkB,EAAOJ,EAAK,QAAO,EACnBrF,EAAS,KAAK,QAIpB,IAAI0F,EACJ,MAAMC,EAAYC,GAAYP,EAAK,QAAO,CAAE,EACxCM,EACFD,EAAWC,GAEXH,EAAY,GACZE,EAAWG,GAAQC,GAAYT,EAAK,QAAO,CAAE,CAAC,GAEhD,MAAMU,EAAY,CAACN,EAAK,CAAC,EAAI,EAAIzF,EAAQyF,EAAK,CAAC,EAAI,EAAIzF,CAAM,EACvDgG,EAAUN,aAAoB,aAC9BO,EAAaF,EAAU,CAAC,EAAIA,EAAU,CAAC,EACvCG,EAAWF,EAAU,aAAe,kBACpCG,EAAY,IAAID,EACQR,EAAS,MAC7C,EACYU,EAAkBF,EAAS,kBAC3BG,EAAiBD,EAAkBD,EAAU,OAAUF,EACvDK,EAAcH,EAAU,WAAaJ,EAAU,CAAC,EAChDQ,EAAY,KAAK,MACrBD,EAAcF,EAAkBL,EAAU,CAAC,CACnD,EACYb,EAAS,KAAK,gBAAgB,mBAAmBG,EAAK,SAAS,EACrEH,EAAO,CAAC,GAAK9G,EAAO,OACpB8G,EAAO,CAAC,GAAK9G,EAAO,OACpB,MAAMoI,EAAa,KAAK,aAAa,MAAK,EACtCA,IACFA,EAAW,CAAC,GAAKpI,EAAO,OACxBoI,EAAW,CAAC,GAAKpI,EAAO,QAE1BmH,EAAY,KAAK,CACf,OAAQL,EACR,WAAYsB,EACZ,KAAML,EACN,SAAUD,EACV,cAAeG,EACf,UAAWN,EACX,UAAWQ,CACnB,CAAO,CACH,CAAC,EACD,KAAK,aAAa,OAAS,EAEvBhB,EAAY,SAAW,EAAG,CAC5B,KAAK,MAAQhB,EAAU,MACvB,KAAK,QAAO,EACZ,MACF,CAEA,MAAMkC,EAAI,KAAK,kBAAkB,CAAC,EAC5BhB,EAAO,KAAK,gBAAgB,YAAYgB,CAAC,EACzCC,EAAc,OAAOjB,GAAS,SAAWA,EAAOA,EAAK,CAAC,EACtDkB,EAAe,OAAOlB,GAAS,SAAWA,EAAOA,EAAK,CAAC,EACvDmB,EAAW,KAAK,MAAMF,EAAc,KAAK,WAAW,EACpDG,EAAY,KAAK,MAAMF,EAAe,KAAK,WAAW,EACtD/G,EAAmB,KAAK,gBAAgB,cAAc6G,CAAC,EACvD9G,EAAmB,KAAK,gBAAgB,cAAc,KAAK,QAAQ,EAEnEE,EAAe,KAAK,gBAAgB,mBACxC,KAAK,iBACX,EAEU0G,EAAYhB,EAAY,CAAC,EAAE,UAC3BuB,EAAQ,IAAIvB,EAAY,CAAC,EAAE,SAASgB,EAAYK,EAAWC,CAAS,EAEpEhK,EAAKmC,GAAyB4H,EAAUC,EAAWvH,GAAc,CACrE,mBAAoB,GACpB,UAAW,EACjB,CAAK,EAED,IAAIyH,EACJ,MAAMC,EAASnK,EAAG,KAClB,IAAIoK,EACA1B,EAAY,CAAC,EAAE,UAAY,cAC7B0B,EAAcpK,EAAG,MACjBA,EAAG,aAAa,0BAA0B,EAC1CA,EAAG,aAAa,mBAAmB,EACnCA,EAAG,aAAa,iBAAiB,EAGjCkK,EAFkBlK,EAAG,aAAa,0BAA0B,IACvB,MACD,KAAK,cAEzCoK,EAAcpK,EAAG,cACjBkK,EAAkB,KAAK,aAGzB,MAAMG,EAAkB,EAClBC,EAAU,KAAK,KAAKZ,EAAYW,CAAe,EACrD,QAASE,EAASD,EAAU,EAAGC,GAAU,EAAG,EAAEA,EAAQ,CACpD,MAAMrH,EAAU,CAAA,EAChB,QAASW,EAAI,EAAG2G,EAAM9B,EAAY,OAAQ7E,EAAI2G,EAAK,EAAE3G,EAAG,CACtD,MAAM4G,EAAa/B,EAAY7E,CAAC,EAE1BqF,EAAYuB,EAAW,UACvB5J,EAAQqI,EAAU,CAAC,EACnBpI,EAASoI,EAAU,CAAC,EAEpBwB,EAAO,IAAID,EAAW,SAASJ,EAAkBxJ,EAAQC,CAAM,EAC/D6J,EAAQF,EAAW,KACzB,IAAIhC,EAAS8B,EAASF,EACtB,QAASO,EAAI,EAAGJ,EAAME,EAAK,OAAQE,EAAIJ,EAAKI,GAAKP,EAC/CK,EAAKE,CAAC,EAAID,EAAMlC,CAAM,EACtBiC,EAAKE,EAAI,CAAC,EAAID,EAAMlC,EAAS,CAAC,EAC9BiC,EAAKE,EAAI,CAAC,EAAID,EAAMlC,EAAS,CAAC,EAC9BiC,EAAKE,EAAI,CAAC,EAAID,EAAMlC,EAAS,CAAC,EAC9BA,GAAUiB,EAGZ,MAAMmB,EAAU7K,EAAG,cAAa,EAChCA,EAAG,YAAYA,EAAG,WAAY6K,CAAO,EAEjCX,GACFlK,EAAG,cAAcA,EAAG,WAAYA,EAAG,mBAAoBA,EAAG,MAAM,EAChEA,EAAG,cAAcA,EAAG,WAAYA,EAAG,mBAAoBA,EAAG,MAAM,IAEhEA,EAAG,cAAcA,EAAG,WAAYA,EAAG,mBAAoBA,EAAG,OAAO,EACjEA,EAAG,cAAcA,EAAG,WAAYA,EAAG,mBAAoBA,EAAG,OAAO,GAEnEA,EAAG,cAAcA,EAAG,WAAYA,EAAG,eAAgBA,EAAG,aAAa,EACnEA,EAAG,cAAcA,EAAG,WAAYA,EAAG,eAAgBA,EAAG,aAAa,EACnEA,EAAG,WACDA,EAAG,WACH,EACAmK,EACAtJ,EACAC,EACA,EACAqJ,EACAC,EACAM,CACV,EAEQxH,EAAQ,KAAK,CACX,OAAQuH,EAAW,OACnB,WAAYA,EAAW,WACvB,QAASI,EACT,MAAOhK,EACP,OAAQC,CAClB,CAAS,CACH,CAEA,KAAM,CAAC,YAAAgK,EAAa,MAAAjK,EAAO,OAAAC,CAAM,EAAIiK,GACnC/K,EACA6J,EACAC,EACA,KAAK,YACLhH,EACAC,EACAC,EACA,KAAK,eACLE,EACA,KAAK,QACLkH,EACA,KAAK,aACLF,CACR,EAGYc,EAAOnK,EACPoK,EAAOnK,EAASuJ,EAChBK,EAAO,IAAIhC,EAAY,CAAC,EAAE,SAASsC,EAAOC,CAAI,EACpDjL,EAAG,gBAAgBA,EAAG,YAAa8K,CAAW,EAC9C9K,EAAG,WAAW,EAAG,EAAGa,EAAOC,EAAQd,EAAG,KAAMoK,EAAaM,CAAI,EAE7D,IAAIjC,EAAS8B,EAASF,EACtB,QAASxG,EAAI,EAAG2G,EAAME,EAAK,OAAQ7G,EAAI2G,EAAK3G,GAAKwG,EAAiB,CAEhE,MAAMa,GAASF,EAAO,GAAMnH,EAAIoH,EAAQ,IAAMA,EAAQpH,EAAIoH,EAC1DhB,EAAMxB,CAAM,EAAIiC,EAAKQ,CAAK,EAC1BjB,EAAMxB,EAAS,CAAC,EAAIiC,EAAKQ,EAAQ,CAAC,EAClCjB,EAAMxB,EAAS,CAAC,EAAIiC,EAAKQ,EAAQ,CAAC,EAClCjB,EAAMxB,EAAS,CAAC,EAAIiC,EAAKQ,EAAQ,CAAC,EAClCzC,GAAUiB,CACZ,CACF,CAKA,GAHAlH,GAAgBxC,CAAE,EAClByC,GAAa,KAAKzC,EAAG,MAAM,EAEvB2I,EAAW,CACb,MAAMwC,EAAUC,GAAsBvB,EAAaC,CAAY,EACzDuB,EAAY,IAAI,UAAUpB,EAAOJ,CAAW,EAClDsB,EAAQ,aAAaE,EAAW,EAAG,CAAC,EACpC,KAAK,YAAcF,EAAQ,MAC7B,MACE,KAAK,YAAclB,EAErB,KAAK,YAAc,CAACF,EAAUC,CAAS,EACvC,KAAK,MAAQtC,EAAU,OACvB,KAAK,QAAO,CACd,CAMA,MAAO,CACL,GAAI,KAAK,QAAUA,EAAU,MAAQ,KAAK,QAAUA,EAAU,MAC5D,OAEF,KAAK,MAAQA,EAAU,QACvB,KAAK,QAAO,EAEZ,IAAI4D,EAAa,EAEjB,KAAK,qBAAuB,CAAA,EAC5B,KAAK,aAAa,QAAQ,CAAC,CAAC,KAAA9C,CAAI,IAAM,CACpC,MAAM+C,EAAQ/C,EAAK,SAAQ,EAC3B,GAAI+C,IAAU7D,EAAU,MAAQ6D,IAAU7D,EAAU,QAClD,OAEF4D,IAEA,MAAME,EAAkBC,GAAOjD,EAAMkD,GAAU,OAAQ,IAAM,CAC3D,MAAMH,EAAQ/C,EAAK,SAAQ,GAEzB+C,GAAS7D,EAAU,QACnB6D,GAAS7D,EAAU,OACnB6D,GAAS7D,EAAU,SAEnBiE,GAAcH,CAAe,EAC7BF,IACIA,IAAe,IACjB,KAAK,iBAAgB,EACrB,KAAK,WAAU,GAGrB,CAAC,EACD,KAAK,qBAAqB,KAAKE,CAAe,CAChD,CAAC,EAEGF,IAAe,EACjB,WAAW,KAAK,WAAW,KAAK,IAAI,EAAG,CAAC,EAExC,KAAK,aAAa,QAAQ,SAAU,CAAC,KAAA9C,CAAI,EAAG,CAC5BA,EAAK,SAAQ,GACdd,EAAU,MACrBc,EAAK,KAAI,CAEb,CAAC,CAEL,CAKA,kBAAmB,CACjB,KAAK,qBAAqB,QAAQmD,EAAa,EAC/C,KAAK,qBAAuB,IAC9B,CACF,CCpfA,MAAMC,WAAuBC,EAAW,CAItC,YAAY5E,EAAS,CACnB,MAAM6E,EACJ7E,EAAQ,aAAe,OAAY,YAAcA,EAAQ,WAE3D,IAAI8E,EAAW9E,EAAQ,SACnB8E,IAAa,QAAaD,IAC5BC,EAAWC,GAAU,CACnB,OAAQC,GAAqBH,CAAU,EACvC,cAAe7E,EAAQ,cACvB,QAASA,EAAQ,QACjB,QAASA,EAAQ,QACjB,SAAUA,EAAQ,QAC1B,CAAO,GAGH,MAAM,CACJ,UAAW,GACX,aAAcA,EAAQ,aACtB,wBAAyBA,EAAQ,wBACjC,WAAY6E,EACZ,SAAUC,EACV,MAAO9E,EAAQ,MACf,MAAOA,EAAQ,MACf,WAAYA,EAAQ,WACpB,YAAaA,EAAQ,YACrB,IAAKA,EAAQ,IACb,WAAYA,EAAQ,UAC1B,CAAK,EAMD,KAAK,QAAUA,EAAQ,SAAW,OAAYA,EAAQ,OAAS,EAM/D,KAAK,UAAYA,EAAQ,SAAWiF,EAAOjF,EAAQ,QAAQ,EAAI,KAM/D,KAAK,WAAa,KAMlB,KAAK,iBAAmB,CAAA,EAKxB,KAAK,QAAUA,EAAQ,OAKvB,KAAK,kBAAoB,KAAK,kBAAkB,KAAK,IAAI,EAKzD,KAAK,UAAYA,EAAQ,YAAc,OAAY,EAAIA,EAAQ,UAM/D,KAAK,uBAAyB,CAAA,EAM9B,KAAK,aAAeA,EAAQ,aAAe,YAK3C,KAAK,gBAAkB,IACzB,CAQA,aAAakF,EAAW,CACtB,KAAK,WAAaA,CACpB,CASA,YAAYvC,EAAG,CACb,GAAI,KAAK,WACP,OAAO,KAAK,WAAWA,CAAC,EAE1B,GAAI,KAAK,UACP,OAAO,KAAK,UAEd,MAAMmC,EAAW,KAAK,YAAW,EACjC,OAAOA,EAAWG,EAAOH,EAAS,YAAYnC,CAAC,CAAC,EAAI,CAAC,IAAK,GAAG,CAC/D,CAOA,uBAAuBkC,EAAY,CACjC,MAAMM,EAAW,KAAK,cAAa,EACnC,OACG,CAACA,GAAYC,EAAWD,EAAUN,CAAU,IAC7C,CAAC,KAAK,gBAEC,KAAK,QAGP,CACT,CAMA,UAAUQ,EAAQ,CAChB,KAAK,QAAUA,CACjB,CAWA,eAAe1C,EAAG2C,EAAGC,EAAG7E,EAAYT,EAAYuF,EAAW,CACzD,MAAMC,EACJ,KAAK,UAAY,KAAK,yBAAyBxF,GAAcS,CAAU,EACnEgF,EAAuB,KAAK,IAAI,MACpC,KACAD,EAAe,eAAc,EAAG,IAAI,CAAC,EAAG9C,IAAM,CAC5C,MAAMgD,EAAWV,EAAOQ,EAAe,YAAY9C,CAAC,CAAC,EAC/CiD,EAAc,KAAK,YAAYjD,CAAC,EACtC,OAAO,KAAK,IACViD,EAAY,CAAC,EAAID,EAAS,CAAC,EAC3BC,EAAY,CAAC,EAAID,EAAS,CAAC,CACrC,CACM,CAAC,CACP,EAEUE,EAAiB,KAAK,yBAAyBnF,CAAU,EACzDoF,EAAY,CAACnD,EAAG2C,EAAGC,CAAC,EACpBQ,EAAmB,KAAK,+BAC5BD,EACApF,CACN,EAEUV,EAAU,OAAO,OACrB,CACE,WAAYC,GAAcS,EAC1B,eAAA+E,EACA,WAAA/E,EACA,eAAAmF,EACA,UAAAC,EACA,iBAAAC,EACA,WAAYL,EACZ,OAAQ,KAAK,QACb,gBAAiB,CAAC/C,EAAG2C,EAAGC,EAAG3J,IACzB,KAAK,QAAQ+G,EAAG2C,EAAGC,EAAG3J,EAAY,OAAW4J,CAAS,EACxD,gBAAiB,KAAK,eAC9B,EAC8D,KAAK,WACnE,EACUjE,EACc,IAAIzB,GAAeE,CAAO,EAE9C,OAAAuB,EAAK,IAAM,KAAK,OAAM,EACfA,CACT,CAYA,QAAQoB,EAAG2C,EAAGC,EAAG3J,EAAYiJ,EAAYW,EAAW,CAClD,MAAMQ,EAAmB,KAAK,cAAa,EAC3C,GACEnB,IACEmB,GAAoB,CAACZ,EAAWY,EAAkBnB,CAAU,GAC5D,KAAK,iBAEP,OAAO,KAAK,eACVlC,EACA2C,EACAC,EACAV,EACAmB,EACAR,CACR,EAGI,MAAM7D,EAAO,KAAK,YAAYgB,CAAC,EAEzBsD,EAAe,KAAK,QAEpBC,EAAa,IAAI,gBAKjBC,EAAgB,CACpB,OAAQD,EAAW,OACnB,YAAa,KAAK,YACxB,EAEUJ,EAAY,KAAK,+BAA+B,CAACnD,EAAG2C,EAAGC,CAAC,CAAC,EAC/D,GAAI,CAACO,EACH,OAAO,KAGT,MAAMM,EAAM,KAAK,OAAM,EACjBC,EAAWC,GAAY,KAAMF,EAAKzD,EAAG2C,EAAGC,CAAC,EAC/C,GAAIC,GAAaA,EAAU,YAAYa,CAAQ,EAC7C,OAAgCb,EAAU,IAAIa,CAAQ,EAGxD,MAAME,EAAWT,EAAU,CAAC,EACtBU,EAAWV,EAAU,CAAC,EACtBW,EAAWX,EAAU,CAAC,EACtBY,EAAQ,KAAK,YAAW,GAAI,iBAAiBH,CAAQ,EACvDG,IACFP,EAAc,KAAOO,EAAM,UAAS,EAAK,GAE3C,SAASrB,GAAS,CAChB,OAAOsB,GAAU,UAAY,CAC3B,OAAOV,EAAaM,EAAUC,EAAUC,EAAUN,CAAa,CACjE,CAAC,CACH,CAKA,MAAMnG,EAAU,OAAO,OACrB,CACE,UAAW,CAAC2C,EAAG2C,EAAGC,CAAC,EACnB,OAAQF,EACR,KAAM1D,EACN,WAAYuE,CACpB,EACM,KAAK,WACX,EAEU3E,EACc,IAAIxB,GAASC,CAAO,EAExC,OAAAuB,EAAK,IAAM,KAAK,OAAM,EACtBA,EAAK,iBAAiBkD,GAAU,OAAQ,KAAK,iBAAiB,EAE9De,GAAW,IAAIa,EAAU9E,CAAI,EACtBA,CACT,CAMA,kBAAkBqF,EAAO,CACvB,MAAMrF,EAAoDqF,EAAM,OAC1DC,EAAMC,EAAOvF,CAAI,EACjBwF,EAAYxF,EAAK,SAAQ,EAC/B,IAAIlH,EACA0M,GAAatG,EAAU,SACzB,KAAK,iBAAiBoG,CAAG,EAAI,GAC7BxM,EAAO2M,EAAc,eACZH,KAAO,KAAK,mBACrB,OAAO,KAAK,iBAAiBA,CAAG,EAChCxM,EACE0M,GAAatG,EAAU,MACnBuG,EAAc,cACdD,GAAatG,EAAU,OACrBuG,EAAc,YACd,QAEN3M,GACF,KAAK,cAAc,IAAI4M,GAAgB5M,EAAMkH,CAAI,CAAC,CAEtD,CAOA,yBAAyBsD,EAAY,CACnC,MAAMM,EAAW,KAAK,cAAa,EACnC,GACE,KAAK,WACJ,CAACA,GAAYC,EAAWD,EAAUN,CAAU,IAC7C,CAAC,KAAK,gBAEN,OAAO,KAAK,SAGd,MAAMqC,EAAUJ,EAAOjC,CAAU,EACjC,OAAMqC,KAAW,KAAK,yBACpB,KAAK,uBAAuBA,CAAO,EACjCC,GAAyBtC,CAAU,GAEhC,KAAK,uBAAuBqC,CAAO,CAC5C,CAcA,yBAAyBrC,EAAYuC,EAAU,CAC7C,MAAMC,EAAOC,GAAczC,CAAU,EACrC,GAAIwC,EAAM,CACR,MAAMH,EAAUJ,EAAOO,CAAI,EACrBH,KAAW,KAAK,yBACpB,KAAK,uBAAuBA,CAAO,EAAIE,EAE3C,CACF,CACF","x_google_ignoreList":[0,1,2,3]}