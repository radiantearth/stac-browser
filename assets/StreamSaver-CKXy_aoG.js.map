{"version":3,"file":"StreamSaver-CKXy_aoG.js","sources":["../../node_modules/streamsaver-js/StreamSaver.js"],"sourcesContent":["/*! streamsaver. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */\r\n\r\n/* global chrome location ReadableStream define MessageChannel TransformStream */\r\n\r\n;((name, definition) => {\r\n  typeof module !== 'undefined'\r\n    ? module.exports = definition()\r\n    : typeof define === 'function' && typeof define.amd === 'object'\r\n      ? define(definition)\r\n      : this[name] = definition()\r\n})('streamSaver', () => {\r\n  'use strict'\r\n\r\n  const global = typeof window === 'object' ? window : this\r\n  if (!global.HTMLElement) console.warn('streamsaver is meant to run on browsers main thread')\r\n\r\n  let mitmTransporter = null\r\n  let supportsTransferable = false\r\n  const test = fn => { try { fn() } catch (e) {} }\r\n  const ponyfill = global.WebStreamsPolyfill || {}\r\n  const isSecureContext = global.isSecureContext\r\n  // TODO: Must come up with a real detection test (#69)\r\n  let useBlobFallback = /constructor/i.test(global.HTMLElement) || !!global.safari || !!global.WebKitPoint\r\n  const downloadStrategy = isSecureContext || 'MozAppearance' in document.documentElement.style\r\n    ? 'iframe'\r\n    : 'navigate'\r\n\r\n  const streamSaver = {\r\n    createWriteStream,\r\n    WritableStream: global.WritableStream || ponyfill.WritableStream,\r\n    supported: true,\r\n    version: { full: '2.0.5', major: 2, minor: 0, dot: 5 },\r\n    mitm: 'https://jimmywarting.github.io/StreamSaver.js/mitm.html?version=2.0.0'\r\n  }\r\n\r\n  /**\r\n   * create a hidden iframe and append it to the DOM (body)\r\n   *\r\n   * @param  {string} src page to load\r\n   * @return {HTMLIFrameElement} page to load\r\n   */\r\n  function makeIframe (src) {\r\n    if (!src) throw new Error('meh')\r\n    const iframe = document.createElement('iframe')\r\n    iframe.hidden = true\r\n    iframe.src = src\r\n    iframe.loaded = false\r\n    iframe.name = 'iframe'\r\n    iframe.isIframe = true\r\n    iframe.postMessage = (...args) => iframe.contentWindow.postMessage(...args)\r\n    iframe.addEventListener('load', () => {\r\n      iframe.loaded = true\r\n    }, { once: true })\r\n    document.body.appendChild(iframe)\r\n    return iframe\r\n  }\r\n\r\n  /**\r\n   * create a popup that simulates the basic things\r\n   * of what a iframe can do\r\n   *\r\n   * @param  {string} src page to load\r\n   * @return {object}     iframe like object\r\n   */\r\n  function makePopup (src) {\r\n    const options = 'width=200,height=100'\r\n    const delegate = document.createDocumentFragment()\r\n    const popup = {\r\n      frame: global.open(src, 'popup', options),\r\n      loaded: false,\r\n      isIframe: false,\r\n      isPopup: true,\r\n      remove () { popup.frame.close() },\r\n      addEventListener (...args) { delegate.addEventListener(...args) },\r\n      dispatchEvent (...args) { delegate.dispatchEvent(...args) },\r\n      removeEventListener (...args) { delegate.removeEventListener(...args) },\r\n      postMessage (...args) { popup.frame.postMessage(...args) }\r\n    }\r\n\r\n    const onReady = evt => {\r\n      if (evt.source === popup.frame) {\r\n        popup.loaded = true\r\n        global.removeEventListener('message', onReady)\r\n        popup.dispatchEvent(new Event('load'))\r\n      }\r\n    }\r\n\r\n    global.addEventListener('message', onReady)\r\n\r\n    return popup\r\n  }\r\n\r\n  try {\r\n    // We can't look for service worker since it may still work on http\r\n    new Response(new ReadableStream())\r\n    if (isSecureContext && !('serviceWorker' in navigator)) {\r\n      useBlobFallback = true\r\n    }\r\n  } catch (err) {\r\n    useBlobFallback = true\r\n  }\r\n\r\n  test(() => {\r\n    // Transferable stream was first enabled in chrome v73 behind a flag\r\n    const { readable } = new TransformStream()\r\n    const mc = new MessageChannel()\r\n    mc.port1.postMessage(readable, [readable])\r\n    mc.port1.close()\r\n    mc.port2.close()\r\n    supportsTransferable = true\r\n    // Freeze TransformStream object (can only work with native)\r\n    Object.defineProperty(streamSaver, 'TransformStream', {\r\n      configurable: false,\r\n      writable: false,\r\n      value: TransformStream\r\n    })\r\n  })\r\n\r\n  function loadTransporter () {\r\n    if (!mitmTransporter) {\r\n      mitmTransporter = isSecureContext && !'MozAppearance' in document.documentElement.style\r\n        ? makeIframe(streamSaver.mitm)\r\n        : makePopup(streamSaver.mitm)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param  {string} filename filename that should be used\r\n   * @param  {object} options  [description]\r\n   * @param  {number} size     deprecated\r\n   * @return {WritableStream<Uint8Array>}\r\n   */\r\n  function createWriteStream (filename, options, size) {\r\n    let opts = {\r\n      size: null,\r\n      pathname: null,\r\n      writableStrategy: undefined,\r\n      readableStrategy: undefined\r\n    }\r\n\r\n    let bytesWritten = 0 // by StreamSaver.js (not the service worker)\r\n    let downloadUrl = null\r\n    let channel = null\r\n    let ts = null\r\n\r\n    // normalize arguments\r\n    if (Number.isFinite(options)) {\r\n      [ size, options ] = [ options, size ]\r\n      console.warn('[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream')\r\n      opts.size = size\r\n      opts.writableStrategy = options\r\n    } else if (options && options.highWaterMark) {\r\n      console.warn('[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream')\r\n      opts.size = size\r\n      opts.writableStrategy = options\r\n    } else {\r\n      opts = options || {}\r\n    }\r\n    if (!useBlobFallback) {\r\n      loadTransporter()\r\n\r\n      channel = new MessageChannel()\r\n\r\n      // Make filename RFC5987 compatible\r\n      filename = encodeURIComponent(filename.replace(/\\//g, ':'))\r\n        .replace(/['()]/g, escape)\r\n        .replace(/\\*/g, '%2A')\r\n\r\n      const response = {\r\n        transferringReadable: supportsTransferable,\r\n        pathname: opts.pathname || Math.random().toString().slice(-6) + '/' + filename,\r\n        headers: {\r\n          'Content-Type': 'application/octet-stream; charset=utf-8',\r\n          'Content-Disposition': \"attachment; filename*=UTF-8''\" + filename\r\n        }\r\n      }\r\n\r\n      if (opts.size) {\r\n        response.headers['Content-Length'] = opts.size\r\n      }\r\n\r\n      const args = [ response, '*', [ channel.port2 ] ]\r\n\r\n      if (supportsTransferable) {\r\n        const transformer = downloadStrategy === 'iframe' ? undefined : {\r\n          // This transformer & flush method is only used by insecure context.\r\n          transform (chunk, controller) {\r\n            if (!(chunk instanceof Uint8Array)) {\r\n              throw new TypeError('Can only write Uint8Arrays')\r\n            }\r\n            bytesWritten += chunk.length\r\n            controller.enqueue(chunk)\r\n\r\n            if (downloadUrl) {\r\n              location.href = downloadUrl\r\n              downloadUrl = null\r\n            }\r\n          },\r\n          flush () {\r\n            if (downloadUrl) {\r\n              location.href = downloadUrl\r\n            }\r\n          }\r\n        }\r\n        ts = new streamSaver.TransformStream(\r\n          transformer,\r\n          opts.writableStrategy,\r\n          opts.readableStrategy\r\n        )\r\n        const readableStream = ts.readable\r\n\r\n        channel.port1.postMessage({ readableStream }, [ readableStream ])\r\n      }\r\n\r\n      channel.port1.onmessage = evt => {\r\n        // Service worker sent us a link that we should open.\r\n        if (evt.data.download) {\r\n          // Special treatment for popup...\r\n          if (downloadStrategy === 'navigate') {\r\n            mitmTransporter.remove()\r\n            mitmTransporter = null\r\n            if (bytesWritten) {\r\n              location.href = evt.data.download\r\n            } else {\r\n              downloadUrl = evt.data.download\r\n            }\r\n          } else {\r\n            if (mitmTransporter.isPopup) {\r\n              mitmTransporter.remove()\r\n              mitmTransporter = null\r\n              // Special case for firefox, they can keep sw alive with fetch\r\n              if (downloadStrategy === 'iframe') {\r\n                makeIframe(streamSaver.mitm)\r\n              }\r\n            }\r\n\r\n            // We never remove this iframes b/c it can interrupt saving\r\n            makeIframe(evt.data.download)\r\n          }\r\n        } else if (evt.data.abort) {\r\n          chunks = []\r\n          channel.port1.postMessage('abort') //send back so controller is aborted\r\n          channel.port1.onmessage = null\r\n          channel.port1.close()\r\n          channel.port2.close()\r\n          channel = null\r\n        }\r\n      }\r\n\r\n      if (mitmTransporter.loaded) {\r\n        mitmTransporter.postMessage(...args)\r\n      } else {\r\n        mitmTransporter.addEventListener('load', () => {\r\n          mitmTransporter.postMessage(...args)\r\n        }, { once: true })\r\n      }\r\n    }\r\n\r\n    let chunks = []\r\n\r\n    return (!useBlobFallback && ts && ts.writable) || new streamSaver.WritableStream({\r\n      write (chunk) {\r\n        if (!(chunk instanceof Uint8Array)) {\r\n          throw new TypeError('Can only write Uint8Arrays')\r\n        }\r\n        if (useBlobFallback) {\r\n          // Safari... The new IE6\r\n          // https://github.com/jimmywarting/StreamSaver.js/issues/69\r\n          //\r\n          // even though it has everything it fails to download anything\r\n          // that comes from the service worker..!\r\n          chunks.push(chunk)\r\n          return\r\n        }\r\n\r\n        // is called when a new chunk of data is ready to be written\r\n        // to the underlying sink. It can return a promise to signal\r\n        // success or failure of the write operation. The stream\r\n        // implementation guarantees that this method will be called\r\n        // only after previous writes have succeeded, and never after\r\n        // close or abort is called.\r\n\r\n        // TODO: Kind of important that service worker respond back when\r\n        // it has been written. Otherwise we can't handle backpressure\r\n        // EDIT: Transferable streams solves this...\r\n        channel.port1.postMessage(chunk)\r\n        bytesWritten += chunk.length\r\n\r\n        if (downloadUrl) {\r\n          location.href = downloadUrl\r\n          downloadUrl = null\r\n        }\r\n      },\r\n      close () {\r\n        if (useBlobFallback) {\r\n          const blob = new Blob(chunks, { type: 'application/octet-stream; charset=utf-8' })\r\n          const link = document.createElement('a')\r\n          link.href = URL.createObjectURL(blob)\r\n          link.download = filename\r\n          link.click()\r\n        } else {\r\n          channel.port1.postMessage('end')\r\n        }\r\n      },\r\n      abort () {\r\n        chunks = []\r\n        channel.port1.postMessage('abort')\r\n        channel.port1.onmessage = null\r\n        channel.port1.close()\r\n        channel.port2.close()\r\n        channel = null\r\n      }\r\n    }, opts.writableStrategy)\r\n  }\r\n\r\n  return streamSaver\r\n})\r\n"],"names":["name","definition","module","global","mitmTransporter","supportsTransferable","test","fn","ponyfill","isSecureContext","useBlobFallback","downloadStrategy","streamSaver","createWriteStream","makeIframe","src","iframe","args","makePopup","options","delegate","popup","onReady","evt","readable","mc","loadTransporter","filename","size","opts","bytesWritten","downloadUrl","channel","ts","response","transformer","chunk","controller","readableStream","chunks","blob","link"],"mappings":"4cAIE,CAACA,EAAMC,IAAe,CAElBC,EAAA,QAAiBD,EAAU,CAIjC,GAAG,cAAe,IAAM,CAGtB,MAAME,EAAS,OAAO,QAAW,SAAW,OAAS,KAChDA,EAAO,aAAa,QAAQ,KAAK,qDAAqD,EAE3F,IAAIC,EAAkB,KAClBC,EAAuB,GAC3B,MAAMC,EAAOC,GAAM,CAAE,GAAI,CAAEA,SAAiB,EAAE,EACxCC,EAAWL,EAAO,oBAAsB,CAAA,EACxCM,EAAkBN,EAAO,gBAE/B,IAAIO,EAAkB,eAAe,KAAKP,EAAO,WAAW,GAAK,CAAC,CAACA,EAAO,QAAU,CAAC,CAACA,EAAO,YAC7F,MAAMQ,EAAmBF,GAAmB,kBAAmB,SAAS,gBAAgB,MACpF,SACA,WAEEG,EAAc,CAClB,kBAAAC,EACA,eAAgBV,EAAO,gBAAkBK,EAAS,eAClD,UAAW,GACX,QAAS,CAAE,KAAM,QAAS,MAAO,EAAG,MAAO,EAAG,IAAK,CAAC,EACpD,KAAM,yEASR,SAASM,EAAYC,EAAK,CACxB,GAAI,CAACA,EAAK,MAAM,IAAI,MAAM,KAAK,EAC/B,MAAMC,EAAS,SAAS,cAAc,QAAQ,EAC9C,OAAAA,EAAO,OAAS,GAChBA,EAAO,IAAMD,EACbC,EAAO,OAAS,GAChBA,EAAO,KAAO,SACdA,EAAO,SAAW,GAClBA,EAAO,YAAc,IAAIC,IAASD,EAAO,cAAc,YAAY,GAAGC,CAAI,EAC1ED,EAAO,iBAAiB,OAAQ,IAAM,CACpCA,EAAO,OAAS,EACtB,EAAO,CAAE,KAAM,GAAM,EACjB,SAAS,KAAK,YAAYA,CAAM,EACzBA,CACX,CASE,SAASE,EAAWH,EAAK,CACvB,MAAMI,EAAU,uBACVC,EAAW,SAAS,uBAAsB,EAC1CC,EAAQ,CACZ,MAAOlB,EAAO,KAAKY,EAAK,QAASI,CAAO,EACxC,OAAQ,GACR,SAAU,GACV,QAAS,GACT,QAAU,CAAEE,EAAM,MAAM,MAAK,CAAE,EAC/B,oBAAqBJ,EAAM,CAAEG,EAAS,iBAAiB,GAAGH,CAAI,CAAC,EAC/D,iBAAkBA,EAAM,CAAEG,EAAS,cAAc,GAAGH,CAAI,CAAC,EACzD,uBAAwBA,EAAM,CAAEG,EAAS,oBAAoB,GAAGH,CAAI,CAAC,EACrE,eAAgBA,EAAM,CAAEI,EAAM,MAAM,YAAY,GAAGJ,CAAI,CAAC,GAGpDK,EAAUC,GAAO,CACjBA,EAAI,SAAWF,EAAM,QACvBA,EAAM,OAAS,GACflB,EAAO,oBAAoB,UAAWmB,CAAO,EAC7CD,EAAM,cAAc,IAAI,MAAM,MAAM,CAAC,EAE7C,EAEI,OAAAlB,EAAO,iBAAiB,UAAWmB,CAAO,EAEnCD,CACX,CAEE,GAAI,CAEF,IAAI,SAAS,IAAI,cAAgB,EAC7BZ,GAAmB,EAAE,kBAAmB,aAC1CC,EAAkB,GAExB,MAAgB,CACZA,EAAkB,EACtB,CAEEJ,EAAK,IAAM,CAET,KAAM,CAAE,SAAAkB,GAAa,IAAI,gBACnBC,EAAK,IAAI,eACfA,EAAG,MAAM,YAAYD,EAAU,CAACA,CAAQ,CAAC,EACzCC,EAAG,MAAM,MAAK,EACdA,EAAG,MAAM,MAAK,EACdpB,EAAuB,GAEvB,OAAO,eAAeO,EAAa,kBAAmB,CACpD,aAAc,GACd,SAAU,GACV,MAAO,eACb,CAAK,CACL,CAAG,EAED,SAASc,GAAmB,CACrBtB,IACHA,EAAkBK,GAAmB,MAAoB,SAAS,gBAAgB,MAC9EK,EAAWF,EAAY,IAAI,EAC3BM,EAAUN,EAAY,IAAI,EAEpC,CAQE,SAASC,EAAmBc,EAAUR,EAASS,EAAM,CACnD,IAAIC,EAAO,CACT,KAAM,KACN,SAAU,KACV,iBAAkB,OAClB,iBAAkB,QAGhBC,EAAe,EACfC,EAAc,KACdC,EAAU,KACVC,EAAK,KAeT,GAZI,OAAO,SAASd,CAAO,GACzB,CAAES,EAAMT,CAAO,EAAK,CAAEA,EAASS,CAAI,EACnC,QAAQ,KAAK,sFAAsF,EACnGC,EAAK,KAAOD,EACZC,EAAK,iBAAmBV,GACfA,GAAWA,EAAQ,eAC5B,QAAQ,KAAK,sFAAsF,EACnGU,EAAK,KAAOD,EACZC,EAAK,iBAAmBV,GAExBU,EAAOV,GAAW,CAAA,EAEhB,CAACT,EAAiB,CACpBgB,EAAe,EAEfM,EAAU,IAAI,eAGdL,EAAW,mBAAmBA,EAAS,QAAQ,MAAO,GAAG,CAAC,EACvD,QAAQ,SAAU,MAAM,EACxB,QAAQ,MAAO,KAAK,EAEvB,MAAMO,EAAW,CACf,qBAAsB7B,EACtB,SAAUwB,EAAK,UAAY,KAAK,OAAM,EAAG,SAAQ,EAAG,MAAM,EAAE,EAAI,IAAMF,EACtE,QAAS,CACP,eAAgB,0CAChB,sBAAuB,gCAAkCA,IAIzDE,EAAK,OACPK,EAAS,QAAQ,gBAAgB,EAAIL,EAAK,MAG5C,MAAMZ,EAAO,CAAEiB,EAAU,IAAK,CAAEF,EAAQ,MAAO,EAE/C,GAAI3B,EAAsB,CACxB,MAAM8B,EAAcxB,IAAqB,SAAW,OAAY,CAE9D,UAAWyB,EAAOC,EAAY,CAC5B,GAAI,EAAED,aAAiB,YACrB,MAAM,IAAI,UAAU,4BAA4B,EAElDN,GAAgBM,EAAM,OACtBC,EAAW,QAAQD,CAAK,EAEpBL,IACF,SAAS,KAAOA,EAChBA,EAAc,KAE5B,EACU,OAAS,CACHA,IACF,SAAS,KAAOA,EAE9B,GAEQE,EAAK,IAAIrB,EAAY,gBACnBuB,EACAN,EAAK,iBACLA,EAAK,kBAEP,MAAMS,EAAiBL,EAAG,SAE1BD,EAAQ,MAAM,YAAY,CAAE,eAAAM,CAAc,EAAI,CAAEA,EAAgB,CACxE,CAEMN,EAAQ,MAAM,UAAYT,GAAO,CAE3BA,EAAI,KAAK,SAEPZ,IAAqB,YACvBP,EAAgB,OAAM,EACtBA,EAAkB,KACd0B,EACF,SAAS,KAAOP,EAAI,KAAK,SAEzBQ,EAAcR,EAAI,KAAK,WAGrBnB,EAAgB,UAClBA,EAAgB,OAAM,EACtBA,EAAkB,KAEdO,IAAqB,UACvBG,EAAWF,EAAY,IAAI,GAK/BE,EAAWS,EAAI,KAAK,QAAQ,GAErBA,EAAI,KAAK,QAClBgB,EAAS,CAAA,EACTP,EAAQ,MAAM,YAAY,OAAO,EACjCA,EAAQ,MAAM,UAAY,KAC1BA,EAAQ,MAAM,MAAK,EACnBA,EAAQ,MAAM,MAAK,EACnBA,EAAU,KAEpB,EAEU5B,EAAgB,OAClBA,EAAgB,YAAY,GAAGa,CAAI,EAEnCb,EAAgB,iBAAiB,OAAQ,IAAM,CAC7CA,EAAgB,YAAY,GAAGa,CAAI,CAC7C,EAAW,CAAE,KAAM,GAAM,CAEzB,CAEI,IAAIsB,EAAS,CAAA,EAEb,MAAQ,CAAC7B,GAAmBuB,GAAMA,EAAG,UAAa,IAAIrB,EAAY,eAAe,CAC/E,MAAOwB,EAAO,CACZ,GAAI,EAAEA,aAAiB,YACrB,MAAM,IAAI,UAAU,4BAA4B,EAElD,GAAI1B,EAAiB,CAMnB6B,EAAO,KAAKH,CAAK,EACjB,MACV,CAYQJ,EAAQ,MAAM,YAAYI,CAAK,EAC/BN,GAAgBM,EAAM,OAElBL,IACF,SAAS,KAAOA,EAChBA,EAAc,KAExB,EACM,OAAS,CACP,GAAIrB,EAAiB,CACnB,MAAM8B,EAAO,IAAI,KAAKD,EAAQ,CAAE,KAAM,0CAA2C,EAC3EE,EAAO,SAAS,cAAc,GAAG,EACvCA,EAAK,KAAO,IAAI,gBAAgBD,CAAI,EACpCC,EAAK,SAAWd,EAChBc,EAAK,MAAK,CACpB,MACUT,EAAQ,MAAM,YAAY,KAAK,CAEzC,EACM,OAAS,CACPO,EAAS,CAAA,EACTP,EAAQ,MAAM,YAAY,OAAO,EACjCA,EAAQ,MAAM,UAAY,KAC1BA,EAAQ,MAAM,MAAK,EACnBA,EAAQ,MAAM,MAAK,EACnBA,EAAU,IAClB,CACA,EAAOH,EAAK,gBAAgB,CAC5B,CAEE,OAAOjB,CACT,CAAC","x_google_ignoreList":[0]}