{"version":3,"file":"VectorTile-UyqE-kwB.js","sources":["../../node_modules/ol/renderer/canvas/VectorTileLayer.js","../../node_modules/ol/layer/VectorTile.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {ascending} from '../../array.js';\nimport {wrapX} from '../../coordinate.js';\nimport {\n  boundingExtent,\n  buffer,\n  containsExtent,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {equivalent, getTransform, transformExtent} from '../../proj.js';\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup, {\n  DECLUTTER,\n} from '../../render/canvas/ExecutorGroup.js';\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {toSize} from '../../size.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply,\n  reset as resetTransform,\n  scale,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport {\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],\n  'hybrid': ['Polygon', 'LineString'],\n  'vector': [],\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst VECTOR_REPLAYS = {\n  'hybrid': ['Image', 'Text', 'Default'],\n  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'],\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n * @extends {CanvasTileLayerRenderer<import(\"../../layer/VectorTile.js\").default<import('../../source/VectorTile.js').default<import('../../Feature.js').FeatureLike>>>}\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   * @param {import(\"./TileLayer.js\").Options} options Options.\n   */\n  constructor(layer, options) {\n    super(layer, options);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedOpacity_ = 1;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {Array<ZIndexContext>}\n     */\n    this.tileClipContexts_ = null;\n  }\n\n  /**\n   * Determine whether tiles for next extent should be enqueued for rendering.\n   * @return {boolean} Rendering tiles for next extent is supported.\n   * @override\n   */\n  enqueueTilesForNextExtent() {\n    return this.getLayer().getRenderMode() !== 'vector';\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @override\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    this.updateExecutorGroup_(\n      tile,\n      frameState.pixelRatio,\n      frameState.viewState.projection,\n    );\n    if (this.tileImageNeedsRender_(tile)) {\n      this.renderTileImage_(tile, frameState);\n    }\n    super.drawTile(tile, frameState, x, y, w, h, gutter, transition);\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @override\n   */\n  getTile(z, x, y, frameState) {\n    const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n      this.getOrCreateTile(z, x, y, frameState)\n    );\n    if (!tile) {\n      return null;\n    }\n\n    const viewState = frameState.viewState;\n    const resolution = viewState.resolution;\n    const viewHints = frameState.viewHints;\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const withinTileResolutionRange =\n      tileGrid.getZForResolution(resolution, source.zDirection) === z;\n    if (hifi && withinTileResolutionRange) {\n      tile.wantedResolution = resolution;\n    } else if (!tile.wantedResolution) {\n      tile.wantedResolution = tileGrid.getResolution(z);\n    }\n\n    return tile;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    const layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ !== layerRevision) {\n      this.renderedLayerRevision_ = layerRevision;\n      this.renderedTiles.length = 0;\n    }\n    return super.prepareFrame(frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateExecutorGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const revision = layer.getRevision();\n    const renderOrder = layer.getRenderOrder() || null;\n\n    const resolution = tile.wantedResolution;\n    const builderState = tile.getReplayState(layer);\n    if (\n      !builderState.dirty &&\n      builderState.renderedResolution === resolution &&\n      builderState.renderedRevision == revision &&\n      builderState.renderedRenderOrder == renderOrder\n    ) {\n      return;\n    }\n\n    const source = layer.getSource();\n    const declutter = !!layer.getDeclutter();\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    const layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    builderState.dirty = false;\n    for (let t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      const sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n      const sourceProjection = source.getProjection();\n      const sourceTileCoord = sourceTile.tileCoord;\n      let sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      if (\n        projection &&\n        sourceProjection &&\n        !equivalent(projection, sourceProjection)\n      ) {\n        sourceTileExtent = transformExtent(\n          sourceTileExtent,\n          sourceProjection,\n          projection,\n          32,\n        );\n      }\n\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const builderExtent = buffer(\n        sharedExtent,\n        layer.getRenderBuffer() * resolution,\n        this.tempExtent,\n      );\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent)\n        ? null\n        : builderExtent;\n      const builderGroup = new CanvasBuilderGroup(\n        0,\n        sharedExtent,\n        resolution,\n        pixelRatio,\n      );\n      const squaredTolerance = getSquaredRenderTolerance(\n        resolution,\n        pixelRatio,\n      );\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @param {number} [index] Render order index.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function (feature, index) {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            builderGroup,\n            declutter,\n            index,\n          );\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        let feature = features[i];\n        if (\n          projection &&\n          sourceTile.projection &&\n          !equivalent(projection, sourceTile.projection)\n        ) {\n          feature = feature.clone();\n          feature\n            .getGeometry()\n            .applyTransform(getTransform(sourceTile.projection, projection));\n        }\n        if (\n          !bufferedExtent ||\n          intersects(bufferedExtent, feature.getGeometry().getExtent())\n        ) {\n          render.call(this, feature, i);\n        }\n      }\n      const executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      const replayExtent =\n        layer.getRenderMode() !== 'vector' &&\n        declutter &&\n        sourceTiles.length === 1\n          ? null\n          : sharedExtent;\n      const renderingReplayGroup = new CanvasExecutorGroup(\n        replayExtent,\n        resolution,\n        pixelRatio,\n        source.getOverlaps(),\n        executorGroupInstructions,\n        layer.getRenderBuffer(),\n        true,\n      );\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    const source = layer.getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n\n    const hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      let key = feature.getId();\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          }),\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    const renderedTiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const layerUid = getUid(layer);\n    const declutter = layer.getDeclutter();\n    const declutteredFeatures = declutter\n      ? frameState.declutter?.[declutter]?.all().map((item) => item.value)\n      : null;\n    let found;\n    foundFeature: for (let i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      const tile = renderedTiles[i];\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      if (!intersects(tileExtent, hitExtent)) {\n        continue;\n      }\n\n      const executorGroups = tile.executorGroups[layerUid];\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        found = executorGroups[t].forEachFeatureAtCoordinate(\n          coordinate,\n          resolution,\n          rotation,\n          hitTolerance,\n          featureCallback,\n          declutteredFeatures,\n        );\n        if (found) {\n          break foundFeature;\n        }\n      }\n    }\n    return found;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature.js\").FeatureLike>>} Promise that resolves with an array of features.\n   * @override\n   */\n  getFeatures(pixel) {\n    if (this.renderedTiles.length === 0) {\n      return Promise.resolve([]);\n    }\n    return new Promise((resolve, reject) => {\n      const layer = this.getLayer();\n      const source = layer.getSource();\n      const projection = this.renderedProjection;\n      const projectionExtent = projection.getExtent();\n      const resolution = this.renderedResolution;\n      const tileGrid = source.getTileGridForProjection(projection);\n      const coordinate = applyTransform(\n        this.renderedPixelToCoordinateTransform_,\n        pixel.slice(),\n      );\n      const tileCoordString = tileGrid\n        .getTileCoordForCoordAndResolution(coordinate, resolution)\n        .toString();\n      const tile =\n        /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n          this.renderedTiles\n        ).find(\n          (tile) =>\n            tile.tileCoord.toString() === tileCoordString &&\n            tile.getState() === TileState.LOADED,\n        );\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n      if (\n        source.getWrapX() &&\n        projection.canWrapX() &&\n        !containsExtent(\n          projectionExtent,\n          tileGrid.getTileCoordExtent(tile.tileCoord),\n        )\n      ) {\n        wrapX(coordinate, projection);\n      }\n      const layerUid = getUid(layer);\n      const extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      const corner = getTopLeft(extent);\n      const tilePixel = [\n        (coordinate[0] - corner[0]) / resolution,\n        (corner[1] - coordinate[1]) / resolution,\n      ];\n      const features = tile\n        .getSourceTiles()\n        .reduce(\n          (accumulator, sourceTile) =>\n            accumulator.concat(sourceTile.getFeatures()),\n          /** @type {Array<import(\"../../Feature.js\").FeatureLike>} */ ([]),\n        );\n      let hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n      if (!hitDetectionImageData) {\n        const tileSize = toSize(\n          tileGrid.getTileSize(\n            tileGrid.getZForResolution(resolution, source.zDirection),\n          ),\n        );\n        const rotation = this.renderedRotation_;\n        const transforms = [\n          this.getRenderTransform(\n            tileGrid.getTileCoordCenter(tile.wrappedTileCoord),\n            resolution,\n            0,\n            HIT_DETECT_RESOLUTION,\n            tileSize[0] * HIT_DETECT_RESOLUTION,\n            tileSize[1] * HIT_DETECT_RESOLUTION,\n            0,\n          ),\n        ];\n        hitDetectionImageData = createHitDetectionImageData(\n          tileSize,\n          transforms,\n          features,\n          layer.getStyleFunction(),\n          tileGrid.getTileCoordExtent(tile.wrappedTileCoord),\n          tile.getReplayState(layer).renderedResolution,\n          rotation,\n        );\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    });\n  }\n\n  /**\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @return {Array<import('../../Feature.js').FeatureLike>} Features.\n   */\n  getFeaturesInExtent(extent) {\n    /** @type {Array<import('../../Feature.js').FeatureLike>} */\n    const features = [];\n    const tileCache = this.getTileCache();\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      this.frameState.viewState.projection,\n    );\n    const z = tileGrid.getZForResolution(this.renderedResolution);\n    /** @type {Object<string, true>} */\n    const visitedSourceTiles = {};\n    tileCache.forEach((tile) => {\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const sourceTiles = tile.getSourceTiles();\n      for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        const sourceTile = sourceTiles[i];\n        const key = sourceTile.getKey();\n        if (key in visitedSourceTiles) {\n          continue;\n        }\n        visitedSourceTiles[key] = true;\n        const tileCoord = sourceTile.tileCoord;\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          const tileFeatures = sourceTile.getFeatures();\n          if (tileFeatures) {\n            for (let j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              const candidate = tileFeatures[j];\n              const geometry = candidate.getGeometry();\n              if (intersects(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @override\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   */\n  renderDeclutter(frameState, layerState) {\n    const context = this.context;\n    const alpha = context.globalAlpha;\n    context.globalAlpha = layerState.opacity;\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const scaledCanvasSize = [\n      this.context.canvas.width,\n      this.context.canvas.height,\n    ];\n    const declutter = this.getLayer().getDeclutter();\n    const declutterTree = declutter\n      ? frameState.declutter?.[declutter]\n      : undefined;\n    const layerUid = getUid(this.getLayer());\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    for (let i = 0, ii = tiles.length; i < ii; ++i) {\n      const tile = tiles[i];\n      const executorGroups = tile.executorGroups[layerUid];\n      if (executorGroups) {\n        for (let j = executorGroups.length - 1; j >= 0; --j) {\n          executorGroups[j].execute(\n            this.context,\n            scaledCanvasSize,\n            this.getTileRenderTransform(tile, frameState),\n            frameState.viewState.rotation,\n            hifi,\n            DECLUTTER,\n            declutterTree,\n          );\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderDeferredInternal(frameState) {\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const layerUid = getUid(this.getLayer());\n    const executorGroups = tiles.reduce((acc, tile, index) => {\n      tile.executorGroups[layerUid].forEach((executorGroup) =>\n        acc.push({\n          executorGroup,\n          index,\n        }),\n      );\n      return acc;\n    }, /** @type {Array<{executorGroup: CanvasExecutorGroup, index: number}>} */ ([]));\n\n    const executorGroupZIndexContexts = executorGroups.map(({executorGroup}) =>\n      executorGroup.getDeferredZIndexContexts(),\n    );\n    /** @type {Object<number, true>} */\n    const usedZIndices = {};\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroupZindexContext =\n        executorGroups[i].executorGroup.getDeferredZIndexContexts();\n      for (const key in executorGroupZindexContext) {\n        usedZIndices[key] = true;\n      }\n    }\n    const zIndexKeys = Object.keys(usedZIndices).map(Number).sort(ascending);\n    zIndexKeys.forEach((zIndex) => {\n      executorGroupZIndexContexts.forEach((zIndexContexts, i) => {\n        if (!zIndexContexts[zIndex]) {\n          return;\n        }\n        zIndexContexts[zIndex].forEach((zIndexContext) => {\n          const {executorGroup, index} = executorGroups[i];\n          const context = executorGroup.getRenderedContext();\n          const alpha = context.globalAlpha;\n          context.globalAlpha = this.renderedOpacity_;\n          const tileClipContext = this.tileClipContexts_[index];\n          if (tileClipContext) {\n            tileClipContext.draw(context);\n          }\n          zIndexContext.draw(context);\n          if (tileClipContext) {\n            context.restore();\n          }\n          context.globalAlpha = alpha;\n          zIndexContext.clear();\n        });\n        zIndexContexts[zIndex].length = 0;\n      });\n    });\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile The tile\n   * @param {import('../../Map.js').FrameState} frameState Current frame state\n   * @return {import('../../transform.js').Transform} Transform to use to render this tile\n   */\n  getTileRenderTransform(tile, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    const size = frameState.size;\n    const width = Math.round(size[0] * pixelRatio);\n    const height = Math.round(size[1] * pixelRatio);\n\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n    const tileCoord = tile.tileCoord;\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const worldOffset =\n      tileGrid.getTileCoordExtent(tileCoord, this.tempExtent)[0] -\n      tileExtent[0];\n    const transform = multiply(\n      scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio),\n      this.getRenderTransform(\n        center,\n        resolution,\n        rotation,\n        pixelRatio,\n        width,\n        height,\n        worldOffset,\n      ),\n    );\n    return transform;\n  }\n\n  /**\n   * Render the vectors for this layer.\n   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Target context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  postRender(context, frameState) {\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n\n    this.renderedPixelToCoordinateTransform_ =\n      frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n    this.renderedOpacity_ =\n      frameState.layerStatesArray[frameState.layerIndex].opacity;\n\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const renderMode = layer.getRenderMode();\n    const alpha = context.globalAlpha;\n    context.globalAlpha = this.renderedOpacity_;\n    const declutter = layer.getDeclutter();\n    const replayTypes = declutter\n      ? VECTOR_REPLAYS[renderMode].filter((type) => !DECLUTTER.includes(type))\n      : VECTOR_REPLAYS[renderMode];\n    const viewState = frameState.viewState;\n    const rotation = viewState.rotation;\n    const tileSource = layer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection,\n    );\n\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const clips = [];\n    const clipZs = [];\n    const tileClipContexts = [];\n    const layerUid = getUid(layer);\n    let ready = true;\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile = tiles[i];\n      ready = ready && !tile.getReplayState(layer).dirty;\n      const executorGroups = tile.executorGroups[layerUid].filter((group) =>\n        group.hasExecutors(replayTypes),\n      );\n      if (executorGroups.length === 0) {\n        continue;\n      }\n      const transform = this.getTileRenderTransform(tile, frameState);\n      const currentZ = tile.tileCoord[0];\n      let contextSaved = false;\n      // Clip mask for regions in this tile that already filled by a higher z tile\n      const currentClip = executorGroups[0].getClipCoords(transform);\n      let clipContext = context;\n      let tileClipContext;\n      if (currentClip) {\n        tileClipContext = new ZIndexContext();\n        clipContext = tileClipContext.getContext();\n        for (let j = 0, jj = clips.length; j < jj; ++j) {\n          if (z !== currentZ && currentZ < clipZs[j]) {\n            const clip = clips[j];\n            if (\n              intersects(\n                [\n                  currentClip[0],\n                  currentClip[3],\n                  currentClip[4],\n                  currentClip[7],\n                ],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                clipContext.save();\n                contextSaved = true;\n              }\n              clipContext.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              clipContext.moveTo(currentClip[0], currentClip[1]);\n              clipContext.lineTo(currentClip[2], currentClip[3]);\n              clipContext.lineTo(currentClip[4], currentClip[5]);\n              clipContext.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              clipContext.moveTo(clip[6], clip[7]);\n              clipContext.lineTo(clip[4], clip[5]);\n              clipContext.lineTo(clip[2], clip[3]);\n              clipContext.lineTo(clip[0], clip[1]);\n              clipContext.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n      }\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        executorGroup.execute(\n          context,\n          [context.canvas.width, context.canvas.height],\n          transform,\n          rotation,\n          hifi,\n          replayTypes,\n          frameState.declutter?.[declutter],\n        );\n      }\n      if (contextSaved) {\n        if (clipContext === context) {\n          clipContext.restore();\n        } else {\n          tileClipContexts[i] = tileClipContext;\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n    this.ready = ready;\n    this.tileClipContexts_ = tileClipContexts;\n    if (!frameState.declutter) {\n      this.renderDeferredInternal(frameState);\n    }\n\n    super.postRender(context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {boolean} [declutter] Enable decluttering.\n   * @param {number} [index] Render order index.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    declutter,\n    index,\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            undefined,\n            declutter,\n            index,\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        undefined,\n        declutter,\n        index,\n      );\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  tileImageNeedsRender_(tile) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    if (layer.getRenderMode() === 'vector') {\n      return false;\n    }\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const resolution = tile.wantedResolution;\n    const tileImageNeedsRender =\n      replayState.renderedTileResolution !== resolution ||\n      replayState.renderedTileRevision !== revision;\n    return tileImageNeedsRender;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  renderTileImage_(tile, frameState) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source = layer.getSource();\n    let pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const renderPixelRatio =\n      (frameState.pixelRatio / tile.wantedResolution) * tileResolution;\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext();\n\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.round(\n      Math.max(pixelRatio, renderPixelRatio / pixelRatio),\n    );\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      const canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tempExtent);\n    const pixelScale = renderPixelRatio / resolution;\n    const transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroup = executorGroups[i];\n      executorGroup.execute(\n        context,\n        [\n          context.canvas.width * renderScale,\n          context.canvas.height * renderScale,\n        ],\n        transform,\n        0,\n        true,\n        IMAGE_REPLAYS[layer.getRenderMode()],\n        null,\n      );\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  }\n}\n\nexport default CanvasVectorTileLayerRenderer;\n","/**\n * @module ol/layer/VectorTile\n */\nimport {assert} from '../asserts.js';\nimport CanvasVectorTileLayerRenderer from '../renderer/canvas/VectorTileLayer.js';\nimport BaseVectorLayer from './BaseVector.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} VectorTileLayerOnSignature\n */\n\n/**\n * @typedef {'hybrid' | 'vector'} VectorTileRenderType\n */\n\n/***\n * @template T\n * @typedef {T extends import(\"../source/VectorTile.js\").default<infer U extends import(\"../Feature.js\").FeatureLike> ? U : never} ExtractedFeatureType\n */\n\n/**\n * @template {import(\"../source/VectorTile.js\").default<FeatureType>} [VectorTileSourceType=import(\"../source/VectorTile.js\").default<*>]\n * @template {import(\"../Feature\").FeatureLike} [FeatureType=ExtractedFeatureType<VectorTileSourceType>]\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the\n * renderer when getting features from the vector tile for the rendering or hit-detection.\n * Recommended value: Vector tiles are usually generated with a buffer, so this value should match\n * the largest possible buffer of the used tiles. It should be at least the size of the largest\n * point symbol or line width.\n * @property {VectorTileRenderType} [renderMode='hybrid'] Render mode for vector tiles:\n *  `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom\n *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on\n *    rotated views, but get lifted above all polygon and line elements.\n *  `'vector'`: Everything is rendered as vectors and the original render order is maintained. Use\n *    this mode for improved performance and visual epxerience on vector tile layers with not too many\n *    rendered features (e.g. for highlighting a subset of features of another layer with the same\n *    source).\n * @property {VectorTileSourceType} [source] Source.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * @property {boolean|string|number} [declutter=false] Declutter images and text. Any truthy value will enable\n * decluttering. Within a layer, a feature rendered before another has higher priority. All layers with the\n * same `declutter` value will be decluttered together. The priority is determined by the drawing order of the\n * layers with the same `declutter` value. Higher in the layer stack means higher priority. To declutter distinct\n * layers or groups of layers separately, use different truthy values for `declutter`.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer\n * style. When set to `null`, only\n * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style\n * which will be used if this is not set.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no\n * background will be rendered.\n * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be\n * recreated during animations. This means that no vectors will be shown clipped, but the setting\n * will have a performance impact for large amounts of vector data. When set to `false`, batches\n * will be recreated when no animation is active.\n * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be\n * recreated during interactions. See also `updateWhileAnimating`.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n * @property {number} [cacheSize=0] The internal tile cache size.  If too small, this will auto-grow to hold\n * two zoom levels worth of tiles.\n */\n\n/**\n * @classdesc\n * Layer for vector tile data that is rendered client-side.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/VectorTile.js\").default<FeatureType>} [VectorTileSourceType=import(\"../source/VectorTile.js\").default<*>]\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=ExtractedFeatureType<VectorTileSourceType>]\n * @extends {BaseVectorLayer<FeatureType, VectorTileSourceType, CanvasVectorTileLayerRenderer>}\n * @api\n */\nclass VectorTileLayer extends BaseVectorLayer {\n  /**\n   * @param {Options<VectorTileSourceType, FeatureType>} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n    delete baseOptions.preload;\n    const cacheSize = options.cacheSize === undefined ? 0 : options.cacheSize;\n    delete options.cacheSize;\n    delete baseOptions.useInterimTilesOnError;\n\n    super(baseOptions);\n\n    /***\n     * @type {VectorTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {VectorTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {VectorTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n\n    const renderMode = options.renderMode || 'hybrid';\n    assert(\n      renderMode == 'hybrid' || renderMode == 'vector',\n      \"`renderMode` must be `'hybrid'` or `'vector'`\",\n    );\n\n    /**\n     * @private\n     * @type {VectorTileRenderType}\n     */\n    this.renderMode_ = renderMode;\n\n    this.setPreload(options.preload ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true,\n    );\n\n    /**\n     * @return {import(\"./Base.js\").BackgroundColor} Background color.\n     * @function\n     * @api\n     */\n    this.getBackground;\n\n    /**\n     * @param {import(\"./Base.js\").BackgroundColor} background Background color.\n     * @function\n     * @api\n     */\n    this.setBackground;\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    return new CanvasVectorTileLayerRenderer(this, {\n      cacheSize: this.cacheSize_,\n    });\n  }\n\n  /**\n   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise\n   * that resolves with an array of features. The array will either contain the topmost feature\n   * when a hit was detected, or it will be empty.\n   *\n   * The hit detection algorithm used for this method is optimized for performance, but is less\n   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import(\"../Map.js\").default#getFeaturesAtPixel}.\n   * Text is not considered, and icons are only represented by their bounding box instead of the exact\n   * image.\n   *\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with an array of features.\n   * @api\n   * @override\n   */\n  getFeatures(pixel) {\n    return super.getFeatures(pixel);\n  }\n\n  /**\n   * Get features whose bounding box intersects the provided extent. Only features for cached\n   * tiles for the last rendered zoom level are available in the source. So this method is only\n   * suitable for requesting tiles for extents that are currently rendered.\n   *\n   * Features are returned in random tile order and as they are included in the tiles. This means\n   * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   */\n  getFeaturesInExtent(extent) {\n    return /** @type {Array<FeatureType>} */ (\n      /** @type {*} */ (this.getRenderer().getFeaturesInExtent(extent))\n    );\n  }\n\n  /**\n   * @return {VectorTileRenderType} The render mode.\n   */\n  getRenderMode() {\n    return this.renderMode_;\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Deprecated.  Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Deprecated.  Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n}\n\nexport default VectorTileLayer;\n"],"names":["IMAGE_REPLAYS","VECTOR_REPLAYS","CanvasVectorTileLayerRenderer","CanvasTileLayerRenderer","layer","options","createTransform","tile","frameState","x","y","w","h","gutter","transition","z","viewState","resolution","viewHints","source","tileGrid","hifi","ViewHint","withinTileResolutionRange","layerRevision","pixelRatio","projection","revision","renderOrder","builderState","declutter","sourceTileGrid","tileExtent","sourceTiles","layerUid","getUid","t","tt","sourceTile","TileState","sourceProjection","sourceTileCoord","sourceTileExtent","equivalent","transformExtent","sharedExtent","getIntersection","builderExtent","buffer","bufferedExtent","equals","builderGroup","CanvasBuilderGroup","squaredTolerance","getSquaredRenderTolerance","render","feature","index","styles","styleFunction","dirty","features","i","ii","getTransform","intersects","executorGroupInstructions","replayExtent","renderingReplayGroup","CanvasExecutorGroup","coordinate","hitTolerance","callback","matches","rotation","hitExtent","boundingExtent","featureCallback","geometry","distanceSq","key","match","renderedTiles","declutteredFeatures","item","found","foundFeature","executorGroups","pixel","resolve","reject","projectionExtent","applyTransform","tileCoordString","containsExtent","wrapX","extent","corner","getTopLeft","tilePixel","accumulator","hitDetectionImageData","tileSize","toSize","transforms","HIT_DETECT_RESOLUTION","createHitDetectionImageData","hitDetect","tileCache","visitedSourceTiles","tileCoord","tileFeatures","j","jj","candidate","event","layerState","context","alpha","scaledCanvasSize","declutterTree","tiles","DECLUTTER","acc","executorGroup","executorGroupZIndexContexts","usedZIndices","executorGroupZindexContext","ascending","zIndex","zIndexContexts","zIndexContext","tileClipContext","center","size","width","height","worldOffset","multiply","scale","renderMode","replayTypes","type","tileSource","clips","clipZs","tileClipContexts","ready","group","transform","currentZ","contextSaved","currentClip","clipContext","ZIndexContext","clip","loading","renderFeature","replayState","tileResolution","renderPixelRatio","renderScale","canvasTransform","resetTransform","scaleTransform","pixelScale","translateTransform","VectorTileLayer","BaseVectorLayer","baseOptions","cacheSize","assert","TileProperty","preload","useInterimTilesOnError"],"mappings":"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","x_google_ignoreList":[0,1]}