{"version":3,"file":"WMTSCapabilities-DUAuigqY.js","sources":["../../node_modules/ol/xml.js","../../node_modules/ol/format/XML.js","../../node_modules/ol/format/xlink.js","../../node_modules/ol/format/xsd.js","../../node_modules/ol/format/OWS.js","../../node_modules/ol/format/WMTSCapabilities.js"],"sourcesContent":["/**\n * @module ol/xml\n */\nimport {extend} from './array.js';\n\n/**\n * When using {@link module:ol/xml.makeChildAppender} or\n * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Element} node Node.\n */\n\n/**\n * @typedef {function(Element, Array<*>): void} Parser\n */\n\n/**\n * @typedef {function(Element, *, Array<*>): void} Serializer\n */\n\n/**\n * @type {string}\n */\nexport const XML_SCHEMA_INSTANCE_URI =\n  'http://www.w3.org/2001/XMLSchema-instance';\n\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\nexport function createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\nexport function getAllTextContent(node, normalizeWhitespace) {\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n  if (\n    node.nodeType == Node.CDATA_SECTION_NODE ||\n    node.nodeType == Node.TEXT_NODE\n  ) {\n    if (normalizeWhitespace) {\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      accumulator.push(node.nodeValue);\n    }\n  } else {\n    let n;\n    for (n = node.firstChild; n; n = n.nextSibling) {\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\n    }\n  }\n  return accumulator;\n}\n\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\nexport function isDocument(object) {\n  return 'documentElement' in object;\n}\n\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\nexport function getAttributeNS(node, namespaceURI, name) {\n  return node.getAttributeNS(namespaceURI, name) || '';\n}\n\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\nexport function parse(xml) {\n  return new DOMParser().parseFromString(xml, 'application/xml');\n}\n\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayExtender(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        extend(array, value);\n      }\n    }\n  );\n}\n\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayPusher(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeReplacer(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        objectStack[objectStack.length - 1] = value;\n      }\n    }\n  );\n}\n\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertyPusher(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        let array;\n        if (name in object) {\n          array = object[name];\n        } else {\n          array = [];\n          object[name] = array;\n        }\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertySetter(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        object[name] = value;\n      }\n    }\n  );\n}\n\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeChildAppender(nodeWriter, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {*} value Value to be written.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, value, objectStack) {\n      nodeWriter.call(thisArg ?? this, node, value, objectStack);\n      const parent = /** @type {NodeStackItem} */ (\n        objectStack[objectStack.length - 1]\n      );\n      const parentNode = parent.node;\n      parentNode.appendChild(node);\n    }\n  );\n}\n\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the\n * `nodeWriter` called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeArraySerializer(nodeWriter, thisArg) {\n  let serializersNS, nodeFactory;\n  return function (node, value, objectStack) {\n    if (serializersNS === undefined) {\n      serializersNS = {};\n      const serializers = {};\n      serializers[node.localName] = nodeWriter;\n      serializersNS[node.namespaceURI] = serializers;\n      nodeFactory = makeSimpleNodeFactory(node.localName);\n    }\n    serialize(serializersNS, nodeFactory, value, objectStack);\n  };\n}\n\n/**\n * Create a node factory which can use the `keys` passed to\n * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string} [fixedNodeName] Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string} [fixedNamespaceURI] Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\nexport function makeSimpleNodeFactory(fixedNodeName, fixedNamespaceURI) {\n  return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [newNodeName] Node name.\n     * @return {Node} Node.\n     */\n    function (value, objectStack, newNodeName) {\n      const context = /** @type {NodeStackItem} */ (\n        objectStack[objectStack.length - 1]\n      );\n      const node = context.node;\n      let nodeName = fixedNodeName;\n      if (nodeName === undefined) {\n        nodeName = newNodeName;\n      }\n\n      const namespaceURI =\n        fixedNamespaceURI !== undefined ? fixedNamespaceURI : node.namespaceURI;\n      return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\n    }\n  );\n}\n\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nexport const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n\n/**\n * Create an array of `values` to be used with {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `key` argument.\n * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<*>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n */\nexport function makeSequence(object, orderedKeys) {\n  const length = orderedKeys.length;\n  const sequence = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    sequence[i] = object[orderedKeys[i]];\n  }\n  return sequence;\n}\n\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>} [structureNS] Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\nexport function makeStructureNS(namespaceURIs, structure, structureNS) {\n  structureNS = structureNS !== undefined ? structureNS : {};\n  let i, ii;\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n    structureNS[namespaceURIs[i]] = structure;\n  }\n  return structureNS;\n}\n\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n */\nexport function parseNode(parsersNS, node, objectStack, thisArg) {\n  let n;\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n    const parsers = parsersNS[n.namespaceURI];\n    if (parsers !== undefined) {\n      const parser = parsers[n.localName];\n      if (parser !== undefined) {\n        parser.call(thisArg, n, objectStack);\n      }\n    }\n  }\n}\n\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\nexport function pushParseAndPop(object, parsersNS, node, objectStack, thisArg) {\n  objectStack.push(object);\n  parseNode(parsersNS, node, objectStack, thisArg);\n  return /** @type {T} */ (objectStack.pop());\n}\n\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\nexport function serialize(\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg,\n) {\n  const length = (keys !== undefined ? keys : values).length;\n  let value, node;\n  for (let i = 0; i < length; ++i) {\n    value = values[i];\n    if (value !== undefined) {\n      node = nodeFactory.call(\n        thisArg,\n        value,\n        objectStack,\n        keys !== undefined ? keys[i] : undefined,\n      );\n      if (node !== undefined) {\n        serializersNS[node.namespaceURI][node.localName].call(\n          thisArg,\n          node,\n          value,\n          objectStack,\n        );\n      }\n    }\n  }\n}\n\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\nexport function pushSerializeAndPop(\n  object,\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg,\n) {\n  objectStack.push(object);\n  serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg);\n  return /** @type {O|undefined} */ (objectStack.pop());\n}\n\nlet xmlSerializer_ = undefined;\n\n/**\n * Register a XMLSerializer. Can be used  to inject a XMLSerializer\n * where there is no globally available implementation.\n *\n * @param {XMLSerializer} xmlSerializer A XMLSerializer.\n * @api\n */\nexport function registerXMLSerializer(xmlSerializer) {\n  xmlSerializer_ = xmlSerializer;\n}\n\n/**\n * @return {XMLSerializer} The XMLSerializer.\n */\nexport function getXMLSerializer() {\n  if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {\n    xmlSerializer_ = new XMLSerializer();\n  }\n  return xmlSerializer_;\n}\n\nlet document_ = undefined;\n\n/**\n * Register a Document to use when creating nodes for XML serializations. Can be used\n * to inject a Document where there is no globally available implementation.\n *\n * @param {Document} document A Document.\n * @api\n */\nexport function registerDocument(document) {\n  document_ = document;\n}\n\n/**\n * Get a document that should be used when creating nodes for XML serializations.\n * @return {Document} The document.\n */\nexport function getDocument() {\n  if (document_ === undefined && typeof document !== 'undefined') {\n    document_ = document.implementation.createDocument('', '', null);\n  }\n  return document_;\n}\n","/**\n * @module ol/format/XML\n */\nimport {abstract} from '../util.js';\nimport {isDocument, parse} from '../xml.js';\n\n/**\n * @classdesc\n * Generic format for reading non-feature XML data\n *\n * @abstract\n */\nclass XML {\n  /**\n   * Read the source document.\n   *\n   * @param {Document|Element|string} source The XML source.\n   * @return {Object|null} An object representing the source.\n   * @api\n   */\n  read(source) {\n    if (!source) {\n      return null;\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFromDocument(doc);\n    }\n    if (isDocument(source)) {\n      return this.readFromDocument(/** @type {Document} */ (source));\n    }\n    return this.readFromNode(/** @type {Element} */ (source));\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {Object|null} Object\n   */\n  readFromDocument(doc) {\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readFromNode(/** @type {Element} */ (n));\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @abstract\n   * @param {Element} node Node.\n   * @return {Object|null} Object\n   */\n  readFromNode(node) {\n    abstract();\n  }\n}\n\nexport default XML;\n","/**\n * @module ol/format/xlink\n */\n\n/**\n * @const\n * @type {string}\n */\nconst NAMESPACE_URI = 'http://www.w3.org/1999/xlink';\n\n/**\n * @param {Element} node Node.\n * @return {string|null} href.\n */\nexport function readHref(node) {\n  return node.getAttributeNS(NAMESPACE_URI, 'href');\n}\n","/**\n * @module ol/format/xsd\n */\nimport {padNumber} from '../string.js';\nimport {getAllTextContent, getDocument} from '../xml.js';\n\n/**\n * @param {Node} node Node.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBoolean(node) {\n  const s = getAllTextContent(node, false);\n  return readBooleanString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBooleanString(string) {\n  const m = /^\\s*(true|1)|(false|0)\\s*$/.exec(string);\n  if (m) {\n    return m[1] !== undefined || false;\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} DateTime in seconds.\n */\nexport function readDateTime(node) {\n  const s = getAllTextContent(node, false);\n  const dateTime = Date.parse(s);\n  return isNaN(dateTime) ? undefined : dateTime / 1000;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimal(node) {\n  const s = getAllTextContent(node, false);\n  return readDecimalString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimalString(string) {\n  // FIXME check spec\n  const m = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)\\s*$/i.exec(string);\n  if (m) {\n    return parseFloat(m[1]);\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Non negative integer.\n */\nexport function readPositiveInteger(node) {\n  const s = getAllTextContent(node, false);\n  return readNonNegativeIntegerString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Non negative integer.\n */\nexport function readNonNegativeIntegerString(string) {\n  const m = /^\\s*(\\d+)\\s*$/.exec(string);\n  if (m) {\n    return parseInt(m[1], 10);\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {string|undefined} String.\n */\nexport function readString(node) {\n  return getAllTextContent(node, false).trim();\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the boolean to.\n * @param {boolean} bool Boolean.\n */\nexport function writeBooleanTextNode(node, bool) {\n  writeStringTextNode(node, bool ? '1' : '0');\n}\n\n/**\n * @param {Node} node Node to append a CDATA Section with the string to.\n * @param {string} string String.\n */\nexport function writeCDATASection(node, string) {\n  node.appendChild(getDocument().createCDATASection(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the dateTime to.\n * @param {number} dateTime DateTime in seconds.\n */\nexport function writeDateTimeTextNode(node, dateTime) {\n  const date = new Date(dateTime * 1000);\n  const string =\n    date.getUTCFullYear() +\n    '-' +\n    padNumber(date.getUTCMonth() + 1, 2) +\n    '-' +\n    padNumber(date.getUTCDate(), 2) +\n    'T' +\n    padNumber(date.getUTCHours(), 2) +\n    ':' +\n    padNumber(date.getUTCMinutes(), 2) +\n    ':' +\n    padNumber(date.getUTCSeconds(), 2) +\n    'Z';\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} decimal Decimal.\n */\nexport function writeDecimalTextNode(node, decimal) {\n  const string = decimal.toPrecision();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} nonNegativeInteger Non negative integer.\n */\nexport function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {\n  const string = nonNegativeInteger.toString();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\nconst whiteSpaceStart = /^\\s/;\nconst whiteSpaceEnd = /\\s$/;\nconst cdataCharacters = /(\\n|\\t|\\r|<|&| {2})/;\n\n/**\n * @param {Node} node Node to append a TextNode with the string to.\n * @param {string} string String.\n */\nexport function writeStringTextNode(node, string) {\n  if (\n    typeof string === 'string' &&\n    (whiteSpaceStart.test(string) ||\n      whiteSpaceEnd.test(string) ||\n      cdataCharacters.test(string))\n  ) {\n    string.split(']]>').forEach((part, i, a) => {\n      if (i < a.length - 1) {\n        part += ']]';\n      }\n      if (i > 0) {\n        part = '>' + part;\n      }\n      writeCDATASection(node, part);\n    });\n  } else {\n    node.appendChild(getDocument().createTextNode(string));\n  }\n}\n","/**\n * @module ol/format/OWS\n */\nimport {\n  makeObjectPropertyPusher,\n  makeObjectPropertySetter,\n  makeStructureNS,\n  pushParseAndPop,\n} from '../xml.js';\nimport XML from './XML.js';\nimport {readHref} from './xlink.js';\nimport {readString} from './xsd.js';\n\n/**\n * @const\n * @type {Array<null|string>}\n */\nconst NAMESPACE_URIS = [null, 'http://www.opengis.net/ows/1.1'];\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'ServiceIdentification': makeObjectPropertySetter(readServiceIdentification),\n  'ServiceProvider': makeObjectPropertySetter(readServiceProvider),\n  'OperationsMetadata': makeObjectPropertySetter(readOperationsMetadata),\n});\n\nclass OWS extends XML {\n  constructor() {\n    super();\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Object|null} Object\n   * @override\n   */\n  readFromNode(node) {\n    const owsObject = pushParseAndPop({}, PARSERS, node, []);\n    return owsObject ? owsObject : null;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst ADDRESS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'DeliveryPoint': makeObjectPropertySetter(readString),\n  'City': makeObjectPropertySetter(readString),\n  'AdministrativeArea': makeObjectPropertySetter(readString),\n  'PostalCode': makeObjectPropertySetter(readString),\n  'Country': makeObjectPropertySetter(readString),\n  'ElectronicMailAddress': makeObjectPropertySetter(readString),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst ALLOWED_VALUES_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Value': makeObjectPropertyPusher(readValue),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst CONSTRAINT_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'AllowedValues': makeObjectPropertySetter(readAllowedValues),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst CONTACT_INFO_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Phone': makeObjectPropertySetter(readPhone),\n  'Address': makeObjectPropertySetter(readAddress),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst DCP_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'HTTP': makeObjectPropertySetter(readHttp),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst HTTP_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Get': makeObjectPropertyPusher(readGet),\n  'Post': undefined, // TODO\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst OPERATION_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'DCP': makeObjectPropertySetter(readDcp),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst OPERATIONS_METADATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Operation': readOperation,\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PHONE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Voice': makeObjectPropertySetter(readString),\n  'Facsimile': makeObjectPropertySetter(readString),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst REQUEST_METHOD_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Constraint': makeObjectPropertyPusher(readConstraint),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst SERVICE_CONTACT_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'IndividualName': makeObjectPropertySetter(readString),\n  'PositionName': makeObjectPropertySetter(readString),\n  'ContactInfo': makeObjectPropertySetter(readContactInfo),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst SERVICE_IDENTIFICATION_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Abstract': makeObjectPropertySetter(readString),\n  'AccessConstraints': makeObjectPropertySetter(readString),\n  'Fees': makeObjectPropertySetter(readString),\n  'Title': makeObjectPropertySetter(readString),\n  'ServiceTypeVersion': makeObjectPropertySetter(readString),\n  'ServiceType': makeObjectPropertySetter(readString),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst SERVICE_PROVIDER_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'ProviderName': makeObjectPropertySetter(readString),\n  'ProviderSite': makeObjectPropertySetter(readHref),\n  'ServiceContact': makeObjectPropertySetter(readServiceContact),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The address.\n */\nfunction readAddress(node, objectStack) {\n  return pushParseAndPop({}, ADDRESS_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The values.\n */\nfunction readAllowedValues(node, objectStack) {\n  return pushParseAndPop({}, ALLOWED_VALUES_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The constraint.\n */\nfunction readConstraint(node, objectStack) {\n  const name = node.getAttribute('name');\n  if (!name) {\n    return undefined;\n  }\n  return pushParseAndPop({'name': name}, CONSTRAINT_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The contact info.\n */\nfunction readContactInfo(node, objectStack) {\n  return pushParseAndPop({}, CONTACT_INFO_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The DCP.\n */\nfunction readDcp(node, objectStack) {\n  return pushParseAndPop({}, DCP_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The GET object.\n */\nfunction readGet(node, objectStack) {\n  const href = readHref(node);\n  if (!href) {\n    return undefined;\n  }\n  return pushParseAndPop(\n    {'href': href},\n    REQUEST_METHOD_PARSERS,\n    node,\n    objectStack,\n  );\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The HTTP object.\n */\nfunction readHttp(node, objectStack) {\n  return pushParseAndPop({}, HTTP_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The operation.\n */\nfunction readOperation(node, objectStack) {\n  const name = node.getAttribute('name');\n  const value = pushParseAndPop({}, OPERATION_PARSERS, node, objectStack);\n  if (!value) {\n    return undefined;\n  }\n  const object = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  object[name] = value;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The operations metadata.\n */\nfunction readOperationsMetadata(node, objectStack) {\n  return pushParseAndPop({}, OPERATIONS_METADATA_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The phone.\n */\nfunction readPhone(node, objectStack) {\n  return pushParseAndPop({}, PHONE_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The service identification.\n */\nfunction readServiceIdentification(node, objectStack) {\n  return pushParseAndPop({}, SERVICE_IDENTIFICATION_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The service contact.\n */\nfunction readServiceContact(node, objectStack) {\n  return pushParseAndPop({}, SERVICE_CONTACT_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The service provider.\n */\nfunction readServiceProvider(node, objectStack) {\n  return pushParseAndPop({}, SERVICE_PROVIDER_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {string|undefined} The value.\n */\nfunction readValue(node, objectStack) {\n  return readString(node);\n}\n\nexport default OWS;\n","/**\n * @module ol/format/WMTSCapabilities\n */\nimport {boundingExtent} from '../extent.js';\nimport {\n  makeArrayPusher,\n  makeObjectPropertyPusher,\n  makeObjectPropertySetter,\n  makeStructureNS,\n  pushParseAndPop,\n} from '../xml.js';\nimport OWS from './OWS.js';\nimport XML from './XML.js';\nimport {readHref} from './xlink.js';\nimport {readDecimal, readPositiveInteger, readString} from './xsd.js';\n\n/**\n * @const\n * @type {Array<null|string>}\n */\nconst NAMESPACE_URIS = [null, 'http://www.opengis.net/wmts/1.0'];\n\n/**\n * @const\n * @type {Array<null|string>}\n */\nconst OWS_NAMESPACE_URIS = [null, 'http://www.opengis.net/ows/1.1'];\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Contents': makeObjectPropertySetter(readContents),\n});\n\n/**\n * @classdesc\n * Format for reading WMTS capabilities data.\n *\n * @api\n */\nclass WMTSCapabilities extends XML {\n  constructor() {\n    super();\n\n    /**\n     * @type {OWS}\n     * @private\n     */\n    this.owsParser_ = new OWS();\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Object|null} Object\n   * @override\n   */\n  readFromNode(node) {\n    let version = node.getAttribute('version');\n    if (version) {\n      version = version.trim();\n    }\n    let WMTSCapabilityObject = this.owsParser_.readFromNode(node);\n    if (!WMTSCapabilityObject) {\n      return null;\n    }\n    WMTSCapabilityObject['version'] = version;\n    WMTSCapabilityObject = pushParseAndPop(\n      WMTSCapabilityObject,\n      PARSERS,\n      node,\n      [],\n    );\n    return WMTSCapabilityObject ? WMTSCapabilityObject : null;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst CONTENTS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Layer': makeObjectPropertyPusher(readLayer),\n  'TileMatrixSet': makeObjectPropertyPusher(readTileMatrixSet),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LAYER_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'Style': makeObjectPropertyPusher(readStyle),\n    'Format': makeObjectPropertyPusher(readString),\n    'TileMatrixSetLink': makeObjectPropertyPusher(readTileMatrixSetLink),\n    'Dimension': makeObjectPropertyPusher(readDimensions),\n    'ResourceURL': makeObjectPropertyPusher(readResourceUrl),\n  },\n  makeStructureNS(OWS_NAMESPACE_URIS, {\n    'Title': makeObjectPropertySetter(readString),\n    'Abstract': makeObjectPropertySetter(readString),\n    'WGS84BoundingBox': makeObjectPropertySetter(readBoundingBox),\n    'BoundingBox': makeObjectPropertyPusher(readBoundingBoxWithCrs),\n    'Identifier': makeObjectPropertySetter(readString),\n  }),\n);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst STYLE_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'LegendURL': makeObjectPropertyPusher(readLegendUrl),\n  },\n  makeStructureNS(OWS_NAMESPACE_URIS, {\n    'Title': makeObjectPropertySetter(readString),\n    'Identifier': makeObjectPropertySetter(readString),\n  }),\n);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst TMS_LINKS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'TileMatrixSet': makeObjectPropertySetter(readString),\n  'TileMatrixSetLimits': makeObjectPropertySetter(readTileMatrixLimitsList),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst TMS_LIMITS_LIST_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'TileMatrixLimits': makeArrayPusher(readTileMatrixLimits),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst TMS_LIMITS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'TileMatrix': makeObjectPropertySetter(readString),\n  'MinTileRow': makeObjectPropertySetter(readPositiveInteger),\n  'MaxTileRow': makeObjectPropertySetter(readPositiveInteger),\n  'MinTileCol': makeObjectPropertySetter(readPositiveInteger),\n  'MaxTileCol': makeObjectPropertySetter(readPositiveInteger),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst DIMENSION_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'Default': makeObjectPropertySetter(readString),\n    'Value': makeObjectPropertyPusher(readString),\n  },\n  makeStructureNS(OWS_NAMESPACE_URIS, {\n    'Identifier': makeObjectPropertySetter(readString),\n  }),\n);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst WGS84_BBOX_READERS = makeStructureNS(OWS_NAMESPACE_URIS, {\n  'LowerCorner': makeArrayPusher(readCoordinates),\n  'UpperCorner': makeArrayPusher(readCoordinates),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst TMS_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'WellKnownScaleSet': makeObjectPropertySetter(readString),\n    'TileMatrix': makeObjectPropertyPusher(readTileMatrix),\n  },\n  makeStructureNS(OWS_NAMESPACE_URIS, {\n    'SupportedCRS': makeObjectPropertySetter(readString),\n    'Identifier': makeObjectPropertySetter(readString),\n    'BoundingBox': makeObjectPropertySetter(readBoundingBox),\n  }),\n);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst TM_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'TopLeftCorner': makeObjectPropertySetter(readCoordinates),\n    'ScaleDenominator': makeObjectPropertySetter(readDecimal),\n    'TileWidth': makeObjectPropertySetter(readPositiveInteger),\n    'TileHeight': makeObjectPropertySetter(readPositiveInteger),\n    'MatrixWidth': makeObjectPropertySetter(readPositiveInteger),\n    'MatrixHeight': makeObjectPropertySetter(readPositiveInteger),\n  },\n  makeStructureNS(OWS_NAMESPACE_URIS, {\n    'Identifier': makeObjectPropertySetter(readString),\n  }),\n);\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Attribution object.\n */\nfunction readContents(node, objectStack) {\n  return pushParseAndPop({}, CONTENTS_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Layers object.\n */\nfunction readLayer(node, objectStack) {\n  return pushParseAndPop({}, LAYER_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Tile Matrix Set object.\n */\nfunction readTileMatrixSet(node, objectStack) {\n  return pushParseAndPop({}, TMS_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Style object.\n */\nfunction readStyle(node, objectStack) {\n  const style = pushParseAndPop({}, STYLE_PARSERS, node, objectStack);\n  if (!style) {\n    return undefined;\n  }\n  const isDefault = node.getAttribute('isDefault') === 'true';\n  style['isDefault'] = isDefault;\n  return style;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Tile Matrix Set Link object.\n */\nfunction readTileMatrixSetLink(node, objectStack) {\n  return pushParseAndPop({}, TMS_LINKS_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Dimension object.\n */\nfunction readDimensions(node, objectStack) {\n  return pushParseAndPop({}, DIMENSION_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Resource URL object.\n */\nfunction readResourceUrl(node, objectStack) {\n  const format = node.getAttribute('format');\n  const template = node.getAttribute('template');\n  const resourceType = node.getAttribute('resourceType');\n  const resource = {};\n  if (format) {\n    resource['format'] = format;\n  }\n  if (template) {\n    resource['template'] = template;\n  }\n  if (resourceType) {\n    resource['resourceType'] = resourceType;\n  }\n  return resource;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} BBox object.\n */\nfunction readBoundingBox(node, objectStack) {\n  const coordinates = pushParseAndPop(\n    [],\n    WGS84_BBOX_READERS,\n    node,\n    objectStack,\n  );\n  if (coordinates.length != 2) {\n    return undefined;\n  }\n  return boundingExtent(coordinates);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} BBox object.\n */\nfunction readBoundingBoxWithCrs(node, objectStack) {\n  const crs = node.getAttribute('crs');\n  const coordinates = pushParseAndPop(\n    [],\n    WGS84_BBOX_READERS,\n    node,\n    objectStack,\n  );\n  if (coordinates.length != 2) {\n    return undefined;\n  }\n  return {extent: boundingExtent(coordinates), crs: crs};\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Legend object.\n */\nfunction readLegendUrl(node, objectStack) {\n  const legend = {};\n  legend['format'] = node.getAttribute('format');\n  legend['href'] = readHref(node);\n  return legend;\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Coordinates object.\n */\nfunction readCoordinates(node, objectStack) {\n  const coordinates = readString(node).split(/\\s+/);\n  if (!coordinates || coordinates.length != 2) {\n    return undefined;\n  }\n  const x = +coordinates[0];\n  const y = +coordinates[1];\n  if (isNaN(x) || isNaN(y)) {\n    return undefined;\n  }\n  return [x, y];\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} TileMatrix object.\n */\nfunction readTileMatrix(node, objectStack) {\n  return pushParseAndPop({}, TM_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} TileMatrixSetLimits Object.\n */\nfunction readTileMatrixLimitsList(node, objectStack) {\n  return pushParseAndPop([], TMS_LIMITS_LIST_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} TileMatrixLimits Array.\n */\nfunction readTileMatrixLimits(node, objectStack) {\n  return pushParseAndPop({}, TMS_LIMITS_PARSERS, node, objectStack);\n}\n\nexport default WMTSCapabilities;\n"],"names":["getAllTextContent","node","normalizeWhitespace","getAllTextContent_","accumulator","n","isDocument","object","parse","xml","makeArrayPusher","valueReader","thisArg","objectStack","value","makeObjectPropertyPusher","property","name","array","makeObjectPropertySetter","makeStructureNS","namespaceURIs","structure","structureNS","ii","parseNode","parsersNS","parsers","parser","pushParseAndPop","XML","source","doc","abstract","NAMESPACE_URI","readHref","readDecimal","s","readDecimalString","string","m","readPositiveInteger","readNonNegativeIntegerString","readString","NAMESPACE_URIS","PARSERS","readServiceIdentification","readServiceProvider","readOperationsMetadata","OWS","owsObject","ADDRESS_PARSERS","ALLOWED_VALUES_PARSERS","readValue","CONSTRAINT_PARSERS","readAllowedValues","CONTACT_INFO_PARSERS","readPhone","readAddress","DCP_PARSERS","readHttp","HTTP_PARSERS","readGet","OPERATION_PARSERS","readDcp","OPERATIONS_METADATA_PARSERS","readOperation","PHONE_PARSERS","REQUEST_METHOD_PARSERS","readConstraint","SERVICE_CONTACT_PARSERS","readContactInfo","SERVICE_IDENTIFICATION_PARSERS","SERVICE_PROVIDER_PARSERS","readServiceContact","href","OWS_NAMESPACE_URIS","readContents","WMTSCapabilities","version","WMTSCapabilityObject","CONTENTS_PARSERS","readLayer","readTileMatrixSet","LAYER_PARSERS","readStyle","readTileMatrixSetLink","readDimensions","readResourceUrl","readBoundingBox","readBoundingBoxWithCrs","STYLE_PARSERS","readLegendUrl","TMS_LINKS_PARSERS","readTileMatrixLimitsList","TMS_LIMITS_LIST_PARSERS","readTileMatrixLimits","TMS_LIMITS_PARSERS","DIMENSION_PARSERS","WGS84_BBOX_READERS","readCoordinates","TMS_PARSERS","readTileMatrix","TM_PARSERS","style","isDefault","format","template","resourceType","resource","coordinates","boundingExtent","crs","legend","x","y"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}