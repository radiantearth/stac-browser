{"version":3,"file":"WebGLPoints-DG3ctQTz.js","sources":["../../node_modules/ol/renderer/webgl/PointsLayer.js","../../node_modules/ol/layer/WebGLPoints.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport ViewHint from '../../ViewHint.js';\nimport {assert} from '../../asserts.js';\nimport {listen, unlistenByKey} from '../../events.js';\nimport {buffer, createEmpty, equals} from '../../extent.js';\nimport BaseVector from '../../layer/BaseVector.js';\nimport {fromUserCoordinate, getUserProjection} from '../../proj.js';\nimport {WebGLWorkerMessageType} from '../../render/webgl/constants.js';\nimport {\n  colorDecodeId,\n  colorEncodeIdAndPack,\n} from '../../render/webgl/encodeUtil.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport {AttributeType, DefaultUniform} from '../../webgl/Helper.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {getWorldParameters} from './worldUtil.js';\n\n/** @typedef {import(\"../../geom/Point.js\").default} Point */\n/** @typedef {import(\"../../Feature\").default<Point>} PointFeature */\n\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(PointFeature, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {PointFeature} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../coordinate.js\").Coordinate} flatCoordinates Point coordinates\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  In the vertex shader as an `attribute` by prefixing it with `a_`\n *  In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {boolean} [hitDetectionEnabled] Whether shader is hit detection aware.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nclass WebGLPointsLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    const projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    /**\n     * @private\n     */\n    this.sourceRevision_ = -1;\n\n    /**\n     * @private\n     */\n    this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    /**\n     * @private\n     */\n    this.instanceAttributesBuffer_ = new WebGLArrayBuffer(\n      ARRAY_BUFFER,\n      DYNAMIC_DRAW,\n    );\n    /**\n     * @private\n     */\n    this.indicesBuffer_ = new WebGLArrayBuffer(\n      ELEMENT_ARRAY_BUFFER,\n      DYNAMIC_DRAW,\n    );\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hitDetectionEnabled_ = options.hitDetectionEnabled ?? true;\n\n    const customAttributes = options.attributes\n      ? options.attributes.map(function (attribute) {\n          return {\n            name: 'a_' + attribute.name,\n            size: 1,\n            type: AttributeType.FLOAT,\n          };\n        })\n      : [];\n\n    /**\n     * A list of attributes used by the renderer.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.attributes = [\n      {\n        name: 'a_localPosition',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n    ];\n\n    /**\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.instanceAttributes = [\n      {\n        name: 'a_position',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n    ];\n\n    if (this.hitDetectionEnabled_) {\n      this.instanceAttributes.push({\n        name: 'a_hitColor',\n        size: 2,\n        type: AttributeType.FLOAT,\n      });\n      this.instanceAttributes.push({\n        name: 'a_featureUid',\n        size: 1,\n        type: AttributeType.FLOAT,\n      });\n    }\n    this.instanceAttributes.push(...customAttributes);\n\n    this.customAttributes = options.attributes ? options.attributes : [];\n\n    /**\n     * @private\n     */\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = projectionMatrixTransform;\n\n    /**\n     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.renderTransform_ = createTransform();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.invertRenderTransform_ = createTransform();\n\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n    this.renderInstructions_ = new Float32Array(0);\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    this.hitRenderTarget_;\n\n    /**\n     * Keep track of latest message sent to worker\n     * @type {number}\n     * @private\n     */\n    this.lastSentId = 0;\n\n    /**\n     * @private\n     */\n    this.worker_ = createWebGLWorker();\n\n    this.worker_.addEventListener(\n      'message',\n      /**\n       * @param {*} event Event.\n       */\n      (event) => {\n        const received = event.data;\n        if (received.type === WebGLWorkerMessageType.GENERATE_POINT_BUFFERS) {\n          const projectionTransform = received.projectionTransform;\n          this.verticesBuffer_.fromArrayBuffer(received.vertexAttributesBuffer);\n          this.instanceAttributesBuffer_.fromArrayBuffer(\n            received.instanceAttributesBuffer,\n          );\n          this.helper.flushBufferData(this.verticesBuffer_);\n          this.helper.flushBufferData(this.instanceAttributesBuffer_);\n          this.indicesBuffer_.fromArrayBuffer(received.indicesBuffer);\n          this.helper.flushBufferData(this.indicesBuffer_);\n\n          this.renderTransform_ = projectionTransform;\n          makeInverseTransform(\n            this.invertRenderTransform_,\n            this.renderTransform_,\n          );\n          this.renderInstructions_ = new Float32Array(\n            event.data.renderInstructions,\n          );\n          if (received.id === this.lastSentId) {\n            this.ready = true;\n          }\n          this.getLayer().changed();\n        }\n      },\n    );\n\n    /**\n     * This object will be updated when the source changes. Key is uid.\n     * @type {Object<string, FeatureCacheItem>}\n     * @private\n     */\n    this.featureCache_ = {};\n\n    /**\n     * Amount of features in the cache.\n     * @type {number}\n     * @private\n     */\n    this.featureCount_ = 0;\n\n    const source = /** @type {import(\"../../source/Vector.js\").default} */ (\n      this.getLayer().getSource()\n    );\n    /**\n     * @private\n     */\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this,\n      ),\n    ];\n    source.forEachFeature((feature) => {\n      const geometry = feature.getGeometry();\n      if (geometry && geometry.getType() === 'Point') {\n        this.featureCache_[getUid(feature)] = {\n          feature: /** @type {PointFeature} */ (feature),\n          properties: feature.getProperties(),\n          flatCoordinates: /** @type {Point} */ (geometry).getFlatCoordinates(),\n        };\n        this.featureCount_++;\n      }\n    });\n  }\n\n  /**\n   * @override\n   */\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(\n      this.fragmentShader_,\n      this.vertexShader_,\n    );\n\n    if (this.hitDetectionEnabled_) {\n      this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n    }\n\n    // upload buffers again if any\n    if (this.verticesBuffer_.getArray()) {\n      this.helper.flushBufferData(this.verticesBuffer_);\n    }\n    if (this.indicesBuffer_.getArray()) {\n      this.helper.flushBufferData(this.indicesBuffer_);\n    }\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    const geometry = feature.getGeometry();\n    if (geometry && geometry.getType() === 'Point') {\n      this.featureCache_[getUid(feature)] = {\n        feature: /** @type {PointFeature} */ (feature),\n        properties: feature.getProperties(),\n        flatCoordinates: /** @type {Point} */ (geometry).getFlatCoordinates(),\n      };\n      this.featureCount_++;\n    }\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    const featureUid = getUid(feature);\n    const item = this.featureCache_[featureUid];\n    const geometry = feature.getGeometry();\n    if (item) {\n      if (geometry && geometry.getType() === 'Point') {\n        item.properties = feature.getProperties();\n        item.flatCoordinates = /** @type {Point} */ (\n          geometry\n        ).getFlatCoordinates();\n      } else {\n        delete this.featureCache_[featureUid];\n        this.featureCount_--;\n      }\n    } else {\n      if (geometry && geometry.getType() === 'Point') {\n        this.featureCache_[featureUid] = {\n          feature: /** @type {PointFeature} */ (feature),\n          properties: feature.getProperties(),\n          flatCoordinates: /** @type {Point} */ (geometry).getFlatCoordinates(),\n        };\n        this.featureCount_++;\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    const featureUid = getUid(feature);\n    if (featureUid in this.featureCache_) {\n      delete this.featureCache_[featureUid];\n      this.featureCount_--;\n    }\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.featureCache_ = {};\n    this.featureCount_ = 0;\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n    const [startWorld, endWorld, worldWidth] = getWorldParameters(\n      frameState,\n      this.getLayer(),\n    );\n\n    // draw the normal canvas\n    this.renderWorlds(frameState, false, startWorld, endWorld, worldWidth);\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent,\n    );\n\n    if (this.hitDetectionEnabled_) {\n      // draw the hit buffer\n      this.renderWorlds(frameState, true, startWorld, endWorld, worldWidth);\n      this.hitRenderTarget_.clearCachedData();\n    }\n\n    this.postRender(gl, frameState);\n\n    const canvas = this.helper.getCanvas();\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n\n      this.rebuildBuffers_(frameState);\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    this.helper.useProgram(this.program_, frameState);\n    this.helper.prepareDraw(frameState);\n\n    return true;\n  }\n\n  /**\n   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  rebuildBuffers_(frameState) {\n    // saves the projection transform for the current frame state\n    const projectionTransform = createTransform();\n    this.helper.makeProjectionTransform(frameState, projectionTransform);\n\n    const userProjection = getUserProjection();\n\n    const baseInstructionLength = this.hitDetectionEnabled_ ? 5 : 2; // see below\n    const singleInstructionLength =\n      baseInstructionLength + this.customAttributes.length;\n    const totalSize = singleInstructionLength * this.featureCount_;\n    const renderInstructions =\n      this.renderInstructions_ && this.renderInstructions_.length === totalSize\n        ? this.renderInstructions_\n        : new Float32Array(totalSize);\n    this.renderInstructions_ = null;\n\n    // loop over features to fill the buffer\n    /** @type {import('../../coordinate.js').Coordinate} */\n    let tmpCoords = [];\n    /** @type {Array<number>} */\n    const tmpColor = [];\n    let idx = -1;\n    const projection = frameState.viewState.projection;\n    for (const featureUid in this.featureCache_) {\n      const featureCache = this.featureCache_[featureUid];\n      if (userProjection) {\n        tmpCoords = fromUserCoordinate(\n          featureCache.flatCoordinates,\n          projection,\n        );\n      } else {\n        tmpCoords[0] = featureCache.flatCoordinates[0];\n        tmpCoords[1] = featureCache.flatCoordinates[1];\n      }\n      applyTransform(projectionTransform, tmpCoords);\n\n      renderInstructions[++idx] = tmpCoords[0];\n      renderInstructions[++idx] = tmpCoords[1];\n\n      // for hit detection, the feature uid is saved in the opacity value\n      // and the index of the opacity value is encoded in the color values\n      if (this.hitDetectionEnabled_) {\n        const hitColor = colorEncodeIdAndPack(idx + 3, tmpColor);\n        renderInstructions[++idx] = hitColor[0];\n        renderInstructions[++idx] = hitColor[1];\n        renderInstructions[++idx] = Number(featureUid);\n      }\n\n      // pushing custom attributes\n      for (let j = 0; j < this.customAttributes.length; j++) {\n        const value = this.customAttributes[j].callback(\n          featureCache.feature,\n          featureCache.properties,\n        );\n        renderInstructions[++idx] = value;\n      }\n    }\n\n    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: ++this.lastSentId,\n      type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,\n      renderInstructions: renderInstructions.buffer,\n      customAttributesSize: singleInstructionLength - 2,\n    };\n    // additional properties will be sent back as-is by the worker\n    message['projectionTransform'] = projectionTransform;\n    this.ready = false;\n    this.worker_.postMessage(message, [renderInstructions.buffer]);\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    assert(\n      this.hitDetectionEnabled_,\n      '`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option.',\n    );\n    if (!this.renderInstructions_ || !this.hitDetectionEnabled_) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(\n      frameState.coordinateToPixelTransform,\n      coordinate.slice(),\n    );\n\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const index = colorDecodeId(color);\n    const opacity = this.renderInstructions_[index];\n    const uid = Math.floor(opacity).toString();\n\n    const source = this.getLayer().getSource();\n    const feature = source.getFeatureByUid(uid);\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n    return undefined;\n  }\n\n  /**\n   * Render the world, either to the main framebuffer or to the hit framebuffer\n   * @param {import(\"../../Map.js\").FrameState} frameState current frame state\n   * @param {boolean} forHitDetection whether the rendering is for hit detection\n   * @param {number} startWorld the world to render in the first iteration\n   * @param {number} endWorld the last world to render\n   * @param {number} worldWidth the width of the worlds being rendered\n   */\n  renderWorlds(frameState, forHitDetection, startWorld, endWorld, worldWidth) {\n    let world = startWorld;\n\n    this.helper.useProgram(this.program_, frameState);\n\n    if (forHitDetection) {\n      this.hitRenderTarget_.setSize([\n        Math.floor(frameState.size[0] / 2),\n        Math.floor(frameState.size[1] / 2),\n      ]);\n      this.helper.prepareDrawToRenderTarget(\n        frameState,\n        this.hitRenderTarget_,\n        true,\n      );\n    }\n\n    const instanceAttributesStride = this.instanceAttributes.reduce(\n      (prev, curr) => prev + (curr.size || 1),\n      0,\n    );\n    const instanceCount =\n      this.instanceAttributesBuffer_.getSize() / instanceAttributesStride;\n\n    do {\n      this.helper.bindBuffer(this.indicesBuffer_);\n      this.helper.bindBuffer(this.verticesBuffer_);\n      this.helper.enableAttributes(this.attributes);\n      this.helper.bindBuffer(this.instanceAttributesBuffer_);\n      this.helper.enableAttributesInstanced(this.instanceAttributes);\n\n      this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n      translateTransform(this.currentTransform_, world * worldWidth, 0);\n      multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n      this.helper.applyUniforms(frameState);\n      this.helper.applyHitDetectionUniform(forHitDetection);\n      const renderCount = this.indicesBuffer_.getSize();\n      this.helper.drawElementsInstanced(0, renderCount, instanceCount);\n    } while (++world < endWorld);\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n\n  renderDeclutter() {}\n}\n\nexport default WebGLPointsLayerRenderer;\n","/**\n * @module ol/layer/WebGLPoints\n */\nimport {parseLiteralStyle} from '../render/webgl/style.js';\nimport WebGLPointsLayerRenderer from '../renderer/webgl/PointsLayer.js';\nimport Layer from './Layer.js';\n\n/**\n * @template {import(\"../source/Vector.js\").default<import('../Feature').FeatureLike>} VectorSourceType\n * @typedef {Object} Options\n * @property {import('../style/flat.js').FlatStyle} style Literal style to apply to the layer features.\n * @property {import(\"../expr/expression.js\").EncodedExpression} [filter] The filter used\n * to determine if a style applies. If no filter is included, the rule always applies.\n * @property {import('../style/flat.js').StyleVariables} [variables] Style variables. Each variable must hold a literal value (not\n * an expression). These variables can be used as {@link import(\"../expr/expression.js\").ExpressionValue expressions} in the styles properties\n * using the `['var', 'varName']` operator.\n * To update style variables, use the {@link import(\"./WebGLPoints.js\").default#updateStyleVariables} method.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {VectorSourceType} [source] Point source.\n * @property {boolean} [disableHitDetection=false] Setting this to true will provide a slight performance boost, but will\n * prevent all hit detection on the layer.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Layer optimized for rendering large point datasets. Takes a `style` property which\n * is a serializable JSON object describing how the layer should be rendered.\n *\n * Here are a few samples of literal style objects:\n * ```js\n * const style = {\n *   'circle-radius': 8,\n *   'circle-fill-color': '#33AAFF',\n *   'circle-opacity': 0.9\n * }\n * ```\n *\n * ```js\n * const style = {\n *   'icon-src': '../static/exclamation-mark.png',\n *   'icon-offset': [0, 12],\n *   'icon-width': 4,\n *   'icon-height': 8\n * }\n * ```\n *\n * **Important: a `WebGLPoints` layer must be manually disposed when removed, otherwise the underlying WebGL context\n * will not be garbage collected.**\n *\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Vector.js\").default<import('../Feature').FeatureLike>} VectorSourceType\n * @extends {Layer<VectorSourceType, WebGLPointsLayerRenderer>}\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\n * @deprecated Use ol/layer/WebGLVector instead\n */\nclass WebGLPointsLayer extends Layer {\n  /**\n   * @param {Options<VectorSourceType>} options Options.\n   */\n  constructor(options) {\n    const baseOptions = Object.assign({}, options);\n\n    super(baseOptions);\n\n    /**\n     * @type {import('../style/flat.js').StyleVariables}\n     * @private\n     */\n    this.styleVariables_ = options.variables || {};\n\n    /**\n     * @private\n     * @type {import('../render/webgl/style.js').StyleParseResult}\n     */\n    this.parseResult_ = parseLiteralStyle(\n      options.style,\n      this.styleVariables_,\n      options.filter,\n    );\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hitDetectionDisabled_ = !!options.disableHitDetection;\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    const attributes = Object.keys(this.parseResult_.attributes).map(\n      (name) => ({\n        name,\n        ...this.parseResult_.attributes[name],\n      }),\n    );\n    return new WebGLPointsLayerRenderer(this, {\n      vertexShader: this.parseResult_.builder.getSymbolVertexShader(),\n      fragmentShader: this.parseResult_.builder.getSymbolFragmentShader(),\n      hitDetectionEnabled: !this.hitDetectionDisabled_,\n      uniforms: this.parseResult_.uniforms,\n      attributes:\n        /** @type {Array<import('../renderer/webgl/PointsLayer.js').CustomAttribute>} */ (\n          attributes\n        ),\n    });\n  }\n\n  /**\n   * Update any variables used by the layer style and trigger a re-render.\n   * @param {Object<string, number>} variables Variables to update.\n   */\n  updateStyleVariables(variables) {\n    Object.assign(this.styleVariables_, variables);\n    this.changed();\n  }\n}\n\nexport default WebGLPointsLayer;\n"],"names":["WebGLPointsLayerRenderer","WebGLLayerRenderer","layer","options","uniforms","projectionMatrixTransform","createTransform","DefaultUniform","WebGLArrayBuffer","ARRAY_BUFFER","DYNAMIC_DRAW","ELEMENT_ARRAY_BUFFER","customAttributes","attribute","AttributeType","createEmpty","createWebGLWorker","event","received","WebGLWorkerMessageType","projectionTransform","makeInverseTransform","source","listen","VectorEventType","feature","geometry","getUid","WebGLRenderTarget","featureUid","item","frameState","gl","startWorld","endWorld","worldWidth","getWorldParameters","vectorSource","viewState","viewNotMoving","ViewHint","extentChanged","equals","sourceChanged","projection","resolution","renderBuffer","BaseVector","extent","buffer","singleInstructionLength","totalSize","renderInstructions","tmpCoords","tmpColor","idx","featureCache","applyTransform","hitColor","colorEncodeIdAndPack","j","value","message","coordinate","hitTolerance","callback","matches","assert","pixel","data","color","index","colorDecodeId","opacity","uid","forHitDetection","world","instanceAttributesStride","prev","curr","instanceCount","translateTransform","multiplyTransform","renderCount","key","unlistenByKey","WebGLPointsLayer","Layer","baseOptions","parseLiteralStyle","attributes","name","variables"],"mappings":"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","x_google_ignoreList":[0,1]}