{"version":3,"file":"VectorTile-DXttuOY-.js","sources":["../../node_modules/ol/VectorRenderTile.js","../../node_modules/ol/VectorTile.js","../../node_modules/ol/source/VectorTile.js"],"sourcesContent":["/**\n * @module ol/VectorRenderTile\n */\nimport Tile from './Tile.js';\nimport {createCanvasContext2D, releaseCanvas} from './dom.js';\nimport {getUid} from './util.js';\n\n/**\n * @typedef {Object} ReplayState\n * @property {boolean} dirty Dirty.\n * @property {null|import(\"./render.js\").OrderFunction} renderedRenderOrder RenderedRenderOrder.\n * @property {number} renderedTileRevision RenderedTileRevision.\n * @property {number} renderedResolution RenderedResolution.\n * @property {number} renderedRevision RenderedRevision.\n * @property {number} renderedTileResolution RenderedTileResolution.\n * @property {number} renderedTileZ RenderedTileZ.\n */\n\n/**\n * @type {Array<HTMLCanvasElement|OffscreenCanvas>}\n */\nconst canvasPool = [];\n\nclass VectorRenderTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {import(\"./tilecoord.js\").TileCoord} urlTileCoord Wrapped tile coordinate for source urls.\n   * @param {function(VectorRenderTile):Array<import(\"./VectorTile\").default>} getSourceTiles Function.\n   * @param {function(VectorRenderTile):void} removeSourceTiles Function.\n   */\n  constructor(\n    tileCoord,\n    state,\n    urlTileCoord,\n    getSourceTiles,\n    removeSourceTiles,\n  ) {\n    super(tileCoord, state, {transition: 0});\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D|null}\n     */\n    this.context_ = null;\n\n    /**\n     * Executor groups. Read/written by the renderer.\n     * @type {Object<string, Array<import(\"./render/canvas/ExecutorGroup.js\").default>>}\n     */\n    this.executorGroups = {};\n\n    /**\n     * Number of loading source tiles. Read/written by the source.\n     * @type {number}\n     */\n    this.loadingSourceTiles = 0;\n\n    /**\n     * @type {Object<string, ImageData>}\n     */\n    this.hitDetectionImageData = {};\n\n    /**\n     * @private\n     * @type {!Object<string, ReplayState>}\n     */\n    this.replayState_ = {};\n\n    /**\n     * @type {Array<import(\"./VectorTile.js\").default>}\n     */\n    this.sourceTiles = [];\n\n    /**\n     * @type {Object<string, boolean>}\n     */\n    this.errorTileKeys = {};\n\n    /**\n     * @type {number}\n     */\n    this.wantedResolution;\n\n    /**\n     * @type {!function():Array<import(\"./VectorTile.js\").default>}\n     */\n    this.getSourceTiles = getSourceTiles.bind(undefined, this);\n\n    /**\n     * @type {!function(VectorRenderTile):void}\n     * @private\n     */\n    this.removeSourceTiles_ = removeSourceTiles;\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord = urlTileCoord;\n  }\n\n  /**\n   * @return {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} The rendering context.\n   */\n  getContext() {\n    if (!this.context_) {\n      this.context_ = createCanvasContext2D(1, 1, canvasPool);\n    }\n    return this.context_;\n  }\n\n  /**\n   * @return {boolean} Tile has a rendering context.\n   */\n  hasContext() {\n    return !!this.context_;\n  }\n\n  /**\n   * Get the Canvas for this tile.\n   * @return {HTMLCanvasElement|OffscreenCanvas} Canvas.\n   */\n  getImage() {\n    return this.hasContext() ? this.getContext().canvas : null;\n  }\n\n  /**\n   * @param {import(\"./layer/Layer.js\").default} layer Layer.\n   * @return {ReplayState} The replay state.\n   */\n  getReplayState(layer) {\n    const key = getUid(layer);\n    if (!(key in this.replayState_)) {\n      this.replayState_[key] = {\n        dirty: false,\n        renderedRenderOrder: null,\n        renderedResolution: NaN,\n        renderedRevision: -1,\n        renderedTileResolution: NaN,\n        renderedTileRevision: -1,\n        renderedTileZ: -1,\n      };\n    }\n    return this.replayState_[key];\n  }\n\n  /**\n   * Load the tile.\n   * @override\n   */\n  load() {\n    this.getSourceTiles();\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   * @override\n   */\n  release() {\n    if (this.context_) {\n      releaseCanvas(this.context_);\n      canvasPool.push(this.context_.canvas);\n      this.context_ = null;\n    }\n    this.removeSourceTiles_(this);\n    this.sourceTiles.length = 0;\n    super.release();\n  }\n}\n\nexport default VectorRenderTile;\n","/**\n * @module ol/VectorTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\n\n/**\n * @template {import('./Feature.js').FeatureLike} FeatureType\n */\nclass VectorTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Data source url.\n   * @param {import(\"./format/Feature.js\").default<FeatureType>} format Feature format.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, src, format, tileLoadFunction, options) {\n    super(tileCoord, state, options);\n\n    /**\n     * Extent of this tile; set by the source.\n     * @type {import(\"./extent.js\").Extent}\n     */\n    this.extent = null;\n\n    /**\n     * @private\n     * @type {import(\"./format/Feature.js\").default<FeatureType>}\n     */\n    this.format_ = format;\n\n    /**\n     * @private\n     * @type {Array<FeatureType>}\n     */\n    this.features_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./featureloader.js\").FeatureLoader}\n     */\n    this.loader_;\n\n    /**\n     * Feature projection of this tile; set by the source.\n     * @type {import(\"./proj/Projection.js\").default}\n     */\n    this.projection = null;\n\n    /**\n     * Resolution of this tile; set by the source.\n     * @type {number}\n     */\n    this.resolution;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.url_ = src;\n\n    this.key = src;\n  }\n\n  /**\n   * @return {string} Tile url.\n   */\n  getTileUrl() {\n    return this.url_;\n  }\n\n  /**\n   * Get the feature format assigned for reading this tile's features.\n   * @return {import(\"./format/Feature.js\").default<FeatureType>} Feature format.\n   * @api\n   */\n  getFormat() {\n    return this.format_;\n  }\n\n  /**\n   * Get the features for this tile. Geometries will be in the view projection.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   */\n  getFeatures() {\n    return this.features_;\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.setState(TileState.LOADING);\n      this.tileLoadFunction_(this, this.url_);\n      if (this.loader_) {\n        this.loader_(this.extent, this.resolution, this.projection);\n      }\n    }\n  }\n\n  /**\n   * Handler for successful tile load.\n   * @param {Array<FeatureType>} features The loaded features.\n   * @param {import(\"./proj/Projection.js\").default} dataProjection Data projection.\n   */\n  onLoad(features, dataProjection) {\n    this.setFeatures(features);\n  }\n\n  /**\n   * Handler for tile load errors.\n   */\n  onError() {\n    this.setState(TileState.ERROR);\n  }\n\n  /**\n   * Function for use in a {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.\n   * Sets the features for the tile.\n   * @param {Array<FeatureType>} features Features.\n   * @api\n   */\n  setFeatures(features) {\n    this.features_ = features;\n    this.setState(TileState.LOADED);\n  }\n\n  /**\n   * Set the feature loader for reading this tile's features.\n   * @param {import(\"./featureloader.js\").FeatureLoader<FeatureType>} loader Feature loader.\n   * @api\n   */\n  setLoader(loader) {\n    this.loader_ = loader;\n  }\n}\n\nexport default VectorTile;\n","/**\n * @module ol/source/VectorTile\n */\n\nimport TileState from '../TileState.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport Tile from '../VectorTile.js';\nimport EventType from '../events/EventType.js';\nimport {\n  buffer as bufferExtent,\n  getIntersection,\n  intersects,\n} from '../extent.js';\nimport {loadFeaturesXhr} from '../featureloader.js';\nimport {isEmpty} from '../obj.js';\nimport {equivalent, transformExtent} from '../proj.js';\nimport {toSize} from '../size.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport {DEFAULT_MAX_ZOOM} from '../tilegrid/common.js';\nimport {\n  createXYZ,\n  extentFromProjection,\n  getForProjection,\n} from '../tilegrid.js';\nimport UrlTile from './UrlTile.js';\n\n/**\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {import(\"../format/Feature.js\").default<FeatureType>} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile source.\n * @property {import(\"./Source.js\").State} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate tiles.\n * Default is {@link module:ol/VectorTile~VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=1]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTileLayer}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector~VectorSource} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n */\nclass VectorTile extends UrlTile {\n  /**\n   * @param {!Options<FeatureType>} options Vector tile options.\n   */\n  constructor(options) {\n    const projection = options.projection || 'EPSG:3857';\n\n    const extent = options.extent || extentFromProjection(projection);\n\n    const tileGrid =\n      options.tileGrid ||\n      createXYZ({\n        extent: extent,\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize || 512,\n      });\n\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      interpolate: true,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction\n        ? options.tileLoadFunction\n        : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition,\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default<FeatureType>|null}\n     */\n    this.format_ = options.format ? options.format : null;\n\n    /**\n     * @type {Object<string, Array<string>>}\n     * @private\n     */\n    this.tileKeysBySourceTileUrl_ = {};\n\n    /**\n     @type {Object<string, Tile<FeatureType>>}\n     */\n    this.sourceTiles_ = {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n    this.tileClass = options.tileClass ? options.tileClass : Tile;\n\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGrids_ = {};\n  }\n\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  getOverlaps() {\n    return this.overlaps_;\n  }\n\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection\").default} projection Projection.\n   * @param {VectorRenderTile} tile Vector render tile.\n   * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n   */\n  getSourceTiles(pixelRatio, projection, tile) {\n    if (tile.getState() === TileState.IDLE) {\n      tile.setState(TileState.LOADING);\n      const urlTileCoord = tile.wrappedTileCoord;\n      const tileGrid = this.getTileGridForProjection(projection);\n      let extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      const z = urlTileCoord[0];\n      const resolution = tileGrid.getResolution(z);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      bufferExtent(extent, -resolution, extent);\n      const sourceProjection = this.projection;\n      if (\n        projection &&\n        this.projection &&\n        !equivalent(projection, sourceProjection)\n      ) {\n        extent = transformExtent(extent, projection, sourceProjection);\n      }\n      const sourceTileGrid = this.tileGrid;\n      const sourceExtent = sourceTileGrid.getExtent();\n      if (sourceExtent) {\n        getIntersection(extent, sourceExtent, extent);\n      }\n      let sourceResolution = resolution;\n      if (\n        projection &&\n        sourceProjection &&\n        !equivalent(projection, sourceProjection)\n      ) {\n        sourceResolution =\n          resolution /\n          sourceProjection.getMetersPerUnit() /\n          projection.getMetersPerUnit();\n      }\n      const sourceZ = sourceTileGrid.getZForResolution(\n        sourceResolution,\n        this.zDirection,\n      );\n\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, (sourceTileCoord) => {\n        const tileUrl = this.tileUrlFunction(\n          sourceTileCoord,\n          pixelRatio,\n          projection,\n        );\n        if (!this.sourceTiles_[tileUrl]) {\n          this.sourceTiles_[tileUrl] = new this.tileClass(\n            sourceTileCoord,\n            tileUrl ? TileState.IDLE : TileState.EMPTY,\n            tileUrl,\n            this.format_,\n            this.tileLoadFunction,\n          );\n        }\n        const sourceTile = this.sourceTiles_[tileUrl];\n        tile.sourceTiles.push(sourceTile);\n        if (!this.tileKeysBySourceTileUrl_[tileUrl]) {\n          this.tileKeysBySourceTileUrl_[tileUrl] = [];\n        }\n        this.tileKeysBySourceTileUrl_[tileUrl].push(tile.getKey());\n        const sourceTileState = sourceTile.getState();\n        if (sourceTileState < TileState.LOADED) {\n          const listenChange = (event) => {\n            this.handleTileChange(event);\n            const state = sourceTile.getState();\n            if (state === TileState.LOADED || state === TileState.ERROR) {\n              const sourceTileKey = sourceTile.getKey();\n              if (sourceTileKey in tile.errorTileKeys) {\n                if (sourceTile.getState() === TileState.LOADED) {\n                  delete tile.errorTileKeys[sourceTileKey];\n                }\n              } else {\n                tile.loadingSourceTiles--;\n              }\n              if (state === TileState.ERROR) {\n                tile.errorTileKeys[sourceTileKey] = true;\n              } else {\n                sourceTile.removeEventListener(EventType.CHANGE, listenChange);\n              }\n              if (tile.loadingSourceTiles === 0) {\n                tile.setState(\n                  isEmpty(tile.errorTileKeys)\n                    ? TileState.LOADED\n                    : TileState.ERROR,\n                );\n              }\n            }\n          };\n          sourceTile.addEventListener(EventType.CHANGE, listenChange);\n          tile.loadingSourceTiles++;\n        }\n        if (sourceTileState === TileState.IDLE) {\n          sourceTile.extent =\n            sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n          sourceTile.projection = this.projection;\n          sourceTile.resolution = sourceTileGrid.getResolution(\n            sourceTileCoord[0],\n          );\n          sourceTile.load();\n        }\n      });\n      if (!tile.loadingSourceTiles) {\n        tile.setState(\n          tile.sourceTiles.some(\n            (sourceTile) => sourceTile.getState() === TileState.ERROR,\n          )\n            ? TileState.ERROR\n            : TileState.LOADED,\n        );\n      }\n    }\n\n    return tile.sourceTiles;\n  }\n\n  /**\n   * @param {VectorRenderTile} tile Vector render tile.\n   */\n  removeSourceTiles(tile) {\n    const tileKey = tile.getKey();\n    const sourceTiles = tile.sourceTiles;\n    for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n      const sourceTileUrl = sourceTiles[i].getTileUrl();\n      if (!this.tileKeysBySourceTileUrl_[sourceTileUrl]) {\n        return;\n      }\n      const index =\n        this.tileKeysBySourceTileUrl_[sourceTileUrl].indexOf(tileKey);\n      if (index === -1) {\n        continue;\n      }\n      this.tileKeysBySourceTileUrl_[sourceTileUrl].splice(index, 1);\n      if (this.tileKeysBySourceTileUrl_[sourceTileUrl].length === 0) {\n        delete this.tileKeysBySourceTileUrl_[sourceTileUrl];\n        delete this.sourceTiles_[sourceTileUrl];\n      }\n    }\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!VectorRenderTile} Tile.\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tileCoord = [z, x, y];\n    let urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection,\n    );\n    const sourceExtent = this.getTileGrid().getExtent();\n    const sourceProjection = this.projection;\n    const tileGrid = this.getTileGridForProjection(projection);\n    if (urlTileCoord && sourceExtent) {\n      const tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n      if (\n        !intersects(\n          sourceExtent,\n          !projection ||\n            !sourceProjection ||\n            equivalent(projection, sourceProjection)\n            ? tileExtent\n            : transformExtent(tileExtent, projection, sourceProjection),\n        )\n      ) {\n        urlTileCoord = null;\n      }\n    }\n    let empty = true;\n    if (urlTileCoord !== null) {\n      const sourceTileGrid = this.tileGrid;\n      const resolution = tileGrid.getResolution(z);\n      let sourceResolution = resolution;\n      if (\n        projection &&\n        sourceProjection &&\n        !equivalent(projection, sourceProjection)\n      ) {\n        sourceResolution =\n          resolution /\n          sourceProjection.getMetersPerUnit() /\n          projection.getMetersPerUnit();\n      }\n      const sourceZ = sourceTileGrid.getZForResolution(sourceResolution, 1);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      bufferExtent(extent, -resolution, extent);\n      sourceTileGrid.forEachTileCoord(\n        !projection ||\n          !sourceProjection ||\n          equivalent(projection, sourceProjection)\n          ? extent\n          : transformExtent(extent, projection, sourceProjection),\n        sourceZ,\n        (sourceTileCoord) => {\n          empty =\n            empty &&\n            !this.tileUrlFunction(\n              sourceTileCoord,\n              pixelRatio,\n              sourceProjection,\n            );\n        },\n      );\n    }\n    const newTile = new VectorRenderTile(\n      tileCoord,\n      empty ? TileState.EMPTY : TileState.IDLE,\n      urlTileCoord,\n      this.getSourceTiles.bind(this, pixelRatio, projection),\n      this.removeSourceTiles.bind(this),\n    );\n    newTile.key = this.getKey();\n    return newTile;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @override\n   */\n  getTileGridForProjection(projection) {\n    const code = projection.getCode();\n    let tileGrid = this.tileGrids_[code];\n    if (!tileGrid) {\n      const sourceProjection = this.projection;\n      if (\n        sourceProjection !== null &&\n        !equivalent(sourceProjection, projection)\n      ) {\n        return getForProjection(projection);\n      }\n\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      const sourceTileGrid = this.tileGrid;\n      const resolutions = sourceTileGrid.getResolutions().slice();\n      const origins = resolutions.map(function (resolution, z) {\n        return sourceTileGrid.getOrigin(z);\n      });\n      const tileSizes = resolutions.map(function (resolution, z) {\n        return sourceTileGrid.getTileSize(z);\n      });\n      const length = DEFAULT_MAX_ZOOM + 1;\n      for (let z = resolutions.length; z < length; ++z) {\n        resolutions.push(resolutions[z - 1] / 2);\n        origins.push(origins[z - 1]);\n        tileSizes.push(tileSizes[z - 1]);\n      }\n      tileGrid = new TileGrid({\n        extent: sourceTileGrid.getExtent(),\n        origins: origins,\n        resolutions: resolutions,\n        tileSizes: tileSizes,\n      });\n      this.tileGrids_[code] = tileGrid;\n    }\n    return tileGrid;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   * @override\n   */\n  getTilePixelRatio(pixelRatio) {\n    return pixelRatio;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   * @override\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    return [\n      Math.round(tileSize[0] * pixelRatio),\n      Math.round(tileSize[1] * pixelRatio),\n    ];\n  }\n\n  /**\n   * @param {boolean} overlaps The source has overlapping geometries.\n   */\n  setOverlaps(overlaps) {\n    this.overlaps_ = overlaps;\n    this.changed();\n  }\n}\n\nexport default VectorTile;\n\n/**\n * Sets the loader for a tile.\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n * @param {import(\"../VectorTile.js\").default<FeatureType>} tile Vector tile.\n * @param {string} url URL.\n */\nexport function defaultLoadFunction(tile, url) {\n  tile.setLoader(\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    function (extent, resolution, projection) {\n      loadFeaturesXhr(\n        url,\n        tile.getFormat(),\n        extent,\n        resolution,\n        projection,\n        tile.onLoad.bind(tile),\n        tile.onError.bind(tile),\n      );\n    },\n  );\n}\n"],"names":["canvasPool","VectorRenderTile","Tile","tileCoord","state","urlTileCoord","getSourceTiles","removeSourceTiles","createCanvasContext2D","layer","key","getUid","releaseCanvas","src","format","tileLoadFunction","options","TileState","features","dataProjection","loader","VectorTile","UrlTile","projection","extent","extentFromProjection","tileGrid","createXYZ","defaultLoadFunction","pixelRatio","tile","z","resolution","bufferExtent","sourceProjection","equivalent","transformExtent","sourceTileGrid","sourceExtent","getIntersection","sourceResolution","sourceZ","sourceTileCoord","tileUrl","sourceTile","sourceTileState","listenChange","event","sourceTileKey","EventType","isEmpty","tileKey","sourceTiles","i","ii","sourceTileUrl","index","x","y","tileExtent","intersects","empty","newTile","code","getForProjection","resolutions","origins","tileSizes","length","DEFAULT_MAX_ZOOM","TileGrid","tileSize","toSize","overlaps","url","loadFeaturesXhr"],"mappings":"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","x_google_ignoreList":[0,1,2]}