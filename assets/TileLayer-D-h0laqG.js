import{D as ce,a as le}from"./DataTile-uej8eNh4.js";import{I as ye,R as Ce}from"./Tile-BrHfHitc.js";import{T as Re}from"./TileRange-2Tc-Ry00.js";import{ax as me,ao as _e,W as ve,A as ae,aA as Se,f as L,a4 as we,g as z,aF as Ee,ay as H,v as J,aD as Ke,a9 as je,a3 as Pe,_ as Le,Y as Fe}from"./GeoJSON-BlyzYhKz.js";import{L as de}from"./LRUCache-CwUIRQIv.js";import{c as he,g as N}from"./tilecoord-DYaQ6NdW.js";function V(R,e,t){if(!(t in R))return R[t]=new Set([e]),!0;const i=R[t],o=i.has(e);return o||i.add(e),!o}function Ae(R,e,t){const i=R[t];return i?i.delete(e):!1}function ue(R,e){const t=R.layerStatesArray[R.layerIndex];t.extent&&(e=J(e,H(t.extent,R.viewState.projection)));const i=t.layer.getRenderSource();if(!i.getWrapX()){const o=i.getTileGridForProjection(R.viewState.projection).getExtent();o&&(e=J(e,o))}return e}class ke extends me{constructor(e,t){super(e),t=t||{},this.extentChanged=!0,this.renderComplete=!1,this.renderedExtent_=null,this.renderedPixelRatio,this.renderedProjection=null,this.renderedTiles=[],this.renderedSourceKey_,this.renderedSourceRevision_,this.tempExtent=_e(),this.tempTileRange_=new Re(0,0,0,0),this.tempTileCoord_=he(0,0,0);const i=t.cacheSize!==void 0?t.cacheSize:512;this.tileCache_=new de(i),this.sourceTileCache_=null,this.maxStaleKeys=i*.5}getTileCache(){return this.tileCache_}getSourceTileCache(){return this.sourceTileCache_||(this.sourceTileCache_=new de(512)),this.sourceTileCache_}getOrCreateTile(e,t,i,o){const a=this.tileCache_,r=this.getLayer().getSource(),c=N(r,r.getKey(),e,t,i);let s;if(a.containsKey(c))s=a.get(c);else{const n=o.viewState.projection,l=r.getProjection();if(s=r.getTile(e,t,i,o.pixelRatio,n,!l||ve(l,n)?void 0:this.getSourceTileCache()),!s)return null;a.set(c,s)}return s}getTile(e,t,i,o){const a=this.getOrCreateTile(e,t,i,o);return a||null}getData(e){const t=this.frameState;if(!t)return null;const i=this.getLayer(),o=ae(t.pixelToCoordinateTransform,e.slice()),a=i.getExtent();if(a&&!Se(a,o))return null;const u=t.viewState,r=i.getRenderSource(),c=r.getTileGridForProjection(u.projection),s=r.getTilePixelRatio(t.pixelRatio);for(let n=c.getZForResolution(u.resolution);n>=c.getMinZoom();--n){const l=c.getTileCoordForCoordAndZ(o,n),d=this.getTile(n,l[1],l[2],t);if(!d||d.getState()!==L.LOADED)continue;const g=c.getOrigin(n),T=we(c.getTileSize(n)),S=c.getResolution(n);let h;if(d instanceof ye||d instanceof Ce)h=d.getImage();else if(d instanceof ce){if(h=le(d.getData()),!h)continue}else continue;const _=Math.floor(s*((o[0]-g[0])/S-l[1]*T[0])),F=Math.floor(s*((g[1]-o[1])/S-l[2]*T[1])),m=Math.round(s*r.getGutterForProjection(u.projection));return this.getImageData(h,_+m,F+m)}return null}prepareFrame(e){this.renderedProjection?e.viewState.projection!==this.renderedProjection&&(this.tileCache_.clear(),this.renderedProjection=e.viewState.projection):this.renderedProjection=e.viewState.projection;const t=this.getLayer().getSource();if(!t)return!1;const i=t.getRevision();return this.renderedSourceRevision_?this.renderedSourceRevision_!==i&&(this.renderedSourceRevision_=i,this.renderedSourceKey_===t.getKey()&&(this.tileCache_.clear(),this.sourceTileCache_?.clear())):this.renderedSourceRevision_=i,!0}enqueueTilesForNextExtent(){return!0}enqueueTiles(e,t,i,o,a){const u=e.viewState,r=this.getLayer(),c=r.getRenderSource(),s=c.getTileGridForProjection(u.projection),n=z(c);n in e.wantedTiles||(e.wantedTiles[n]={});const l=e.wantedTiles[n],d=r.getMapInternal(),g=Math.max(i-a,s.getMinZoom(),s.getZForResolution(Math.min(r.getMaxResolution(),d?d.getView().getResolutionForZoom(Math.max(r.getMinZoom(),0)):s.getResolution(0)),c.zDirection)),T=u.rotation,S=T?Ee(u.center,u.resolution,T,e.size):void 0;for(let h=i;h>=g;--h){const _=s.getTileRangeForExtentAndZ(t,h,this.tempTileRange_),F=s.getResolution(h);for(let m=_.minX;m<=_.maxX;++m)for(let w=_.minY;w<=_.maxY;++w){if(T&&!s.tileCoordIntersectsViewport([h,m,w],S))continue;const E=this.getTile(h,m,w,e);if(!E||!V(o,E,h))continue;const x=E.getKey();if(l[x]=!0,E.getState()===L.IDLE&&!e.tileQueue.isKeyQueued(x)){const Z=he(h,m,w,this.tempTileCoord_);e.tileQueue.enqueue([E,n,s.getTileCoordCenter(Z),F])}}}}findStaleTile_(e,t){const i=this.tileCache_,o=e[0],a=e[1],u=e[2],r=this.getStaleKeys();for(let c=0;c<r.length;++c){const s=N(this.getLayer().getSource(),r[c],o,a,u);if(i.containsKey(s)){const n=i.peek(s);if(n.getState()===L.LOADED)return n.endTransition(z(this)),V(t,n,o),!0}}return!1}findAltTiles_(e,t,i,o){const a=e.getTileRangeForTileCoordAndZ(t,i,this.tempTileRange_);if(!a)return!1;let u=!0;const r=this.tileCache_,c=this.getLayer().getRenderSource(),s=c.getKey();for(let n=a.minX;n<=a.maxX;++n)for(let l=a.minY;l<=a.maxY;++l){const d=N(c,s,i,n,l);let g=!1;if(r.containsKey(d)){const T=r.peek(d);T.getState()===L.LOADED&&(V(o,T,i),g=!0)}g||(u=!1)}return u}renderFrame(e,t){this.renderComplete=!0;const i=e.layerStatesArray[e.layerIndex],o=e.viewState,a=o.projection,u=o.resolution,r=o.center,c=e.pixelRatio,s=this.getLayer(),n=s.getSource(),l=n.getTileGridForProjection(a),d=l.getZForResolution(u,n.zDirection),g=l.getResolution(d),T=n.getKey();this.renderedSourceKey_?this.renderedSourceKey_!==T&&(this.prependStaleKey(this.renderedSourceKey_),this.renderedSourceKey_=T):this.renderedSourceKey_=T;let S=e.extent;const h=n.getTilePixelRatio(c);this.prepareContainer(e,t);const _=this.context.canvas.width,F=this.context.canvas.height,m=i.extent&&H(i.extent);m&&(S=J(S,H(i.extent)));const w=g*_/2/h,E=g*F/2/h,D=[r[0]-w,r[1]-E,r[0]+w,r[1]+E],x={};this.renderedTiles.length=0;const Z=s.getPreload();if(e.nextExtent&&this.enqueueTilesForNextExtent()){const f=l.getZForResolution(o.nextResolution,n.zDirection),y=ue(e,e.nextExtent);this.enqueueTiles(e,y,f,x,Z)}const $=ue(e,S);if(this.enqueueTiles(e,$,d,x,0),Z>0&&setTimeout(()=>{this.enqueueTiles(e,$,d-1,x,Z-1)},0),!(d in x))return this.container;const ee=z(this),ge=e.time;for(const f of x[d]){const y=f.getState();if(y===L.EMPTY)continue;const K=f.tileCoord;if(y===L.LOADED&&f.getAlpha(ee,ge)===1){f.endTransition(ee);continue}if(y!==L.ERROR&&(this.renderComplete=!1),this.findStaleTile_(K,x)){Ae(x,f,d),e.animate=!0;continue}if(this.findAltTiles_(l,K,d+1,x))continue;const M=l.getMinZoom();for(let A=d-1;A>=M&&!this.findAltTiles_(l,K,A,x);--A);}const k=g/u*c/h,p=this.getRenderContext(e);Ke(this.tempTransform,_/2,F/2,k,k,0,-_/2,-F/2),i.extent&&this.clipUnrotated(p,e,m),n.getInterpolate()||(p.imageSmoothingEnabled=!1),this.preRender(p,e);const G=Object.keys(x).map(Number);G.sort(je);let v;const Q=[],te=[];for(let f=G.length-1;f>=0;--f){const y=G[f],K=n.getTilePixelSize(y,c,a),I=l.getResolution(y)/g,M=K[0]*I*k,A=K[1]*I*k,b=l.getTileCoordForCoordAndZ(Pe(D),y),ie=l.getTileCoordExtent(b),q=ae(this.tempTransform,[h*(ie[0]-D[0])/g,h*(D[3]-ie[3])/g]),pe=h*n.getGutterForProjection(a);for(const O of x[y]){if(O.getState()!==L.LOADED)continue;const ne=O.tileCoord,oe=b[1]-ne[1],Te=Math.round(q[0]-(oe-1)*M),se=b[2]-ne[2],xe=Math.round(q[1]-(se-1)*A),j=Math.round(q[0]-oe*M),P=Math.round(q[1]-se*A),U=Te-j,Y=xe-P,re=G.length===1;let B=!1;v=[j,P,j+U,P,j+U,P+Y,j,P+Y];for(let X=0,fe=Q.length;X<fe;++X)if(!re&&y<te[X]){const C=Q[X];Le([j,P,j+U,P+Y],[C[0],C[3],C[4],C[7]])&&(B||(p.save(),B=!0),p.beginPath(),p.moveTo(v[0],v[1]),p.lineTo(v[2],v[3]),p.lineTo(v[4],v[5]),p.lineTo(v[6],v[7]),p.moveTo(C[6],C[7]),p.lineTo(C[4],C[5]),p.lineTo(C[2],C[3]),p.lineTo(C[0],C[1]),p.clip())}Q.push(v),te.push(y),this.drawTile(O,e,j,P,U,Y,pe,re),B&&p.restore(),this.renderedTiles.unshift(O),this.updateUsedTiles(e.usedTiles,n,O)}}if(this.renderedResolution=g,this.extentChanged=!this.renderedExtent_||!Fe(this.renderedExtent_,D),this.renderedExtent_=D,this.renderedPixelRatio=c,this.postRender(this.context,e),i.extent&&p.restore(),p.imageSmoothingEnabled=!0,this.renderComplete){const f=(y,K)=>{const W=z(n),I=K.wantedTiles[W],M=I?Object.keys(I).length:0;this.updateCacheSize(M),this.tileCache_.expireCache(),this.sourceTileCache_?.expireCache()};e.postRenderFunctions.push(f)}return this.container}updateCacheSize(e){this.tileCache_.highWaterMark=Math.max(this.tileCache_.highWaterMark,e*2)}drawTile(e,t,i,o,a,u,r,c){let s;if(e instanceof ce){if(s=le(e.getData()),!s)throw new Error("Rendering array data is not yet supported")}else s=this.getTileImage(e);if(!s)return;const n=this.getRenderContext(t),l=z(this),d=t.layerStatesArray[t.layerIndex],g=d.opacity*(c?e.getAlpha(l,t.time):1),T=g!==n.globalAlpha;T&&(n.save(),n.globalAlpha=g),n.drawImage(s,r,r,s.width-2*r,s.height-2*r,i,o,a,u),T&&n.restore(),g!==d.opacity?t.animate=!0:c&&e.endTransition(l)}getImage(){const e=this.context;return e?e.canvas:null}getTileImage(e){return e.getImage()}updateUsedTiles(e,t,i){const o=z(t);o in e||(e[o]={}),e[o][i.getKey()]=!0}}export{ke as C};
//# sourceMappingURL=TileLayer-D-h0laqG.js.map
