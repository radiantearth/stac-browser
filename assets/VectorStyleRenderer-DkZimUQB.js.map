{"version":3,"file":"VectorStyleRenderer-DkZimUQB.js","sources":["../../node_modules/ol/render/webgl/MixedGeometryBatch.js","../../node_modules/ol/render/webgl/renderinstructions.js","../../node_modules/ol/render/webgl/VectorStyleRenderer.js"],"sourcesContent":["/**\n * @module ol/render/webgl/MixedGeometryBatch\n */\nimport {inflateEnds} from '../../geom/flat/orient.js';\nimport RenderFeature from '../../render/Feature.js';\nimport {getUid} from '../../util.js';\n\n/**\n * @typedef {import(\"../../Feature.js\").default} Feature\n */\n/**\n * @typedef {import(\"../../geom/Geometry.js\").Type} GeometryType\n */\n\n/**\n * @typedef {Object} GeometryBatchItem Object that holds a reference to a feature as well as the raw coordinates of its various geometries\n * @property {Feature|RenderFeature} feature Feature\n * @property {Array<Array<number>>} flatCoordss Array of flat coordinates arrays, one for each geometry related to the feature\n * @property {number} [verticesCount] Only defined for linestring and polygon batches\n * @property {number} [ringsCount] Only defined for polygon batches\n * @property {Array<Array<number>>} [ringsVerticesCounts] Array of vertices counts in each ring for each geometry; only defined for polygons batches\n * @property {number} [ref] The reference in the global batch (used for hit detection)\n */\n\n/**\n * @typedef {PointGeometryBatch|LineStringGeometryBatch|PolygonGeometryBatch} GeometryBatch\n */\n\n/**\n * @typedef {Object} PolygonGeometryBatch A geometry batch specific to polygons\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {number} verticesCount Amount of vertices from geometries in the batch.\n * @property {number} ringsCount How many outer and inner rings in this batch.\n */\n\n/**\n * @typedef {Object} LineStringGeometryBatch A geometry batch specific to lines\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {number} verticesCount Amount of vertices from geometries in the batch.\n */\n\n/**\n * @typedef {Object} PointGeometryBatch A geometry batch specific to points\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n */\n\n/**\n * @classdesc This class is used to group several geometries of various types together for faster rendering.\n * Three inner batches are maintained for polygons, lines and points. Each time a feature is added, changed or removed\n * from the batch, these inner batches are modified accordingly in order to keep them up-to-date.\n *\n * A feature can be present in several inner batches, for example a polygon geometry will be present in the polygon batch\n * and its linear rings will be present in the line batch. Multi geometries are also broken down into individual geometries\n * and added to the corresponding batches in a recursive manner.\n *\n * Corresponding {@link module:ol/render/webgl/BatchRenderer} instances are then used to generate the render instructions\n * and WebGL buffers (vertices and indices) for each inner batches; render instructions are stored on the inner batches,\n * alongside the transform used to convert world coords to screen coords at the time these instructions were generated.\n * The resulting WebGL buffers are stored on the batches as well.\n *\n * An important aspect of geometry batches is that there is no guarantee that render instructions and WebGL buffers\n * are synchronized, i.e. render instructions can describe a new state while WebGL buffers might not have been written yet.\n * This is why two world-to-screen transforms are stored on each batch: one for the render instructions and one for\n * the WebGL buffers.\n */\nclass MixedGeometryBatch {\n  constructor() {\n    /**\n     * @private\n     */\n    this.globalCounter_ = 0;\n\n    /**\n     * Refs are used as keys for hit detection.\n     * @type {Map<number, Feature|RenderFeature>}\n     * @private\n     */\n    this.refToFeature_ = new Map();\n\n    /**\n     * Features are split in \"entries\", which are individual geometries. We use the following map to share a single ref for all those entries.\n     * @type {Map<string, number>}\n     * @private\n     */\n    this.uidToRef_ = new Map();\n\n    /**\n     * The precision in WebGL shaders is limited.\n     * To keep the refs as small as possible we maintain an array of freed up references.\n     * @type {Array<number>}\n     * @private\n     */\n    this.freeGlobalRef_ = [];\n\n    /**\n     * @type {PolygonGeometryBatch}\n     */\n    this.polygonBatch = {\n      entries: {},\n      geometriesCount: 0,\n      verticesCount: 0,\n      ringsCount: 0,\n    };\n\n    /**\n     * @type {PointGeometryBatch}\n     */\n    this.pointBatch = {\n      entries: {},\n      geometriesCount: 0,\n    };\n\n    /**\n     * @type {LineStringGeometryBatch}\n     */\n    this.lineStringBatch = {\n      entries: {},\n      geometriesCount: 0,\n      verticesCount: 0,\n    };\n  }\n\n  /**\n   * @param {Array<Feature|RenderFeature>} features Array of features to add to the batch\n   * @param {import(\"../../proj.js\").TransformFunction} [projectionTransform] Projection transform.\n   */\n  addFeatures(features, projectionTransform) {\n    for (let i = 0; i < features.length; i++) {\n      this.addFeature(features[i], projectionTransform);\n    }\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature to add to the batch\n   * @param {import(\"../../proj.js\").TransformFunction} [projectionTransform] Projection transform.\n   */\n  addFeature(feature, projectionTransform) {\n    let geometry = feature.getGeometry();\n    if (!geometry) {\n      return;\n    }\n    if (projectionTransform) {\n      geometry = geometry.clone();\n      geometry.applyTransform(projectionTransform);\n    }\n    this.addGeometry_(geometry, feature);\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @return {GeometryBatchItem|void} the cleared entry\n   * @private\n   */\n  clearFeatureEntryInPointBatch_(feature) {\n    const featureUid = getUid(feature);\n    const entry = this.pointBatch.entries[featureUid];\n    if (!entry) {\n      return;\n    }\n    this.pointBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.pointBatch.entries[featureUid];\n    return entry;\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @return {GeometryBatchItem|void} the cleared entry\n   * @private\n   */\n  clearFeatureEntryInLineStringBatch_(feature) {\n    const featureUid = getUid(feature);\n    const entry = this.lineStringBatch.entries[featureUid];\n    if (!entry) {\n      return;\n    }\n    this.lineStringBatch.verticesCount -= entry.verticesCount;\n    this.lineStringBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.lineStringBatch.entries[featureUid];\n    return entry;\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @return {GeometryBatchItem|void} the cleared entry\n   * @private\n   */\n  clearFeatureEntryInPolygonBatch_(feature) {\n    const featureUid = getUid(feature);\n    const entry = this.polygonBatch.entries[featureUid];\n    if (!entry) {\n      return;\n    }\n    this.polygonBatch.verticesCount -= entry.verticesCount;\n    this.polygonBatch.ringsCount -= entry.ringsCount;\n    this.polygonBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.polygonBatch.entries[featureUid];\n    return entry;\n  }\n\n  /**\n   * @param {import(\"../../geom.js\").Geometry|RenderFeature} geometry Geometry\n   * @param {Feature|RenderFeature} feature Feature\n   * @private\n   */\n  addGeometry_(geometry, feature) {\n    const type = geometry.getType();\n    switch (type) {\n      case 'GeometryCollection': {\n        const geometries =\n          /** @type {import(\"../../geom.js\").GeometryCollection} */ (\n            geometry\n          ).getGeometriesArray();\n        for (const geometry of geometries) {\n          this.addGeometry_(geometry, feature);\n        }\n        break;\n      }\n      case 'MultiPolygon': {\n        const multiPolygonGeom =\n          /** @type {import(\"../../geom.js\").MultiPolygon} */ (geometry);\n        this.addCoordinates_(\n          type,\n          multiPolygonGeom.getFlatCoordinates(),\n          multiPolygonGeom.getEndss(),\n          feature,\n          getUid(feature),\n          multiPolygonGeom.getStride(),\n        );\n        break;\n      }\n      case 'MultiLineString': {\n        const multiLineGeom =\n          /** @type {import(\"../../geom.js\").MultiLineString|RenderFeature} */ (\n            geometry\n          );\n        this.addCoordinates_(\n          type,\n          multiLineGeom.getFlatCoordinates(),\n          multiLineGeom.getEnds(),\n          feature,\n          getUid(feature),\n          multiLineGeom.getStride(),\n        );\n        break;\n      }\n      case 'MultiPoint': {\n        const multiPointGeom =\n          /** @type {import(\"../../geom.js\").MultiPoint|RenderFeature} */ (\n            geometry\n          );\n        this.addCoordinates_(\n          type,\n          multiPointGeom.getFlatCoordinates(),\n          null,\n          feature,\n          getUid(feature),\n          multiPointGeom.getStride(),\n        );\n        break;\n      }\n      case 'Polygon': {\n        const polygonGeom =\n          /** @type {import(\"../../geom.js\").Polygon|RenderFeature} */ (\n            geometry\n          );\n        this.addCoordinates_(\n          type,\n          polygonGeom.getFlatCoordinates(),\n          polygonGeom.getEnds(),\n          feature,\n          getUid(feature),\n          polygonGeom.getStride(),\n        );\n        break;\n      }\n      case 'Point': {\n        const pointGeom = /** @type {import(\"../../geom.js\").Point} */ (\n          geometry\n        );\n        this.addCoordinates_(\n          type,\n          pointGeom.getFlatCoordinates(),\n          null,\n          feature,\n          getUid(feature),\n          pointGeom.getStride(),\n        );\n        break;\n      }\n      case 'LineString':\n      case 'LinearRing': {\n        const lineGeom = /** @type {import(\"../../geom.js\").LineString} */ (\n          geometry\n        );\n\n        const stride = lineGeom.getStride();\n\n        this.addCoordinates_(\n          type,\n          lineGeom.getFlatCoordinates(),\n          null,\n          feature,\n          getUid(feature),\n          stride,\n          lineGeom.getLayout?.(),\n        );\n        break;\n      }\n      default:\n      // pass\n    }\n  }\n\n  /**\n   * @param {GeometryType} type Geometry type\n   * @param {Array<number>} flatCoords Flat coordinates\n   * @param {Array<number> | Array<Array<number>> | null} ends Coordinate ends\n   * @param {Feature|RenderFeature} feature Feature\n   * @param {string} featureUid Feature uid\n   * @param {number} stride Stride\n   * @param {import('../../geom/Geometry.js').GeometryLayout} [layout] Layout\n   * @private\n   */\n  addCoordinates_(type, flatCoords, ends, feature, featureUid, stride, layout) {\n    /** @type {number} */\n    let verticesCount;\n    switch (type) {\n      case 'MultiPolygon': {\n        const multiPolygonEndss = /** @type {Array<Array<number>>} */ (ends);\n        for (let i = 0, ii = multiPolygonEndss.length; i < ii; i++) {\n          let polygonEnds = multiPolygonEndss[i];\n          const prevPolygonEnds = i > 0 ? multiPolygonEndss[i - 1] : null;\n          const startIndex = prevPolygonEnds\n            ? prevPolygonEnds[prevPolygonEnds.length - 1]\n            : 0;\n          const endIndex = polygonEnds[polygonEnds.length - 1];\n          polygonEnds =\n            startIndex > 0\n              ? polygonEnds.map((end) => end - startIndex)\n              : polygonEnds;\n          this.addCoordinates_(\n            'Polygon',\n            flatCoords.slice(startIndex, endIndex),\n            polygonEnds,\n            feature,\n            featureUid,\n            stride,\n            layout,\n          );\n        }\n        break;\n      }\n      case 'MultiLineString': {\n        const multiLineEnds = /** @type {Array<number>} */ (ends);\n        for (let i = 0, ii = multiLineEnds.length; i < ii; i++) {\n          const startIndex = i > 0 ? multiLineEnds[i - 1] : 0;\n          this.addCoordinates_(\n            'LineString',\n            flatCoords.slice(startIndex, multiLineEnds[i]),\n            null,\n            feature,\n            featureUid,\n            stride,\n            layout,\n          );\n        }\n        break;\n      }\n      case 'MultiPoint':\n        for (let i = 0, ii = flatCoords.length; i < ii; i += stride) {\n          this.addCoordinates_(\n            'Point',\n            flatCoords.slice(i, i + 2),\n            null,\n            feature,\n            featureUid,\n            null,\n            null,\n          );\n        }\n        break;\n      case 'Polygon': {\n        const polygonEnds = /** @type {Array<number>} */ (ends);\n        if (feature instanceof RenderFeature) {\n          const multiPolygonEnds = inflateEnds(flatCoords, polygonEnds);\n          if (multiPolygonEnds.length > 1) {\n            this.addCoordinates_(\n              'MultiPolygon',\n              flatCoords,\n              multiPolygonEnds,\n              feature,\n              featureUid,\n              stride,\n              layout,\n            );\n            return;\n          }\n        }\n        if (!this.polygonBatch.entries[featureUid]) {\n          this.polygonBatch.entries[featureUid] = this.addRefToEntry_(\n            featureUid,\n            {\n              feature: feature,\n              flatCoordss: [],\n              verticesCount: 0,\n              ringsCount: 0,\n              ringsVerticesCounts: [],\n            },\n          );\n        }\n        verticesCount = flatCoords.length / stride;\n        const ringsCount = ends.length;\n        const ringsVerticesCount = ends.map((end, ind, arr) =>\n          ind > 0 ? (end - arr[ind - 1]) / stride : end / stride,\n        );\n        this.polygonBatch.verticesCount += verticesCount;\n        this.polygonBatch.ringsCount += ringsCount;\n        this.polygonBatch.geometriesCount++;\n        this.polygonBatch.entries[featureUid].flatCoordss.push(\n          getFlatCoordinatesXY(flatCoords, stride),\n        );\n        this.polygonBatch.entries[featureUid].ringsVerticesCounts.push(\n          ringsVerticesCount,\n        );\n        this.polygonBatch.entries[featureUid].verticesCount += verticesCount;\n        this.polygonBatch.entries[featureUid].ringsCount += ringsCount;\n        for (let i = 0, ii = polygonEnds.length; i < ii; i++) {\n          const startIndex = i > 0 ? polygonEnds[i - 1] : 0;\n          this.addCoordinates_(\n            'LinearRing',\n            flatCoords.slice(startIndex, polygonEnds[i]),\n            null,\n            feature,\n            featureUid,\n            stride,\n            layout,\n          );\n        }\n        break;\n      }\n      case 'Point':\n        if (!this.pointBatch.entries[featureUid]) {\n          this.pointBatch.entries[featureUid] = this.addRefToEntry_(\n            featureUid,\n            {\n              feature: feature,\n              flatCoordss: [],\n            },\n          );\n        }\n        this.pointBatch.geometriesCount++;\n        this.pointBatch.entries[featureUid].flatCoordss.push(flatCoords);\n        break;\n      case 'LineString':\n      case 'LinearRing':\n        if (!this.lineStringBatch.entries[featureUid]) {\n          this.lineStringBatch.entries[featureUid] = this.addRefToEntry_(\n            featureUid,\n            {\n              feature: feature,\n              flatCoordss: [],\n              verticesCount: 0,\n            },\n          );\n        }\n        verticesCount = flatCoords.length / stride;\n        this.lineStringBatch.verticesCount += verticesCount;\n        this.lineStringBatch.geometriesCount++;\n        this.lineStringBatch.entries[featureUid].flatCoordss.push(\n          getFlatCoordinatesXYM(flatCoords, stride, layout),\n        );\n        this.lineStringBatch.entries[featureUid].verticesCount += verticesCount;\n        break;\n      default:\n      // pass\n    }\n  }\n\n  /**\n   * @param {string} featureUid Feature uid\n   * @param {GeometryBatchItem} entry The entry to add\n   * @return {GeometryBatchItem} the added entry\n   * @private\n   */\n  addRefToEntry_(featureUid, entry) {\n    const currentRef = this.uidToRef_.get(featureUid);\n\n    // the ref starts at 1 to distinguish from white color (no feature)\n    const ref =\n      currentRef || this.freeGlobalRef_.pop() || ++this.globalCounter_;\n    entry.ref = ref;\n    if (!currentRef) {\n      this.refToFeature_.set(ref, entry.feature);\n      this.uidToRef_.set(featureUid, ref);\n    }\n    return entry;\n  }\n\n  /**\n   * Return a ref to the pool of available refs.\n   * @param {number} ref the ref to return\n   * @param {string} featureUid the feature uid\n   * @private\n   */\n  removeRef_(ref, featureUid) {\n    if (!ref) {\n      throw new Error('This feature has no ref: ' + featureUid);\n    }\n    this.refToFeature_.delete(ref);\n    this.uidToRef_.delete(featureUid);\n    this.freeGlobalRef_.push(ref);\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @param {import(\"../../proj.js\").TransformFunction} [projectionTransform] Projection transform.\n   */\n  changeFeature(feature, projectionTransform) {\n    // the feature is not present in the batch; do not add it to avoid unexpected behaviors\n    if (!this.uidToRef_.get(getUid(feature))) {\n      return;\n    }\n    this.removeFeature(feature);\n    let geometry = feature.getGeometry();\n    if (!geometry) {\n      return;\n    }\n    if (projectionTransform) {\n      geometry = geometry.clone();\n      geometry.applyTransform(projectionTransform);\n    }\n    this.addGeometry_(geometry, feature);\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   */\n  removeFeature(feature) {\n    let entry = this.clearFeatureEntryInPointBatch_(feature);\n    entry = this.clearFeatureEntryInPolygonBatch_(feature) || entry;\n    entry = this.clearFeatureEntryInLineStringBatch_(feature) || entry;\n    if (entry) {\n      this.removeRef_(entry.ref, getUid(entry.feature));\n    }\n  }\n\n  clear() {\n    this.polygonBatch.entries = {};\n    this.polygonBatch.geometriesCount = 0;\n    this.polygonBatch.verticesCount = 0;\n    this.polygonBatch.ringsCount = 0;\n    this.lineStringBatch.entries = {};\n    this.lineStringBatch.geometriesCount = 0;\n    this.lineStringBatch.verticesCount = 0;\n    this.pointBatch.entries = {};\n    this.pointBatch.geometriesCount = 0;\n    this.globalCounter_ = 0;\n    this.freeGlobalRef_ = [];\n    this.refToFeature_.clear();\n    this.uidToRef_.clear();\n  }\n\n  /**\n   * Resolve the feature associated to a ref.\n   * @param {number} ref Hit detected ref\n   * @return {Feature|RenderFeature} feature\n   */\n  getFeatureFromRef(ref) {\n    return this.refToFeature_.get(ref);\n  }\n\n  isEmpty() {\n    return this.globalCounter_ === 0;\n  }\n\n  /**\n   * Will return a new instance of this class that only contains the features\n   * for which the provided callback returned true\n   * @param {function((Feature|RenderFeature)): boolean} featureFilter Feature filter callback\n   * @return {MixedGeometryBatch} Filtered geometry batch\n   */\n  filter(featureFilter) {\n    const filtered = new MixedGeometryBatch();\n    filtered.globalCounter_ = this.globalCounter_;\n    filtered.uidToRef_ = this.uidToRef_;\n    filtered.refToFeature_ = this.refToFeature_;\n    let empty = true;\n    for (const feature of this.refToFeature_.values()) {\n      if (featureFilter(feature)) {\n        filtered.addFeature(feature);\n        empty = false;\n      }\n    }\n    // no feature was added at all; simply return an empty batch for consistency downstream\n    if (empty) {\n      return new MixedGeometryBatch();\n    }\n    return filtered;\n  }\n}\n\n/**\n * @param {Array<number>} flatCoords Flat coords\n * @param {number} stride Stride\n * @return {Array<number>} Flat coords with only XY components\n */\nfunction getFlatCoordinatesXY(flatCoords, stride) {\n  if (stride === 2) {\n    return flatCoords;\n  }\n  return flatCoords.filter((v, i) => i % stride < 2);\n}\n\n/**\n * @param {Array<number>} flatCoords Flat coords\n * @param {number} stride Stride\n * @param {string} layout Layout\n * @return {Array<number>} Flat coords with only XY components\n */\nfunction getFlatCoordinatesXYM(flatCoords, stride, layout) {\n  if (stride === 3 && layout === 'XYM') {\n    return flatCoords;\n  }\n  // this is XYZM layout\n  if (stride === 4) {\n    return flatCoords.filter((v, i) => i % stride !== 2);\n  }\n  // this is XYZ layout\n  if (stride === 3) {\n    return flatCoords.map((v, i) => (i % stride !== 2 ? v : 0));\n  }\n  // this is XY layout\n  return new Array(flatCoords.length * 1.5)\n    .fill(0)\n    .map((v, i) => (i % 3 === 2 ? 0 : flatCoords[Math.round(i / 1.5)]));\n}\n\nexport default MixedGeometryBatch;\n","/**\n * @module ol/render/webgl/renderinstructions\n */\nimport {UNDEFINED_PROP_VALUE} from '../../expr/gpu.js';\nimport {transform2D} from '../../geom/flat/transform.js';\nimport {apply as applyTransform} from '../../transform.js';\n\n/**\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"./MixedGeometryBatch.js\").GeometryBatchItem} batchEntry Batch item\n * @param {number} currentIndex Current index\n * @return {number} The amount of values pushed\n */\nfunction pushCustomAttributesInRenderInstructions(\n  renderInstructions,\n  customAttributes,\n  batchEntry,\n  currentIndex,\n) {\n  let shift = 0;\n  for (const key in customAttributes) {\n    const attr = customAttributes[key];\n    const value = attr.callback.call(batchEntry, batchEntry.feature);\n    let first = value?.[0] ?? value;\n    if (first === UNDEFINED_PROP_VALUE) {\n      console.warn('The \"has\" operator might return false positives.'); // eslint-disable-line no-console\n    }\n    if (first === undefined) {\n      first = UNDEFINED_PROP_VALUE;\n    } else if (first === null) {\n      first = 0;\n    }\n    renderInstructions[currentIndex + shift++] = first;\n    if (!attr.size || attr.size === 1) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[1];\n    if (attr.size < 3) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[2];\n    if (attr.size < 4) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[3];\n  }\n  return shift;\n}\n\n/**\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @return {number} Cumulated size of all attributes\n */\nexport function getCustomAttributesSize(customAttributes) {\n  return Object.keys(customAttributes).reduce(\n    (prev, curr) => prev + (customAttributes[curr].size || 1),\n    0,\n  );\n}\n\n/**\n * Render instructions for lines are structured like so:\n * [ x0, y0, customAttr0, ... , xN, yN, customAttrN ]\n * @param {import(\"./MixedGeometryBatch.js\").PointGeometryBatch} batch Point geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generatePointRenderInstructions(\n  batch,\n  renderInstructions,\n  customAttributes,\n  transform,\n) {\n  // here we anticipate the amount of render instructions for points:\n  // 2 instructions per vertex for position (x and y)\n  // + 1 instruction per vertex per custom attributes\n  const totalInstructionsCount =\n    (2 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount;\n  if (\n    !renderInstructions ||\n    renderInstructions.length !== totalInstructionsCount\n  ) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  const tmpCoords = [];\n  let renderIndex = 0;\n  for (const featureUid in batch.entries) {\n    const batchEntry = batch.entries[featureUid];\n    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      tmpCoords[0] = batchEntry.flatCoordss[i][0];\n      tmpCoords[1] = batchEntry.flatCoordss[i][1];\n      applyTransform(transform, tmpCoords);\n\n      renderInstructions[renderIndex++] = tmpCoords[0];\n      renderInstructions[renderIndex++] = tmpCoords[1];\n      renderIndex += pushCustomAttributesInRenderInstructions(\n        renderInstructions,\n        customAttributes,\n        batchEntry,\n        renderIndex,\n      );\n    }\n  }\n  return renderInstructions;\n}\n\n/**\n * Render instructions for lines are structured like so:\n * [ customAttr0, ... , customAttrN, numberOfVertices0, x0, y0, ... , xN, yN, numberOfVertices1, ... ]\n * @param {import(\"./MixedGeometryBatch.js\").LineStringGeometryBatch} batch Line String geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generateLineStringRenderInstructions(\n  batch,\n  renderInstructions,\n  customAttributes,\n  transform,\n) {\n  // here we anticipate the amount of render instructions for lines:\n  // 3 instructions per vertex for position (x, y and m)\n  // + 1 instruction per line per custom attributes\n  // + 1 instruction per line (for vertices count)\n  const totalInstructionsCount =\n    3 * batch.verticesCount +\n    (1 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount;\n  if (\n    !renderInstructions ||\n    renderInstructions.length !== totalInstructionsCount\n  ) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  const flatCoords = [];\n  let renderIndex = 0;\n  for (const featureUid in batch.entries) {\n    const batchEntry = batch.entries[featureUid];\n    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      flatCoords.length = batchEntry.flatCoordss[i].length;\n      transform2D(\n        batchEntry.flatCoordss[i],\n        0,\n        flatCoords.length,\n        3,\n        transform,\n        flatCoords,\n        3,\n      );\n      renderIndex += pushCustomAttributesInRenderInstructions(\n        renderInstructions,\n        customAttributes,\n        batchEntry,\n        renderIndex,\n      );\n\n      // vertices count\n      renderInstructions[renderIndex++] = flatCoords.length / 3;\n\n      // looping on points for positions\n      for (let j = 0, jj = flatCoords.length; j < jj; j += 3) {\n        renderInstructions[renderIndex++] = flatCoords[j];\n        renderInstructions[renderIndex++] = flatCoords[j + 1];\n        renderInstructions[renderIndex++] = flatCoords[j + 2];\n      }\n    }\n  }\n  return renderInstructions;\n}\n\n/**\n * Render instructions for polygons are structured like so:\n * [ customAttr0, ..., customAttrN, numberOfRings, numberOfVerticesInRing0, ..., numberOfVerticesInRingN, x0, y0, ..., xN, yN, numberOfRings,... ]\n * @param {import(\"./MixedGeometryBatch.js\").PolygonGeometryBatch} batch Polygon geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generatePolygonRenderInstructions(\n  batch,\n  renderInstructions,\n  customAttributes,\n  transform,\n) {\n  // here we anticipate the amount of render instructions for polygons:\n  // 2 instructions per vertex for position (x and y)\n  // + 1 instruction per polygon per custom attributes\n  // + 1 instruction per polygon (for vertices count in polygon)\n  // + 1 instruction per ring (for vertices count in ring)\n  const totalInstructionsCount =\n    2 * batch.verticesCount +\n    (1 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount +\n    batch.ringsCount;\n  if (\n    !renderInstructions ||\n    renderInstructions.length !== totalInstructionsCount\n  ) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  const flatCoords = [];\n  let renderIndex = 0;\n  for (const featureUid in batch.entries) {\n    const batchEntry = batch.entries[featureUid];\n    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      flatCoords.length = batchEntry.flatCoordss[i].length;\n      transform2D(\n        batchEntry.flatCoordss[i],\n        0,\n        flatCoords.length,\n        2,\n        transform,\n        flatCoords,\n      );\n      renderIndex += pushCustomAttributesInRenderInstructions(\n        renderInstructions,\n        customAttributes,\n        batchEntry,\n        renderIndex,\n      );\n\n      // ring count\n      renderInstructions[renderIndex++] =\n        batchEntry.ringsVerticesCounts[i].length;\n\n      // vertices count in each ring\n      for (\n        let j = 0, jj = batchEntry.ringsVerticesCounts[i].length;\n        j < jj;\n        j++\n      ) {\n        renderInstructions[renderIndex++] =\n          batchEntry.ringsVerticesCounts[i][j];\n      }\n\n      // looping on points for positions\n      for (let j = 0, jj = flatCoords.length; j < jj; j += 2) {\n        renderInstructions[renderIndex++] = flatCoords[j];\n        renderInstructions[renderIndex++] = flatCoords[j + 1];\n      }\n    }\n  }\n  return renderInstructions;\n}\n","/**\n * @module ol/render/webgl/VectorStyleRenderer\n */\nimport {\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n} from '../../transform.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport {AttributeType} from '../../webgl/Helper.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {WebGLWorkerMessageType} from './constants.js';\nimport {colorEncodeIdAndPack} from './encodeUtil.js';\nimport {\n  generateLineStringRenderInstructions,\n  generatePointRenderInstructions,\n  generatePolygonRenderInstructions,\n  getCustomAttributesSize,\n} from './renderinstructions.js';\nimport {parseLiteralStyle} from './style.js';\n\nconst tmpColor = [];\n/** @type {Worker|undefined} */\nlet WEBGL_WORKER;\nfunction getWebGLWorker() {\n  if (!WEBGL_WORKER) {\n    WEBGL_WORKER = createWebGLWorker();\n  }\n  return WEBGL_WORKER;\n}\nlet workerMessageCounter = 0;\n\n/**\n * Names of attributes made available to the vertex shader.\n * Please note: changing these *will* break custom shaders!\n * @enum {string}\n */\nexport const Attributes = {\n  POSITION: 'a_position',\n  LOCAL_POSITION: 'a_localPosition',\n  SEGMENT_START: 'a_segmentStart',\n  SEGMENT_END: 'a_segmentEnd',\n  MEASURE_START: 'a_measureStart',\n  MEASURE_END: 'a_measureEnd',\n  ANGLE_TANGENT_SUM: 'a_angleTangentSum',\n  JOIN_ANGLES: 'a_joinAngles',\n  DISTANCE_LOW: 'a_distanceLow',\n  DISTANCE_HIGH: 'a_distanceHigh',\n};\n\n/**\n * @typedef {Object} AttributeDefinition A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {number} [size] Amount of numerical values composing the attribute, either 1, 2, 3 or 4; in case size is > 1, the return value\n * of the callback should be an array; if unspecified, assumed to be a single float value\n * @property {function(this:import(\"./MixedGeometryBatch.js\").GeometryBatchItem, import(\"../../Feature\").FeatureLike):number|Array<number>} callback This callback computes the numerical value of the\n * attribute for a given feature.\n */\n\n/**\n * @typedef {Object<string, AttributeDefinition>} AttributeDefinitions\n * @typedef {Object<string, import(\"../../webgl/Helper\").UniformValue>} UniformDefinitions\n */\n\n/**\n * @typedef {Array<WebGLArrayBuffer>} WebGLArrayBufferSet Buffers organized like so: [indicesBuffer, vertexAttributesBuffer, instanceAttributesBuffer]\n */\n\n/**\n * @typedef {Object} WebGLBuffers\n * @property {WebGLArrayBufferSet} polygonBuffers Array containing indices and vertices buffers for polygons\n * @property {WebGLArrayBufferSet} lineStringBuffers Array containing indices and vertices buffers for line strings\n * @property {WebGLArrayBufferSet} pointBuffers Array containing indices and vertices buffers for points\n * @property {import(\"../../transform.js\").Transform} invertVerticesTransform Inverse of the transform applied when generating buffers\n */\n\n/**\n * @typedef {Object} RenderInstructions\n * @property {Float32Array|null} polygonInstructions Polygon instructions; null if nothing to render\n * @property {Float32Array|null} lineStringInstructions LineString instructions; null if nothing to render\n * @property {Float32Array|null} pointInstructions Point instructions; null if nothing to render\n */\n\n/**\n * @typedef {Object} ShaderProgram An object containing both shaders (vertex and fragment)\n * @property {string} vertex Vertex shader source\n * @property {string} fragment Fragment shader source\n */\n\n/**\n * @typedef {import('./style.js').StyleParseResult} StyleShaders\n */\n\n/**\n * @typedef {import('../../style/flat.js').FlatStyleLike} FlatStyleLike\n */\n/**\n * @typedef {import('../../style/flat.js').FlatStyle} FlatStyle\n */\n/**\n * @typedef {import('../../style/flat.js').Rule} FlatStyleRule\n */\n\n/**\n * @typedef {Object} SubRenderPass\n * @property {string} vertexShader Vertex shader\n * @property {string} fragmentShader Fragment shader\n * @property {Array<import('../../webgl/Helper.js').AttributeDescription>} attributesDesc Attributes description, defined for each primitive vertex\n * @property {Array<import('../../webgl/Helper.js').AttributeDescription>} instancedAttributesDesc Attributes description, defined once per primitive\n * @property {number} instancePrimitiveVertexCount Number of vertices per instance primitive in this render pass\n * @property {WebGLProgram} [program] Program; this has to be recreated if the helper is lost/changed\n */\n\n/**\n * @typedef {Object} RenderPass\n * @property {SubRenderPass} [fillRenderPass] Fill render pass; undefined if no fill in pass\n * @property {SubRenderPass} [strokeRenderPass] Stroke render pass; undefined if no stroke in pass\n * @property {SubRenderPass} [symbolRenderPass] Symbol render pass; undefined if no symbol in pass\n */\n\n/**\n * @classdesc This class is responsible for:\n * 1. generating WebGL buffers according to a provided style, using a MixedGeometryBatch as input\n * 2. rendering geometries contained in said buffers\n *\n * A VectorStyleRenderer instance can be created either from a literal style or from shaders.\n * The shaders should not be provided explicitly but instead as a preconfigured ShaderBuilder instance.\n *\n * The `generateBuffers` method returns a promise resolving to WebGL buffers that are intended to be rendered by the\n * same renderer.\n */\nclass VectorStyleRenderer {\n  /**\n   * @param {FlatStyleLike|StyleShaders|Array<StyleShaders>} styles Vector styles expressed as flat styles, flat style rules or style shaders\n   * @param {import('../../style/flat.js').StyleVariables} variables Style variables\n   * @param {import('../../webgl/Helper.js').default} helper Helper\n   * @param {boolean} [enableHitDetection] Whether to enable the hit detection (needs compatible shader)\n   */\n  constructor(styles, variables, helper, enableHitDetection) {\n    /**\n     * @private\n     * @type {import('../../webgl/Helper.js').default}\n     */\n    this.helper_;\n\n    /**\n     * @private\n     */\n    this.hitDetectionEnabled_ = !!enableHitDetection;\n\n    /**\n     * @type {Array<StyleShaders>}\n     * @private\n     */\n    this.styleShaders = convertStyleToShaders(styles, variables);\n\n    /**\n     * @type {AttributeDefinitions}\n     * @private\n     */\n    this.customAttributes_ = {};\n\n    /**\n     @type {UniformDefinitions}\n     * @private\n     */\n    this.uniforms_ = {};\n\n    // add hit detection attribute if enabled\n    if (this.hitDetectionEnabled_) {\n      this.customAttributes_['hitColor'] = {\n        callback() {\n          return colorEncodeIdAndPack(this.ref, tmpColor);\n        },\n        size: 2,\n      };\n    }\n\n    // add attributes & uniforms coming from all shaders\n    for (const styleShader of this.styleShaders) {\n      for (const attributeName in styleShader.attributes) {\n        if (attributeName in this.customAttributes_) {\n          // already defined: skip\n          continue;\n        }\n        this.customAttributes_[attributeName] =\n          styleShader.attributes[attributeName];\n      }\n      for (const uniformName in styleShader.uniforms) {\n        if (uniformName in this.uniforms_) {\n          // already defined: skip\n          continue;\n        }\n        this.uniforms_[uniformName] = styleShader.uniforms[uniformName];\n      }\n    }\n\n    // create a render pass for each shader\n    /**\n     * @type {Array<RenderPass>}\n     * @private\n     */\n    this.renderPasses_ = this.styleShaders.map((styleShader) => {\n      /** @type {RenderPass} */\n      const renderPass = {};\n\n      const customAttributesDesc = Object.entries(this.customAttributes_).map(\n        ([name, value]) => {\n          const isUsed = name in styleShader.attributes || name === 'hitColor';\n          return {\n            name: isUsed ? `a_${name}` : null, // giving a null name means this is only used for \"spacing\" in between attributes\n            size: value.size || 1,\n            type: AttributeType.FLOAT,\n          };\n        },\n      );\n\n      // set up each subpass\n      if (styleShader.builder.getFillVertexShader()) {\n        renderPass.fillRenderPass = {\n          vertexShader: styleShader.builder.getFillVertexShader(),\n          fragmentShader: styleShader.builder.getFillFragmentShader(),\n          attributesDesc: [\n            {\n              name: Attributes.POSITION,\n              size: 2,\n              type: AttributeType.FLOAT,\n            },\n            ...customAttributesDesc,\n          ],\n          instancedAttributesDesc: [], // no instanced rendering for polygons\n          instancePrimitiveVertexCount: 3,\n        };\n      }\n      if (styleShader.builder.getStrokeVertexShader()) {\n        renderPass.strokeRenderPass = {\n          vertexShader: styleShader.builder.getStrokeVertexShader(),\n          fragmentShader: styleShader.builder.getStrokeFragmentShader(),\n          attributesDesc: [\n            {\n              name: Attributes.LOCAL_POSITION,\n              size: 2,\n              type: AttributeType.FLOAT,\n            },\n          ],\n          instancedAttributesDesc: [\n            {\n              name: Attributes.SEGMENT_START,\n              size: 2,\n              type: AttributeType.FLOAT,\n            },\n            {\n              name: Attributes.MEASURE_START,\n              size: 1,\n              type: AttributeType.FLOAT,\n            },\n            {\n              name: Attributes.SEGMENT_END,\n              size: 2,\n              type: AttributeType.FLOAT,\n            },\n            {\n              name: Attributes.MEASURE_END,\n              size: 1,\n              type: AttributeType.FLOAT,\n            },\n            {\n              name: Attributes.JOIN_ANGLES,\n              size: 2,\n              type: AttributeType.FLOAT,\n            },\n            {\n              name: Attributes.DISTANCE_LOW,\n              size: 1,\n              type: AttributeType.FLOAT,\n            },\n            {\n              name: Attributes.DISTANCE_HIGH,\n              size: 1,\n              type: AttributeType.FLOAT,\n            },\n            {\n              name: Attributes.ANGLE_TANGENT_SUM,\n              size: 1,\n              type: AttributeType.FLOAT,\n            },\n            ...customAttributesDesc,\n          ],\n          instancePrimitiveVertexCount: 6,\n        };\n      }\n      if (styleShader.builder.getSymbolVertexShader()) {\n        renderPass.symbolRenderPass = {\n          vertexShader: styleShader.builder.getSymbolVertexShader(),\n          fragmentShader: styleShader.builder.getSymbolFragmentShader(),\n          attributesDesc: [\n            {\n              name: Attributes.LOCAL_POSITION,\n              size: 2,\n              type: AttributeType.FLOAT,\n            },\n          ],\n          instancedAttributesDesc: [\n            {\n              name: Attributes.POSITION,\n              size: 2,\n              type: AttributeType.FLOAT,\n            },\n            ...customAttributesDesc,\n          ],\n          instancePrimitiveVertexCount: 6,\n        };\n      }\n      return renderPass;\n    });\n\n    this.hasFill_ = this.renderPasses_.some((pass) => pass.fillRenderPass);\n    this.hasStroke_ = this.renderPasses_.some((pass) => pass.strokeRenderPass);\n    this.hasSymbol_ = this.renderPasses_.some((pass) => pass.symbolRenderPass);\n\n    // this will initialize render passes with the given helper\n    this.setHelper(helper);\n  }\n\n  /**\n   * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch\n   * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n   * @return {Promise<WebGLBuffers|null>} A promise resolving to WebGL buffers; returns null if buffers are empty\n   */\n  async generateBuffers(geometryBatch, transform) {\n    if (geometryBatch.isEmpty()) {\n      return null;\n    }\n    const renderInstructions = this.generateRenderInstructions_(\n      geometryBatch,\n      transform,\n    );\n    const [polygonBuffers, lineStringBuffers, pointBuffers] = await Promise.all(\n      [\n        this.generateBuffersForType_(\n          renderInstructions.polygonInstructions,\n          'Polygon',\n          transform,\n        ),\n        this.generateBuffersForType_(\n          renderInstructions.lineStringInstructions,\n          'LineString',\n          transform,\n        ),\n        this.generateBuffersForType_(\n          renderInstructions.pointInstructions,\n          'Point',\n          transform,\n        ),\n      ],\n    );\n    // also return the inverse of the transform that was applied when generating buffers\n    const invertVerticesTransform = makeInverseTransform(\n      createTransform(),\n      transform,\n    );\n    return {\n      polygonBuffers: polygonBuffers,\n      lineStringBuffers: lineStringBuffers,\n      pointBuffers: pointBuffers,\n      invertVerticesTransform: invertVerticesTransform,\n    };\n  }\n\n  /**\n   * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch\n   * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n   * @return {RenderInstructions} Render instructions\n   * @private\n   */\n  generateRenderInstructions_(geometryBatch, transform) {\n    const polygonInstructions = this.hasFill_\n      ? generatePolygonRenderInstructions(\n          geometryBatch.polygonBatch,\n          new Float32Array(0),\n          this.customAttributes_,\n          transform,\n        )\n      : null;\n    const lineStringInstructions = this.hasStroke_\n      ? generateLineStringRenderInstructions(\n          geometryBatch.lineStringBatch,\n          new Float32Array(0),\n          this.customAttributes_,\n          transform,\n        )\n      : null;\n    const pointInstructions = this.hasSymbol_\n      ? generatePointRenderInstructions(\n          geometryBatch.pointBatch,\n          new Float32Array(0),\n          this.customAttributes_,\n          transform,\n        )\n      : null;\n\n    return {\n      polygonInstructions,\n      lineStringInstructions,\n      pointInstructions,\n    };\n  }\n\n  /**\n   * @param {Float32Array|null} renderInstructions Render instructions\n   * @param {import(\"../../geom/Geometry.js\").Type} geometryType Geometry type\n   * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n   * @return {Promise<WebGLArrayBufferSet>|null} Indices buffer and vertices buffer; null if nothing to render\n   * @private\n   */\n  generateBuffersForType_(renderInstructions, geometryType, transform) {\n    if (renderInstructions === null) {\n      return null;\n    }\n\n    const messageId = workerMessageCounter++;\n    let messageType;\n    switch (geometryType) {\n      case 'Polygon':\n        messageType = WebGLWorkerMessageType.GENERATE_POLYGON_BUFFERS;\n        break;\n      case 'LineString':\n        messageType = WebGLWorkerMessageType.GENERATE_LINE_STRING_BUFFERS;\n        break;\n      case 'Point':\n        messageType = WebGLWorkerMessageType.GENERATE_POINT_BUFFERS;\n        break;\n      default:\n      // pass\n    }\n\n    /** @type {import('./constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: messageId,\n      type: messageType,\n      renderInstructions: renderInstructions.buffer,\n      renderInstructionsTransform: transform,\n      customAttributesSize: getCustomAttributesSize(this.customAttributes_),\n    };\n    const WEBGL_WORKER = getWebGLWorker();\n    WEBGL_WORKER.postMessage(message, [renderInstructions.buffer]);\n\n    // leave ownership of render instructions\n    renderInstructions = null;\n\n    return new Promise((resolve) => {\n      /**\n       * @param {{data: import('./constants.js').WebGLWorkerGenerateBuffersMessage}} event Event.\n       */\n      const handleMessage = (event) => {\n        const received = event.data;\n\n        // this is not the response to our request: skip\n        if (received.id !== messageId) {\n          return;\n        }\n\n        // we've received our response: stop listening\n        WEBGL_WORKER.removeEventListener('message', handleMessage);\n\n        // the helper has disposed in the meantime; the promise will not be resolved\n        if (!this.helper_.getGL()) {\n          return;\n        }\n\n        // copy & flush received buffers to GPU\n        const indicesBuffer = new WebGLArrayBuffer(\n          ELEMENT_ARRAY_BUFFER,\n          DYNAMIC_DRAW,\n        ).fromArrayBuffer(received.indicesBuffer);\n        const vertexAttributesBuffer = new WebGLArrayBuffer(\n          ARRAY_BUFFER,\n          DYNAMIC_DRAW,\n        ).fromArrayBuffer(received.vertexAttributesBuffer);\n        const instanceAttributesBuffer = new WebGLArrayBuffer(\n          ARRAY_BUFFER,\n          DYNAMIC_DRAW,\n        ).fromArrayBuffer(received.instanceAttributesBuffer);\n        this.helper_.flushBufferData(indicesBuffer);\n        this.helper_.flushBufferData(vertexAttributesBuffer);\n        this.helper_.flushBufferData(instanceAttributesBuffer);\n\n        resolve([\n          indicesBuffer,\n          vertexAttributesBuffer,\n          instanceAttributesBuffer,\n        ]);\n      };\n\n      WEBGL_WORKER.addEventListener('message', handleMessage);\n    });\n  }\n\n  /**\n   * Render the geometries in the given buffers.\n   * @param {WebGLBuffers} buffers WebGL Buffers to draw\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state\n   * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms\n   */\n  render(buffers, frameState, preRenderCallback) {\n    for (const renderPass of this.renderPasses_) {\n      renderPass.fillRenderPass &&\n        this.renderInternal_(\n          buffers.polygonBuffers[0],\n          buffers.polygonBuffers[1],\n          buffers.polygonBuffers[2],\n          renderPass.fillRenderPass,\n          frameState,\n          preRenderCallback,\n        );\n      renderPass.strokeRenderPass &&\n        this.renderInternal_(\n          buffers.lineStringBuffers[0],\n          buffers.lineStringBuffers[1],\n          buffers.lineStringBuffers[2],\n          renderPass.strokeRenderPass,\n          frameState,\n          preRenderCallback,\n        );\n      renderPass.symbolRenderPass &&\n        this.renderInternal_(\n          buffers.pointBuffers[0],\n          buffers.pointBuffers[1],\n          buffers.pointBuffers[2],\n          renderPass.symbolRenderPass,\n          frameState,\n          preRenderCallback,\n        );\n    }\n  }\n\n  /**\n   * @param {WebGLArrayBuffer} indicesBuffer Indices buffer\n   * @param {WebGLArrayBuffer} vertexAttributesBuffer Vertex attributes buffer\n   * @param {WebGLArrayBuffer} instanceAttributesBuffer Instance attributes buffer\n   * @param {SubRenderPass} subRenderPass Render pass (program, attributes, etc.) specific to one geometry type\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms\n   * @private\n   */\n  renderInternal_(\n    indicesBuffer,\n    vertexAttributesBuffer,\n    instanceAttributesBuffer,\n    subRenderPass,\n    frameState,\n    preRenderCallback,\n  ) {\n    const renderCount = indicesBuffer.getSize();\n    if (renderCount === 0) {\n      return;\n    }\n\n    const usesInstancedRendering = subRenderPass.instancedAttributesDesc.length;\n\n    this.helper_.useProgram(subRenderPass.program, frameState);\n    this.helper_.bindBuffer(vertexAttributesBuffer);\n    this.helper_.bindBuffer(indicesBuffer);\n    this.helper_.enableAttributes(subRenderPass.attributesDesc);\n    this.helper_.bindBuffer(instanceAttributesBuffer);\n    this.helper_.enableAttributesInstanced(\n      subRenderPass.instancedAttributesDesc,\n    );\n\n    preRenderCallback();\n\n    if (usesInstancedRendering) {\n      const instanceAttributesStride =\n        subRenderPass.instancedAttributesDesc.reduce(\n          (prev, curr) => prev + (curr.size || 1),\n          0,\n        );\n      const instanceCount =\n        instanceAttributesBuffer.getSize() / instanceAttributesStride;\n\n      this.helper_.drawElementsInstanced(0, renderCount, instanceCount);\n    } else {\n      this.helper_.drawElements(0, renderCount);\n    }\n  }\n\n  /**\n   * @param {import('../../webgl/Helper.js').default} helper Helper\n   * @param {WebGLBuffers} buffers WebGL Buffers to reload if any\n   */\n  setHelper(helper, buffers = null) {\n    this.helper_ = helper;\n\n    for (const renderPass of this.renderPasses_) {\n      if (renderPass.fillRenderPass) {\n        renderPass.fillRenderPass.program = this.helper_.getProgram(\n          renderPass.fillRenderPass.fragmentShader,\n          renderPass.fillRenderPass.vertexShader,\n        );\n      }\n      if (renderPass.strokeRenderPass) {\n        renderPass.strokeRenderPass.program = this.helper_.getProgram(\n          renderPass.strokeRenderPass.fragmentShader,\n          renderPass.strokeRenderPass.vertexShader,\n        );\n      }\n      if (renderPass.symbolRenderPass) {\n        renderPass.symbolRenderPass.program = this.helper_.getProgram(\n          renderPass.symbolRenderPass.fragmentShader,\n          renderPass.symbolRenderPass.vertexShader,\n        );\n      }\n    }\n    this.helper_.addUniforms(this.uniforms_);\n\n    if (buffers) {\n      if (buffers.polygonBuffers) {\n        this.helper_.flushBufferData(buffers.polygonBuffers[0]);\n        this.helper_.flushBufferData(buffers.polygonBuffers[1]);\n        this.helper_.flushBufferData(buffers.polygonBuffers[2]);\n      }\n      if (buffers.lineStringBuffers) {\n        this.helper_.flushBufferData(buffers.lineStringBuffers[0]);\n        this.helper_.flushBufferData(buffers.lineStringBuffers[1]);\n        this.helper_.flushBufferData(buffers.lineStringBuffers[2]);\n      }\n      if (buffers.pointBuffers) {\n        this.helper_.flushBufferData(buffers.pointBuffers[0]);\n        this.helper_.flushBufferData(buffers.pointBuffers[1]);\n        this.helper_.flushBufferData(buffers.pointBuffers[2]);\n      }\n    }\n  }\n}\n\nexport default VectorStyleRenderer;\n\n/**\n * Breaks down a vector style into an array of prebuilt shader builders with attributes and uniforms\n * @param {FlatStyleLike|StyleShaders|Array<StyleShaders>} style Vector style\n * @param {import('../../style/flat.js').StyleVariables} variables Style variables\n * @return {Array<StyleShaders>} Array of style shaders\n */\nexport function convertStyleToShaders(style, variables) {\n  // possible cases:\n  // - single shader\n  // - multiple shaders\n  // - single style\n  // - multiple styles\n  // - multiple rules\n  const asArray = Array.isArray(style) ? style : [style];\n\n  // if array of rules: break rules into separate styles, compute \"else\" filters\n  if ('style' in asArray[0]) {\n    /** @type {Array<StyleShaders>} */\n    const shaders = [];\n    const rules = /** @type {Array<FlatStyleRule>} */ (asArray);\n    const previousFilters = [];\n    for (const rule of rules) {\n      /** @type {Array<FlatStyle>} */\n      const ruleStyles = Array.isArray(rule.style) ? rule.style : [rule.style];\n      /** @type {import(\"../../expr/expression.js\").EncodedExpression} */\n      let currentFilter = rule.filter;\n      if (rule.else && previousFilters.length) {\n        currentFilter = [\n          'all',\n          ...previousFilters.map((filter) => ['!', filter]),\n        ];\n        if (rule.filter) {\n          currentFilter.push(rule.filter);\n        }\n        if (currentFilter.length < 3) {\n          currentFilter = currentFilter[1];\n        }\n      }\n      if (rule.filter) {\n        previousFilters.push(rule.filter);\n      }\n      // parse each style and convert to shader\n      const styleShaders = ruleStyles.map((style) =>\n        parseLiteralStyle(style, variables, currentFilter),\n      );\n      shaders.push(...styleShaders);\n    }\n    return shaders;\n  }\n\n  // if array of shaders: return as is\n  if ('builder' in asArray[0]) {\n    return /** @type {Array<StyleShaders>} */ (asArray);\n  }\n\n  // array of flat styles: simply convert to shaders\n  return /** @type {Array<FlatStyle>} */ (asArray).map((style) =>\n    parseLiteralStyle(style, variables, null),\n  );\n}\n"],"names":["MixedGeometryBatch","features","projectionTransform","i","feature","geometry","featureUid","getUid","entry","type","geometries","multiPolygonGeom","multiLineGeom","multiPointGeom","polygonGeom","pointGeom","lineGeom","stride","flatCoords","ends","layout","verticesCount","multiPolygonEndss","ii","polygonEnds","prevPolygonEnds","startIndex","endIndex","end","multiLineEnds","RenderFeature","multiPolygonEnds","inflateEnds","ringsCount","ringsVerticesCount","ind","arr","getFlatCoordinatesXY","getFlatCoordinatesXYM","currentRef","ref","featureFilter","filtered","empty","v","pushCustomAttributesInRenderInstructions","renderInstructions","customAttributes","batchEntry","currentIndex","shift","key","attr","value","first","UNDEFINED_PROP_VALUE","getCustomAttributesSize","prev","curr","generatePointRenderInstructions","batch","transform","totalInstructionsCount","tmpCoords","renderIndex","applyTransform","generateLineStringRenderInstructions","transform2D","j","jj","generatePolygonRenderInstructions","tmpColor","WEBGL_WORKER","getWebGLWorker","createWebGLWorker","workerMessageCounter","Attributes","VectorStyleRenderer","styles","variables","helper","enableHitDetection","convertStyleToShaders","colorEncodeIdAndPack","styleShader","attributeName","uniformName","renderPass","customAttributesDesc","name","AttributeType","pass","geometryBatch","polygonBuffers","lineStringBuffers","pointBuffers","invertVerticesTransform","makeInverseTransform","createTransform","polygonInstructions","lineStringInstructions","pointInstructions","geometryType","messageId","messageType","WebGLWorkerMessageType","message","resolve","handleMessage","event","received","indicesBuffer","WebGLArrayBuffer","ELEMENT_ARRAY_BUFFER","DYNAMIC_DRAW","vertexAttributesBuffer","ARRAY_BUFFER","instanceAttributesBuffer","buffers","frameState","preRenderCallback","subRenderPass","renderCount","usesInstancedRendering","instanceAttributesStride","instanceCount","style","asArray","shaders","rules","previousFilters","rule","ruleStyles","currentFilter","filter","styleShaders","parseLiteralStyle"],"mappings":"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","x_google_ignoreList":[0,1,2]}