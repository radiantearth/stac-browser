{"version":3,"file":"common-0gNrjJbx.js","sources":["../../node_modules/ol/reproj.js","../../node_modules/ol/reproj/Triangulation.js","../../node_modules/ol/reproj/common.js"],"sourcesContent":["/**\n * @module ol/reproj\n */\nimport {createCanvasContext2D, releaseCanvas} from './dom.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  extend,\n  forEachCorner,\n  getCenter,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from './extent.js';\nimport {solveLinearSystem} from './math.js';\nimport {getPointResolution, transform} from './proj.js';\n\nlet brokenDiagonalRendering_;\n\n/**\n * @type {Array<HTMLCanvasElement|OffscreenCanvas>}\n */\nexport const canvasPool = [];\n\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(u1, v1);\n  ctx.lineTo(u2, v2);\n  ctx.closePath();\n  ctx.save();\n  ctx.clip();\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n  ctx.restore();\n}\n\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\n  return (\n    Math.abs(data[offset * 4] - 210) > 2 ||\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\n  );\n}\n\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n  if (brokenDiagonalRendering_ === undefined) {\n    const ctx = createCanvasContext2D(6, 6, canvasPool);\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n    drawTestTriangle(ctx, 4, 5, 4, 0);\n    drawTestTriangle(ctx, 4, 5, 0, 5);\n    const data = ctx.getImageData(0, 0, 3, 3).data;\n    brokenDiagonalRendering_ =\n      verifyBrokenDiagonalRendering(data, 0) ||\n      verifyBrokenDiagonalRendering(data, 4) ||\n      verifyBrokenDiagonalRendering(data, 8);\n    releaseCanvas(ctx);\n    canvasPool.push(ctx.canvas);\n  }\n\n  return brokenDiagonalRendering_;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(\n  sourceProj,\n  targetProj,\n  targetCenter,\n  targetResolution,\n) {\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  let sourceResolution = getPointResolution(\n    targetProj,\n    targetResolution,\n    targetCenter,\n  );\n\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  const sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    const compensationFactor =\n      getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n      sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(\n  sourceProj,\n  targetProj,\n  targetExtent,\n  targetResolution,\n) {\n  const targetCenter = getCenter(targetExtent);\n  let sourceResolution = calculateSourceResolution(\n    sourceProj,\n    targetProj,\n    targetCenter,\n    targetResolution,\n  );\n\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    forEachCorner(targetExtent, function (corner) {\n      sourceResolution = calculateSourceResolution(\n        sourceProj,\n        targetProj,\n        corner,\n        targetResolution,\n      );\n      return isFinite(sourceResolution) && sourceResolution > 0;\n    });\n  }\n\n  return sourceResolution;\n}\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"./extent.js\").Extent} extent Extent.\n * @property {import(\"./extent.js\").Extent} [clipExtent] Clip extent.\n * @property {import('./DataTile.js').ImageLike} image Image.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @param {boolean} [drawSingle] Draw single source images directly without stitchContext.\n * @param {boolean} [clipExtent] Clip stitchContext to sourceExtent.\n * @return {HTMLCanvasElement|OffscreenCanvas} Canvas with reprojected data.\n */\nexport function render(\n  width,\n  height,\n  pixelRatio,\n  sourceResolution,\n  sourceExtent,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  renderEdges,\n  interpolate,\n  drawSingle,\n  clipExtent,\n) {\n  const context = createCanvasContext2D(\n    Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height),\n    canvasPool,\n  );\n\n  if (!interpolate) {\n    context.imageSmoothingEnabled = false;\n  }\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  function pixelRound(value) {\n    return Math.round(value * pixelRatio) / pixelRatio;\n  }\n\n  context.globalCompositeOperation = 'lighter';\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  let stitchContext;\n  const stitchScale = pixelRatio / sourceResolution;\n  // Round up Float32 scale values to prevent interpolation in Firefox.\n  const inverseScale = (interpolate ? 1 : 1 + Math.pow(2, -24)) / stitchScale;\n\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\n    stitchContext = createCanvasContext2D(\n      Math.round(getWidth(sourceDataExtent) * stitchScale),\n      Math.round(getHeight(sourceDataExtent) * stitchScale),\n      canvasPool,\n    );\n\n    if (!interpolate) {\n      stitchContext.imageSmoothingEnabled = false;\n    }\n    if (sourceExtent && clipExtent) {\n      const xPos = (sourceExtent[0] - sourceDataExtent[0]) * stitchScale;\n      const yPos = -(sourceExtent[3] - sourceDataExtent[3]) * stitchScale;\n      const width = getWidth(sourceExtent) * stitchScale;\n      const height = getHeight(sourceExtent) * stitchScale;\n      stitchContext.rect(xPos, yPos, width, height);\n      stitchContext.clip();\n    }\n\n    sources.forEach(function (src, i, arr) {\n      // This test should never fail -- but it does. Need to find a fix the upstream condition\n      if (src.image.width > 0 && src.image.height > 0) {\n        if (src.clipExtent) {\n          stitchContext.save();\n          const xPos = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale;\n          const yPos = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale;\n          const width = getWidth(src.clipExtent) * stitchScale;\n          const height = getHeight(src.clipExtent) * stitchScale;\n          stitchContext.rect(\n            interpolate ? xPos : Math.round(xPos),\n            interpolate ? yPos : Math.round(yPos),\n            interpolate ? width : Math.round(xPos + width) - Math.round(xPos),\n            interpolate ? height : Math.round(yPos + height) - Math.round(yPos),\n          );\n          stitchContext.clip();\n        }\n\n        const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale;\n        const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale;\n        const srcWidth = getWidth(src.extent) * stitchScale;\n        const srcHeight = getHeight(src.extent) * stitchScale;\n        stitchContext.drawImage(\n          src.image,\n          gutter,\n          gutter,\n          src.image.width - 2 * gutter,\n          src.image.height - 2 * gutter,\n          interpolate ? xPos : Math.round(xPos),\n          interpolate ? yPos : Math.round(yPos),\n          interpolate\n            ? srcWidth\n            : Math.round(xPos + srcWidth) - Math.round(xPos),\n          interpolate\n            ? srcHeight\n            : Math.round(yPos + srcHeight) - Math.round(yPos),\n        );\n\n        if (src.clipExtent) {\n          stitchContext.restore();\n        }\n      }\n    });\n  }\n  const targetTopLeft = getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    const source = triangle.source;\n    const target = triangle.target;\n    let x0 = source[0][0],\n      y0 = source[0][1];\n    let x1 = source[1][0],\n      y1 = source[1][1];\n    let x2 = source[2][0],\n      y2 = source[2][1];\n    // Make sure that everything is on pixel boundaries\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n    const v0 = pixelRound(\n      -(target[0][1] - targetTopLeft[1]) / targetResolution,\n    );\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n    const v1 = pixelRound(\n      -(target[1][1] - targetTopLeft[1]) / targetResolution,\n    );\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n    const v2 = pixelRound(\n      -(target[2][1] - targetTopLeft[1]) / targetResolution,\n    );\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    const sourceNumericalShiftX = x0;\n    const sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    const augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0],\n    ];\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n\n    if (isBrokenDiagonalRendering() || !interpolate) {\n      // Make sure that all lines are horizontal or vertical\n      context.moveTo(u1, v1);\n      // This is the diagonal line. Do it in 4 steps\n      const steps = 4;\n      const ud = u0 - u1;\n      const vd = v0 - v1;\n      for (let step = 0; step < steps; step++) {\n        // Go horizontally\n        context.lineTo(\n          u1 + pixelRound(((step + 1) * ud) / steps),\n          v1 + pixelRound((step * vd) / (steps - 1)),\n        );\n        // Go vertically\n        if (step != steps - 1) {\n          context.lineTo(\n            u1 + pixelRound(((step + 1) * ud) / steps),\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1)),\n          );\n        }\n      }\n      // We are almost at u0r, v0r\n      context.lineTo(u2, v2);\n    } else {\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n    }\n\n    context.clip();\n\n    context.transform(\n      affineCoefs[0],\n      affineCoefs[2],\n      affineCoefs[1],\n      affineCoefs[3],\n      u0,\n      v0,\n    );\n\n    context.translate(\n      sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY,\n    );\n\n    let image;\n    if (stitchContext) {\n      image = stitchContext.canvas;\n      context.scale(inverseScale, -inverseScale);\n    } else {\n      const source = sources[0];\n      const extent = source.extent;\n      image = source.image;\n      context.scale(\n        getWidth(extent) / image.width,\n        -getHeight(extent) / image.height,\n      );\n    }\n\n    context.drawImage(image, 0, 0);\n    context.restore();\n  });\n\n  if (stitchContext) {\n    releaseCanvas(stitchContext);\n    canvasPool.push(stitchContext.canvas);\n  }\n\n  if (renderEdges) {\n    context.save();\n\n    context.globalCompositeOperation = 'source-over';\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const target = triangle.target;\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n","/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {modulo} from '../math.js';\nimport {\n  createTransformFromCoordinateTransform,\n  getTransform,\n  transform,\n} from '../proj.js';\nimport {apply as applyMatrix} from '../transform.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   * @param {import(\"../transform.js\").Transform} [sourceMatrix] Source transform matrix.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    destinationResolution,\n    sourceMatrix,\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = sourceMatrix\n      ? createTransformFromCoordinateTransform((input) =>\n          applyMatrix(\n            sourceMatrix,\n            transform(input, this.targetProj_, this.sourceProj_),\n          ),\n        )\n      : getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overall reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              Math.log2(\n                getArea(targetExtent) /\n                  (destinationResolution * destinationResolution * 256 * 256),\n              ),\n            ),\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision,\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0],\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach((triangle) => {\n        if (\n          Math.max(\n            triangle.source[0][0],\n            triangle.source[1][0],\n            triangle.source[2][0],\n          ) -\n            leftBound >\n          this.sourceWorldWidth_ / 2\n        ) {\n          const newTriangle = [\n            [triangle.source[0][0], triangle.source[0][1]],\n            [triangle.source[1][0], triangle.source[1][1]],\n            [triangle.source[2][0], triangle.source[2][1]],\n          ];\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          const minX = Math.min(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0],\n          );\n          const maxX = Math.max(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0],\n          );\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1,\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1,\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1,\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1,\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n","/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport const ERROR_THRESHOLD = 0.5;\n"],"names":["brokenDiagonalRendering_","canvasPool","drawTestTriangle","ctx","u1","v1","u2","v2","verifyBrokenDiagonalRendering","data","offset","isBrokenDiagonalRendering","createCanvasContext2D","releaseCanvas","calculateSourceResolution","sourceProj","targetProj","targetCenter","targetResolution","sourceCenter","transform","sourceResolution","getPointResolution","targetMetersPerUnit","sourceMetersPerUnit","sourceExtent","containsCoordinate","compensationFactor","calculateSourceExtentResolution","targetExtent","getCenter","forEachCorner","corner","render","width","height","pixelRatio","triangulation","sources","gutter","renderEdges","interpolate","drawSingle","clipExtent","context","pixelRound","value","sourceDataExtent","createEmpty","src","i","arr","extend","stitchContext","stitchScale","inverseScale","getWidth","getHeight","xPos","yPos","srcWidth","srcHeight","targetTopLeft","getTopLeft","triangle","source","target","x0","y0","x1","y1","x2","y2","u0","v0","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","solveLinearSystem","steps","ud","vd","step","image","extent","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","maxSourceExtent","errorThreshold","destinationResolution","sourceMatrix","transformInvCache","transformInv","createTransformFromCoordinateTransform","input","applyMatrix","getTransform","c","key","destinationTopLeft","destinationTopRight","getTopRight","destinationBottomRight","getBottomRight","destinationBottomLeft","getBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","getArea","leftBound","newTriangle","minX","a","b","aSrc","bSrc","cSrc","d","dSrc","sourceQuadExtent","boundingExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","targetQuadExtent","intersects","isNotFinite","center","centerSrc","dx","modulo","dy","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","extendCoordinate","ERROR_THRESHOLD"],"mappings":"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","x_google_ignoreList":[0,1,2]}