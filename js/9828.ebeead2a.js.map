{"version":3,"file":"js/9828.ebeead2a.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/renderer/canvas/TileLayer.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/TileProperty.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport DataTile, {asImageLike} from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport {toSize} from '../../size.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport {createOrUpdate as createTileCoord, getKeyZXY} from '../../tilecoord.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport CanvasLayerRenderer from './Layer.js';\n\n/**\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(sourceKey, z, x, y) {\n  return `${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default|null}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(\n        z,\n        x,\n        y,\n        frameState.pixelRatio,\n        frameState.viewState.projection,\n      );\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection) {\n      this.renderedProjection = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection) {\n      this.tileCache_.clear();\n      this.renderedProjection = frameState.viewState.projection;\n    }\n\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedRevision_) {\n      this.renderedRevision_ = sourceRevision;\n    } else if (this.renderedRevision_ !== sourceRevision) {\n      this.renderedRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    const rotation = viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          viewState.resolution,\n          rotation,\n          frameState.size,\n        )\n      : undefined;\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(staleKeys[i], z, x, y);\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.peek(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.peek(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    let allTilesIdle = true;\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  maybe skip transition when not fully opaque\n     *  decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(\n        frameExtent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          renderExtent,\n          z - 1,\n          tilesByZ,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (tileState === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      if (tileState !== TileState.IDLE) {\n        allTilesIdle = false;\n      }\n      if (tileState !== TileState.ERROR) {\n        this.renderComplete = false;\n      }\n\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tilesByZ,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tilesByZ,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (\n              intersects(\n                [x, y, x + w, y + h],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (this.renderComplete) {\n      /**\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = (map, frameState) => {\n        const tileSourceKey = getUid(tileSource);\n        const wantedTiles = frameState.wantedTiles[tileSourceKey];\n        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n        this.updateCacheSize(tilesCount);\n        this.tileCache_.expireCache();\n      };\n\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n    if (!this.renderComplete && !allTilesIdle) {\n      frameState.animate = true;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(\n      this.tileCache_.highWaterMark,\n      tileCount * 2,\n    );\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(\n        /** @type {import(\"../../ImageTile.js\").default} */ (tile),\n      );\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n","/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n"],"names":["getCacheKey","sourceKey","z","x","y","addTileToLookup","tilesByZ","tile","Set","set","existing","has","add","removeTileFromLookup","delete","getRenderExtent","frameState","extent","layerState","layerStatesArray","layerIndex","viewState","projection","source","layer","getRenderSource","getWrapX","gridExtent","getTileGridForProjection","getExtent","CanvasTileLayerRenderer","constructor","tileLayer","options","super","this","extentChanged","renderComplete","renderedExtent_","renderedPixelRatio","renderedProjection","renderedRevision_","renderedTiles","renderedSourceKey_","renderedSourceRevision_","tempExtent","tempTileRange_","tempTileCoord_","cacheSize","undefined","tileCache_","maxStaleKeys","getTileCache","getOrCreateTile","tileCache","getLayer","tileSource","getSource","cacheKey","getKey","containsKey","get","getTile","pixelRatio","getData","pixel","coordinate","pixelToCoordinateTransform","slice","layerExtent","tileGrid","tilePixelRatio","getTilePixelRatio","getZForResolution","resolution","getMinZoom","tileCoord","getTileCoordForCoordAndZ","getState","LOADED","tileOrigin","getOrigin","tileSize","getTileSize","tileResolution","getResolution","image","getImage","col","Math","floor","row","gutter","round","getGutterForProjection","getImageData","prepareFrame","clear","sourceRevision","getRevision","enqueueTiles","initialZ","preload","tileSourceKey","wantedTiles","map","getMapInternal","minZ","max","min","getMaxResolution","getView","getResolutionForZoom","zDirection","rotation","viewport","center","size","tileRange","getTileRangeForExtentAndZ","minX","maxX","minY","maxY","tileCoordIntersectsViewport","added","tileQueueKey","IDLE","tileQueue","isKeyQueued","enqueue","getTileCoordCenter","findStaleTile_","staleKeys","getStaleKeys","i","length","peek","endTransition","findAltTiles_","altZ","getTileRangeForTileCoordAndZ","covered","loaded","renderFrame","target","allTilesIdle","viewResolution","viewCenter","prependStaleKey","frameExtent","prepareContainer","width","context","canvas","height","dx","dy","canvasExtent","getPreload","nextExtent","targetZ","nextResolution","renderExtent","setTimeout","container","uid","time","tileState","EMPTY","alpha","getAlpha","ERROR","hasStaleTile","animate","coveredByChildren","minZoom","parentZ","coveredByParent","canvasScale","getRenderContext","tempTransform","clipUnrotated","getInterpolate","imageSmoothingEnabled","preRender","zs","Object","keys","Number","currentClip","sort","clips","clipZs","currentZ","currentTilePixelSize","getTilePixelSize","currentResolution","currentScale","originTileCoord","originTileExtent","getTileCoordExtent","origin","tileGutter","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","ii","clip","save","beginPath","moveTo","lineTo","push","drawTile","restore","unshift","updateUsedTiles","usedTiles","renderedResolution","postRender","postRenderFunction","tilesCount","updateCacheSize","expireCache","postRenderFunctions","tileCount","highWaterMark","Error","getTileImage","opacity","alphaChanged","globalAlpha","drawImage","PRELOAD","USE_INTERIM_TILES_ON_ERROR"],"sourceRoot":""}