{"version":3,"file":"js/2362.25b10200.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/renderer/webgl/PointsLayer.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/WebGLPoints.js","webpack://@radiantearth/stac-browser/./node_modules/ol/renderer/webgl/worldUtil.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport ViewHint from '../../ViewHint.js';\nimport {assert} from '../../asserts.js';\nimport {listen, unlistenByKey} from '../../events.js';\nimport {buffer, createEmpty, equals} from '../../extent.js';\nimport BaseVector from '../../layer/BaseVector.js';\nimport {fromUserCoordinate, getUserProjection} from '../../proj.js';\nimport {WebGLWorkerMessageType} from '../../render/webgl/constants.js';\nimport {colorDecodeId, colorEncodeId} from '../../render/webgl/encodeUtil.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport {AttributeType, DefaultUniform} from '../../webgl/Helper.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {getWorldParameters} from './worldUtil.js';\n\n/** @typedef {import(\"../../geom/Point.js\").default} Point */\n/** @typedef {import(\"../../Feature\").default<Point>} PointFeature */\n\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(PointFeature, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {PointFeature} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../coordinate.js\").Coordinate} flatCoordinates Point coordinates\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  In the vertex shader as an `attribute` by prefixing it with `a_`\n *  In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {boolean} [hitDetectionEnabled] Whether shader is hit detection aware.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nclass WebGLPointsLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    const projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    /**\n     * @private\n     */\n    this.sourceRevision_ = -1;\n\n    /**\n     * @private\n     */\n    this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    /**\n     * @private\n     */\n    this.indicesBuffer_ = new WebGLArrayBuffer(\n      ELEMENT_ARRAY_BUFFER,\n      DYNAMIC_DRAW,\n    );\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hitDetectionEnabled_ = options.hitDetectionEnabled ?? true;\n\n    const customAttributes = options.attributes\n      ? options.attributes.map(function (attribute) {\n          return {\n            name: 'a_' + attribute.name,\n            size: 1,\n            type: AttributeType.FLOAT,\n          };\n        })\n      : [];\n\n    /**\n     * A list of attributes used by the renderer. By default only the position and\n     * index of the vertex (0 to 3) are required.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.attributes = [\n      {\n        name: 'a_position',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_index',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ];\n\n    if (this.hitDetectionEnabled_) {\n      this.attributes.push({\n        name: 'a_hitColor',\n        size: 4,\n        type: AttributeType.FLOAT,\n      });\n      this.attributes.push({\n        name: 'a_featureUid',\n        size: 1,\n        type: AttributeType.FLOAT,\n      });\n    }\n    this.attributes.push(...customAttributes);\n\n    this.customAttributes = options.attributes ? options.attributes : [];\n\n    /**\n     * @private\n     */\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = projectionMatrixTransform;\n\n    /**\n     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.renderTransform_ = createTransform();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.invertRenderTransform_ = createTransform();\n\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n    this.renderInstructions_ = new Float32Array(0);\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    this.hitRenderTarget_;\n\n    /**\n     * Keep track of latest message sent to worker\n     * @type {number}\n     * @private\n     */\n    this.lastSentId = 0;\n\n    /**\n     * @private\n     */\n    this.worker_ = createWebGLWorker();\n\n    this.worker_.addEventListener(\n      'message',\n      /**\n       * @param {*} event Event.\n       */\n      (event) => {\n        const received = event.data;\n        if (received.type === WebGLWorkerMessageType.GENERATE_POINT_BUFFERS) {\n          const projectionTransform = received.projectionTransform;\n          this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n          this.helper.flushBufferData(this.verticesBuffer_);\n          this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n          this.helper.flushBufferData(this.indicesBuffer_);\n\n          this.renderTransform_ = projectionTransform;\n          makeInverseTransform(\n            this.invertRenderTransform_,\n            this.renderTransform_,\n          );\n          this.renderInstructions_ = new Float32Array(\n            event.data.renderInstructions,\n          );\n          if (received.id === this.lastSentId) {\n            this.ready = true;\n          }\n          this.getLayer().changed();\n        }\n      },\n    );\n\n    /**\n     * This object will be updated when the source changes. Key is uid.\n     * @type {Object<string, FeatureCacheItem>}\n     * @private\n     */\n    this.featureCache_ = {};\n\n    /**\n     * Amount of features in the cache.\n     * @type {number}\n     * @private\n     */\n    this.featureCount_ = 0;\n\n    const source = /** @type {import(\"../../source/Vector.js\").default} */ (\n      this.getLayer().getSource()\n    );\n    /**\n     * @private\n     */\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this,\n      ),\n    ];\n    source.forEachFeature((feature) => {\n      const geometry = feature.getGeometry();\n      if (geometry && geometry.getType() === 'Point') {\n        this.featureCache_[getUid(feature)] = {\n          feature: /** @type {PointFeature} */ (feature),\n          properties: feature.getProperties(),\n          flatCoordinates: /** @type {Point} */ (geometry).getFlatCoordinates(),\n        };\n        this.featureCount_++;\n      }\n    });\n  }\n\n  /**\n   * @override\n   */\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(\n      this.fragmentShader_,\n      this.vertexShader_,\n    );\n\n    if (this.hitDetectionEnabled_) {\n      this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n    }\n\n    // upload buffers again if any\n    if (this.verticesBuffer_.getArray()) {\n      this.helper.flushBufferData(this.verticesBuffer_);\n    }\n    if (this.indicesBuffer_.getArray()) {\n      this.helper.flushBufferData(this.indicesBuffer_);\n    }\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    const geometry = feature.getGeometry();\n    if (geometry && geometry.getType() === 'Point') {\n      this.featureCache_[getUid(feature)] = {\n        feature: /** @type {PointFeature} */ (feature),\n        properties: feature.getProperties(),\n        flatCoordinates: /** @type {Point} */ (geometry).getFlatCoordinates(),\n      };\n      this.featureCount_++;\n    }\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    const featureUid = getUid(feature);\n    const item = this.featureCache_[featureUid];\n    const geometry = feature.getGeometry();\n    if (item) {\n      if (geometry && geometry.getType() === 'Point') {\n        item.properties = feature.getProperties();\n        item.flatCoordinates = /** @type {Point} */ (\n          geometry\n        ).getFlatCoordinates();\n      } else {\n        delete this.featureCache_[featureUid];\n        this.featureCount_--;\n      }\n    } else {\n      if (geometry && geometry.getType() === 'Point') {\n        this.featureCache_[featureUid] = {\n          feature: /** @type {PointFeature} */ (feature),\n          properties: feature.getProperties(),\n          flatCoordinates: /** @type {Point} */ (geometry).getFlatCoordinates(),\n        };\n        this.featureCount_++;\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    const featureUid = getUid(feature);\n    if (featureUid in this.featureCache_) {\n      delete this.featureCache_[featureUid];\n      this.featureCount_--;\n    }\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.featureCache_ = {};\n    this.featureCount_ = 0;\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n    const [startWorld, endWorld, worldWidth] = getWorldParameters(\n      frameState,\n      this.getLayer(),\n    );\n\n    // draw the normal canvas\n    this.renderWorlds(frameState, false, startWorld, endWorld, worldWidth);\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent,\n    );\n\n    if (this.hitDetectionEnabled_) {\n      // draw the hit buffer\n      this.renderWorlds(frameState, true, startWorld, endWorld, worldWidth);\n      this.hitRenderTarget_.clearCachedData();\n    }\n\n    this.postRender(gl, frameState);\n\n    const canvas = this.helper.getCanvas();\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n\n      this.rebuildBuffers_(frameState);\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    this.helper.useProgram(this.program_, frameState);\n    this.helper.prepareDraw(frameState);\n\n    // write new data\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n\n    return true;\n  }\n\n  /**\n   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  rebuildBuffers_(frameState) {\n    // saves the projection transform for the current frame state\n    const projectionTransform = createTransform();\n    this.helper.makeProjectionTransform(frameState, projectionTransform);\n\n    const userProjection = getUserProjection();\n\n    const baseInstructionLength = this.hitDetectionEnabled_ ? 7 : 2; // see below\n    const singleInstructionLength =\n      baseInstructionLength + this.customAttributes.length;\n    const totalSize = singleInstructionLength * this.featureCount_;\n    const renderInstructions =\n      this.renderInstructions_ && this.renderInstructions_.length === totalSize\n        ? this.renderInstructions_\n        : new Float32Array(totalSize);\n    this.renderInstructions_ = null;\n\n    // loop over features to fill the buffer\n    /** @type {import('../../coordinate.js').Coordinate} */\n    let tmpCoords = [];\n    /** @type {Array<number>} */\n    const tmpColor = [];\n    let idx = -1;\n    const projection = frameState.viewState.projection;\n    for (const featureUid in this.featureCache_) {\n      const featureCache = this.featureCache_[featureUid];\n      if (userProjection) {\n        tmpCoords = fromUserCoordinate(\n          featureCache.flatCoordinates,\n          projection,\n        );\n      } else {\n        tmpCoords[0] = featureCache.flatCoordinates[0];\n        tmpCoords[1] = featureCache.flatCoordinates[1];\n      }\n      applyTransform(projectionTransform, tmpCoords);\n\n      renderInstructions[++idx] = tmpCoords[0];\n      renderInstructions[++idx] = tmpCoords[1];\n\n      // for hit detection, the feature uid is saved in the opacity value\n      // and the index of the opacity value is encoded in the color values\n      if (this.hitDetectionEnabled_) {\n        const hitColor = colorEncodeId(idx + 5, tmpColor);\n        renderInstructions[++idx] = hitColor[0];\n        renderInstructions[++idx] = hitColor[1];\n        renderInstructions[++idx] = hitColor[2];\n        renderInstructions[++idx] = hitColor[3];\n        renderInstructions[++idx] = Number(featureUid);\n      }\n\n      // pushing custom attributes\n      for (let j = 0; j < this.customAttributes.length; j++) {\n        const value = this.customAttributes[j].callback(\n          featureCache.feature,\n          featureCache.properties,\n        );\n        renderInstructions[++idx] = value;\n      }\n    }\n\n    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: ++this.lastSentId,\n      type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,\n      renderInstructions: renderInstructions.buffer,\n      customAttributesSize: singleInstructionLength - 2,\n    };\n    // additional properties will be sent back as-is by the worker\n    message['projectionTransform'] = projectionTransform;\n    this.ready = false;\n    this.worker_.postMessage(message, [renderInstructions.buffer]);\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    assert(\n      this.hitDetectionEnabled_,\n      '`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option.',\n    );\n    if (!this.renderInstructions_ || !this.hitDetectionEnabled_) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(\n      frameState.coordinateToPixelTransform,\n      coordinate.slice(),\n    );\n\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const index = colorDecodeId(color);\n    const opacity = this.renderInstructions_[index];\n    const uid = Math.floor(opacity).toString();\n\n    const source = this.getLayer().getSource();\n    const feature = source.getFeatureByUid(uid);\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n    return undefined;\n  }\n\n  /**\n   * Render the world, either to the main framebuffer or to the hit framebuffer\n   * @param {import(\"../../Map.js\").FrameState} frameState current frame state\n   * @param {boolean} forHitDetection whether the rendering is for hit detection\n   * @param {number} startWorld the world to render in the first iteration\n   * @param {number} endWorld the last world to render\n   * @param {number} worldWidth the width of the worlds being rendered\n   */\n  renderWorlds(frameState, forHitDetection, startWorld, endWorld, worldWidth) {\n    let world = startWorld;\n\n    this.helper.useProgram(this.program_, frameState);\n\n    if (forHitDetection) {\n      this.hitRenderTarget_.setSize([\n        Math.floor(frameState.size[0] / 2),\n        Math.floor(frameState.size[1] / 2),\n      ]);\n      this.helper.prepareDrawToRenderTarget(\n        frameState,\n        this.hitRenderTarget_,\n        true,\n      );\n    }\n\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n\n    do {\n      this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n      translateTransform(this.currentTransform_, world * worldWidth, 0);\n      multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n      this.helper.applyUniforms(frameState);\n      this.helper.applyHitDetectionUniform(forHitDetection);\n      const renderCount = this.indicesBuffer_.getSize();\n      this.helper.drawElements(0, renderCount);\n    } while (++world < endWorld);\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n\n  renderDeclutter() {}\n}\n\nexport default WebGLPointsLayerRenderer;\n","/**\n * @module ol/layer/WebGLPoints\n */\nimport {parseLiteralStyle} from '../render/webgl/style.js';\nimport WebGLPointsLayerRenderer from '../renderer/webgl/PointsLayer.js';\nimport Layer from './Layer.js';\n\n/**\n * @template {import(\"../source/Vector.js\").default<import('../Feature').FeatureLike>} VectorSourceType\n * @typedef {Object} Options\n * @property {import('../style/flat.js').FlatStyle} style Literal style to apply to the layer features.\n * @property {import(\"../expr/expression.js\").EncodedExpression} [filter] The filter used\n * to determine if a style applies. If no filter is included, the rule always applies.\n * @property {import('../style/flat.js').StyleVariables} [variables] Style variables. Each variable must hold a literal value (not\n * an expression). These variables can be used as {@link import(\"../expr/expression.js\").ExpressionValue expressions} in the styles properties\n * using the `['var', 'varName']` operator.\n * To update style variables, use the {@link import(\"./WebGLPoints.js\").default#updateStyleVariables} method.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {VectorSourceType} [source] Point source.\n * @property {boolean} [disableHitDetection=false] Setting this to true will provide a slight performance boost, but will\n * prevent all hit detection on the layer.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Layer optimized for rendering large point datasets. Takes a `style` property which\n * is a serializable JSON object describing how the layer should be rendered.\n *\n * Here are a few samples of literal style objects:\n * ```js\n * const style = {\n *   'circle-radius': 8,\n *   'circle-fill-color': '#33AAFF',\n *   'circle-opacity': 0.9\n * }\n * ```\n *\n * ```js\n * const style = {\n *   'icon-src': '../static/exclamation-mark.png',\n *   'icon-offset': [0, 12],\n *   'icon-width': 4,\n *   'icon-height': 8\n * }\n * ```\n *\n * **Important: a `WebGLPoints` layer must be manually disposed when removed, otherwise the underlying WebGL context\n * will not be garbage collected.**\n *\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Vector.js\").default<import('../Feature').FeatureLike>} VectorSourceType\n * @extends {Layer<VectorSourceType, WebGLPointsLayerRenderer>}\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\n * @deprecated Use ol/layer/WebGLVector instead\n */\nclass WebGLPointsLayer extends Layer {\n  /**\n   * @param {Options<VectorSourceType>} options Options.\n   */\n  constructor(options) {\n    const baseOptions = Object.assign({}, options);\n\n    super(baseOptions);\n\n    /**\n     * @type {import('../style/flat.js').StyleVariables}\n     * @private\n     */\n    this.styleVariables_ = options.variables || {};\n\n    /**\n     * @private\n     * @type {import('../render/webgl/style.js').StyleParseResult}\n     */\n    this.parseResult_ = parseLiteralStyle(\n      options.style,\n      this.styleVariables_,\n      options.filter,\n    );\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hitDetectionDisabled_ = !!options.disableHitDetection;\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    const attributes = Object.keys(this.parseResult_.attributes).map(\n      (name) => ({\n        name,\n        ...this.parseResult_.attributes[name],\n      }),\n    );\n    return new WebGLPointsLayerRenderer(this, {\n      vertexShader: this.parseResult_.builder.getSymbolVertexShader(),\n      fragmentShader: this.parseResult_.builder.getSymbolFragmentShader(),\n      hitDetectionEnabled: !this.hitDetectionDisabled_,\n      uniforms: this.parseResult_.uniforms,\n      attributes:\n        /** @type {Array<import('../renderer/webgl/PointsLayer.js').CustomAttribute>} */ (\n          attributes\n        ),\n    });\n  }\n\n  /**\n   * Update any variables used by the layer style and trigger a re-render.\n   * @param {Object<string, number>} variables Variables to update.\n   */\n  updateStyleVariables(variables) {\n    Object.assign(this.styleVariables_, variables);\n    this.changed();\n  }\n}\n\nexport default WebGLPointsLayer;\n","import {getWidth} from '../../extent.js';\n\n/**\n * Compute world params\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {any} layer The layer\n * @return {Array<number>} The world start, end and width.\n */\nexport function getWorldParameters(frameState, layer) {\n  const projection = frameState.viewState.projection;\n\n  const vectorSource = layer.getSource();\n  const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n  const projectionExtent = projection.getExtent();\n\n  const extent = frameState.extent;\n  const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n  const endWorld = multiWorld\n    ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n    : 1;\n\n  const startWorld = multiWorld\n    ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n    : 0;\n\n  return [startWorld, endWorld, worldWidth];\n}\n"],"names":["WebGLPointsLayerRenderer","constructor","layer","options","uniforms","projectionMatrixTransform","PROJECTION_MATRIX","super","postProcesses","this","sourceRevision_","verticesBuffer_","indicesBuffer_","vertexShader_","vertexShader","fragmentShader_","fragmentShader","program_","hitDetectionEnabled_","hitDetectionEnabled","customAttributes","attributes","map","attribute","name","size","type","FLOAT","push","previousExtent_","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","Float32Array","hitRenderTarget_","lastSentId","worker_","addEventListener","event","received","data","GENERATE_POINT_BUFFERS","projectionTransform","fromArrayBuffer","vertexBuffer","helper","flushBufferData","indexBuffer","renderInstructions","id","ready","getLayer","changed","featureCache_","featureCount_","source","getSource","sourceListenKeys_","VectorEventType","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","forEachFeature","feature","geometry","getGeometry","getType","properties","getProperties","flatCoordinates","getFlatCoordinates","afterHelperCreated","getProgram","getArray","featureUid","item","renderFrame","frameState","gl","getGL","preRender","startWorld","endWorld","worldWidth","renderWorlds","finalizeDraw","dispatchPreComposeEvent","dispatchPostComposeEvent","clearCachedData","postRender","canvas","getCanvas","prepareFrameInternal","vectorSource","viewState","viewNotMoving","viewHints","ViewHint","ANIMATING","INTERACTING","extentChanged","extent","sourceChanged","getRevision","projection","resolution","renderBuffer","BaseVector","getRenderBuffer","loadFeatures","rebuildBuffers_","slice","useProgram","prepareDraw","bindBuffer","enableAttributes","makeProjectionTransform","userProjection","baseInstructionLength","singleInstructionLength","length","totalSize","tmpCoords","tmpColor","idx","featureCache","hitColor","Number","j","value","callback","message","buffer","customAttributesSize","postMessage","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","pixel","coordinateToPixelTransform","readPixel","color","index","opacity","uid","Math","floor","toString","getFeatureByUid","forHitDetection","world","setSize","prepareDrawToRenderTarget","applyUniforms","applyHitDetectionUniform","renderCount","getSize","drawElements","disposeInternal","terminate","forEach","key","renderDeclutter","WebGLPointsLayer","baseOptions","Object","assign","styleVariables_","variables","parseResult_","style","filter","hitDetectionDisabled_","disableHitDetection","createRenderer","keys","builder","getSymbolVertexShader","getSymbolFragmentShader","updateStyleVariables","getWorldParameters","multiWorld","getWrapX","canWrapX","projectionExtent","getExtent","ceil"],"sourceRoot":""}