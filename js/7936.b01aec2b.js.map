{"version":3,"file":"js/7936.b01aec2b.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/Tile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/structs/LRUCache.js","webpack://@radiantearth/stac-browser/./node_modules/ol/net.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/UTFGrid.js"],"sourcesContent":["/**\n * @module ol/Tile\n */\nimport TileState from './TileState.js';\nimport {easeIn} from './easing.js';\nimport EventType from './events/EventType.js';\nimport EventTarget from './events/Target.js';\nimport {abstract} from './util.js';\n\n/**\n * A function that takes a {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState.js';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   const xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     const data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes a {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * A key assigned to the tile. This is used in conjunction with a source key\n     * to determine if a cached version of this tile may be used by the renderer.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @private\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n\n    /**\n     * @type {boolean}\n     */\n    this.interpolate = !!options.interpolate;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {\n    // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`\n    this.setState(TileState.EMPTY);\n  }\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state === TileState.EMPTY) {\n      // no more state changes\n      return;\n    }\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    this.release();\n    super.disposeInternal();\n  }\n}\n\nexport default Tile;\n","/**\n * @module ol/structs/LRUCache\n */\n\nimport Disposable from '../Disposable.js';\nimport {assert} from '../asserts.js';\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Entry|null} newer Newer.\n * @property {Entry|null} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nclass LRUCache {\n  /**\n   * @param {number} [highWaterMark] High water mark.\n   */\n  constructor(highWaterMark) {\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n\n  deleteOldest() {\n    const entry = this.pop();\n    if (entry instanceof Disposable) {\n      entry.dispose();\n    }\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  }\n\n  /**\n   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},\n   * the entry will be disposed.\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n   */\n  expireCache(keep) {\n    while (this.canExpireCache()) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    while (this.oldest_) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  }\n\n  /**\n   * @param {function(T, string, LRUCache<T>): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   */\n  forEach(f) {\n    let entry = this.oldest_;\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {*} [options] Options (reserved for subclasses).\n   * @return {T} Value.\n   */\n  get(key, options) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      return entry.value_;\n    }\n    if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  }\n\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  remove(key) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {Entry} */ (entry.older);\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.count_;\n  }\n\n  /**\n   * @return {Array<string>} Keys.\n   */\n  getKeys() {\n    const keys = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  }\n\n  /**\n   * @return {Array<T>} Values.\n   */\n  getValues() {\n    const values = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  }\n\n  /**\n   * @return {T} Last value.\n   */\n  peekLast() {\n    return this.oldest_.value_;\n  }\n\n  /**\n   * @return {string} Last key.\n   */\n  peekLastKey() {\n    return this.oldest_.key_;\n  }\n\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  peekFirstKey() {\n    return this.newest_.key_;\n  }\n\n  /**\n   * Return an entry without updating least recently used time.\n   * @param {string} key Key.\n   * @return {T|undefined} Value.\n   */\n  peek(key) {\n    return this.entries_[key]?.value_;\n  }\n\n  /**\n   * @return {T} value Value.\n   */\n  pop() {\n    const entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  replace(key, value) {\n    this.get(key); // update `newest_`\n    this.entries_[key].value_ = value;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  set(key, value) {\n    assert(\n      !(key in this.entries_),\n      'Tried to set a value for a key that is used already',\n    );\n    const entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value,\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  }\n\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n  setSize(size) {\n    this.highWaterMark = size;\n  }\n}\n\nexport default LRUCache;\n","/**\n * @module ol/net\n */\nimport {getUid} from './util.js';\n\n/**\n * Simple JSONP helper. Supports error callbacks and a custom callback param.\n * The error callback will be called when no JSONP is executed after 10 seconds.\n *\n * @param {string} url Request url. A 'callback' query parameter will be\n *     appended.\n * @param {Function} callback Callback on success.\n * @param {Function} [errback] Callback on error.\n * @param {string} [callbackParam] Custom query parameter for the JSONP\n *     callback. Default is 'callback'.\n */\nexport function jsonp(url, callback, errback, callbackParam) {\n  const script = document.createElement('script');\n  const key = 'olc_' + getUid(callback);\n  function cleanup() {\n    delete window[key];\n    script.parentNode.removeChild(script);\n  }\n  script.async = true;\n  script.src =\n    url +\n    (url.includes('?') ? '&' : '?') +\n    (callbackParam || 'callback') +\n    '=' +\n    key;\n  const timer = setTimeout(function () {\n    cleanup();\n    if (errback) {\n      errback();\n    }\n  }, 10000);\n  window[key] = function (data) {\n    clearTimeout(timer);\n    cleanup();\n    callback(data);\n  };\n  document.head.appendChild(script);\n}\n\nexport class ResponseError extends Error {\n  /**\n   * @param {XMLHttpRequest} response The XHR object.\n   */\n  constructor(response) {\n    const message = 'Unexpected response status: ' + response.status;\n    super(message);\n\n    /**\n     * @type {string}\n     */\n    this.name = 'ResponseError';\n\n    /**\n     * @type {XMLHttpRequest}\n     */\n    this.response = response;\n  }\n}\n\nexport class ClientError extends Error {\n  /**\n   * @param {XMLHttpRequest} client The XHR object.\n   */\n  constructor(client) {\n    super('Failed to issue request');\n\n    /**\n     * @type {string}\n     */\n    this.name = 'ClientError';\n\n    /**\n     * @type {XMLHttpRequest}\n     */\n    this.client = client;\n  }\n}\n\n/**\n * @param {string} url The URL.\n * @return {Promise<Object>} A promise that resolves to the JSON response.\n */\nexport function getJSON(url) {\n  return new Promise(function (resolve, reject) {\n    /**\n     * @param {ProgressEvent<XMLHttpRequest>} event The load event.\n     */\n    function onLoad(event) {\n      const client = event.target;\n      // status will be 0 for file:// urls\n      if (!client.status || (client.status >= 200 && client.status < 300)) {\n        let data;\n        try {\n          data = JSON.parse(client.responseText);\n        } catch (err) {\n          const message = 'Error parsing response text as JSON: ' + err.message;\n          reject(new Error(message));\n          return;\n        }\n        resolve(data);\n        return;\n      }\n\n      reject(new ResponseError(client));\n    }\n\n    /**\n     * @param {ProgressEvent<XMLHttpRequest>} event The error event.\n     */\n    function onError(event) {\n      reject(new ClientError(event.target));\n    }\n\n    const client = new XMLHttpRequest();\n    client.addEventListener('load', onLoad);\n    client.addEventListener('error', onError);\n    client.open('GET', url);\n    client.setRequestHeader('Accept', 'application/json');\n    client.send();\n  });\n}\n\n/**\n * @param {string} base The base URL.\n * @param {string} url The potentially relative URL.\n * @return {string} The full URL.\n */\nexport function resolveUrl(base, url) {\n  if (url.includes('://')) {\n    return url;\n  }\n  return new URL(url, base).href;\n}\n\nlet originalXHR;\nexport function overrideXHR(xhr) {\n  if (typeof XMLHttpRequest !== 'undefined') {\n    originalXHR = XMLHttpRequest;\n  }\n  global.XMLHttpRequest = xhr;\n}\n\nexport function restoreXHR() {\n  global.XMLHttpRequest = originalXHR;\n}\n","/**\n * @module ol/source/UTFGrid\n */\n\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport EventType from '../events/EventType.js';\nimport {listenOnce} from '../events.js';\nimport {applyTransform, intersects} from '../extent.js';\nimport {jsonp as requestJSONP} from '../net.js';\nimport {get as getProjection, getTransformFromProjections} from '../proj.js';\nimport LRUCache from '../structs/LRUCache.js';\nimport {getKeyZXY} from '../tilecoord.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\nimport {createFromTemplates, nullTileUrlFunction} from '../tileurlfunction.js';\nimport TileSource from './Tile.js';\n\n/**\n * @typedef {Object} UTFGridJSON\n * @property {Array<string>} grid The grid.\n * @property {Array<string>} keys The keys.\n * @property {Object<string, Object>} [data] Optional data.\n */\n\nexport class CustomTile extends Tile {\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {import(\"../extent.js\").Extent} extent Extent of the tile.\n   * @param {boolean} preemptive Load the tile when visible (before it's needed).\n   * @param {boolean} jsonp Load the tile as a script.\n   */\n  constructor(tileCoord, state, src, extent, preemptive, jsonp) {\n    super(tileCoord, state);\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = extent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ = preemptive;\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.grid_ = null;\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.keys_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, Object>|undefined}\n     */\n    this.data_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = jsonp;\n  }\n\n  /**\n   * Get the image element for this tile.\n   * @return {HTMLImageElement} Image.\n   */\n  getImage() {\n    return null;\n  }\n\n  /**\n   * Synchronously returns data at given coordinate (if available).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {*} The data.\n   */\n  getData(coordinate) {\n    if (!this.grid_ || !this.keys_) {\n      return null;\n    }\n    const xRelative =\n      (coordinate[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]);\n    const yRelative =\n      (coordinate[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]);\n\n    const row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];\n\n    if (typeof row !== 'string') {\n      return null;\n    }\n\n    let code = row.charCodeAt(Math.floor(xRelative * row.length));\n    if (code >= 93) {\n      code--;\n    }\n    if (code >= 35) {\n      code--;\n    }\n    code -= 32;\n\n    let data = null;\n    if (code in this.keys_) {\n      const id = this.keys_[code];\n      if (this.data_ && id in this.data_) {\n        data = this.data_[id];\n      } else {\n        data = id;\n      }\n    }\n    return data;\n  }\n\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate (or `null` if not yet loaded).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean} [request] If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   */\n  forDataAtCoordinate(coordinate, callback, request) {\n    if (this.state == TileState.EMPTY && request === true) {\n      this.state = TileState.IDLE;\n      listenOnce(this, EventType.CHANGE, (e) => {\n        callback(this.getData(coordinate));\n      });\n      this.loadInternal_();\n    } else {\n      if (request === true) {\n        setTimeout(() => {\n          callback(this.getData(coordinate));\n        }, 0);\n      } else {\n        callback(this.getData(coordinate));\n      }\n    }\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   * @override\n   */\n  getKey() {\n    return this.src_;\n  }\n\n  /**\n   * @private\n   */\n  handleError_() {\n    this.state = TileState.ERROR;\n    this.changed();\n  }\n\n  /**\n   * @param {!UTFGridJSON} json UTFGrid data.\n   * @private\n   */\n  handleLoad_(json) {\n    this.grid_ = json['grid'];\n    this.keys_ = json['keys'];\n    this.data_ = json['data'];\n\n    this.state = TileState.LOADED;\n    this.changed();\n  }\n\n  /**\n   * @private\n   */\n  loadInternal_() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      if (this.jsonp_) {\n        requestJSONP(\n          this.src_,\n          this.handleLoad_.bind(this),\n          this.handleError_.bind(this),\n        );\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', this.src_);\n        client.send();\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {!UTFGridJSON} */ (\n          JSON.parse(client.responseText)\n        );\n      } catch {\n        this.handleError_();\n        return;\n      }\n      this.handleLoad_(response);\n    } else {\n      this.handleError_();\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleError_();\n  }\n\n  /**\n   * @override\n   */\n  load() {\n    if (this.preemptive_) {\n      this.loadInternal_();\n    } else {\n      this.setState(TileState.EMPTY);\n    }\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [preemptive=true]\n * If `true` the UTFGrid source loads the tiles based on their \"visibility\".\n * This improves the speed of response, but increases traffic.\n * Note that if set to `false` (lazy loading), you need to pass `true` as\n * `request` to the `forDataAtCoordinateAndResolution` method otherwise no\n * data will ever be loaded.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {import(\"./TileJSON.js\").Config} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {string} [url] TileJSON endpoint that provides the configuration for this source.\n * Request will be made through JSONP. If not provided, `tileJSON` must be configured.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for UTFGrid interaction data loaded from TileJSON format.\n * @api\n */\nclass UTFGrid extends TileSource {\n  /**\n   * @param {Options} options Source options.\n   */\n  constructor(options) {\n    super({\n      projection: getProjection('EPSG:3857'),\n      state: 'loading',\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ =\n      options.preemptive !== undefined ? options.preemptive : true;\n\n    /**\n     * @private\n     * @type {!import(\"../Tile.js\").UrlFunction}\n     */\n    this.tileUrlFunction_ = nullTileUrlFunction;\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.template_ = undefined;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = options.jsonp || false;\n\n    /**\n     * @private\n     * @type {LRUCache}\n     */\n    this.tileCache_ = new LRUCache(512);\n\n    if (options.url) {\n      if (this.jsonp_) {\n        requestJSONP(\n          options.url,\n          this.handleTileJSONResponse.bind(this),\n          this.handleTileJSONError.bind(this),\n        );\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', options.url);\n        client.send();\n      }\n    } else if (options.tileJSON) {\n      this.handleTileJSONResponse(options.tileJSON);\n    } else {\n      throw new Error('Either `url` or `tileJSON` options must be provided');\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {import(\"./TileJSON.js\").Config} */ (\n          JSON.parse(client.responseText)\n        );\n      } catch {\n        this.handleTileJSONError();\n        return;\n      }\n      this.handleTileJSONResponse(response);\n    } else {\n      this.handleTileJSONError();\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleTileJSONError();\n  }\n\n  /**\n   * Return the template from TileJSON.\n   * @return {string|undefined} The template from TileJSON.\n   * @api\n   */\n  getTemplate() {\n    return this.template_;\n  }\n\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate and resolution (or `null` if not yet loaded or\n   * in case of an error).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean} [request] If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   * @api\n   */\n  forDataAtCoordinateAndResolution(coordinate, resolution, callback, request) {\n    if (this.tileGrid) {\n      const z = this.tileGrid.getZForResolution(resolution, this.zDirection);\n      const tileCoord = this.tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = /** @type {!CustomTile} */ (\n        this.getTile(\n          tileCoord[0],\n          tileCoord[1],\n          tileCoord[2],\n          1,\n          this.getProjection(),\n        )\n      );\n      if (tile.getState() == TileState.IDLE) {\n        tile.load();\n      }\n      tile.forDataAtCoordinate(coordinate, callback, request);\n    } else {\n      if (request === true) {\n        setTimeout(function () {\n          callback(null);\n        }, 0);\n      } else {\n        callback(null);\n      }\n    }\n  }\n\n  /**\n   * @protected\n   */\n  handleTileJSONError() {\n    this.setState('error');\n  }\n\n  /**\n   * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse\n   * @protected\n   * @param {import(\"./TileJSON.js\").Config} tileJSON Tile JSON.\n   */\n  handleTileJSONResponse(tileJSON) {\n    const epsg4326Projection = getProjection('EPSG:4326');\n\n    const sourceProjection = this.getProjection();\n    let extent;\n    if (tileJSON['bounds'] !== undefined) {\n      const transform = getTransformFromProjections(\n        epsg4326Projection,\n        sourceProjection,\n      );\n      extent = applyTransform(tileJSON['bounds'], transform);\n    }\n\n    const gridExtent = extentFromProjection(sourceProjection);\n    const minZoom = tileJSON['minzoom'] || 0;\n    const maxZoom = tileJSON['maxzoom'] || 22;\n    const tileGrid = createXYZ({\n      extent: gridExtent,\n      maxZoom: maxZoom,\n      minZoom: minZoom,\n    });\n    this.tileGrid = tileGrid;\n\n    this.template_ = tileJSON['template'];\n\n    const grids = tileJSON['grids'];\n    if (!grids) {\n      this.setState('error');\n      return;\n    }\n\n    this.tileUrlFunction_ = createFromTemplates(grids, tileGrid);\n\n    if (tileJSON['attribution']) {\n      const attributionExtent = extent !== undefined ? extent : gridExtent;\n      this.setAttributions(function (frameState) {\n        if (intersects(attributionExtent, frameState.extent)) {\n          return [tileJSON['attribution']];\n        }\n        return null;\n      });\n    }\n\n    this.setState('ready');\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!CustomTile} Tile.\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tileCoord = [z, x, y];\n    const urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection,\n    );\n    const tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);\n    const tileKey = `${this.getKey()},${getKeyZXY(z, x, y)}`;\n    if (this.tileCache_.containsKey(tileKey)) {\n      return this.tileCache_.get(tileKey);\n    }\n    this.tileCache_.expireCache();\n    const tile = new CustomTile(\n      tileCoord,\n      tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\n      tileUrl !== undefined ? tileUrl : '',\n      this.tileGrid.getTileCoordExtent(tileCoord),\n      this.preemptive_,\n      this.jsonp_,\n    );\n    this.tileCache_.set(tileKey, tile);\n    return tile;\n  }\n}\n\nexport default UTFGrid;\n"],"names":["Tile","constructor","tileCoord","state","options","super","this","key","transition_","undefined","transition","transitionStarts_","interpolate","changed","dispatchEvent","CHANGE","release","setState","EMPTY","getKey","getTileCoord","getState","ERROR","Error","load","getAlpha","id","time","start","delta","inTransition","endTransition","disposeInternal","LRUCache","highWaterMark","count_","entries_","oldest_","newest_","deleteOldest","entry","pop","dispose","canExpireCache","getCount","expireCache","keep","clear","containsKey","hasOwnProperty","forEach","f","value_","key_","newer","get","older","remove","getKeys","keys","Array","i","getValues","values","peekLast","peekLastKey","peekFirstKey","peek","replace","value","set","setSize","size","jsonp","url","callback","errback","callbackParam","script","document","createElement","cleanup","window","parentNode","removeChild","async","src","includes","timer","setTimeout","data","clearTimeout","head","appendChild","ResponseError","response","message","status","name","ClientError","client","getJSON","Promise","resolve","reject","onLoad","event","target","JSON","parse","responseText","err","onError","XMLHttpRequest","addEventListener","open","setRequestHeader","send","resolveUrl","base","URL","href","CustomTile","extent","preemptive","src_","extent_","preemptive_","grid_","keys_","data_","jsonp_","getImage","getData","coordinate","xRelative","yRelative","row","Math","floor","length","code","charCodeAt","forDataAtCoordinate","request","IDLE","e","loadInternal_","handleError_","handleLoad_","json","LOADED","LOADING","bind","onXHRLoad_","onXHRError_","UTFGrid","projection","wrapX","zDirection","tileUrlFunction_","template_","tileCache_","handleTileJSONResponse","handleTileJSONError","tileJSON","getTemplate","forDataAtCoordinateAndResolution","resolution","tileGrid","z","getZForResolution","getTileCoordForCoordAndZ","tile","getTile","getProjection","epsg4326Projection","sourceProjection","transform","gridExtent","minZoom","maxZoom","grids","attributionExtent","setAttributions","frameState","x","y","pixelRatio","urlTileCoord","getTileCoordForTileUrlFunction","tileUrl","tileKey","getTileCoordExtent"],"sourceRoot":""}