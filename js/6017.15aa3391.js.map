{"version":3,"file":"js/6017.15aa3391.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/tilegrid.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/Tile.js"],"sourcesContent":["/**\n * @module ol/tilegrid\n */\nimport {\n  containsCoordinate,\n  createOrUpdate,\n  getCorner,\n  getHeight,\n  getWidth,\n} from './extent.js';\nimport {METERS_PER_UNIT, get as getProjection} from './proj.js';\nimport {toSize} from './size.js';\nimport TileGrid from './tilegrid/TileGrid.js';\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\n\nexport {TileGrid};\nexport {default as WMTS} from './tilegrid/WMTS.js';\n\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n  let tileGrid = projection.getDefaultTileGrid();\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n  return tileGrid;\n}\n\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n  const z = tileCoord[0];\n  const center = tileGrid.getTileCoordCenter(tileCoord);\n  const projectionExtent = extentFromProjection(projection);\n  if (!containsCoordinate(projectionExtent, center)) {\n    const worldWidth = getWidth(projectionExtent);\n    const worldsAway = Math.ceil(\n      (projectionExtent[0] - center[0]) / worldWidth,\n    );\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\n  }\n  return tileCoord;\n}\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, maxZoom, tileSize, corner) {\n  corner = corner !== undefined ? corner : 'top-left';\n\n  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);\n\n  return new TileGrid({\n    extent: extent,\n    origin: getCorner(extent, corner),\n    resolutions: resolutions,\n    tileSize: tileSize,\n  });\n}\n\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions} [options] Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(options) {\n  const xyzOptions = options || {};\n\n  const extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n\n  const gridOptions = {\n    extent: extent,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(\n      extent,\n      xyzOptions.maxZoom,\n      xyzOptions.tileSize,\n      xyzOptions.maxResolution,\n    ),\n  };\n  return new TileGrid(gridOptions);\n}\n\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number} [maxResolution] Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {\n  maxZoom = maxZoom !== undefined ? maxZoom : DEFAULT_MAX_ZOOM;\n  tileSize = toSize(tileSize !== undefined ? tileSize : DEFAULT_TILE_SIZE);\n\n  const height = getHeight(extent);\n  const width = getWidth(extent);\n\n  maxResolution =\n    maxResolution > 0\n      ? maxResolution\n      : Math.max(width / tileSize[0], height / tileSize[1]);\n\n  const length = maxZoom + 1;\n  const resolutions = new Array(length);\n  for (let z = 0; z < length; ++z) {\n    resolutions[z] = maxResolution / Math.pow(2, z);\n  }\n  return resolutions;\n}\n\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, maxZoom, tileSize, corner) {\n  const extent = extentFromProjection(projection);\n  return createForExtent(extent, maxZoom, tileSize, corner);\n}\n\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n  projection = getProjection(projection);\n  let extent = projection.getExtent();\n  if (!extent) {\n    const half =\n      (180 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit();\n    extent = createOrUpdate(-half, -half, half, half);\n  }\n  return extent;\n}\n","/**\n * @module ol/source/Tile\n */\nimport Event from '../events/Event.js';\nimport {scale as scaleSize, toSize} from '../size.js';\nimport {withinExtentAndZ} from '../tilecoord.js';\nimport {\n  getForProjection as getTileGridForProjection,\n  wrapX,\n} from '../tilegrid.js';\nimport {abstract, getUid} from '../util.js';\nimport Source from './Source.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./TileEventType\").TileSourceEventTypes, TileSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     import(\"./TileEventType\").TileSourceEventTypes, Return>} TileSourceOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./Source.js\").State} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {boolean} [wrapX=false] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n *\n * @template {import(\"../Tile.js\").default} [TileType=import(\"../Tile.js\").default]\n * @abstract\n * @api\n */\nclass TileSource extends Source {\n  /**\n   * @param {Options} options SourceTile source options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: options.projection,\n      state: options.state,\n      wrapX: options.wrapX,\n      interpolate: options.interpolate,\n    });\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {TileSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilePixelRatio_ =\n      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n\n    /**\n     * @type {import(\"../tilegrid/TileGrid.js\").default|null}\n     * @protected\n     */\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n\n    const tileSize = [256, 256];\n    if (this.tileGrid) {\n      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);\n    }\n\n    /**\n     * @protected\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize = [0, 0];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.key_ = options.key || getUid(this);\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").Options}\n     */\n    this.tileOptions = {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    };\n\n    /**\n     * zDirection hint, read by the renderer. Indicates which resolution should be used\n     * by a renderer if the views resolution does not match any resolution of the tile source.\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n     * will be used. If -1, the nearest higher resolution will be used.\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\n     */\n    this.zDirection = options.zDirection ? options.zDirection : 0;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  getGutterForProjection(projection) {\n    return 0;\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   */\n  getKey() {\n    return this.key_;\n  }\n\n  /**\n   * Set the value to be used as the key for all tiles in the source.\n   * @param {string} key The key for tiles.\n   * @protected\n   */\n  setKey(key) {\n    if (this.key_ !== key) {\n      this.key_ = key;\n      this.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   * @override\n   */\n  getResolutions(projection) {\n    const tileGrid = projection\n      ? this.getTileGridForProjection(projection)\n      : this.tileGrid;\n    if (!tileGrid) {\n      return null;\n    }\n    return tileGrid.getResolutions();\n  }\n\n  /**\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {TileType|null} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    return abstract();\n  }\n\n  /**\n   * Return the tile grid of the tile source.\n   * @return {import(\"../tilegrid/TileGrid.js\").default|null} Tile grid.\n   * @api\n   */\n  getTileGrid() {\n    return this.tileGrid;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    if (!this.tileGrid) {\n      return getTileGridForProjection(projection);\n    }\n    return this.tileGrid;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source. Subclasses may override this\n   * method, which is meant to return a supported pixel ratio that matches the\n   * provided `pixelRatio` as close as possible.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return this.tilePixelRatio_;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    if (tilePixelRatio == 1) {\n      return tileSize;\n    }\n    return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n  }\n\n  /**\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n   * is outside the resolution and extent range of the tile grid, `null` will be\n   * returned.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n   *     null if no tile URL should be created for the passed `tileCoord`.\n   */\n  getTileCoordForTileUrlFunction(tileCoord, projection) {\n    const gridProjection =\n      projection !== undefined ? projection : this.getProjection();\n    const tileGrid =\n      projection !== undefined\n        ? this.getTileGridForProjection(gridProjection)\n        : this.tileGrid || this.getTileGridForProjection(gridProjection);\n    if (this.getWrapX() && gridProjection.isGlobal()) {\n      tileCoord = wrapX(tileGrid, tileCoord, gridProjection);\n    }\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n  }\n\n  /**\n   * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.\n   * @api\n   */\n  clear() {}\n\n  /**\n   * @override\n   */\n  refresh() {\n    this.clear();\n    super.refresh();\n  }\n}\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\nexport class TileSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Tile.js\").default} tile The tile.\n   */\n  constructor(type, tile) {\n    super(type);\n\n    /**\n     * The tile related to the event.\n     * @type {import(\"../Tile.js\").default}\n     * @api\n     */\n    this.tile = tile;\n  }\n}\n\nexport default TileSource;\n"],"names":["getForProjection","projection","tileGrid","getDefaultTileGrid","createForProjection","setDefaultTileGrid","wrapX","tileCoord","z","center","getTileCoordCenter","projectionExtent","extentFromProjection","worldWidth","worldsAway","Math","ceil","getTileCoordForCoordAndZ","createForExtent","extent","maxZoom","tileSize","corner","undefined","resolutions","resolutionsFromExtent","origin","createXYZ","options","xyzOptions","getExtent","gridOptions","minZoom","maxResolution","height","width","max","length","Array","pow","half","degrees","getMetersPerUnit","TileSource","constructor","super","attributions","attributionsCollapsible","state","interpolate","this","on","once","un","tilePixelRatio_","tilePixelRatio","getTileSize","getMinZoom","tmpSize","key_","key","tileOptions","transition","zDirection","getGutterForProjection","getKey","setKey","changed","getResolutions","getTileGridForProjection","getTile","x","y","pixelRatio","getTileGrid","getTilePixelRatio","getTilePixelSize","getTileCoordForTileUrlFunction","gridProjection","getProjection","getWrapX","isGlobal","clear","refresh","TileSourceEvent","type","tile"],"sourceRoot":""}