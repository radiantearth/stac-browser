{"version":3,"file":"js/5151.ee422048.js","mappings":"yQAmCO,SAASA,EAAiBC,EAAoBC,EAAOC,GAC1D,MAAMC,GAAiB,UACvB,OAAO,QACLF,EACAC,EACAC,EACAH,EAEJ,CAOO,SAASI,EAAUC,GACxB,MAAMC,GAAQ,QAAQD,GAChBE,EAAe,IAAXD,EAAM,GACVE,EAAIF,EAAM,GACVG,EAAe,IAAXH,EAAM,GACVI,EAAIC,KAAKC,MAAiB,IAAXN,EAAM,IAC3B,MAAO,CAACC,EAAIC,EAAGC,EAAIC,EACrB,CAEA,MAAMG,EAAkB,6OAaxB,SAASC,EAAoBC,GAC3B,OAAIA,IAAS,MAAaA,IAAS,KAC1B,EAELA,IAAS,KACJ,EAEF,CACT,CAMA,SAASC,EAAoBD,GAC3B,MAAME,EAAOH,EAAoBC,GACjC,OAAIE,EAAO,EACkC,MAAOA,IAE7C,OACT,CAOO,SAASC,EAAYC,GAC1B,MAAMC,EAAOC,KAAKC,UAAUH,GACzBI,MAAM,IACNC,OAAO,CAACC,EAAMC,KAAUD,GAAQ,GAAKA,EAAOC,EAAKC,WAAW,GAAI,GACnE,OAAQP,IAAS,GAAGQ,UACtB,CAQA,SAASC,EAA4BC,EAAOC,EAASC,EAAaC,GAChE,GAAI,GAAGA,YAAkBH,GAAoB,UAAXG,EAAoB,CACpD,IAAIC,EAASnC,EACXiC,EACAF,EAAM,GAAGG,WACT,MAEF,GAAI,GAAGA,aAAmBH,EAAO,CAC/B,MAAMK,EAAUpC,EACdiC,EACAF,EAAM,GAAGG,YACT,MAEFC,EAAS,OAAOA,MAAWC,IAC7B,CACI,GAAGF,kBAAwBH,IAC7BI,EAAS,IAAIA,OAAYnC,EACvBiC,EACAF,EAAM,GAAGG,iBACT,gBAGJF,EAAQK,wBAAwB,QAAQF,gBAC1C,CACA,GAAI,GAAGD,WAAiBH,EAAO,CAC7B,MAAMO,EAAQtC,EACZiC,EACAF,EAAM,GAAGG,UACT,MAEFF,EAAQK,wBACN,GAAGL,EAAQO,+BAA+BD,IAE9C,CACI,GAAGJ,kBAAwBH,GAC7BC,EAAQQ,0BACNxC,EACEiC,EACAF,EAAM,GAAGG,iBACT,OAIF,GAAGA,cAAoBH,GACzBC,EAAQS,4BACNzC,EAAiBiC,EAAaF,EAAM,GAAGG,aAAmB,OAG1D,GAAGA,sBAA4BH,GACjCC,EAAQU,0BAA0BX,EAAM,GAAGG,qBAE/C,CAUA,SAASS,EACPC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAI1C,EAAQ,WAIZ,GAHkB,OAAduC,IACFvC,EAAQuC,GAEU,OAAhBC,GAAwC,OAAhBC,EAAsB,CAChD,MAAME,EAAkB,eAAeF,cAAwBA,aAAuBH,KACtFtC,EAAQ,OAAOwC,MAAgBxC,MAAU2C,IAC3C,CACA,MAAMC,EAAe,kCAAkCN,MACvD,IAAIO,EAAS,GAAG7C,2BAA+B4C,KAI/C,OAHgB,OAAZF,IACFG,EAAS,GAAGA,2BAAgCH,MAEvCG,CACT,CAYA,SAASC,EAAqBrB,EAAOC,EAASqB,EAAUnB,EAAQoB,GAC9D,MAAMC,EAAQ,IAAIC,MAClBD,EAAME,iBAC+BC,IAAnC3B,EAAM,GAAGG,iBACL,YACAH,EAAM,GAAGG,kBACf,OACmC,kBAA1BH,EAAM,GAAGG,QAChB,mDAAmDA,uBAErDqB,EAAMI,IAA6B5B,EAAM,GAAGG,QAG5CmB,EAAS,YAAYC,UAAoB,IAChCC,EAAMK,SAAW,CAACL,EAAMM,MAAON,EAAMO,QAAU,CAAC,EAAG,GAE5D9B,EAAQ+B,WAAW,iBAAiBT,UACpC,MAAMpC,EAAO,YAAYoC,SAIzB,OAFAD,EAAS,YAAYC,KAAeC,EACpCvB,EAAQ+B,WAAW,sBAAsBT,KAClCpC,CACT,CAWA,SAAS8C,EACPjC,EACAG,EACA+B,EACAC,EACAC,GAEA,IAAIC,EAAmBpE,EACrBiE,EACAlC,EAAM,GAAGG,WACT,MAEF,GAAI,GAAGA,mBAAyBH,EAC9B,OAAQA,EAAM,GAAGG,mBACf,IAAK,YACHkC,EAAmB,QAAQF,cAAsBC,uBAAgCC,oBACjF,MACF,IAAK,cACHA,EAAmB,YAAYF,UAAkBC,uBAAgCC,oBACjF,MACF,IAAK,eACHA,EAAmB,GAAGF,OAAeC,OAAgBC,IACrD,MACF,SAGJ,OAAOA,CACT,CASA,SAASC,EACPtC,EACAC,EACAqB,EACApB,EACAqC,GAIAA,EAAYC,UAAU,uBACpB,6FAIFzC,EAA4BC,EAAOC,EAASC,EAAa,WAGzD,IAAIe,EAAU,KACV,mBAAoBjB,IACtBiB,EAAUhD,EACRsE,EACAvC,EAAM,kBACN,OAKJ,IAAIyC,EAAe,WACnB,GAAI,iBAAkBzC,EAAO,CAC3B,MAAMO,EAAQtC,EACZsE,EACAvC,EAAM,gBACN,MAEFyC,EAAe,cAAclC,GAC/B,CAGA,IAAIO,EAAY,KACZ,sBAAuBd,IACzBc,EAAY7C,EACVsE,EACAvC,EAAM,qBACN,OAKJ,IAAIe,EAAc,KACd,wBAAyBf,IAC3Be,EAAc9C,EACZsE,EACAvC,EAAM,uBACN,OAKJ,IAAII,EAASnC,EACXsE,EACAvC,EAAM,iBACN,MAIEgB,EAAc,KACd,wBAAyBhB,IAC3BgB,EAAc/C,EACZsE,EACAvC,EAAM,uBACN,MAEFI,EAAS,IAAIA,OAAYY,YAI3B,MAAMH,EAAgB,uBAAuB4B,MAAiBrC,KACxDsC,EAAkB9B,EACtBC,EACAC,EACAC,EACAC,EACAC,GAEFhB,EAAQ0C,yBAAyBD,EACnC,CASA,SAASE,EACP5C,EACAC,EACAqB,EACApB,EACAqC,GAEAA,EAAYC,UAAU,SAAW,qEAOjCD,EAAYC,UAAU,qBACpB,s2BAeFD,EAAYC,UAAU,wBACpB,kxBAeFzC,EAA4BC,EAAOC,EAASC,EAAa,UAGzD,IAAIe,EAAU,KACV,kBAAmBjB,IACrBiB,EAAUhD,EAAiBsE,EAAavC,EAAM,iBAAkB,OAIlE,IAAIyC,EAAe,WACnB,GAAI,gBAAiBzC,EAAO,CAC1B,MAAMO,EAAQtC,EAAiBsE,EAAavC,EAAM,eAAgB,MAClEyC,EAAe,cAAclC,GAC/B,CAGA,IAAIO,EAAY,KACZ,qBAAsBd,IACxBc,EAAY7C,EACVsE,EACAvC,EAAM,oBACN,OAKJ,IAAIe,EAAc,KACd,uBAAwBf,IAC1Be,EAAc9C,EACZsE,EACAvC,EAAM,sBACN,OAKJ,IAAIgB,EAAc,KACd,uBAAwBhB,IAC1BgB,EAAc/C,EACZsE,EACAvC,EAAM,sBACN,OAKJ,MAAM6C,EAAY5E,EAChBsE,EACAvC,EAAM,gBACN,MAEF,IAII8C,EAJAC,EAAQ,KACR,gBAAiB/C,IACnB+C,EAAQ9E,EAAiBsE,EAAavC,EAAM,eAAgB,OAG9D,IAAII,EAASnC,EAAiBsE,EAAavC,EAAM,gBAAiB,MAIlE,GAHoB,OAAhBgB,IACFZ,EAAS,GAAGA,OAAYY,WAEtB,kBAAmBhB,EAAO,CAC5B,IAAIK,EAAUpC,EACZsE,EACAvC,EAAM,iBACN,MAEkB,OAAhBgB,IACFX,EAAU,GAAGA,OAAaW,WAE5B8B,EAAa,qBAAqBL,MAAiBI,MAAczC,MAAWC,MAAY0C,IAC1F,MACED,EAAa,wBAAwBL,MAAiBI,MAAczC,MAAW2C,KAIjF,MAAML,EAAkB9B,EACtBkC,EACAhC,EACAC,EACAC,EACAC,GAEFhB,EAAQ0C,yBAAyBD,EACnC,CASA,SAASM,EACPhD,EACAC,EACAqB,EACApB,EACAqC,GAGA,IAAIhE,EAAQ,YACR,eAAgByB,IAClBzB,EAAQN,EAAiBsE,EAAavC,EAAM,cAAe,OAIzD,iBAAkBA,IACpBzB,EAAQ,GAAGA,2BAA+BN,EACxCsE,EACAvC,EAAM,gBACN,UAKJ,MAAMuB,EAAYnC,EAAYY,EAAM,aAC9BiD,EAAiB5B,EACrBrB,EACAC,EACAqB,EACA,QACAC,GAoBF,GAlBAtB,EACG0C,yBACC,GAAGpE,0BAA8BgD,kBAElCjB,wBAAwB2C,GAGvB,eAAgBjD,GAAS,gBAAiBA,GAC5CC,EAAQK,wBACN,QAAQrC,EACNiC,EACAF,EAAM,cACN,UACI/B,EAAiBiC,EAAaF,EAAM,eAAgB,UAK1D,gBAAiBA,GAAS,cAAeA,EAAO,CAClD,MAAMoC,EAAanE,EACjBiC,EACAF,EAAM,aACN,MAEIkD,EAAWjD,EAAQO,0BACzBP,EAAQK,wBAAwB8B,GAChC,MAAMe,EAASlB,EACbjC,EACA,QACAE,EACA,eACAkC,GAEFnC,EAAQmD,+BACN,UAAUD,2BAAgCf,UAAmBc,UAEjE,CAIA,GAFAnD,EAA4BC,EAAOC,EAASC,EAAa,SAErD,gBAAiBF,EAAO,CAC1B,MAAMqD,EAASpF,EACbiC,EACAF,EAAM,eACN,MAEF,IAIIsD,EAJA/C,EAAQ,MACR,eAAgBP,IAClBO,EAAQtC,EAAiBiC,EAAaF,EAAM,cAAe,OAO3DsD,EAHiC,WAAjCtD,EAAM,wBAC2B,WAAjCA,EAAM,uBAEI,GAAGqD,OAAY9C,IACiB,WAAjCP,EAAM,uBACL,GAAGqD,iBAAsB9C,wBACO,WAAjCP,EAAM,uBACL,GAAGqD,iCAAsC9C,QAEzC,GAAG8C,mBAGf,IAAIE,EAAW,oCAAoCD,oBACnD,GAAI,uBAAwBtD,EAC1B,OAAQA,EAAM,uBACZ,IAAK,YACHuD,EAAW,yBAAyBD,IACpC,MACF,IAAK,cACHC,EAAW,wBAAwBD,IACnC,MACF,IAAK,eACHC,EAAW,oCAAoCD,oBAC/C,MACF,SAGJrD,EAAQQ,0BACN,GAAGR,EAAQuD,iCAAiCD,IAEhD,CACF,CASA,SAASE,EACPzD,EACAC,EACAqB,EACApB,EACAqC,GAOA,GALI,iBAAkBvC,GACpBC,EAAQyD,yBACNzF,EAAiBsE,EAAavC,EAAM,gBAAiB,OAGrD,uBAAwBA,EAAO,CACjC,MAAMuB,EAAYnC,EAAYY,EAAM,uBAC9BiD,EAAiB5B,EACrBrB,EACAC,EACAqB,EACA,kBACAC,GAEF,IAAIoC,EAAuBV,EACvBZ,EAAmB,WACnB,0BAA2BrC,GAAS,wBAAyBA,IAC/D2D,EAAuB1F,EACrBsE,EACAvC,EAAM,uBACN,MAEFqC,EAAmBJ,EACjBjC,EACA,kBACAuC,EACAU,EACAU,IAGJ,IAAIC,EAAoB,KACpB,2BAA4B5D,IAC9B4D,EAAoB3F,EAClBsE,EACAvC,EAAM,0BACN,OAGJuC,EAAYC,UAAU,uBACpB,ovBAUF,MAAMqB,EAAc,YAAYtC,IAChC,IAAIuC,EAAiB,KACjB,iBAAkB9D,IACpB8D,EAAiB7D,EAAQ8D,4BAE3B9D,EAAQyD,yBACN,GAAGI,2BAAwCD,MAAgBZ,MAAmBZ,MAAqBsB,MAAyBC,mDAEhI,CAgCA,GA9BI,iBAAkB5D,GACpBC,EAAQ+D,yBACN/F,EAAiBiC,EAAaF,EAAM,gBAAiB,OAIrD,kBAAmBA,GACrBC,EAAQgE,0BACNhG,EAAiBiC,EAAaF,EAAM,iBAAkB,OAItD,oBAAqBA,GACvBC,EAAQiE,uBACNjG,EAAiBiC,EAAaF,EAAM,mBAAoB,OAIxD,qBAAsBA,GACxBC,EAAQkE,wBACNlG,EAAiBiC,EAAaF,EAAM,oBAAqB,OAIzD,uBAAwBA,GAC1BC,EAAQmE,8BACNnG,EAAiBiC,EAAaF,EAAM,sBAAuB,OAI3D,qBAAsBA,EAAO,CAC/BuC,EAAYC,UAAU,yBACpB,mYAIa,QAAa,iFAEN,QAAa,yKAMnC,IAAI6B,EAAcrE,EAAM,oBAAoBsE,IAAKC,GAC/CtG,EAAiBsE,EAAagC,EAAG,OAG/BF,EAAYG,OAAS,IAAM,IAC7BH,EAAc,IAAIA,KAAgBA,IAGpC,IAAIhC,EAAmB,KACnB,4BAA6BrC,IAC/BqC,EAAmBpE,EACjBiC,EACAF,EAAM,2BACN,OAKJ,MAAMyE,EAAgBrF,EAAYY,EAAM,qBAClC0E,EAAmB,qBAAqBD,IAExCE,EAAiBN,EAAYC,IACjC,CAACC,EAAGK,IAAM,mBAAmBA,OAAOL,MAEhCM,EAAiBR,EACpBC,IAAI,CAACC,EAAGK,IAAM,aAAaA,KAC3BE,KAAK,OACR,IAAIC,EAAoB,KACpBC,EAAqB,2CAA2CD,4CACpE,IAAK,IAAIH,EAAI,EAAGA,EAAIP,EAAYG,OAAQI,GAAK,EAC3CG,EAAoB,GAAGA,iBACrBH,EAAI,iBACUA,EAAI,IACpBI,EAAqB,OAAOA,8CAA+DD,gBAAgCH,gCAG7HrC,EAAYC,UAAUkC,GACpB,SAASA,uDACXC,EAAeG,KAAK,sCACID,gBACjBG,QAEP/E,EAAQgF,iCACN,GAAGP,uBAAsCrC,+BAE7C,CACF,CASA,SAAS6C,EACPlF,EACAC,EACAqB,EACApB,EACAqC,GAOA,GALI,eAAgBvC,GAClBC,EAAQkF,uBACNlH,EAAiBsE,EAAavC,EAAM,cAAe,OAGnD,qBAAsBA,EAAO,CAC/B,MAAMuB,EAAYnC,EAAYY,EAAM,qBAC9BiD,EAAiB5B,EACrBrB,EACAC,EACAqB,EACA,gBACAC,GAEF,IAAIoC,EAAuBV,EACvBZ,EAAmB,WACnB,wBAAyBrC,GAAS,sBAAuBA,IAC3D2D,EAAuB1F,EACrBsE,EACAvC,EAAM,qBACN,MAEFqC,EAAmBJ,EACjBjC,EACA,gBACAuC,EACAU,EACAU,IAGJpB,EAAYC,UAAU,qBACpB,y8BAYF,MAAMqB,EAAc,YAAYtC,IAChC,IAAIuC,EAAiB,KACjB,eAAgB9D,IAClB8D,EAAiB7D,EAAQmF,0BAE3BnF,EAAQkF,uBACN,GAAGrB,yBAAsCD,MAAgBZ,MAAmBZ,MAAqBsB,sBAErG,CACF,CAsBO,SAAS0B,EAAkBrF,EAAOsF,EAAWC,GAClD,MAAMrF,GAAc,UAKdqC,EAAc,KACf,UACHiD,kBAAkB,EAClBF,UAAWpF,EAAYoF,WAGnBrF,EAAU,IAAI,IAGdqB,EAAW,CAAC,EAclB,GAZI,aAActB,EAChBgD,EAAoBhD,EAAOC,EAASqB,EAAUpB,EAAaqC,GAClD,iBAAkBvC,EAC3B4C,EAAqB5C,EAAOC,EAASqB,EAAUpB,EAAaqC,GACnD,kBAAmBvC,GAC5BsC,EAAsBtC,EAAOC,EAASqB,EAAUpB,EAAaqC,GAE/DkB,EAAsBzD,EAAOC,EAASqB,EAAUpB,EAAaqC,GAC7D2C,EAAoBlF,EAAOC,EAASqB,EAAUpB,EAAaqC,GAIvDgD,EAAQ,CACV,MAAME,EAAexH,EAAiBsE,EAAagD,EAAQ,MAC3DtF,EAAQyF,6BAA6B,IAAID,IAC3C,CAGA,IAAK,MAAME,KAAWpD,EAAY+C,UAAW,CAC3C,MAAMM,EAAWrD,EAAY+C,UAAUK,GACjCE,GAAc,QAAuBD,EAASE,MACpD,IAAIC,EAAW7G,EAAoB0G,EAAS3G,MACxC2G,EAAS3G,OAAS,OAEpB8G,EAAW,QAEb9F,EAAQ+B,WAAW,GAAG+D,KAAYF,KAElCvE,EAASuE,GAAe,KACtB,MAAM1H,EAAQmH,EAAUM,EAASE,MACjC,MAAqB,kBAAV3H,EACFA,EAEY,mBAAVA,EACFA,EAAQ,EAAI,EAEjByH,EAAS3G,OAAS,MACb,QAAQd,GAAS,QAEL,kBAAVA,GACF,QAA0BA,GAE5BA,EAEX,CAIA,IAAK,MAAM6H,KAAYzD,EAAY0D,WAAY,CAC7C,MAAMC,EAAW3D,EAAY0D,WAAWD,GACnC9F,EAAY+F,WAAWD,KAC1B9F,EAAY+F,WAAWD,GAAYE,GAErC,IAAIjH,EAAOC,EAAoBgH,EAASjH,MACpCkH,EAAa,UAAUD,EAASJ,OAChCI,EAASjH,OAAS,OACpBA,EAAO,OACPkH,EAAa,eAAeA,KAC5BlG,EAAQmG,wBAAwBrH,IAElCkB,EAAQoG,WAAW,UAAUH,EAASJ,OAAQ7G,EAAMkH,EACtD,CAGA,IAAK,MAAMH,KAAY9F,EAAY+F,WAAY,CAC7C,MAAMC,EAAWhG,EAAY+F,WAAWD,GACxC/F,EAAQqG,aACN,GAAGpH,EAAoBgH,EAASjH,gBAAgBiH,EAASJ,OAE7D,CAGA,IAAK,MAAMS,KAAgBrG,EAAYsC,UACrCvC,EAAQmG,wBAAwBlG,EAAYsC,UAAU+D,IAExD,IAAK,MAAMA,KAAgBhE,EAAYC,UACrCvC,EAAQuG,0BAA0BjE,EAAYC,UAAU+D,IAM1D,MAAME,EAAa,CAAC,EAGpB,IAAK,MAAMT,KAAY9F,EAAY+F,WAAY,CAC7C,MAAMC,EAAWhG,EAAY+F,WAAWD,GAClCU,EAAYC,IAChB,MAAMxI,EAAQwI,EAAQC,IAAIV,EAASJ,MACnC,OAAII,EAASjH,OAAS,KACbX,EAAU,KAAI,QAAQH,GAAS,UAEnB,kBAAVA,GACF,QAA0BA,GAEd,mBAAVA,EACFA,EAAQ,EAAI,EAEdA,GAGTsI,EAAW,QAAQP,EAASJ,QAAU,CACpC3G,KAAMH,EAAoBkH,EAASjH,MACnCyH,WAEJ,CAGA,SAASG,EAAmBC,EAAiBC,EAAc9H,EAAMyH,GAC/D,MAAMM,EAAgB9G,EAAY4G,GAC5BG,EAAgB1E,EAAYuE,GAClC,IAAKE,IAAkBC,EACrB,OAEF,MAAMlB,EAAW7G,EAAoBD,GAC/BiI,EAAWlI,EAAoBC,GACrCgB,EAAQqG,aAAa,GAAGP,OAAcgB,KAClCE,GACFhH,EAAQoG,WAAW,KAAKU,IAAgBhB,EAAU,KAAKgB,KAEzDN,EAAWM,GAAgB,CACzB5H,KAAM+H,EACNR,WAEJ,CAkBA,OAjBAG,EACE,eACA,KACA,KACCF,IACC,SAA0B,QAAoBA,EAAQQ,iBAE1DN,EACE,YACA,KACA,KAAa,KACZF,IACC,MAAMS,EAAKT,EAAQU,SAAW,KAC9B,MAAqB,kBAAPD,GAAkB,QAA0BA,GAAMA,IAI7D,CAACnH,UAASwG,aAAYnF,WAC/B,C","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/webgl/styleparser.js"],"sourcesContent":["/**\n * Utilities for parsing literal style objects\n * @module ol/webgl/styleparser\n */\nimport {assert} from '../asserts.js';\nimport {asArray} from '../color.js';\nimport {\n  BooleanType,\n  ColorType,\n  NumberArrayType,\n  NumberType,\n  SizeType,\n  StringType,\n  computeGeometryType,\n  newParsingContext,\n} from '../expr/expression.js';\nimport {\n  FEATURE_ID_PROPERTY_NAME,\n  GEOMETRY_TYPE_PROPERTY_NAME,\n  buildExpression,\n  getStringNumberEquivalent,\n  newCompilationContext,\n  stringToGlsl,\n  uniformNameForVariable,\n} from '../expr/gpu.js';\nimport {ShaderBuilder} from './ShaderBuilder.js';\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a compilation context that\n * will be read and modified during the parsing operation.\n * @param {import(\"../expr/gpu.js\").CompilationContext} compilationContext Compilation context\n * @param {import(\"../expr/expression.js\").EncodedExpression} value Value\n * @param {number} [expectedType] Expected final type (can be several types combined)\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(compilationContext, value, expectedType) {\n  const parsingContext = newParsingContext();\n  return buildExpression(\n    value,\n    expectedType,\n    parsingContext,\n    compilationContext,\n  );\n}\n\n/**\n * Packs all components of a color into a two-floats array\n * @param {import(\"../color.js\").Color|string} color Color as array of numbers or string\n * @return {Array<number>} Vec2 array containing the color in compressed form\n */\nexport function packColor(color) {\n  const array = asArray(color);\n  const r = array[0] * 256;\n  const g = array[1];\n  const b = array[2] * 256;\n  const a = Math.round(array[3] * 255);\n  return [r + g, b + a];\n}\n\nconst UNPACK_COLOR_FN = `vec4 unpackColor(vec2 packedColor) {\n  return vec4(\n    fract(floor(packedColor[0] / 256.0) / 256.0),\n    fract(packedColor[0] / 256.0),\n    fract(floor(packedColor[1] / 256.0) / 256.0),\n    fract(packedColor[1] / 256.0)\n  );\n}`;\n\n/**\n * @param {number} type Value type\n * @return {1|2|3|4} The amount of components for this value\n */\nfunction getGlslSizeFromType(type) {\n  if (type === ColorType || type === SizeType) {\n    return 2;\n  }\n  if (type === NumberArrayType) {\n    return 4;\n  }\n  return 1;\n}\n\n/**\n * @param {number} type Value type\n * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value\n */\nfunction getGlslTypeFromType(type) {\n  const size = getGlslSizeFromType(type);\n  if (size > 1) {\n    return /** @type {'vec2'|'vec3'|'vec4'} */ (`vec${size}`);\n  }\n  return 'float';\n}\n\n/**\n * see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\n * @param {Object|string} input The hash input, either an object or string\n * @return {string} Hash (if the object cannot be serialized, it is based on `getUid`)\n */\nexport function computeHash(input) {\n  const hash = JSON.stringify(input)\n    .split('')\n    .reduce((prev, curr) => (prev << 5) - prev + curr.charCodeAt(0), 0);\n  return (hash >>> 0).toString();\n}\n\n/**\n * @param {import(\"../style/flat.js\").FlatStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {'shape-'|'circle-'|'icon-'} prefix Properties prefix\n */\nfunction parseCommonSymbolProperties(style, builder, vertContext, prefix) {\n  if (`${prefix}radius` in style && prefix !== 'icon-') {\n    let radius = expressionToGlsl(\n      vertContext,\n      style[`${prefix}radius`],\n      NumberType,\n    );\n    if (`${prefix}radius2` in style) {\n      const radius2 = expressionToGlsl(\n        vertContext,\n        style[`${prefix}radius2`],\n        NumberType,\n      );\n      radius = `max(${radius}, ${radius2})`;\n    }\n    if (`${prefix}stroke-width` in style) {\n      radius = `(${radius} + ${expressionToGlsl(\n        vertContext,\n        style[`${prefix}stroke-width`],\n        NumberType,\n      )} * 0.5)`;\n    }\n    builder.setSymbolSizeExpression(`vec2(${radius} * 2. + 0.5)`); // adding some padding for antialiasing\n  }\n  if (`${prefix}scale` in style) {\n    const scale = expressionToGlsl(\n      vertContext,\n      style[`${prefix}scale`],\n      SizeType,\n    );\n    builder.setSymbolSizeExpression(\n      `${builder.getSymbolSizeExpression()} * ${scale}`,\n    );\n  }\n  if (`${prefix}displacement` in style) {\n    builder.setSymbolOffsetExpression(\n      expressionToGlsl(\n        vertContext,\n        style[`${prefix}displacement`],\n        NumberArrayType,\n      ),\n    );\n  }\n  if (`${prefix}rotation` in style) {\n    builder.setSymbolRotationExpression(\n      expressionToGlsl(vertContext, style[`${prefix}rotation`], NumberType),\n    );\n  }\n  if (`${prefix}rotate-with-view` in style) {\n    builder.setSymbolRotateWithView(!!style[`${prefix}rotate-with-view`]);\n  }\n}\n\n/**\n * @param {string} distanceField The distance field expression\n * @param {string|null} fillColor The fill color expression; null if no fill\n * @param {string|null} strokeColor The stroke color expression; null if no stroke\n * @param {string|null} strokeWidth The stroke width expression; null if no stroke\n * @param {string|null} opacity The opacity expression; null if no stroke\n * @return {string} The final color expression, based on the distance field and given params\n */\nfunction getColorFromDistanceField(\n  distanceField,\n  fillColor,\n  strokeColor,\n  strokeWidth,\n  opacity,\n) {\n  let color = 'vec4(0.)';\n  if (fillColor !== null) {\n    color = fillColor;\n  }\n  if (strokeColor !== null && strokeWidth !== null) {\n    const strokeFillRatio = `smoothstep(-${strokeWidth} + 0.63, -${strokeWidth} - 0.58, ${distanceField})`;\n    color = `mix(${strokeColor}, ${color}, ${strokeFillRatio})`;\n  }\n  const shapeOpacity = `(1.0 - smoothstep(-0.63, 0.58, ${distanceField}))`;\n  let result = `${color} * vec4(1.0, 1.0, 1.0, ${shapeOpacity})`;\n  if (opacity !== null) {\n    result = `${result} * vec4(1.0, 1.0, 1.0, ${opacity})`;\n  }\n  return result;\n}\n\n/**\n * This will parse an image property provided by `<prefix>-src`\n * The image size expression in GLSL will be returned\n * @param {import(\"../style/flat.js\").FlatStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {string} textureId A identifier that will be used in the generated uniforms: `sample2d u_texture<id>` and `vec2 u_texture<id>_size`\n * @return {string} The image size expression\n */\nfunction parseImageProperties(style, builder, uniforms, prefix, textureId) {\n  const image = new Image();\n  image.crossOrigin =\n    style[`${prefix}cross-origin`] === undefined\n      ? 'anonymous'\n      : style[`${prefix}cross-origin`];\n  assert(\n    typeof style[`${prefix}src`] === 'string',\n    `WebGL layers do not support expressions for the ${prefix}src style property`,\n  );\n  image.src = /** @type {string} */ (style[`${prefix}src`]);\n\n  // the size is provided asynchronously using a uniform\n  uniforms[`u_texture${textureId}_size`] = () => {\n    return image.complete ? [image.width, image.height] : [0, 0];\n  };\n  builder.addUniform(`vec2 u_texture${textureId}_size`);\n  const size = `u_texture${textureId}_size`;\n\n  uniforms[`u_texture${textureId}`] = image;\n  builder.addUniform(`sampler2D u_texture${textureId}`);\n  return size;\n}\n\n/**\n * This will parse an image's offset properties provided by `<prefix>-offset`, `<prefix>-offset-origin` and `<prefix>-size`\n * @param {import(\"../style/flat.js\").FlatStyle} style Style\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {import(\"../expr/gpu.js\").CompilationContext} context Shader compilation context (vertex or fragment)\n * @param {string} imageSize Pixel size of the full image as a GLSL expression\n * @param {string} sampleSize Pixel size of the sample in the image as a GLSL expression\n * @return {string} The offset expression\n */\nfunction parseImageOffsetProperties(\n  style,\n  prefix,\n  context,\n  imageSize,\n  sampleSize,\n) {\n  let offsetExpression = expressionToGlsl(\n    context,\n    style[`${prefix}offset`],\n    NumberArrayType,\n  );\n  if (`${prefix}offset-origin` in style) {\n    switch (style[`${prefix}offset-origin`]) {\n      case 'top-right':\n        offsetExpression = `vec2(${imageSize}.x, 0.) + ${sampleSize} * vec2(-1., 0.) + ${offsetExpression} * vec2(-1., 1.)`;\n        break;\n      case 'bottom-left':\n        offsetExpression = `vec2(0., ${imageSize}.y) + ${sampleSize} * vec2(0., -1.) + ${offsetExpression} * vec2(1., -1.)`;\n        break;\n      case 'bottom-right':\n        offsetExpression = `${imageSize} - ${sampleSize} - ${offsetExpression}`;\n        break;\n      default: // pass\n    }\n  }\n  return offsetExpression;\n}\n\n/**\n * @param {import(\"../style/flat.js\").FlatStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseCircleProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  // this function takes in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  fragContext.functions['circleDistanceField'] =\n    `float circleDistanceField(vec2 point, float radius) {\n  return length(point) - radius;\n}`;\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'circle-');\n\n  // OPACITY\n  let opacity = null;\n  if ('circle-opacity' in style) {\n    opacity = expressionToGlsl(\n      fragContext,\n      style['circle-opacity'],\n      NumberType,\n    );\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('circle-scale' in style) {\n    const scale = expressionToGlsl(\n      fragContext,\n      style['circle-scale'],\n      SizeType,\n    );\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('circle-fill-color' in style) {\n    fillColor = expressionToGlsl(\n      fragContext,\n      style['circle-fill-color'],\n      ColorType,\n    );\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('circle-stroke-color' in style) {\n    strokeColor = expressionToGlsl(\n      fragContext,\n      style['circle-stroke-color'],\n      ColorType,\n    );\n  }\n\n  // RADIUS\n  let radius = expressionToGlsl(\n    fragContext,\n    style['circle-radius'],\n    NumberType,\n  );\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('circle-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(\n      fragContext,\n      style['circle-stroke-width'],\n      NumberType,\n    );\n    radius = `(${radius} + ${strokeWidth} * 0.5)`;\n  }\n\n  // FINAL COLOR\n  const distanceField = `circleDistanceField(${currentPoint}, ${radius})`;\n  const colorExpression = getColorFromDistanceField(\n    distanceField,\n    fillColor,\n    strokeColor,\n    strokeWidth,\n    opacity,\n  );\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/flat.js\").FlatStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseShapeProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  fragContext.functions['round'] = `float round(float v) {\n  return sign(v) * floor(abs(v) + 0.5);\n}`;\n\n  // these functions take in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the polygon, positive outside, values in pixels)\n  // inspired by https://github.com/zranger1/PixelblazePatterns/blob/master/Toolkit/sdf2d.md#n-sided-regular-polygon\n  fragContext.functions['starDistanceField'] =\n    `float starDistanceField(vec2 point, float numPoints, float radius, float radius2, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round(beta / alpha) * alpha; // angle in sector\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  vec2 tipToPoint = inSector + vec2(-radius, 0.);\n  vec2 edgeNormal = vec2(radius2 * sin(alpha * 0.5), -radius2 * cos(alpha * 0.5) + radius);\n  return dot(normalize(edgeNormal), tipToPoint);\n}`;\n  fragContext.functions['regularDistanceField'] =\n    `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float radiusIn = radius * cos(PI / numPoints);\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  return inSector.x - radiusIn;\n}`;\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'shape-');\n\n  // OPACITY\n  let opacity = null;\n  if ('shape-opacity' in style) {\n    opacity = expressionToGlsl(fragContext, style['shape-opacity'], NumberType);\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('shape-scale' in style) {\n    const scale = expressionToGlsl(fragContext, style['shape-scale'], SizeType);\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('shape-fill-color' in style) {\n    fillColor = expressionToGlsl(\n      fragContext,\n      style['shape-fill-color'],\n      ColorType,\n    );\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('shape-stroke-color' in style) {\n    strokeColor = expressionToGlsl(\n      fragContext,\n      style['shape-stroke-color'],\n      ColorType,\n    );\n  }\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('shape-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(\n      fragContext,\n      style['shape-stroke-width'],\n      NumberType,\n    );\n  }\n\n  // SHAPE TYPE\n  const numPoints = expressionToGlsl(\n    fragContext,\n    style['shape-points'],\n    NumberType,\n  );\n  let angle = '0.';\n  if ('shape-angle' in style) {\n    angle = expressionToGlsl(fragContext, style['shape-angle'], NumberType);\n  }\n  let shapeField;\n  let radius = expressionToGlsl(fragContext, style['shape-radius'], NumberType);\n  if (strokeWidth !== null) {\n    radius = `${radius} + ${strokeWidth} * 0.5`;\n  }\n  if ('shape-radius2' in style) {\n    let radius2 = expressionToGlsl(\n      fragContext,\n      style['shape-radius2'],\n      NumberType,\n    );\n    if (strokeWidth !== null) {\n      radius2 = `${radius2} + ${strokeWidth} * 0.5`;\n    }\n    shapeField = `starDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${radius2}, ${angle})`;\n  } else {\n    shapeField = `regularDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${angle})`;\n  }\n\n  // FINAL COLOR\n  const colorExpression = getColorFromDistanceField(\n    shapeField,\n    fillColor,\n    strokeColor,\n    strokeWidth,\n    opacity,\n  );\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/flat.js\").FlatStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseIconProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  // COLOR\n  let color = 'vec4(1.0)';\n  if ('icon-color' in style) {\n    color = expressionToGlsl(fragContext, style['icon-color'], ColorType);\n  }\n\n  // OPACITY\n  if ('icon-opacity' in style) {\n    color = `${color} * vec4(1.0, 1.0, 1.0, ${expressionToGlsl(\n      fragContext,\n      style['icon-opacity'],\n      NumberType,\n    )})`;\n  }\n\n  // IMAGE & SIZE\n  const textureId = computeHash(style['icon-src']);\n  const sizeExpression = parseImageProperties(\n    style,\n    builder,\n    uniforms,\n    'icon-',\n    textureId,\n  );\n  builder\n    .setSymbolColorExpression(\n      `${color} * texture2D(u_texture${textureId}, v_texCoord)`,\n    )\n    .setSymbolSizeExpression(sizeExpression);\n\n  // override size if width/height were specified\n  if ('icon-width' in style && 'icon-height' in style) {\n    builder.setSymbolSizeExpression(\n      `vec2(${expressionToGlsl(\n        vertContext,\n        style['icon-width'],\n        NumberType,\n      )}, ${expressionToGlsl(vertContext, style['icon-height'], NumberType)})`,\n    );\n  }\n\n  // tex coord\n  if ('icon-offset' in style && 'icon-size' in style) {\n    const sampleSize = expressionToGlsl(\n      vertContext,\n      style['icon-size'],\n      NumberArrayType,\n    );\n    const fullsize = builder.getSymbolSizeExpression();\n    builder.setSymbolSizeExpression(sampleSize);\n    const offset = parseImageOffsetProperties(\n      style,\n      'icon-',\n      vertContext,\n      'v_quadSizePx',\n      sampleSize,\n    );\n    builder.setTextureCoordinateExpression(\n      `(vec4((${offset}).xyxy) + vec4(0., 0., ${sampleSize})) / (${fullsize}).xyxy`,\n    );\n  }\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'icon-');\n\n  if ('icon-anchor' in style) {\n    const anchor = expressionToGlsl(\n      vertContext,\n      style['icon-anchor'],\n      NumberArrayType,\n    );\n    let scale = `1.0`;\n    if (`icon-scale` in style) {\n      scale = expressionToGlsl(vertContext, style[`icon-scale`], SizeType);\n    }\n    let shiftPx;\n    if (\n      style['icon-anchor-x-units'] === 'pixels' &&\n      style['icon-anchor-y-units'] === 'pixels'\n    ) {\n      shiftPx = `${anchor} * ${scale}`;\n    } else if (style['icon-anchor-x-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(vec2(${scale}).x, v_quadSizePx.y)`;\n    } else if (style['icon-anchor-y-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(v_quadSizePx.x, vec2(${scale}).x)`;\n    } else {\n      shiftPx = `${anchor} * v_quadSizePx`;\n    }\n    // default origin is top-left\n    let offsetPx = `v_quadSizePx * vec2(0.5, -0.5) + ${shiftPx} * vec2(-1., 1.)`;\n    if ('icon-anchor-origin' in style) {\n      switch (style['icon-anchor-origin']) {\n        case 'top-right':\n          offsetPx = `v_quadSizePx * -0.5 + ${shiftPx}`;\n          break;\n        case 'bottom-left':\n          offsetPx = `v_quadSizePx * 0.5 - ${shiftPx}`;\n          break;\n        case 'bottom-right':\n          offsetPx = `v_quadSizePx * vec2(-0.5, 0.5) + ${shiftPx} * vec2(1., -1.)`;\n          break;\n        default: // pass\n      }\n    }\n    builder.setSymbolOffsetExpression(\n      `${builder.getSymbolOffsetExpression()} + ${offsetPx}`,\n    );\n  }\n}\n\n/**\n * @param {import(\"../style/flat.js\").FlatStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseStrokeProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  if ('stroke-color' in style) {\n    builder.setStrokeColorExpression(\n      expressionToGlsl(fragContext, style['stroke-color'], ColorType),\n    );\n  }\n  if ('stroke-pattern-src' in style) {\n    const textureId = computeHash(style['stroke-pattern-src']);\n    const sizeExpression = parseImageProperties(\n      style,\n      builder,\n      uniforms,\n      'stroke-pattern-',\n      textureId,\n    );\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('stroke-pattern-offset' in style && 'stroke-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(\n        fragContext,\n        style[`stroke-pattern-size`],\n        NumberArrayType,\n      );\n      offsetExpression = parseImageOffsetProperties(\n        style,\n        'stroke-pattern-',\n        fragContext,\n        sizeExpression,\n        sampleSizeExpression,\n      );\n    }\n    let spacingExpression = '0.';\n    if ('stroke-pattern-spacing' in style) {\n      spacingExpression = expressionToGlsl(\n        fragContext,\n        style['stroke-pattern-spacing'],\n        NumberType,\n      );\n    }\n    fragContext.functions['sampleStrokePattern'] =\n      `vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {\n  float currentLengthScaled = currentLengthPx * sampleSize.y / lineWidth;\n  float spacingScaled = spacingPx * sampleSize.y / lineWidth;\n  float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));\n  // make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\n  uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);\n  float vCoordPx = (-currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;\n  vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;\n  return texture2D(texture, texCoord);\n}`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('stroke-color' in style) {\n      tintExpression = builder.getStrokeColorExpression();\n    }\n    builder.setStrokeColorExpression(\n      `${tintExpression} * sampleStrokePattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, ${spacingExpression}, currentLengthPx, currentRadiusRatio, v_width)`,\n    );\n  }\n\n  if ('stroke-width' in style) {\n    builder.setStrokeWidthExpression(\n      expressionToGlsl(vertContext, style['stroke-width'], NumberType),\n    );\n  }\n\n  if ('stroke-offset' in style) {\n    builder.setStrokeOffsetExpression(\n      expressionToGlsl(vertContext, style['stroke-offset'], NumberType),\n    );\n  }\n\n  if ('stroke-line-cap' in style) {\n    builder.setStrokeCapExpression(\n      expressionToGlsl(vertContext, style['stroke-line-cap'], StringType),\n    );\n  }\n\n  if ('stroke-line-join' in style) {\n    builder.setStrokeJoinExpression(\n      expressionToGlsl(vertContext, style['stroke-line-join'], StringType),\n    );\n  }\n\n  if ('stroke-miter-limit' in style) {\n    builder.setStrokeMiterLimitExpression(\n      expressionToGlsl(vertContext, style['stroke-miter-limit'], NumberType),\n    );\n  }\n\n  if ('stroke-line-dash' in style) {\n    fragContext.functions['getSingleDashDistance'] =\n      `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\n  float localDistance = mod(distance, dashLengthTotal);\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\n  if (capType == ${stringToGlsl('square')}) {\n    distanceSegment -= v_width * 0.5;\n  } else if (capType == ${stringToGlsl('round')}) {\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\n  }\n  return distanceSegment;\n}`;\n\n    let dashPattern = style['stroke-line-dash'].map((v) =>\n      expressionToGlsl(fragContext, v, NumberType),\n    );\n    // if pattern has odd length, concatenate it with itself to be even\n    if (dashPattern.length % 2 === 1) {\n      dashPattern = [...dashPattern, ...dashPattern];\n    }\n\n    let offsetExpression = '0.';\n    if ('stroke-line-dash-offset' in style) {\n      offsetExpression = expressionToGlsl(\n        vertContext,\n        style['stroke-line-dash-offset'],\n        NumberType,\n      );\n    }\n\n    // define a function for this dash specifically\n    const uniqueDashKey = computeHash(style['stroke-line-dash']);\n    const dashFunctionName = `dashDistanceField_${uniqueDashKey}`;\n\n    const dashLengthsDef = dashPattern.map(\n      (v, i) => `float dashLength${i} = ${v};`,\n    );\n    const totalLengthDef = dashPattern\n      .map((v, i) => `dashLength${i}`)\n      .join(' + ');\n    let currentDashOffset = '0.';\n    let distanceExpression = `getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength0, totalDashLength, capType)`;\n    for (let i = 2; i < dashPattern.length; i += 2) {\n      currentDashOffset = `${currentDashOffset} + dashLength${\n        i - 2\n      } + dashLength${i - 1}`;\n      distanceExpression = `min(${distanceExpression}, getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength${i}, totalDashLength, capType))`;\n    }\n\n    fragContext.functions[dashFunctionName] =\n      `float ${dashFunctionName}(float distance, float radius, float capType) {\n  ${dashLengthsDef.join('\\n  ')}\n  float totalDashLength = ${totalLengthDef};\n  return ${distanceExpression};\n}`;\n    builder.setStrokeDistanceFieldExpression(\n      `${dashFunctionName}(currentLengthPx + ${offsetExpression}, currentRadiusPx, capType)`,\n    );\n  }\n}\n\n/**\n * @param {import(\"../style/flat.js\").FlatStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseFillProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  if ('fill-color' in style) {\n    builder.setFillColorExpression(\n      expressionToGlsl(fragContext, style['fill-color'], ColorType),\n    );\n  }\n  if ('fill-pattern-src' in style) {\n    const textureId = computeHash(style['fill-pattern-src']);\n    const sizeExpression = parseImageProperties(\n      style,\n      builder,\n      uniforms,\n      'fill-pattern-',\n      textureId,\n    );\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('fill-pattern-offset' in style && 'fill-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(\n        fragContext,\n        style[`fill-pattern-size`],\n        NumberArrayType,\n      );\n      offsetExpression = parseImageOffsetProperties(\n        style,\n        'fill-pattern-',\n        fragContext,\n        sizeExpression,\n        sampleSizeExpression,\n      );\n    }\n    fragContext.functions['sampleFillPattern'] =\n      `vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {\n  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);\n  vec2 pxRelativePos = pxPosition - pxOrigin;\n  // rotate the relative position from origin by the current view rotation\n  pxRelativePos = vec2(pxRelativePos.x * cos(u_rotation) - pxRelativePos.y * sin(u_rotation), pxRelativePos.x * sin(u_rotation) + pxRelativePos.y * cos(u_rotation));\n  // sample position is computed according to the sample offset & size\n  vec2 samplePos = mod(pxRelativePos / scaleRatio, sampleSize);\n  // also make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\n  samplePos = clamp(samplePos, vec2(0.5), sampleSize - vec2(0.5));\n  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright\n  return texture2D(texture, (samplePos + textureOffset) / textureSize);\n}`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('fill-color' in style) {\n      tintExpression = builder.getFillColorExpression();\n    }\n    builder.setFillColorExpression(\n      `${tintExpression} * sampleFillPattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, pxOrigin, pxPos)`,\n    );\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").UniformDefinitions} uniforms Uniform definitions\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").AttributeDefinitions} attributes Attribute definitions\n */\n\n/**\n * Parses a {@link import(\"../style/flat.js\").FlatStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/flat.js\").FlatStyle} style Flat style.\n * @param {import('../style/flat.js').StyleVariables} [variables] Style variables.\n * @param {import(\"../expr/expression.js\").EncodedExpression} [filter] Filter (if any)\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style, variables, filter) {\n  const vertContext = newCompilationContext();\n\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const fragContext = {\n    ...newCompilationContext(),\n    inFragmentShader: true,\n    variables: vertContext.variables,\n  };\n\n  const builder = new ShaderBuilder();\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  if ('icon-src' in style) {\n    parseIconProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('shape-points' in style) {\n    parseShapeProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('circle-radius' in style) {\n    parseCircleProperties(style, builder, uniforms, vertContext, fragContext);\n  }\n  parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);\n  parseFillProperties(style, builder, uniforms, vertContext, fragContext);\n\n  // note that the style filter may have already been applied earlier when building the rendering instructions\n  // this is still needed in case a filter cannot be evaluated statically beforehand (e.g. depending on time)\n  if (filter) {\n    const parsedFilter = expressionToGlsl(fragContext, filter, BooleanType);\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n\n  // define one uniform per variable\n  for (const varName in fragContext.variables) {\n    const variable = fragContext.variables[varName];\n    const uniformName = uniformNameForVariable(variable.name);\n    let glslType = getGlslTypeFromType(variable.type);\n    if (variable.type === ColorType) {\n      // we're not packing colors when they're passed as uniforms\n      glslType = 'vec4';\n    }\n    builder.addUniform(`${glslType} ${uniformName}`);\n\n    uniforms[uniformName] = () => {\n      const value = variables[variable.name];\n      if (typeof value === 'number') {\n        return value;\n      }\n      if (typeof value === 'boolean') {\n        return value ? 1 : 0;\n      }\n      if (variable.type === ColorType) {\n        return asArray(value || '#eee');\n      }\n      if (typeof value === 'string') {\n        return getStringNumberEquivalent(value);\n      }\n      return value;\n    };\n  }\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  for (const propName in fragContext.properties) {\n    const property = fragContext.properties[propName];\n    if (!vertContext.properties[propName]) {\n      vertContext.properties[propName] = property;\n    }\n    let type = getGlslTypeFromType(property.type);\n    let expression = `a_prop_${property.name}`;\n    if (property.type === ColorType) {\n      type = 'vec4';\n      expression = `unpackColor(${expression})`;\n      builder.addVertexShaderFunction(UNPACK_COLOR_FN);\n    }\n    builder.addVarying(`v_prop_${property.name}`, type, expression);\n  }\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  for (const propName in vertContext.properties) {\n    const property = vertContext.properties[propName];\n    builder.addAttribute(\n      `${getGlslTypeFromType(property.type)} a_prop_${property.name}`,\n    );\n  }\n\n  // add functions that were collected in the compilation contexts\n  for (const functionName in vertContext.functions) {\n    builder.addVertexShaderFunction(vertContext.functions[functionName]);\n  }\n  for (const functionName in fragContext.functions) {\n    builder.addFragmentShaderFunction(fragContext.functions[functionName]);\n  }\n\n  /**\n   * @type {import('../render/webgl/VectorStyleRenderer.js').AttributeDefinitions}\n   */\n  const attributes = {};\n\n  // Define attributes with their callback for each property used in the vertex shader\n  for (const propName in vertContext.properties) {\n    const property = vertContext.properties[propName];\n    const callback = (feature) => {\n      const value = feature.get(property.name);\n      if (property.type === ColorType) {\n        return packColor([...asArray(value || '#eee')]);\n      }\n      if (typeof value === 'string') {\n        return getStringNumberEquivalent(value);\n      }\n      if (typeof value === 'boolean') {\n        return value ? 1 : 0;\n      }\n      return value;\n    };\n\n    attributes[`prop_${property.name}`] = {\n      size: getGlslSizeFromType(property.type),\n      callback,\n    };\n  }\n\n  // Define attributes for special inputs\n  function defineSpecialInput(contextPropName, glslPropName, type, callback) {\n    const inVertContext = vertContext[contextPropName];\n    const inFragContext = fragContext[contextPropName];\n    if (!inVertContext && !inFragContext) {\n      return;\n    }\n    const glslType = getGlslTypeFromType(type);\n    const attrSize = getGlslSizeFromType(type);\n    builder.addAttribute(`${glslType} a_${glslPropName}`);\n    if (inFragContext) {\n      builder.addVarying(`v_${glslPropName}`, glslType, `a_${glslPropName}`);\n    }\n    attributes[glslPropName] = {\n      size: attrSize,\n      callback,\n    };\n  }\n  defineSpecialInput(\n    'geometryType',\n    GEOMETRY_TYPE_PROPERTY_NAME,\n    StringType,\n    (feature) =>\n      getStringNumberEquivalent(computeGeometryType(feature.getGeometry())),\n  );\n  defineSpecialInput(\n    'featureId',\n    FEATURE_ID_PROPERTY_NAME,\n    StringType | NumberType,\n    (feature) => {\n      const id = feature.getId() ?? null;\n      return typeof id === 'string' ? getStringNumberEquivalent(id) : id;\n    },\n  );\n\n  return {builder, attributes, uniforms};\n}\n"],"names":["expressionToGlsl","compilationContext","value","expectedType","parsingContext","packColor","color","array","r","g","b","a","Math","round","UNPACK_COLOR_FN","getGlslSizeFromType","type","getGlslTypeFromType","size","computeHash","input","hash","JSON","stringify","split","reduce","prev","curr","charCodeAt","toString","parseCommonSymbolProperties","style","builder","vertContext","prefix","radius","radius2","setSymbolSizeExpression","scale","getSymbolSizeExpression","setSymbolOffsetExpression","setSymbolRotationExpression","setSymbolRotateWithView","getColorFromDistanceField","distanceField","fillColor","strokeColor","strokeWidth","opacity","strokeFillRatio","shapeOpacity","result","parseImageProperties","uniforms","textureId","image","Image","crossOrigin","undefined","src","complete","width","height","addUniform","parseImageOffsetProperties","context","imageSize","sampleSize","offsetExpression","parseCircleProperties","fragContext","functions","currentPoint","colorExpression","setSymbolColorExpression","parseShapeProperties","numPoints","shapeField","angle","parseIconProperties","sizeExpression","fullsize","offset","setTextureCoordinateExpression","anchor","shiftPx","offsetPx","getSymbolOffsetExpression","parseStrokeProperties","setStrokeColorExpression","sampleSizeExpression","spacingExpression","textureName","tintExpression","getStrokeColorExpression","setStrokeWidthExpression","setStrokeOffsetExpression","setStrokeCapExpression","setStrokeJoinExpression","setStrokeMiterLimitExpression","dashPattern","map","v","length","uniqueDashKey","dashFunctionName","dashLengthsDef","i","totalLengthDef","join","currentDashOffset","distanceExpression","setStrokeDistanceFieldExpression","parseFillProperties","setFillColorExpression","getFillColorExpression","parseLiteralStyle","variables","filter","inFragmentShader","parsedFilter","setFragmentDiscardExpression","varName","variable","uniformName","name","glslType","propName","properties","property","expression","addVertexShaderFunction","addVarying","addAttribute","functionName","addFragmentShaderFunction","attributes","callback","feature","get","defineSpecialInput","contextPropName","glslPropName","inVertContext","inFragContext","attrSize","getGeometry","id","getId"],"sourceRoot":""}