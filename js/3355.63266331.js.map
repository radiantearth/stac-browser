{"version":3,"file":"js/3355.63266331.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/render/webgl/MixedGeometryBatch.js","webpack://@radiantearth/stac-browser/./node_modules/ol/render/webgl/renderinstructions.js","webpack://@radiantearth/stac-browser/./node_modules/ol/render/webgl/VectorStyleRenderer.js"],"sourcesContent":["/**\n * @module ol/render/webgl/MixedGeometryBatch\n */\nimport {inflateEnds} from '../../geom/flat/orient.js';\nimport RenderFeature from '../../render/Feature.js';\nimport {getUid} from '../../util.js';\n\n/**\n * @typedef {import(\"../../Feature.js\").default} Feature\n */\n/**\n * @typedef {import(\"../../geom/Geometry.js\").Type} GeometryType\n */\n\n/**\n * @typedef {Object} GeometryBatchItem Object that holds a reference to a feature as well as the raw coordinates of its various geometries\n * @property {Feature|RenderFeature} feature Feature\n * @property {Array<Array<number>>} flatCoordss Array of flat coordinates arrays, one for each geometry related to the feature\n * @property {number} [verticesCount] Only defined for linestring and polygon batches\n * @property {number} [ringsCount] Only defined for polygon batches\n * @property {Array<Array<number>>} [ringsVerticesCounts] Array of vertices counts in each ring for each geometry; only defined for polygons batches\n * @property {number} [ref] The reference in the global batch (used for hit detection)\n */\n\n/**\n * @typedef {PointGeometryBatch|LineStringGeometryBatch|PolygonGeometryBatch} GeometryBatch\n */\n\n/**\n * @typedef {Object} PolygonGeometryBatch A geometry batch specific to polygons\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {number} verticesCount Amount of vertices from geometries in the batch.\n * @property {number} ringsCount How many outer and inner rings in this batch.\n */\n\n/**\n * @typedef {Object} LineStringGeometryBatch A geometry batch specific to lines\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {number} verticesCount Amount of vertices from geometries in the batch.\n */\n\n/**\n * @typedef {Object} PointGeometryBatch A geometry batch specific to points\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n */\n\n/**\n * @classdesc This class is used to group several geometries of various types together for faster rendering.\n * Three inner batches are maintained for polygons, lines and points. Each time a feature is added, changed or removed\n * from the batch, these inner batches are modified accordingly in order to keep them up-to-date.\n *\n * A feature can be present in several inner batches, for example a polygon geometry will be present in the polygon batch\n * and its linear rings will be present in the line batch. Multi geometries are also broken down into individual geometries\n * and added to the corresponding batches in a recursive manner.\n *\n * Corresponding {@link module:ol/render/webgl/BatchRenderer} instances are then used to generate the render instructions\n * and WebGL buffers (vertices and indices) for each inner batches; render instructions are stored on the inner batches,\n * alongside the transform used to convert world coords to screen coords at the time these instructions were generated.\n * The resulting WebGL buffers are stored on the batches as well.\n *\n * An important aspect of geometry batches is that there is no guarantee that render instructions and WebGL buffers\n * are synchronized, i.e. render instructions can describe a new state while WebGL buffers might not have been written yet.\n * This is why two world-to-screen transforms are stored on each batch: one for the render instructions and one for\n * the WebGL buffers.\n */\nclass MixedGeometryBatch {\n  constructor() {\n    /**\n     * @private\n     */\n    this.globalCounter_ = 0;\n\n    /**\n     * Refs are used as keys for hit detection.\n     * @type {Map<number, Feature|RenderFeature>}\n     * @private\n     */\n    this.refToFeature_ = new Map();\n\n    /**\n     * Features are split in \"entries\", which are individual geometries. We use the following map to share a single ref for all those entries.\n     * @type {Map<string, number>}\n     * @private\n     */\n    this.uidToRef_ = new Map();\n\n    /**\n     * The precision in WebGL shaders is limited.\n     * To keep the refs as small as possible we maintain an array of freed up references.\n     * @type {Array<number>}\n     * @private\n     */\n    this.freeGlobalRef_ = [];\n\n    /**\n     * @type {PolygonGeometryBatch}\n     */\n    this.polygonBatch = {\n      entries: {},\n      geometriesCount: 0,\n      verticesCount: 0,\n      ringsCount: 0,\n    };\n\n    /**\n     * @type {PointGeometryBatch}\n     */\n    this.pointBatch = {\n      entries: {},\n      geometriesCount: 0,\n    };\n\n    /**\n     * @type {LineStringGeometryBatch}\n     */\n    this.lineStringBatch = {\n      entries: {},\n      geometriesCount: 0,\n      verticesCount: 0,\n    };\n  }\n\n  /**\n   * @param {Array<Feature|RenderFeature>} features Array of features to add to the batch\n   * @param {import(\"../../proj.js\").TransformFunction} [projectionTransform] Projection transform.\n   */\n  addFeatures(features, projectionTransform) {\n    for (let i = 0; i < features.length; i++) {\n      this.addFeature(features[i], projectionTransform);\n    }\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature to add to the batch\n   * @param {import(\"../../proj.js\").TransformFunction} [projectionTransform] Projection transform.\n   */\n  addFeature(feature, projectionTransform) {\n    let geometry = feature.getGeometry();\n    if (!geometry) {\n      return;\n    }\n    if (projectionTransform) {\n      geometry = geometry.clone();\n      geometry.applyTransform(projectionTransform);\n    }\n    this.addGeometry_(geometry, feature);\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @return {GeometryBatchItem|void} the cleared entry\n   * @private\n   */\n  clearFeatureEntryInPointBatch_(feature) {\n    const featureUid = getUid(feature);\n    const entry = this.pointBatch.entries[featureUid];\n    if (!entry) {\n      return;\n    }\n    this.pointBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.pointBatch.entries[featureUid];\n    return entry;\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @return {GeometryBatchItem|void} the cleared entry\n   * @private\n   */\n  clearFeatureEntryInLineStringBatch_(feature) {\n    const featureUid = getUid(feature);\n    const entry = this.lineStringBatch.entries[featureUid];\n    if (!entry) {\n      return;\n    }\n    this.lineStringBatch.verticesCount -= entry.verticesCount;\n    this.lineStringBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.lineStringBatch.entries[featureUid];\n    return entry;\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @return {GeometryBatchItem|void} the cleared entry\n   * @private\n   */\n  clearFeatureEntryInPolygonBatch_(feature) {\n    const featureUid = getUid(feature);\n    const entry = this.polygonBatch.entries[featureUid];\n    if (!entry) {\n      return;\n    }\n    this.polygonBatch.verticesCount -= entry.verticesCount;\n    this.polygonBatch.ringsCount -= entry.ringsCount;\n    this.polygonBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.polygonBatch.entries[featureUid];\n    return entry;\n  }\n\n  /**\n   * @param {import(\"../../geom.js\").Geometry|RenderFeature} geometry Geometry\n   * @param {Feature|RenderFeature} feature Feature\n   * @private\n   */\n  addGeometry_(geometry, feature) {\n    const type = geometry.getType();\n    switch (type) {\n      case 'GeometryCollection': {\n        const geometries =\n          /** @type {import(\"../../geom.js\").GeometryCollection} */ (\n            geometry\n          ).getGeometriesArray();\n        for (const geometry of geometries) {\n          this.addGeometry_(geometry, feature);\n        }\n        break;\n      }\n      case 'MultiPolygon': {\n        const multiPolygonGeom =\n          /** @type {import(\"../../geom.js\").MultiPolygon} */ (geometry);\n        this.addCoordinates_(\n          type,\n          multiPolygonGeom.getFlatCoordinates(),\n          multiPolygonGeom.getEndss(),\n          feature,\n          getUid(feature),\n          multiPolygonGeom.getStride(),\n        );\n        break;\n      }\n      case 'MultiLineString': {\n        const multiLineGeom =\n          /** @type {import(\"../../geom.js\").MultiLineString|RenderFeature} */ (\n            geometry\n          );\n        this.addCoordinates_(\n          type,\n          multiLineGeom.getFlatCoordinates(),\n          multiLineGeom.getEnds(),\n          feature,\n          getUid(feature),\n          multiLineGeom.getStride(),\n        );\n        break;\n      }\n      case 'MultiPoint': {\n        const multiPointGeom =\n          /** @type {import(\"../../geom.js\").MultiPoint|RenderFeature} */ (\n            geometry\n          );\n        this.addCoordinates_(\n          type,\n          multiPointGeom.getFlatCoordinates(),\n          null,\n          feature,\n          getUid(feature),\n          multiPointGeom.getStride(),\n        );\n        break;\n      }\n      case 'Polygon': {\n        const polygonGeom =\n          /** @type {import(\"../../geom.js\").Polygon|RenderFeature} */ (\n            geometry\n          );\n        this.addCoordinates_(\n          type,\n          polygonGeom.getFlatCoordinates(),\n          polygonGeom.getEnds(),\n          feature,\n          getUid(feature),\n          polygonGeom.getStride(),\n        );\n        break;\n      }\n      case 'Point': {\n        const pointGeom = /** @type {import(\"../../geom.js\").Point} */ (\n          geometry\n        );\n        this.addCoordinates_(\n          type,\n          pointGeom.getFlatCoordinates(),\n          null,\n          feature,\n          getUid(feature),\n          pointGeom.getStride(),\n        );\n        break;\n      }\n      case 'LineString':\n      case 'LinearRing': {\n        const lineGeom = /** @type {import(\"../../geom.js\").LineString} */ (\n          geometry\n        );\n\n        const stride = lineGeom.getStride();\n\n        this.addCoordinates_(\n          type,\n          lineGeom.getFlatCoordinates(),\n          null,\n          feature,\n          getUid(feature),\n          stride,\n          lineGeom.getLayout?.(),\n        );\n        break;\n      }\n      default:\n      // pass\n    }\n  }\n\n  /**\n   * @param {GeometryType} type Geometry type\n   * @param {Array<number>} flatCoords Flat coordinates\n   * @param {Array<number> | Array<Array<number>> | null} ends Coordinate ends\n   * @param {Feature|RenderFeature} feature Feature\n   * @param {string} featureUid Feature uid\n   * @param {number} stride Stride\n   * @param {import('../../geom/Geometry.js').GeometryLayout} [layout] Layout\n   * @private\n   */\n  addCoordinates_(type, flatCoords, ends, feature, featureUid, stride, layout) {\n    /** @type {number} */\n    let verticesCount;\n    switch (type) {\n      case 'MultiPolygon': {\n        const multiPolygonEndss = /** @type {Array<Array<number>>} */ (ends);\n        for (let i = 0, ii = multiPolygonEndss.length; i < ii; i++) {\n          let polygonEnds = multiPolygonEndss[i];\n          const prevPolygonEnds = i > 0 ? multiPolygonEndss[i - 1] : null;\n          const startIndex = prevPolygonEnds\n            ? prevPolygonEnds[prevPolygonEnds.length - 1]\n            : 0;\n          const endIndex = polygonEnds[polygonEnds.length - 1];\n          polygonEnds =\n            startIndex > 0\n              ? polygonEnds.map((end) => end - startIndex)\n              : polygonEnds;\n          this.addCoordinates_(\n            'Polygon',\n            flatCoords.slice(startIndex, endIndex),\n            polygonEnds,\n            feature,\n            featureUid,\n            stride,\n            layout,\n          );\n        }\n        break;\n      }\n      case 'MultiLineString': {\n        const multiLineEnds = /** @type {Array<number>} */ (ends);\n        for (let i = 0, ii = multiLineEnds.length; i < ii; i++) {\n          const startIndex = i > 0 ? multiLineEnds[i - 1] : 0;\n          this.addCoordinates_(\n            'LineString',\n            flatCoords.slice(startIndex, multiLineEnds[i]),\n            null,\n            feature,\n            featureUid,\n            stride,\n            layout,\n          );\n        }\n        break;\n      }\n      case 'MultiPoint':\n        for (let i = 0, ii = flatCoords.length; i < ii; i += stride) {\n          this.addCoordinates_(\n            'Point',\n            flatCoords.slice(i, i + 2),\n            null,\n            feature,\n            featureUid,\n            null,\n            null,\n          );\n        }\n        break;\n      case 'Polygon': {\n        const polygonEnds = /** @type {Array<number>} */ (ends);\n        if (feature instanceof RenderFeature) {\n          const multiPolygonEnds = inflateEnds(flatCoords, polygonEnds);\n          if (multiPolygonEnds.length > 1) {\n            this.addCoordinates_(\n              'MultiPolygon',\n              flatCoords,\n              multiPolygonEnds,\n              feature,\n              featureUid,\n              stride,\n              layout,\n            );\n            return;\n          }\n        }\n        if (!this.polygonBatch.entries[featureUid]) {\n          this.polygonBatch.entries[featureUid] = this.addRefToEntry_(\n            featureUid,\n            {\n              feature: feature,\n              flatCoordss: [],\n              verticesCount: 0,\n              ringsCount: 0,\n              ringsVerticesCounts: [],\n            },\n          );\n        }\n        verticesCount = flatCoords.length / stride;\n        const ringsCount = ends.length;\n        const ringsVerticesCount = ends.map((end, ind, arr) =>\n          ind > 0 ? (end - arr[ind - 1]) / stride : end / stride,\n        );\n        this.polygonBatch.verticesCount += verticesCount;\n        this.polygonBatch.ringsCount += ringsCount;\n        this.polygonBatch.geometriesCount++;\n        this.polygonBatch.entries[featureUid].flatCoordss.push(\n          getFlatCoordinatesXY(flatCoords, stride),\n        );\n        this.polygonBatch.entries[featureUid].ringsVerticesCounts.push(\n          ringsVerticesCount,\n        );\n        this.polygonBatch.entries[featureUid].verticesCount += verticesCount;\n        this.polygonBatch.entries[featureUid].ringsCount += ringsCount;\n        for (let i = 0, ii = polygonEnds.length; i < ii; i++) {\n          const startIndex = i > 0 ? polygonEnds[i - 1] : 0;\n          this.addCoordinates_(\n            'LinearRing',\n            flatCoords.slice(startIndex, polygonEnds[i]),\n            null,\n            feature,\n            featureUid,\n            stride,\n            layout,\n          );\n        }\n        break;\n      }\n      case 'Point':\n        if (!this.pointBatch.entries[featureUid]) {\n          this.pointBatch.entries[featureUid] = this.addRefToEntry_(\n            featureUid,\n            {\n              feature: feature,\n              flatCoordss: [],\n            },\n          );\n        }\n        this.pointBatch.geometriesCount++;\n        this.pointBatch.entries[featureUid].flatCoordss.push(flatCoords);\n        break;\n      case 'LineString':\n      case 'LinearRing':\n        if (!this.lineStringBatch.entries[featureUid]) {\n          this.lineStringBatch.entries[featureUid] = this.addRefToEntry_(\n            featureUid,\n            {\n              feature: feature,\n              flatCoordss: [],\n              verticesCount: 0,\n            },\n          );\n        }\n        verticesCount = flatCoords.length / stride;\n        this.lineStringBatch.verticesCount += verticesCount;\n        this.lineStringBatch.geometriesCount++;\n        this.lineStringBatch.entries[featureUid].flatCoordss.push(\n          getFlatCoordinatesXYM(flatCoords, stride, layout),\n        );\n        this.lineStringBatch.entries[featureUid].verticesCount += verticesCount;\n        break;\n      default:\n      // pass\n    }\n  }\n\n  /**\n   * @param {string} featureUid Feature uid\n   * @param {GeometryBatchItem} entry The entry to add\n   * @return {GeometryBatchItem} the added entry\n   * @private\n   */\n  addRefToEntry_(featureUid, entry) {\n    const currentRef = this.uidToRef_.get(featureUid);\n\n    // the ref starts at 1 to distinguish from white color (no feature)\n    const ref =\n      currentRef || this.freeGlobalRef_.pop() || ++this.globalCounter_;\n    entry.ref = ref;\n    if (!currentRef) {\n      this.refToFeature_.set(ref, entry.feature);\n      this.uidToRef_.set(featureUid, ref);\n    }\n    return entry;\n  }\n\n  /**\n   * Return a ref to the pool of available refs.\n   * @param {number} ref the ref to return\n   * @param {string} featureUid the feature uid\n   * @private\n   */\n  removeRef_(ref, featureUid) {\n    if (!ref) {\n      throw new Error('This feature has no ref: ' + featureUid);\n    }\n    this.refToFeature_.delete(ref);\n    this.uidToRef_.delete(featureUid);\n    this.freeGlobalRef_.push(ref);\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @param {import(\"../../proj.js\").TransformFunction} [projectionTransform] Projection transform.\n   */\n  changeFeature(feature, projectionTransform) {\n    // the feature is not present in the batch; do not add it to avoid unexpected behaviors\n    if (!this.uidToRef_.get(getUid(feature))) {\n      return;\n    }\n    this.removeFeature(feature);\n    let geometry = feature.getGeometry();\n    if (!geometry) {\n      return;\n    }\n    if (projectionTransform) {\n      geometry = geometry.clone();\n      geometry.applyTransform(projectionTransform);\n    }\n    this.addGeometry_(geometry, feature);\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   */\n  removeFeature(feature) {\n    let entry = this.clearFeatureEntryInPointBatch_(feature);\n    entry = this.clearFeatureEntryInPolygonBatch_(feature) || entry;\n    entry = this.clearFeatureEntryInLineStringBatch_(feature) || entry;\n    if (entry) {\n      this.removeRef_(entry.ref, getUid(entry.feature));\n    }\n  }\n\n  clear() {\n    this.polygonBatch.entries = {};\n    this.polygonBatch.geometriesCount = 0;\n    this.polygonBatch.verticesCount = 0;\n    this.polygonBatch.ringsCount = 0;\n    this.lineStringBatch.entries = {};\n    this.lineStringBatch.geometriesCount = 0;\n    this.lineStringBatch.verticesCount = 0;\n    this.pointBatch.entries = {};\n    this.pointBatch.geometriesCount = 0;\n    this.globalCounter_ = 0;\n    this.freeGlobalRef_ = [];\n    this.refToFeature_.clear();\n    this.uidToRef_.clear();\n  }\n\n  /**\n   * Resolve the feature associated to a ref.\n   * @param {number} ref Hit detected ref\n   * @return {Feature|RenderFeature} feature\n   */\n  getFeatureFromRef(ref) {\n    return this.refToFeature_.get(ref);\n  }\n\n  isEmpty() {\n    return this.globalCounter_ === 0;\n  }\n\n  /**\n   * Will return a new instance of this class that only contains the features\n   * for which the provided callback returned true\n   * @param {function((Feature|RenderFeature)): boolean} featureFilter Feature filter callback\n   * @return {MixedGeometryBatch} Filtered geometry batch\n   */\n  filter(featureFilter) {\n    const filtered = new MixedGeometryBatch();\n    filtered.globalCounter_ = this.globalCounter_;\n    filtered.uidToRef_ = this.uidToRef_;\n    filtered.refToFeature_ = this.refToFeature_;\n    let empty = true;\n    for (const feature of this.refToFeature_.values()) {\n      if (featureFilter(feature)) {\n        filtered.addFeature(feature);\n        empty = false;\n      }\n    }\n    // no feature was added at all; simply return an empty batch for consistency downstream\n    if (empty) {\n      return new MixedGeometryBatch();\n    }\n    return filtered;\n  }\n}\n\n/**\n * @param {Array<number>} flatCoords Flat coords\n * @param {number} stride Stride\n * @return {Array<number>} Flat coords with only XY components\n */\nfunction getFlatCoordinatesXY(flatCoords, stride) {\n  if (stride === 2) {\n    return flatCoords;\n  }\n  return flatCoords.filter((v, i) => i % stride < 2);\n}\n\n/**\n * @param {Array<number>} flatCoords Flat coords\n * @param {number} stride Stride\n * @param {string} layout Layout\n * @return {Array<number>} Flat coords with only XY components\n */\nfunction getFlatCoordinatesXYM(flatCoords, stride, layout) {\n  if (stride === 3 && layout === 'XYM') {\n    return flatCoords;\n  }\n  // this is XYZM layout\n  if (stride === 4) {\n    return flatCoords.filter((v, i) => i % stride !== 2);\n  }\n  // this is XYZ layout\n  if (stride === 3) {\n    return flatCoords.map((v, i) => (i % stride !== 2 ? v : 0));\n  }\n  // this is XY layout\n  return new Array(flatCoords.length * 1.5)\n    .fill(0)\n    .map((v, i) => (i % 3 === 2 ? 0 : flatCoords[Math.round(i / 1.5)]));\n}\n\nexport default MixedGeometryBatch;\n","/**\n * @module ol/render/webgl/renderinstructions\n */\nimport {UNDEFINED_PROP_VALUE} from '../../expr/gpu.js';\nimport {transform2D} from '../../geom/flat/transform.js';\nimport {apply as applyTransform} from '../../transform.js';\n\n/**\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"./MixedGeometryBatch.js\").GeometryBatchItem} batchEntry Batch item\n * @param {number} currentIndex Current index\n * @return {number} The amount of values pushed\n */\nfunction pushCustomAttributesInRenderInstructions(\n  renderInstructions,\n  customAttributes,\n  batchEntry,\n  currentIndex,\n) {\n  let shift = 0;\n  for (const key in customAttributes) {\n    const attr = customAttributes[key];\n    const value = attr.callback.call(batchEntry, batchEntry.feature);\n    let first = value?.[0] ?? value;\n    if (first === UNDEFINED_PROP_VALUE) {\n      console.warn('The \"has\" operator might return false positives.'); // eslint-disable-line no-console\n    }\n    if (first === undefined) {\n      first = UNDEFINED_PROP_VALUE;\n    } else if (first === null) {\n      first = 0;\n    }\n    renderInstructions[currentIndex + shift++] = first;\n    if (!attr.size || attr.size === 1) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[1];\n    if (attr.size < 3) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[2];\n    if (attr.size < 4) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[3];\n  }\n  return shift;\n}\n\n/**\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @return {number} Cumulated size of all attributes\n */\nexport function getCustomAttributesSize(customAttributes) {\n  return Object.keys(customAttributes).reduce(\n    (prev, curr) => prev + (customAttributes[curr].size || 1),\n    0,\n  );\n}\n\n/**\n * Render instructions for lines are structured like so:\n * [ x0, y0, customAttr0, ... , xN, yN, customAttrN ]\n * @param {import(\"./MixedGeometryBatch.js\").PointGeometryBatch} batch Point geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generatePointRenderInstructions(\n  batch,\n  renderInstructions,\n  customAttributes,\n  transform,\n) {\n  // here we anticipate the amount of render instructions for points:\n  // 2 instructions per vertex for position (x and y)\n  // + 1 instruction per vertex per custom attributes\n  const totalInstructionsCount =\n    (2 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount;\n  if (\n    !renderInstructions ||\n    renderInstructions.length !== totalInstructionsCount\n  ) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  const tmpCoords = [];\n  let renderIndex = 0;\n  for (const featureUid in batch.entries) {\n    const batchEntry = batch.entries[featureUid];\n    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      tmpCoords[0] = batchEntry.flatCoordss[i][0];\n      tmpCoords[1] = batchEntry.flatCoordss[i][1];\n      applyTransform(transform, tmpCoords);\n\n      renderInstructions[renderIndex++] = tmpCoords[0];\n      renderInstructions[renderIndex++] = tmpCoords[1];\n      renderIndex += pushCustomAttributesInRenderInstructions(\n        renderInstructions,\n        customAttributes,\n        batchEntry,\n        renderIndex,\n      );\n    }\n  }\n  return renderInstructions;\n}\n\n/**\n * Render instructions for lines are structured like so:\n * [ customAttr0, ... , customAttrN, numberOfVertices0, x0, y0, ... , xN, yN, numberOfVertices1, ... ]\n * @param {import(\"./MixedGeometryBatch.js\").LineStringGeometryBatch} batch Line String geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generateLineStringRenderInstructions(\n  batch,\n  renderInstructions,\n  customAttributes,\n  transform,\n) {\n  // here we anticipate the amount of render instructions for lines:\n  // 3 instructions per vertex for position (x, y and m)\n  // + 1 instruction per line per custom attributes\n  // + 1 instruction per line (for vertices count)\n  const totalInstructionsCount =\n    3 * batch.verticesCount +\n    (1 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount;\n  if (\n    !renderInstructions ||\n    renderInstructions.length !== totalInstructionsCount\n  ) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  const flatCoords = [];\n  let renderIndex = 0;\n  for (const featureUid in batch.entries) {\n    const batchEntry = batch.entries[featureUid];\n    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      flatCoords.length = batchEntry.flatCoordss[i].length;\n      transform2D(\n        batchEntry.flatCoordss[i],\n        0,\n        flatCoords.length,\n        3,\n        transform,\n        flatCoords,\n        3,\n      );\n      renderIndex += pushCustomAttributesInRenderInstructions(\n        renderInstructions,\n        customAttributes,\n        batchEntry,\n        renderIndex,\n      );\n\n      // vertices count\n      renderInstructions[renderIndex++] = flatCoords.length / 3;\n\n      // looping on points for positions\n      for (let j = 0, jj = flatCoords.length; j < jj; j += 3) {\n        renderInstructions[renderIndex++] = flatCoords[j];\n        renderInstructions[renderIndex++] = flatCoords[j + 1];\n        renderInstructions[renderIndex++] = flatCoords[j + 2];\n      }\n    }\n  }\n  return renderInstructions;\n}\n\n/**\n * Render instructions for polygons are structured like so:\n * [ customAttr0, ..., customAttrN, numberOfRings, numberOfVerticesInRing0, ..., numberOfVerticesInRingN, x0, y0, ..., xN, yN, numberOfRings,... ]\n * @param {import(\"./MixedGeometryBatch.js\").PolygonGeometryBatch} batch Polygon geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generatePolygonRenderInstructions(\n  batch,\n  renderInstructions,\n  customAttributes,\n  transform,\n) {\n  // here we anticipate the amount of render instructions for polygons:\n  // 2 instructions per vertex for position (x and y)\n  // + 1 instruction per polygon per custom attributes\n  // + 1 instruction per polygon (for vertices count in polygon)\n  // + 1 instruction per ring (for vertices count in ring)\n  const totalInstructionsCount =\n    2 * batch.verticesCount +\n    (1 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount +\n    batch.ringsCount;\n  if (\n    !renderInstructions ||\n    renderInstructions.length !== totalInstructionsCount\n  ) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  const flatCoords = [];\n  let renderIndex = 0;\n  for (const featureUid in batch.entries) {\n    const batchEntry = batch.entries[featureUid];\n    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      flatCoords.length = batchEntry.flatCoordss[i].length;\n      transform2D(\n        batchEntry.flatCoordss[i],\n        0,\n        flatCoords.length,\n        2,\n        transform,\n        flatCoords,\n      );\n      renderIndex += pushCustomAttributesInRenderInstructions(\n        renderInstructions,\n        customAttributes,\n        batchEntry,\n        renderIndex,\n      );\n\n      // ring count\n      renderInstructions[renderIndex++] =\n        batchEntry.ringsVerticesCounts[i].length;\n\n      // vertices count in each ring\n      for (\n        let j = 0, jj = batchEntry.ringsVerticesCounts[i].length;\n        j < jj;\n        j++\n      ) {\n        renderInstructions[renderIndex++] =\n          batchEntry.ringsVerticesCounts[i][j];\n      }\n\n      // looping on points for positions\n      for (let j = 0, jj = flatCoords.length; j < jj; j += 2) {\n        renderInstructions[renderIndex++] = flatCoords[j];\n        renderInstructions[renderIndex++] = flatCoords[j + 1];\n      }\n    }\n  }\n  return renderInstructions;\n}\n","/**\n * @module ol/render/webgl/VectorStyleRenderer\n */\nimport {buildExpression, newEvaluationContext} from '../../expr/cpu.js';\nimport {\n  BooleanType,\n  computeGeometryType,\n  newParsingContext,\n} from '../../expr/expression.js';\nimport {\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n} from '../../transform.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport {AttributeType} from '../../webgl/Helper.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {WebGLWorkerMessageType} from './constants.js';\nimport {colorEncodeId} from './encodeUtil.js';\nimport {\n  generateLineStringRenderInstructions,\n  generatePointRenderInstructions,\n  generatePolygonRenderInstructions,\n  getCustomAttributesSize,\n} from './renderinstructions.js';\nimport {parseLiteralStyle} from './style.js';\n\nconst tmpColor = [];\n/** @type {Worker|undefined} */\nlet WEBGL_WORKER;\nfunction getWebGLWorker() {\n  if (!WEBGL_WORKER) {\n    WEBGL_WORKER = createWebGLWorker();\n  }\n  return WEBGL_WORKER;\n}\nlet workerMessageCounter = 0;\n\n/**\n * Names of attributes made available to the vertex shader.\n * Please note: changing these *will* break custom shaders!\n * @enum {string}\n */\nexport const Attributes = {\n  POSITION: 'a_position',\n  INDEX: 'a_index',\n  SEGMENT_START: 'a_segmentStart',\n  SEGMENT_END: 'a_segmentEnd',\n  MEASURE_START: 'a_measureStart',\n  MEASURE_END: 'a_measureEnd',\n  PARAMETERS: 'a_parameters',\n  JOIN_ANGLES: 'a_joinAngles',\n  DISTANCE: 'a_distance',\n};\n\n/**\n * @typedef {Object} AttributeDefinition A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {number} [size] Amount of numerical values composing the attribute, either 1, 2, 3 or 4; in case size is > 1, the return value\n * of the callback should be an array; if unspecified, assumed to be a single float value\n * @property {function(this:import(\"./MixedGeometryBatch.js\").GeometryBatchItem, import(\"../../Feature\").FeatureLike):number|Array<number>} callback This callback computes the numerical value of the\n * attribute for a given feature.\n */\n\n/**\n * @typedef {Object<string, AttributeDefinition>} AttributeDefinitions\n * @typedef {Object<string, import(\"../../webgl/Helper\").UniformValue>} UniformDefinitions\n */\n\n/**\n * @typedef {Object} WebGLBuffers\n * @property {Array<WebGLArrayBuffer>} polygonBuffers Array containing indices and vertices buffers for polygons\n * @property {Array<WebGLArrayBuffer>} lineStringBuffers Array containing indices and vertices buffers for line strings\n * @property {Array<WebGLArrayBuffer>} pointBuffers Array containing indices and vertices buffers for points\n * @property {import(\"../../transform.js\").Transform} invertVerticesTransform Inverse of the transform applied when generating buffers\n */\n\n/**\n * @typedef {Object} RenderInstructions\n * @property {Float32Array|null} polygonInstructions Polygon instructions; null if nothing to render\n * @property {Float32Array|null} lineStringInstructions LineString instructions; null if nothing to render\n * @property {Float32Array|null} pointInstructions Point instructions; null if nothing to render\n */\n\n/**\n * @typedef {Object} ShaderProgram An object containing both shaders (vertex and fragment)\n * @property {string} vertex Vertex shader source\n * @property {string} fragment Fragment shader source\n */\n\n/**\n * @typedef {Object} AsShaders\n * @property {import(\"./ShaderBuilder.js\").ShaderBuilder} builder Shader builder with the appropriate presets.\n * @property {AttributeDefinitions} [attributes] Custom attributes made available in the vertex shaders.\n * Default shaders rely on the attributes in {@link Attributes}.\n * @property {UniformDefinitions} [uniforms] Additional uniforms usable in shaders.\n */\n\n/**\n * @typedef {Object} AsRule\n * @property {import('../../style/flat.js').FlatStyle} style Style\n * @property {import(\"../../expr/expression.js\").EncodedExpression} [filter] Filter\n */\n\n/**\n * @typedef {AsRule|AsShaders} VectorStyle\n */\n\n/**\n * @classdesc This class is responsible for:\n * 1. generate WebGL buffers according to a provided style, using a MixedGeometryBatch as input\n * 2. rendering geometries contained in said buffers\n *\n * A layer renderer will typically maintain several of these in order to have several styles rendered separately.\n *\n * A VectorStyleRenderer instance can be created either from a literal style or from shaders using either\n * `VectorStyleRenderer.fromStyle` or `VectorStyleRenderer.fromShaders`. The shaders should not be provided explicitly\n * but instead as a preconfigured ShaderBuilder instance.\n *\n * The `generateBuffers` method returns a promise resolving to WebGL buffers that are intended to be rendered by the\n * same renderer.\n */\nclass VectorStyleRenderer {\n  /**\n   * @param {VectorStyle} styleOrShaders Literal style or custom shaders\n   * @param {import('../../style/flat.js').StyleVariables} variables Style variables\n   * @param {import('../../webgl/Helper.js').default} helper Helper\n   * @param {boolean} [enableHitDetection] Whether to enable the hit detection (needs compatible shader)\n   * @param {import(\"../../expr/expression.js\").ExpressionValue} [filter] Optional filter expression\n   */\n  constructor(styleOrShaders, variables, helper, enableHitDetection, filter) {\n    /**\n     * @private\n     * @type {import('../../webgl/Helper.js').default}\n     */\n    this.helper_;\n\n    /**\n     * @private\n     */\n    this.hitDetectionEnabled_ = !!enableHitDetection;\n\n    let asShaders = /** @type {AsShaders} */ (styleOrShaders);\n    const isShaders = 'builder' in styleOrShaders;\n    if (!isShaders) {\n      const asRule = /** @type {AsRule} */ (styleOrShaders);\n      const parseResult = parseLiteralStyle(\n        asRule.style,\n        variables,\n        asRule.filter,\n      );\n      asShaders = {\n        builder: parseResult.builder,\n        attributes: parseResult.attributes,\n        uniforms: parseResult.uniforms,\n      };\n    }\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.fillProgram_;\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.strokeProgram_;\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.symbolProgram_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasFill_ = !!asShaders.builder.getFillVertexShader();\n    if (this.hasFill_) {\n      /**\n       * @private\n       */\n      this.fillVertexShader_ = asShaders.builder.getFillVertexShader();\n      /**\n       * @private\n       */\n      this.fillFragmentShader_ = asShaders.builder.getFillFragmentShader();\n    }\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasStroke_ = !!asShaders.builder.getStrokeVertexShader();\n    if (this.hasStroke_) {\n      /**\n       * @private\n       */\n      this.strokeVertexShader_ = asShaders.builder.getStrokeVertexShader();\n      /**\n       * @private\n       */\n      this.strokeFragmentShader_ = asShaders.builder.getStrokeFragmentShader();\n    }\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasSymbol_ = !!asShaders.builder.getSymbolVertexShader();\n    if (this.hasSymbol_) {\n      /**\n       * @private\n       */\n      this.symbolVertexShader_ = asShaders.builder.getSymbolVertexShader();\n      /**\n       * @private\n       */\n      this.symbolFragmentShader_ = asShaders.builder.getSymbolFragmentShader();\n    }\n\n    /**\n     * @type {function(import('../../Feature.js').FeatureLike): boolean}\n     * @private\n     */\n    this.featureFilter_ = null;\n    if (filter) {\n      this.featureFilter_ = this.computeFeatureFilter(filter);\n    }\n\n    const hitDetectionAttributes = this.hitDetectionEnabled_\n      ? {\n          hitColor: {\n            callback() {\n              return colorEncodeId(this.ref, tmpColor);\n            },\n            size: 4,\n          },\n        }\n      : {};\n\n    /**\n     * @private\n     */\n    this.customAttributes_ = Object.assign(\n      {},\n      hitDetectionAttributes,\n      asShaders.attributes,\n    );\n    /**\n     * @private\n     */\n    this.uniforms_ = asShaders.uniforms;\n\n    const customAttributesDesc = Object.entries(this.customAttributes_).map(\n      ([name, value]) => ({\n        name: `a_${name}`,\n        size: value.size || 1,\n        type: AttributeType.FLOAT,\n      }),\n    );\n    /**\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     * @private\n     */\n    this.polygonAttributesDesc_ = [\n      {\n        name: Attributes.POSITION,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      ...customAttributesDesc,\n    ];\n    /**\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     * @private\n     */\n    this.lineStringAttributesDesc_ = [\n      {\n        name: Attributes.SEGMENT_START,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.MEASURE_START,\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.SEGMENT_END,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.MEASURE_END,\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.JOIN_ANGLES,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.DISTANCE,\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.PARAMETERS,\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      ...customAttributesDesc,\n    ];\n    /**\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     * @private\n     */\n    this.pointAttributesDesc_ = [\n      {\n        name: Attributes.POSITION,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.INDEX,\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      ...customAttributesDesc,\n    ];\n\n    this.setHelper(helper);\n  }\n\n  /**\n   * Will apply the style filter when generating geometry batches (if it can be evaluated outside a map context)\n   * @param {import(\"../../expr/expression.js\").ExpressionValue} filter Style filter\n   * @return {function(import('../../Feature.js').FeatureLike): boolean} Feature filter\n   * @private\n   */\n  computeFeatureFilter(filter) {\n    const parsingContext = newParsingContext();\n    /**\n     * @type {import('../../expr/cpu.js').ExpressionEvaluator}\n     */\n    let compiled;\n    try {\n      compiled = buildExpression(filter, BooleanType, parsingContext);\n    } catch {\n      // filter expression failed to compile for CPU: ignore it\n      return null;\n    }\n\n    // do not apply the filter if it depends on map state (e.g. zoom level) or any variable\n    if (parsingContext.mapState || parsingContext.variables.size > 0) {\n      return null;\n    }\n\n    const evalContext = newEvaluationContext();\n    return (feature) => {\n      evalContext.properties = feature.getPropertiesInternal();\n      if (parsingContext.featureId) {\n        const id = feature.getId();\n        if (id !== undefined) {\n          evalContext.featureId = id;\n        } else {\n          evalContext.featureId = null;\n        }\n      }\n      evalContext.geometryType = computeGeometryType(feature.getGeometry());\n      return /** @type {boolean} */ (compiled(evalContext));\n    };\n  }\n\n  /**\n   * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch\n   * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n   * @return {Promise<WebGLBuffers|null>} A promise resolving to WebGL buffers; returns null if buffers are empty\n   */\n  async generateBuffers(geometryBatch, transform) {\n    let filteredBatch = geometryBatch;\n    if (this.featureFilter_) {\n      filteredBatch = filteredBatch.filter(this.featureFilter_);\n      if (filteredBatch.isEmpty()) {\n        return null;\n      }\n    }\n    const renderInstructions = this.generateRenderInstructions_(\n      filteredBatch,\n      transform,\n    );\n    const [polygonBuffers, lineStringBuffers, pointBuffers] = await Promise.all(\n      [\n        this.generateBuffersForType_(\n          renderInstructions.polygonInstructions,\n          'Polygon',\n          transform,\n        ),\n        this.generateBuffersForType_(\n          renderInstructions.lineStringInstructions,\n          'LineString',\n          transform,\n        ),\n        this.generateBuffersForType_(\n          renderInstructions.pointInstructions,\n          'Point',\n          transform,\n        ),\n      ],\n    );\n    // also return the inverse of the transform that was applied when generating buffers\n    const invertVerticesTransform = makeInverseTransform(\n      createTransform(),\n      transform,\n    );\n    return {\n      polygonBuffers: polygonBuffers,\n      lineStringBuffers: lineStringBuffers,\n      pointBuffers: pointBuffers,\n      invertVerticesTransform: invertVerticesTransform,\n    };\n  }\n\n  /**\n   * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch\n   * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n   * @return {RenderInstructions} Render instructions\n   * @private\n   */\n  generateRenderInstructions_(geometryBatch, transform) {\n    const polygonInstructions = this.hasFill_\n      ? generatePolygonRenderInstructions(\n          geometryBatch.polygonBatch,\n          new Float32Array(0),\n          this.customAttributes_,\n          transform,\n        )\n      : null;\n    const lineStringInstructions = this.hasStroke_\n      ? generateLineStringRenderInstructions(\n          geometryBatch.lineStringBatch,\n          new Float32Array(0),\n          this.customAttributes_,\n          transform,\n        )\n      : null;\n    const pointInstructions = this.hasSymbol_\n      ? generatePointRenderInstructions(\n          geometryBatch.pointBatch,\n          new Float32Array(0),\n          this.customAttributes_,\n          transform,\n        )\n      : null;\n\n    return {\n      polygonInstructions,\n      lineStringInstructions,\n      pointInstructions,\n    };\n  }\n\n  /**\n   * @param {Float32Array|null} renderInstructions Render instructions\n   * @param {import(\"../../geom/Geometry.js\").Type} geometryType Geometry type\n   * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n   * @return {Promise<Array<WebGLArrayBuffer>>|null} Indices buffer and vertices buffer; null if nothing to render\n   * @private\n   */\n  generateBuffersForType_(renderInstructions, geometryType, transform) {\n    if (renderInstructions === null) {\n      return null;\n    }\n\n    const messageId = workerMessageCounter++;\n    let messageType;\n    switch (geometryType) {\n      case 'Polygon':\n        messageType = WebGLWorkerMessageType.GENERATE_POLYGON_BUFFERS;\n        break;\n      case 'LineString':\n        messageType = WebGLWorkerMessageType.GENERATE_LINE_STRING_BUFFERS;\n        break;\n      case 'Point':\n        messageType = WebGLWorkerMessageType.GENERATE_POINT_BUFFERS;\n        break;\n      default:\n      // pass\n    }\n\n    /** @type {import('./constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: messageId,\n      type: messageType,\n      renderInstructions: renderInstructions.buffer,\n      renderInstructionsTransform: transform,\n      customAttributesSize: getCustomAttributesSize(this.customAttributes_),\n    };\n    const WEBGL_WORKER = getWebGLWorker();\n    WEBGL_WORKER.postMessage(message, [renderInstructions.buffer]);\n\n    // leave ownership of render instructions\n    renderInstructions = null;\n\n    return new Promise((resolve) => {\n      /**\n       * @param {*} event Event.\n       */\n      const handleMessage = (event) => {\n        const received = event.data;\n\n        // this is not the response to our request: skip\n        if (received.id !== messageId) {\n          return;\n        }\n\n        // we've received our response: stop listening\n        WEBGL_WORKER.removeEventListener('message', handleMessage);\n\n        // the helper has disposed in the meantime; the promise will not be resolved\n        if (!this.helper_.getGL()) {\n          return;\n        }\n\n        // copy & flush received buffers to GPU\n        const verticesBuffer = new WebGLArrayBuffer(\n          ARRAY_BUFFER,\n          DYNAMIC_DRAW,\n        ).fromArrayBuffer(received.vertexBuffer);\n        const indicesBuffer = new WebGLArrayBuffer(\n          ELEMENT_ARRAY_BUFFER,\n          DYNAMIC_DRAW,\n        ).fromArrayBuffer(received.indexBuffer);\n        this.helper_.flushBufferData(verticesBuffer);\n        this.helper_.flushBufferData(indicesBuffer);\n\n        resolve([indicesBuffer, verticesBuffer]);\n      };\n\n      WEBGL_WORKER.addEventListener('message', handleMessage);\n    });\n  }\n\n  /**\n   * Render the geometries in the given buffers.\n   * @param {WebGLBuffers} buffers WebGL Buffers to draw\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state\n   * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms\n   */\n  render(buffers, frameState, preRenderCallback) {\n    this.hasFill_ &&\n      this.renderInternal_(\n        buffers.polygonBuffers[0],\n        buffers.polygonBuffers[1],\n        this.fillProgram_,\n        this.polygonAttributesDesc_,\n        frameState,\n        preRenderCallback,\n      );\n    this.hasStroke_ &&\n      this.renderInternal_(\n        buffers.lineStringBuffers[0],\n        buffers.lineStringBuffers[1],\n        this.strokeProgram_,\n        this.lineStringAttributesDesc_,\n        frameState,\n        preRenderCallback,\n      );\n    this.hasSymbol_ &&\n      this.renderInternal_(\n        buffers.pointBuffers[0],\n        buffers.pointBuffers[1],\n        this.symbolProgram_,\n        this.pointAttributesDesc_,\n        frameState,\n        preRenderCallback,\n      );\n  }\n\n  /**\n   * @param {WebGLArrayBuffer} indicesBuffer Indices buffer\n   * @param {WebGLArrayBuffer} verticesBuffer Vertices buffer\n   * @param {WebGLProgram} program Program\n   * @param {Array<import('../../webgl/Helper.js').AttributeDescription>} attributes Attribute descriptions\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms\n   * @private\n   */\n  renderInternal_(\n    indicesBuffer,\n    verticesBuffer,\n    program,\n    attributes,\n    frameState,\n    preRenderCallback,\n  ) {\n    const renderCount = indicesBuffer.getSize();\n    if (renderCount === 0) {\n      return;\n    }\n    this.helper_.useProgram(program, frameState);\n    this.helper_.bindBuffer(verticesBuffer);\n    this.helper_.bindBuffer(indicesBuffer);\n    this.helper_.enableAttributes(attributes);\n    preRenderCallback();\n    this.helper_.drawElements(0, renderCount);\n  }\n\n  /**\n   * @param {import('../../webgl/Helper.js').default} helper Helper\n   * @param {WebGLBuffers} buffers WebGL Buffers to reload if any\n   */\n  setHelper(helper, buffers = null) {\n    this.helper_ = helper;\n\n    if (this.hasFill_) {\n      this.fillProgram_ = this.helper_.getProgram(\n        this.fillFragmentShader_,\n        this.fillVertexShader_,\n      );\n    }\n    if (this.hasStroke_) {\n      this.strokeProgram_ = this.helper_.getProgram(\n        this.strokeFragmentShader_,\n        this.strokeVertexShader_,\n      );\n    }\n    if (this.hasSymbol_) {\n      this.symbolProgram_ = this.helper_.getProgram(\n        this.symbolFragmentShader_,\n        this.symbolVertexShader_,\n      );\n    }\n    this.helper_.addUniforms(this.uniforms_);\n\n    if (buffers) {\n      if (buffers.polygonBuffers) {\n        this.helper_.flushBufferData(buffers.polygonBuffers[0]);\n        this.helper_.flushBufferData(buffers.polygonBuffers[1]);\n      }\n      if (buffers.lineStringBuffers) {\n        this.helper_.flushBufferData(buffers.lineStringBuffers[0]);\n        this.helper_.flushBufferData(buffers.lineStringBuffers[1]);\n      }\n      if (buffers.pointBuffers) {\n        this.helper_.flushBufferData(buffers.pointBuffers[0]);\n        this.helper_.flushBufferData(buffers.pointBuffers[1]);\n      }\n    }\n  }\n}\n\nexport default VectorStyleRenderer;\n"],"names":["MixedGeometryBatch","constructor","this","globalCounter_","refToFeature_","Map","uidToRef_","freeGlobalRef_","polygonBatch","entries","geometriesCount","verticesCount","ringsCount","pointBatch","lineStringBatch","addFeatures","features","projectionTransform","i","length","addFeature","feature","geometry","getGeometry","clone","applyTransform","addGeometry_","clearFeatureEntryInPointBatch_","featureUid","entry","flatCoordss","clearFeatureEntryInLineStringBatch_","clearFeatureEntryInPolygonBatch_","type","getType","geometries","getGeometriesArray","multiPolygonGeom","addCoordinates_","getFlatCoordinates","getEndss","getStride","multiLineGeom","getEnds","multiPointGeom","polygonGeom","pointGeom","lineGeom","stride","getLayout","flatCoords","ends","layout","multiPolygonEndss","ii","polygonEnds","prevPolygonEnds","startIndex","endIndex","map","end","slice","multiLineEnds","multiPolygonEnds","addRefToEntry_","ringsVerticesCounts","ringsVerticesCount","ind","arr","push","getFlatCoordinatesXY","getFlatCoordinatesXYM","currentRef","get","ref","pop","set","removeRef_","Error","delete","changeFeature","removeFeature","clear","getFeatureFromRef","isEmpty","filter","featureFilter","filtered","empty","values","v","Array","fill","Math","round","pushCustomAttributesInRenderInstructions","renderInstructions","customAttributes","batchEntry","currentIndex","shift","key","attr","value","callback","call","first","console","warn","undefined","size","getCustomAttributesSize","Object","keys","reduce","prev","curr","generatePointRenderInstructions","batch","transform","totalInstructionsCount","Float32Array","tmpCoords","renderIndex","generateLineStringRenderInstructions","j","jj","generatePolygonRenderInstructions","tmpColor","WEBGL_WORKER","getWebGLWorker","workerMessageCounter","Attributes","POSITION","INDEX","SEGMENT_START","SEGMENT_END","MEASURE_START","MEASURE_END","PARAMETERS","JOIN_ANGLES","DISTANCE","VectorStyleRenderer","styleOrShaders","variables","helper","enableHitDetection","helper_","hitDetectionEnabled_","asShaders","isShaders","asRule","parseResult","style","builder","attributes","uniforms","fillProgram_","strokeProgram_","symbolProgram_","hasFill_","getFillVertexShader","fillVertexShader_","fillFragmentShader_","getFillFragmentShader","hasStroke_","getStrokeVertexShader","strokeVertexShader_","strokeFragmentShader_","getStrokeFragmentShader","hasSymbol_","getSymbolVertexShader","symbolVertexShader_","symbolFragmentShader_","getSymbolFragmentShader","featureFilter_","computeFeatureFilter","hitDetectionAttributes","hitColor","customAttributes_","assign","uniforms_","customAttributesDesc","name","FLOAT","polygonAttributesDesc_","lineStringAttributesDesc_","pointAttributesDesc_","setHelper","parsingContext","compiled","mapState","evalContext","properties","getPropertiesInternal","featureId","id","getId","geometryType","generateBuffers","geometryBatch","filteredBatch","generateRenderInstructions_","polygonBuffers","lineStringBuffers","pointBuffers","Promise","all","generateBuffersForType_","polygonInstructions","lineStringInstructions","pointInstructions","invertVerticesTransform","messageId","messageType","GENERATE_POLYGON_BUFFERS","GENERATE_LINE_STRING_BUFFERS","GENERATE_POINT_BUFFERS","message","buffer","renderInstructionsTransform","customAttributesSize","postMessage","resolve","handleMessage","event","received","data","removeEventListener","getGL","verticesBuffer","fromArrayBuffer","vertexBuffer","indicesBuffer","indexBuffer","flushBufferData","addEventListener","render","buffers","frameState","preRenderCallback","renderInternal_","program","renderCount","getSize","useProgram","bindBuffer","enableAttributes","drawElements","getProgram","addUniforms"],"sourceRoot":""}