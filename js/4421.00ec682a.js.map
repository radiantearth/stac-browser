{"version":3,"file":"js/4421.00ec682a.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/reproj.js","webpack://@radiantearth/stac-browser/./node_modules/ol/reproj/Triangulation.js","webpack://@radiantearth/stac-browser/./node_modules/ol/reproj/common.js"],"sourcesContent":["/**\n * @module ol/reproj\n */\nimport {createCanvasContext2D, releaseCanvas} from './dom.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  extend,\n  forEachCorner,\n  getCenter,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from './extent.js';\nimport {solveLinearSystem} from './math.js';\nimport {getPointResolution, transform} from './proj.js';\n\nlet brokenDiagonalRendering_;\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(u1, v1);\n  ctx.lineTo(u2, v2);\n  ctx.closePath();\n  ctx.save();\n  ctx.clip();\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n  ctx.restore();\n}\n\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\n  return (\n    Math.abs(data[offset * 4] - 210) > 2 ||\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\n  );\n}\n\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n  if (brokenDiagonalRendering_ === undefined) {\n    const ctx = createCanvasContext2D(6, 6, canvasPool);\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n    drawTestTriangle(ctx, 4, 5, 4, 0);\n    drawTestTriangle(ctx, 4, 5, 0, 5);\n    const data = ctx.getImageData(0, 0, 3, 3).data;\n    brokenDiagonalRendering_ =\n      verifyBrokenDiagonalRendering(data, 0) ||\n      verifyBrokenDiagonalRendering(data, 4) ||\n      verifyBrokenDiagonalRendering(data, 8);\n    releaseCanvas(ctx);\n    canvasPool.push(ctx.canvas);\n  }\n\n  return brokenDiagonalRendering_;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(\n  sourceProj,\n  targetProj,\n  targetCenter,\n  targetResolution,\n) {\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  let sourceResolution = getPointResolution(\n    targetProj,\n    targetResolution,\n    targetCenter,\n  );\n\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  const sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    const compensationFactor =\n      getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n      sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(\n  sourceProj,\n  targetProj,\n  targetExtent,\n  targetResolution,\n) {\n  const targetCenter = getCenter(targetExtent);\n  let sourceResolution = calculateSourceResolution(\n    sourceProj,\n    targetProj,\n    targetCenter,\n    targetResolution,\n  );\n\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    forEachCorner(targetExtent, function (corner) {\n      sourceResolution = calculateSourceResolution(\n        sourceProj,\n        targetProj,\n        corner,\n        targetResolution,\n      );\n      return isFinite(sourceResolution) && sourceResolution > 0;\n    });\n  }\n\n  return sourceResolution;\n}\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"./extent.js\").Extent} extent Extent.\n * @property {import(\"./extent.js\").Extent} [clipExtent] Clip extent.\n * @property {import('./DataTile.js').ImageLike} image Image.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @param {boolean} [drawSingle] Draw single source images directly without stitchContext.\n * @param {boolean} [clipExtent] Clip stitchContext to sourceExtent.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(\n  width,\n  height,\n  pixelRatio,\n  sourceResolution,\n  sourceExtent,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  renderEdges,\n  interpolate,\n  drawSingle,\n  clipExtent,\n) {\n  const context = createCanvasContext2D(\n    Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height),\n    canvasPool,\n  );\n\n  if (!interpolate) {\n    context.imageSmoothingEnabled = false;\n  }\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  function pixelRound(value) {\n    return Math.round(value * pixelRatio) / pixelRatio;\n  }\n\n  context.globalCompositeOperation = 'lighter';\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  let stitchContext;\n  const stitchScale = pixelRatio / sourceResolution;\n  // Round up Float32 scale values to prevent interpolation in Firefox.\n  const inverseScale = (interpolate ? 1 : 1 + Math.pow(2, -24)) / stitchScale;\n\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\n    stitchContext = createCanvasContext2D(\n      Math.round(getWidth(sourceDataExtent) * stitchScale),\n      Math.round(getHeight(sourceDataExtent) * stitchScale),\n      canvasPool,\n    );\n\n    if (!interpolate) {\n      stitchContext.imageSmoothingEnabled = false;\n    }\n    if (sourceExtent && clipExtent) {\n      const xPos = (sourceExtent[0] - sourceDataExtent[0]) * stitchScale;\n      const yPos = -(sourceExtent[3] - sourceDataExtent[3]) * stitchScale;\n      const width = getWidth(sourceExtent) * stitchScale;\n      const height = getHeight(sourceExtent) * stitchScale;\n      stitchContext.rect(xPos, yPos, width, height);\n      stitchContext.clip();\n    }\n\n    sources.forEach(function (src, i, arr) {\n      // This test should never fail -- but it does. Need to find a fix the upstream condition\n      if (src.image.width > 0 && src.image.height > 0) {\n        if (src.clipExtent) {\n          stitchContext.save();\n          const xPos = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale;\n          const yPos = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale;\n          const width = getWidth(src.clipExtent) * stitchScale;\n          const height = getHeight(src.clipExtent) * stitchScale;\n          stitchContext.rect(\n            interpolate ? xPos : Math.round(xPos),\n            interpolate ? yPos : Math.round(yPos),\n            interpolate ? width : Math.round(xPos + width) - Math.round(xPos),\n            interpolate ? height : Math.round(yPos + height) - Math.round(yPos),\n          );\n          stitchContext.clip();\n        }\n\n        const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale;\n        const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale;\n        const srcWidth = getWidth(src.extent) * stitchScale;\n        const srcHeight = getHeight(src.extent) * stitchScale;\n        stitchContext.drawImage(\n          src.image,\n          gutter,\n          gutter,\n          src.image.width - 2 * gutter,\n          src.image.height - 2 * gutter,\n          interpolate ? xPos : Math.round(xPos),\n          interpolate ? yPos : Math.round(yPos),\n          interpolate\n            ? srcWidth\n            : Math.round(xPos + srcWidth) - Math.round(xPos),\n          interpolate\n            ? srcHeight\n            : Math.round(yPos + srcHeight) - Math.round(yPos),\n        );\n\n        if (src.clipExtent) {\n          stitchContext.restore();\n        }\n      }\n    });\n  }\n  const targetTopLeft = getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    const source = triangle.source;\n    const target = triangle.target;\n    let x0 = source[0][0],\n      y0 = source[0][1];\n    let x1 = source[1][0],\n      y1 = source[1][1];\n    let x2 = source[2][0],\n      y2 = source[2][1];\n    // Make sure that everything is on pixel boundaries\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n    const v0 = pixelRound(\n      -(target[0][1] - targetTopLeft[1]) / targetResolution,\n    );\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n    const v1 = pixelRound(\n      -(target[1][1] - targetTopLeft[1]) / targetResolution,\n    );\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n    const v2 = pixelRound(\n      -(target[2][1] - targetTopLeft[1]) / targetResolution,\n    );\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    const sourceNumericalShiftX = x0;\n    const sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    const augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0],\n    ];\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n\n    if (isBrokenDiagonalRendering() || !interpolate) {\n      // Make sure that all lines are horizontal or vertical\n      context.moveTo(u1, v1);\n      // This is the diagonal line. Do it in 4 steps\n      const steps = 4;\n      const ud = u0 - u1;\n      const vd = v0 - v1;\n      for (let step = 0; step < steps; step++) {\n        // Go horizontally\n        context.lineTo(\n          u1 + pixelRound(((step + 1) * ud) / steps),\n          v1 + pixelRound((step * vd) / (steps - 1)),\n        );\n        // Go vertically\n        if (step != steps - 1) {\n          context.lineTo(\n            u1 + pixelRound(((step + 1) * ud) / steps),\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1)),\n          );\n        }\n      }\n      // We are almost at u0r, v0r\n      context.lineTo(u2, v2);\n    } else {\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n    }\n\n    context.clip();\n\n    context.transform(\n      affineCoefs[0],\n      affineCoefs[2],\n      affineCoefs[1],\n      affineCoefs[3],\n      u0,\n      v0,\n    );\n\n    context.translate(\n      sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY,\n    );\n\n    let image;\n    if (stitchContext) {\n      image = stitchContext.canvas;\n      context.scale(inverseScale, -inverseScale);\n    } else {\n      const source = sources[0];\n      const extent = source.extent;\n      image = source.image;\n      context.scale(\n        getWidth(extent) / image.width,\n        -getHeight(extent) / image.height,\n      );\n    }\n\n    context.drawImage(image, 0, 0);\n    context.restore();\n  });\n\n  if (stitchContext) {\n    releaseCanvas(stitchContext);\n    canvasPool.push(stitchContext.canvas);\n  }\n\n  if (renderEdges) {\n    context.save();\n\n    context.globalCompositeOperation = 'source-over';\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const target = triangle.target;\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n","/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {modulo} from '../math.js';\nimport {\n  createTransformFromCoordinateTransform,\n  getTransform,\n  transform,\n} from '../proj.js';\nimport {apply as applyMatrix} from '../transform.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   * @param {import(\"../transform.js\").Transform} [sourceMatrix] Source transform matrix.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    destinationResolution,\n    sourceMatrix,\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = sourceMatrix\n      ? createTransformFromCoordinateTransform((input) =>\n          applyMatrix(\n            sourceMatrix,\n            transform(input, this.targetProj_, this.sourceProj_),\n          ),\n        )\n      : getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overall reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              Math.log2(\n                getArea(targetExtent) /\n                  (destinationResolution * destinationResolution * 256 * 256),\n              ),\n            ),\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision,\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0],\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach((triangle) => {\n        if (\n          Math.max(\n            triangle.source[0][0],\n            triangle.source[1][0],\n            triangle.source[2][0],\n          ) -\n            leftBound >\n          this.sourceWorldWidth_ / 2\n        ) {\n          const newTriangle = [\n            [triangle.source[0][0], triangle.source[0][1]],\n            [triangle.source[1][0], triangle.source[1][1]],\n            [triangle.source[2][0], triangle.source[2][1]],\n          ];\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          const minX = Math.min(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0],\n          );\n          const maxX = Math.max(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0],\n          );\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1,\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1,\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1,\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1,\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n","/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport const ERROR_THRESHOLD = 0.5;\n"],"names":["brokenDiagonalRendering_","canvasPool","drawTestTriangle","ctx","u1","v1","u2","v2","beginPath","moveTo","lineTo","closePath","save","clip","fillRect","Math","max","restore","verifyBrokenDiagonalRendering","data","offset","abs","isBrokenDiagonalRendering","undefined","globalCompositeOperation","fillStyle","getImageData","push","canvas","calculateSourceResolution","sourceProj","targetProj","targetCenter","targetResolution","sourceCenter","sourceResolution","targetMetersPerUnit","getMetersPerUnit","sourceMetersPerUnit","sourceExtent","getExtent","compensationFactor","isFinite","calculateSourceExtentResolution","targetExtent","corner","render","width","height","pixelRatio","triangulation","sources","gutter","renderEdges","interpolate","drawSingle","clipExtent","context","round","imageSmoothingEnabled","length","pixelRound","value","scale","sourceDataExtent","stitchContext","forEach","src","i","arr","extent","stitchScale","inverseScale","pow","xPos","yPos","rect","image","srcWidth","srcHeight","drawImage","targetTopLeft","getTriangles","triangle","source","target","x0","y0","x1","y1","x2","y2","u0","v0","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","steps","ud","vd","step","transform","translate","strokeStyle","lineWidth","stroke","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","constructor","maxSourceExtent","errorThreshold","destinationResolution","sourceMatrix","this","sourceProj_","targetProj_","transformInvCache","transformInv","input","transformInv_","c","key","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","canWrapX","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","ceil","log2","addQuad_","leftBound","Infinity","min","newTriangle","minX","maxX","addTriangle_","a","b","aSrc","bSrc","cSrc","d","dSrc","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","targetCoverageX","isNotFinite","center","centerSrc","dx","centerSrcEstimX","dy","centerSrcErrorSquared","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","calculateSourceExtent","ERROR_THRESHOLD"],"sourceRoot":""}