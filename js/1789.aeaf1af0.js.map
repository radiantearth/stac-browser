{"version":3,"file":"js/1789.aeaf1af0.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/layer/Heatmap.js","webpack://@radiantearth/stac-browser/./node_modules/ol/renderer/webgl/worldUtil.js","webpack://@radiantearth/stac-browser/./node_modules/ol/renderer/webgl/VectorLayer.js"],"sourcesContent":["/**\n * @module ol/layer/Heatmap\n */\nimport {createCanvasContext2D} from '../dom.js';\nimport {BooleanType, NumberType} from '../expr/expression.js';\nimport {newCompilationContext} from '../expr/gpu.js';\nimport {clamp} from '../math.js';\nimport {ShaderBuilder} from '../render/webgl/ShaderBuilder.js';\nimport {\n  applyContextToBuilder,\n  expressionToGlsl,\n  generateAttributesFromContext,\n  generateUniformsFromContext,\n} from '../render/webgl/compileUtil.js';\nimport WebGLVectorLayerRenderer from '../renderer/webgl/VectorLayer.js';\nimport BaseVector from './BaseVector.js';\n\n/**\n * @typedef {import(\"../style/flat.js\").NumberExpression|string|function(import(\"../Feature.js\").default):number} WeightExpression\n */\n\n/**\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @template {import(\"../source/Vector.js\").default<FeatureType>} [VectorSourceType=import(\"../source/Vector.js\").default<FeatureType>]\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {Array<string>} [gradient=['#00f', '#0ff', '#0f0', '#ff0', '#f00']] The color gradient\n * of the heatmap, specified as an array of CSS color strings.\n * @property {import(\"../style/flat.js\").NumberExpression} [radius=8] Radius size in pixels. Note that for LineStrings,\n * the width of the line will be double the radius.\n * @property {import(\"../style/flat.js\").NumberExpression} [blur=15] Blur size in pixels. This is added to the `radius`\n * parameter above to create the final size of the blur effect.\n * @property {WeightExpression} [weight='weight'] The feature\n * attribute to use for the weight. This also supports expressions returning a number or a function that returns a weight from a feature. Weight values\n * should range from 0 to 1 (and values outside will be clamped to that range).\n * @property {import(\"../style/flat.js\").BooleanExpression} [filter] Optional filter expression.\n * @property {Object<string, number|Array<number>|string|boolean>} [variables] Variables used in expressions (optional)\n * @property {VectorSourceType} [source] Point source.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @enum {string}\n * @private\n */\nconst Property = {\n  BLUR: 'blur',\n  GRADIENT: 'gradient',\n  RADIUS: 'radius',\n};\n\n/**\n * @const\n * @type {Array<string>}\n */\nconst DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];\n\n/**\n * @classdesc\n * Layer for rendering vector data as a heatmap.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @template {import(\"../source/Vector.js\").default<FeatureType>} [VectorSourceType=import(\"../source/Vector.js\").default<FeatureType>]\n * @extends {BaseVector<FeatureType, VectorSourceType, WebGLVectorLayerRenderer>}\n * @api\n */\nclass Heatmap extends BaseVector {\n  /**\n   * @param {Options<FeatureType, VectorSourceType>} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    delete baseOptions.gradient;\n    delete baseOptions.radius;\n    delete baseOptions.blur;\n    delete baseOptions.weight;\n    super(baseOptions);\n\n    this.filter_ = options.filter ?? true;\n\n    /**\n     * @type {import('../style/flat.js').StyleVariables}\n     * @private\n     */\n    this.styleVariables_ = options.variables || {};\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.gradient_ = null;\n\n    this.addChangeListener(Property.GRADIENT, this.handleGradientChanged_);\n\n    this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);\n\n    this.setBlur(options.blur !== undefined ? options.blur : 15);\n\n    this.setRadius(options.radius !== undefined ? options.radius : 8);\n\n    const weight = options.weight ? options.weight : 'weight';\n\n    /**\n     * @private\n     */\n    this.weight_ = weight;\n\n    // For performance reasons, don't sort the features before rendering.\n    // The render order is not relevant for a heatmap representation.\n    this.setRenderOrder(null);\n  }\n\n  /**\n   * Return the blur size in pixels.\n   * @return {import(\"../style/flat.js\").NumberExpression} Blur size in pixels.\n   * @api\n   * @observable\n   */\n  getBlur() {\n    return /** @type {import(\"../style/flat.js\").NumberExpression} */ (\n      this.get(Property.BLUR)\n    );\n  }\n\n  /**\n   * Return the gradient colors as array of strings.\n   * @return {Array<string>} Colors.\n   * @api\n   * @observable\n   */\n  getGradient() {\n    return /** @type {Array<string>} */ (this.get(Property.GRADIENT));\n  }\n\n  /**\n   * Return the size of the radius in pixels.\n   * @return {import(\"../style/flat.js\").NumberExpression} Radius size in pixel.\n   * @api\n   * @observable\n   */\n  getRadius() {\n    return /** @type {import(\"../style/flat.js\").NumberExpression} */ (\n      this.get(Property.RADIUS)\n    );\n  }\n\n  /**\n   * @private\n   */\n  handleGradientChanged_() {\n    this.gradient_ = createGradient(this.getGradient());\n  }\n\n  /**\n   * Set the blur size in pixels.\n   * @param {import(\"../style/flat.js\").NumberExpression} blur Blur size in pixels (supports expressions).\n   * @api\n   * @observable\n   */\n  setBlur(blur) {\n    const previousValue = this.get(Property.BLUR);\n    this.set(Property.BLUR, blur);\n    // if the value stays numerical, simply refresh the layer\n    if (typeof blur === 'number' && typeof previousValue === 'number') {\n      this.changed();\n      return;\n    }\n    this.clearRenderer();\n  }\n\n  /**\n   * Set the gradient colors as array of strings.\n   * @param {Array<string>} colors Gradient.\n   * @api\n   * @observable\n   */\n  setGradient(colors) {\n    this.set(Property.GRADIENT, colors);\n  }\n\n  /**\n   * Set the size of the radius in pixels.\n   * @param {import(\"../style/flat.js\").NumberExpression} radius Radius size in pixel (supports expressions).\n   * @api\n   * @observable\n   */\n  setRadius(radius) {\n    const previousValue = this.get(Property.RADIUS);\n    this.set(Property.RADIUS, radius);\n    // if the value stays numerical, simply refresh the layer\n    if (typeof radius === 'number' && typeof previousValue === 'number') {\n      this.changed();\n      return;\n    }\n    this.clearRenderer();\n  }\n\n  /**\n   * Set the filter expression\n   * @param {import(\"../style/flat.js\").BooleanExpression} filter Filter expression\n   * @api\n   */\n  setFilter(filter) {\n    this.filter_ = filter;\n    this.changed();\n    this.clearRenderer();\n  }\n\n  /**\n   * Set the weight expression\n   * @param {WeightExpression} weight Weight expression\n   * @api\n   */\n  setWeight(weight) {\n    this.weight_ = weight;\n    this.changed();\n    this.clearRenderer();\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    const builder = new ShaderBuilder();\n\n    const context = newCompilationContext();\n    const filterCompiled = expressionToGlsl(context, this.filter_, BooleanType);\n    let radiusCompiled = expressionToGlsl(\n      context,\n      this.getRadius(),\n      NumberType,\n    );\n    let blurCompiled = expressionToGlsl(context, this.getBlur(), NumberType);\n\n    /** @type {import('../render/webgl/VectorStyleRenderer.js').UniformDefinitions} */\n    const blurRadiusUniforms = {};\n    if (typeof this.getBlur() === 'number') {\n      blurCompiled = 'a_blur';\n      blurRadiusUniforms['a_blur'] = () => this.getBlur();\n      builder.addUniform('a_blur', 'float');\n    }\n    if (typeof this.getRadius() === 'number') {\n      radiusCompiled = 'a_radius';\n      blurRadiusUniforms['a_radius'] = () => this.getRadius();\n      builder.addUniform('a_radius', 'float');\n    }\n\n    /** @type {import('../render/webgl/VectorStyleRenderer.js').AttributeDefinitions} */\n    const weightAttribute = {};\n    let weightExpression = null;\n    if (\n      typeof this.weight_ === 'string' ||\n      typeof this.weight_ === 'function'\n    ) {\n      const weightFunction =\n        typeof this.weight_ === 'string'\n          ? (feature) => feature.get(this.weight_)\n          : this.weight_;\n      weightAttribute['prop_weight'] = {\n        size: 1,\n        callback: (feature) => {\n          const weightValue = weightFunction(feature);\n          return weightValue !== undefined ? clamp(weightValue, 0, 1) : 1;\n        },\n      };\n      weightExpression = 'a_prop_weight';\n      builder.addAttribute('a_prop_weight', 'float');\n    } else {\n      const clampedWeight = ['clamp', this.weight_, 0, 1];\n      weightExpression = expressionToGlsl(context, clampedWeight, NumberType);\n    }\n\n    builder\n      .addFragmentShaderFunction(\n        `float getBlurSlope() {\n  float blur = max(1., ${blurCompiled});\n  float radius = ${radiusCompiled};\n  return radius / blur;\n}`,\n      )\n      .setSymbolSizeExpression(`vec2(${radiusCompiled} + ${blurCompiled}) * 2.`)\n      .setSymbolColorExpression(\n        `vec4(smoothstep(0., 1., (1. - length(coordsPx * 2. / v_quadSizePx)) * getBlurSlope()) * ${weightExpression})`,\n      )\n      .setStrokeColorExpression(\n        `vec4(smoothstep(0., 1., (1. - length(currentRadiusPx * 2. / v_width)) * getBlurSlope()) * ${weightExpression})`,\n      )\n      .setStrokeWidthExpression(`(${radiusCompiled} + ${blurCompiled}) * 2.`)\n      .setFillColorExpression(`vec4(${weightExpression})`)\n      .setFragmentDiscardExpression(`!${filterCompiled}`);\n\n    applyContextToBuilder(builder, context);\n    const attributes = generateAttributesFromContext(context);\n    const uniforms = generateUniformsFromContext(context, this.styleVariables_);\n\n    return new WebGLVectorLayerRenderer(this, {\n      className: this.getClassName(),\n      variables: this.styleVariables_,\n      style: {\n        builder,\n        attributes: {\n          ...attributes,\n          ...weightAttribute,\n        },\n        uniforms: {\n          ...uniforms,\n          ...blurRadiusUniforms,\n        },\n      },\n      disableHitDetection: false,\n      postProcesses: [\n        {\n          fragmentShader: `\n            precision mediump float;\n\n            uniform sampler2D u_image;\n            uniform sampler2D u_gradientTexture;\n            uniform float u_opacity;\n\n            varying vec2 v_texCoord;\n\n            void main() {\n              vec4 color = texture2D(u_image, v_texCoord);\n              gl_FragColor.a = color.a * u_opacity;\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\n              gl_FragColor.rgb *= gl_FragColor.a;\n            }`,\n          uniforms: {\n            u_gradientTexture: () => this.gradient_,\n            u_opacity: () => this.getOpacity(),\n          },\n        },\n      ],\n    });\n  }\n\n  /**\n   * Update any variables used by the layer style and trigger a re-render.\n   * @param {import('../style/flat.js').StyleVariables} variables Variables to update.\n   */\n  updateStyleVariables(variables) {\n    Object.assign(this.styleVariables_, variables);\n    this.changed();\n  }\n\n  /**\n   * @override\n   */\n  renderDeclutter() {}\n}\n\n/**\n * @param {Array<string>} colors A list of colored.\n * @return {HTMLCanvasElement} canvas with gradient texture.\n */\nfunction createGradient(colors) {\n  const width = 1;\n  const height = 256;\n  const context = createCanvasContext2D(width, height);\n\n  const gradient = context.createLinearGradient(0, 0, width, height);\n  const step = 1 / (colors.length - 1);\n  for (let i = 0, ii = colors.length; i < ii; ++i) {\n    gradient.addColorStop(i * step, colors[i]);\n  }\n\n  context.fillStyle = gradient;\n  context.fillRect(0, 0, width, height);\n\n  return context.canvas;\n}\n\nexport default Heatmap;\n","import {getWidth} from '../../extent.js';\n\n/**\n * Compute world params\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {any} layer The layer\n * @return {Array<number>} The world start, end and width.\n */\nexport function getWorldParameters(frameState, layer) {\n  const projection = frameState.viewState.projection;\n\n  const vectorSource = layer.getSource();\n  const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n  const projectionExtent = projection.getExtent();\n\n  const extent = frameState.extent;\n  const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n  const endWorld = multiWorld\n    ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n    : 1;\n\n  const startWorld = multiWorld\n    ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n    : 0;\n\n  return [startWorld, endWorld, worldWidth];\n}\n","/**\n * @module ol/renderer/webgl/VectorLayer\n */\nimport ViewHint from '../../ViewHint.js';\nimport {assert} from '../../asserts.js';\nimport {listen, unlistenByKey} from '../../events.js';\nimport {buffer, createEmpty, equals} from '../../extent.js';\nimport BaseVector from '../../layer/BaseVector.js';\nimport {\n  getTransformFromProjections,\n  getUserProjection,\n  toUserExtent,\n  toUserResolution,\n} from '../../proj.js';\nimport MixedGeometryBatch from '../../render/webgl/MixedGeometryBatch.js';\nimport VectorStyleRenderer from '../../render/webgl/VectorStyleRenderer.js';\nimport {colorDecodeId} from '../../render/webgl/encodeUtil.js';\nimport {breakDownFlatStyle} from '../../render/webgl/style.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n  setFromArray as setFromTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {\n  create as createMat4,\n  fromTransform as mat4FromTransform,\n} from '../../vec/mat4.js';\nimport {DefaultUniform} from '../../webgl/Helper.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {getWorldParameters} from './worldUtil.js';\n\nexport const Uniforms = {\n  ...DefaultUniform,\n  RENDER_EXTENT: 'u_renderExtent', // intersection of layer, source, and view extent\n  PATTERN_ORIGIN: 'u_patternOrigin',\n  GLOBAL_ALPHA: 'u_globalAlpha',\n};\n\n/**\n * @typedef {import('../../render/webgl/VectorStyleRenderer.js').AsShaders} StyleAsShaders\n */\n/**\n * @typedef {import('../../render/webgl/VectorStyleRenderer.js').AsRule} StyleAsRule\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {import('../../style/flat.js').FlatStyleLike | Array<StyleAsShaders> | StyleAsShaders} style Flat vector style; also accepts shaders\n * @property {Object<string, number|Array<number>|string|boolean>} variables Style variables\n * @property {boolean} [disableHitDetection=false] Setting this to true will provide a slight performance boost, but will\n * prevent all hit detection on the layer.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Experimental WebGL vector renderer. Supports polygons, lines and points:\n *  Polygons are broken down into triangles\n *  Lines are rendered as strips of quads\n *  Points are rendered as quads\n *\n * You need to provide vertex and fragment shaders as well as custom attributes for each type of geometry. All shaders\n * can access the uniforms in the {@link module:ol/webgl/Helper~DefaultUniform} enum.\n * The vertex shaders can access the following attributes depending on the geometry type:\n *  For polygons: {@link module:ol/render/webgl/PolygonBatchRenderer~Attributes}\n *  For line strings: {@link module:ol/render/webgl/LineStringBatchRenderer~Attributes}\n *  For points: {@link module:ol/render/webgl/PointBatchRenderer~Attributes}\n *\n * Please note that the fragment shaders output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Note: this uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n */\nclass WebGLVectorLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = {\n      [Uniforms.RENDER_EXTENT]: [0, 0, 0, 0],\n      [Uniforms.PATTERN_ORIGIN]: [0, 0],\n      [Uniforms.GLOBAL_ALPHA]: 1,\n    };\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hitDetectionEnabled_ = !options.disableHitDetection;\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    this.hitRenderTarget_;\n\n    /**\n     * @private\n     */\n    this.sourceRevision_ = -1;\n\n    /**\n     * @private\n     */\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = createTransform();\n\n    /**\n     * @private\n     */\n    this.tmpCoords_ = [0, 0];\n    /**\n     * @private\n     */\n    this.tmpTransform_ = createTransform();\n    /**\n     * @private\n     */\n    this.tmpMat4_ = createMat4();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentFrameStateTransform_ = createTransform();\n\n    /**\n     * @type {import('../../style/flat.js').StyleVariables}\n     * @private\n     */\n    this.styleVariables_ = {};\n\n    /**\n     * @type {Array<StyleAsRule | StyleAsShaders>}\n     * @private\n     */\n    this.styles_ = [];\n\n    /**\n     * @type {Array<VectorStyleRenderer>}\n     * @private\n     */\n    this.styleRenderers_ = [];\n\n    /**\n     * @type {Array<import('../../render/webgl/VectorStyleRenderer.js').WebGLBuffers>}\n     * @private\n     */\n    this.buffers_ = [];\n\n    this.applyOptions_(options);\n\n    /**\n     * @private\n     */\n    this.batch_ = new MixedGeometryBatch();\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.initialFeaturesAdded_ = false;\n\n    /**\n     * @private\n     * @type {Array<import(\"../../events.js\").EventsKey|null>}\n     */\n    this.sourceListenKeys_ = null;\n  }\n\n  /**\n   * @private\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  addInitialFeatures_(frameState) {\n    const source = this.getLayer().getSource();\n    const userProjection = getUserProjection();\n    let projectionTransform;\n    if (userProjection) {\n      projectionTransform = getTransformFromProjections(\n        userProjection,\n        frameState.viewState.projection,\n      );\n    }\n    this.batch_.addFeatures(source.getFeatures(), projectionTransform);\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_.bind(this, projectionTransform),\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_.bind(this, projectionTransform),\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this,\n      ),\n    ];\n  }\n\n  /**\n   * @param {Options} options Options.\n   * @private\n   */\n  applyOptions_(options) {\n    this.styleVariables_ = options.variables;\n    this.styles_ = breakDownFlatStyle(options.style);\n  }\n\n  /**\n   * @private\n   */\n  createRenderers_() {\n    this.buffers_ = [];\n    this.styleRenderers_ = this.styles_.map(\n      (style) =>\n        new VectorStyleRenderer(\n          style,\n          this.styleVariables_,\n          this.helper,\n          this.hitDetectionEnabled_,\n          'filter' in style ? style.filter : null,\n        ),\n    );\n  }\n\n  /**\n   * @override\n   */\n  reset(options) {\n    this.applyOptions_(options);\n    if (this.helper) {\n      this.createRenderers_();\n    }\n    super.reset(options);\n  }\n\n  /**\n   * @override\n   */\n  afterHelperCreated() {\n    if (this.styleRenderers_.length) {\n      // To reuse buffers\n      this.styleRenderers_.forEach((renderer, i) =>\n        renderer.setHelper(this.helper, this.buffers_[i]),\n      );\n    } else {\n      this.createRenderers_();\n    }\n\n    if (this.hitDetectionEnabled_) {\n      this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n    }\n  }\n\n  /**\n   * @param {import(\"../../proj.js\").TransformFunction} projectionTransform Transform function.\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(projectionTransform, event) {\n    const feature = event.feature;\n    this.batch_.addFeature(feature, projectionTransform);\n  }\n\n  /**\n   * @param {import(\"../../proj.js\").TransformFunction} projectionTransform Transform function.\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(projectionTransform, event) {\n    const feature = event.feature;\n    this.batch_.changeFeature(feature, projectionTransform);\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    this.batch_.removeFeature(feature);\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.batch_.clear();\n  }\n\n  /**\n   * @param {import(\"../../transform.js\").Transform} batchInvertTransform Inverse of the transformation in which geometries are expressed\n   * @private\n   */\n  applyUniforms_(batchInvertTransform) {\n    // world to screen matrix\n    setFromTransform(this.tmpTransform_, this.currentFrameStateTransform_);\n    multiplyTransform(this.tmpTransform_, batchInvertTransform);\n    this.helper.setUniformMatrixValue(\n      Uniforms.PROJECTION_MATRIX,\n      mat4FromTransform(this.tmpMat4_, this.tmpTransform_),\n    );\n\n    // screen to world matrix\n    makeInverseTransform(this.tmpTransform_, this.tmpTransform_);\n    this.helper.setUniformMatrixValue(\n      Uniforms.SCREEN_TO_WORLD_MATRIX,\n      mat4FromTransform(this.tmpMat4_, this.tmpTransform_),\n    );\n\n    // pattern origin should always be [0, 0] in world coordinates\n    this.tmpCoords_[0] = 0;\n    this.tmpCoords_[1] = 0;\n    makeInverseTransform(this.tmpTransform_, batchInvertTransform);\n    applyTransform(this.tmpTransform_, this.tmpCoords_);\n    this.helper.setUniformFloatVec2(Uniforms.PATTERN_ORIGIN, this.tmpCoords_);\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const [startWorld, endWorld, worldWidth] = getWorldParameters(\n      frameState,\n      this.getLayer(),\n    );\n\n    // draw the normal canvas\n    this.helper.prepareDraw(frameState);\n    this.renderWorlds(frameState, false, startWorld, endWorld, worldWidth);\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent,\n    );\n\n    const canvas = this.helper.getCanvas();\n\n    if (this.hitDetectionEnabled_) {\n      this.renderWorlds(frameState, true, startWorld, endWorld, worldWidth);\n      this.hitRenderTarget_.clearCachedData();\n    }\n\n    this.postRender(gl, frameState);\n\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrameInternal(frameState) {\n    if (!this.initialFeaturesAdded_) {\n      this.addInitialFeatures_(frameState);\n      this.initialFeaturesAdded_ = true;\n    }\n\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n\n      const userProjection = getUserProjection();\n      if (userProjection) {\n        vectorSource.loadFeatures(\n          toUserExtent(extent, userProjection),\n          toUserResolution(resolution, projection),\n          userProjection,\n        );\n      } else {\n        vectorSource.loadFeatures(extent, resolution, projection);\n      }\n\n      this.ready = false;\n\n      const transform = this.helper.makeProjectionTransform(\n        frameState,\n        createTransform(),\n      );\n\n      const generatePromises = this.styleRenderers_.map((renderer, i) =>\n        renderer.generateBuffers(this.batch_, transform).then((buffers) => {\n          if (this.buffers_[i]) {\n            this.disposeBuffers(this.buffers_[i]);\n          }\n          this.buffers_[i] = buffers;\n        }),\n      );\n      Promise.all(generatePromises).then(() => {\n        this.ready = true;\n        this.getLayer().changed();\n      });\n\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    return true;\n  }\n\n  /**\n   * Render the world, either to the main framebuffer or to the hit framebuffer\n   * @param {import(\"../../Map.js\").FrameState} frameState current frame state\n   * @param {boolean} forHitDetection whether the rendering is for hit detection\n   * @param {number} startWorld the world to render in the first iteration\n   * @param {number} endWorld the last world to render\n   * @param {number} worldWidth the width of the worlds being rendered\n   */\n  renderWorlds(frameState, forHitDetection, startWorld, endWorld, worldWidth) {\n    let world = startWorld;\n\n    if (forHitDetection) {\n      this.hitRenderTarget_.setSize([\n        Math.floor(frameState.size[0] / 2),\n        Math.floor(frameState.size[1] / 2),\n      ]);\n      this.helper.prepareDrawToRenderTarget(\n        frameState,\n        this.hitRenderTarget_,\n        true,\n      );\n    }\n\n    do {\n      this.helper.makeProjectionTransform(\n        frameState,\n        this.currentFrameStateTransform_,\n      );\n      translateTransform(\n        this.currentFrameStateTransform_,\n        world * worldWidth,\n        0,\n      );\n      for (let i = 0, ii = this.styleRenderers_.length; i < ii; i++) {\n        const renderer = this.styleRenderers_[i];\n        const buffers = this.buffers_[i];\n        if (!buffers) {\n          continue;\n        }\n        renderer.render(buffers, frameState, () => {\n          this.applyUniforms_(buffers.invertVerticesTransform);\n          this.helper.applyHitDetectionUniform(forHitDetection);\n        });\n      }\n    } while (++world < endWorld);\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    assert(\n      this.hitDetectionEnabled_,\n      '`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option.',\n    );\n    if (!this.styleRenderers_.length || !this.hitDetectionEnabled_) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(\n      frameState.coordinateToPixelTransform,\n      coordinate.slice(),\n    );\n\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const ref = colorDecodeId(color);\n    const feature = this.batch_.getFeatureFromRef(ref);\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n    return undefined;\n  }\n\n  /**\n   * Will release a set of Webgl buffers\n   * @param {import('../../render/webgl/VectorStyleRenderer.js').WebGLBuffers} buffers Buffers\n   */\n  disposeBuffers(buffers) {\n    /**\n     * @param {Array<import('../../webgl/Buffer.js').default>} typeBuffers Buffers\n     */\n    const disposeBuffersOfType = (typeBuffers) => {\n      for (const buffer of typeBuffers) {\n        if (buffer) {\n          this.helper.deleteBuffer(buffer);\n        }\n      }\n    };\n    if (buffers.pointBuffers) {\n      disposeBuffersOfType(buffers.pointBuffers);\n    }\n    if (buffers.lineStringBuffers) {\n      disposeBuffersOfType(buffers.lineStringBuffers);\n    }\n    if (buffers.polygonBuffers) {\n      disposeBuffersOfType(buffers.polygonBuffers);\n    }\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    this.buffers_.forEach((buffers) => {\n      if (buffers) {\n        this.disposeBuffers(buffers);\n      }\n    });\n    if (this.sourceListenKeys_) {\n      this.sourceListenKeys_.forEach(function (key) {\n        unlistenByKey(key);\n      });\n      this.sourceListenKeys_ = null;\n    }\n    super.disposeInternal();\n  }\n\n  renderDeclutter() {}\n}\n\nexport default WebGLVectorLayerRenderer;\n"],"names":["Property","BLUR","GRADIENT","RADIUS","DEFAULT_GRADIENT","Heatmap","constructor","options","baseOptions","Object","assign","gradient","radius","blur","weight","super","this","filter_","filter","styleVariables_","variables","gradient_","addChangeListener","handleGradientChanged_","setGradient","setBlur","undefined","setRadius","weight_","setRenderOrder","getBlur","get","getGradient","getRadius","createGradient","previousValue","set","clearRenderer","changed","colors","setFilter","setWeight","createRenderer","builder","context","filterCompiled","radiusCompiled","blurCompiled","blurRadiusUniforms","addUniform","weightAttribute","weightExpression","weightFunction","feature","size","callback","weightValue","addAttribute","clampedWeight","addFragmentShaderFunction","setSymbolSizeExpression","setSymbolColorExpression","setStrokeColorExpression","setStrokeWidthExpression","setFillColorExpression","setFragmentDiscardExpression","attributes","uniforms","className","getClassName","style","disableHitDetection","postProcesses","fragmentShader","u_gradientTexture","u_opacity","getOpacity","updateStyleVariables","renderDeclutter","width","height","createLinearGradient","step","length","i","ii","addColorStop","fillStyle","fillRect","canvas","getWorldParameters","frameState","layer","projection","viewState","vectorSource","getSource","multiWorld","getWrapX","canWrapX","projectionExtent","getExtent","extent","worldWidth","endWorld","Math","ceil","startWorld","floor","Uniforms","RENDER_EXTENT","PATTERN_ORIGIN","GLOBAL_ALPHA","WebGLVectorLayerRenderer","hitDetectionEnabled_","hitRenderTarget_","sourceRevision_","previousExtent_","currentTransform_","tmpCoords_","tmpTransform_","tmpMat4_","currentFrameStateTransform_","styles_","styleRenderers_","buffers_","applyOptions_","batch_","initialFeaturesAdded_","sourceListenKeys_","addInitialFeatures_","source","getLayer","userProjection","projectionTransform","addFeatures","getFeatures","ADDFEATURE","handleSourceFeatureAdded_","bind","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","createRenderers_","map","helper","reset","afterHelperCreated","forEach","renderer","setHelper","event","addFeature","changeFeature","removeFeature","clear","applyUniforms_","batchInvertTransform","setUniformMatrixValue","PROJECTION_MATRIX","SCREEN_TO_WORLD_MATRIX","setUniformFloatVec2","renderFrame","gl","getGL","preRender","prepareDraw","renderWorlds","finalizeDraw","dispatchPreComposeEvent","dispatchPostComposeEvent","getCanvas","clearCachedData","postRender","prepareFrameInternal","viewNotMoving","viewHints","ANIMATING","INTERACTING","extentChanged","sourceChanged","getRevision","resolution","renderBuffer","getRenderBuffer","loadFeatures","ready","transform","makeProjectionTransform","generatePromises","generateBuffers","then","buffers","disposeBuffers","Promise","all","slice","forHitDetection","world","setSize","prepareDrawToRenderTarget","render","invertVerticesTransform","applyHitDetectionUniform","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","pixel","coordinateToPixelTransform","data","readPixel","color","ref","getFeatureFromRef","disposeBuffersOfType","typeBuffers","buffer","deleteBuffer","pointBuffers","lineStringBuffers","polygonBuffers","disposeInternal","key"],"sourceRoot":""}