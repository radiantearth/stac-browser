{"version":3,"file":"js/9721.5f8395fd.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/renderer/webgl/FlowLayer.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/Flow.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/BaseTile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/tilecoord.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/TileProperty.js","webpack://@radiantearth/stac-browser/./node_modules/ol/TileRange.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/FlowLayer\n */\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport {DefaultUniform} from '../../webgl/Helper.js';\nimport {ARRAY_BUFFER, STATIC_DRAW} from '../../webgl.js';\nimport WebGLTileLayerRenderer from './TileLayer.js';\n\n/**\n * @typedef {import(\"../../layer/Flow.js\").default} LayerType\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} maxSpeed The maximum particle speed in the input data.\n * @property {number} [speedFactor=0.001] A larger factor increases the rate at which particles cross the screen.\n * @property {number} [particles=65536] The number of particles to render.\n * @property {number} [cacheSize=512] The texture cache size.\n * @property {string} tileVertexShader The flow tile vertex shader.\n * @property {string} tileFragmentShader The flow tile fragment shader.\n * @property {string} textureVertexShader Generic texture fragment shader.\n * @property {string} textureFragmentShader Generic texture fragment shader.\n * @property {string} particlePositionVertexShader The particle position vertex shader.\n * @property {string} particlePositionFragmentShader The particle position fragment shader.\n * @property {string} particleColorVertexShader The particle color vertex shader.\n * @property {string} particleColorFragmentShader The particle color fragment shader.\n */\n\n/**\n * Shader uniforms.\n * @enum {string}\n */\nexport const U = {\n  TEXTURE: 'u_texture',\n  VELOCITY_TEXTURE: 'u_velocityTexture',\n  POSITION_TEXTURE: 'u_positionTexture',\n  PARTICLE_COUNT_SQRT: 'u_particleCountSqrt',\n  MAX_SPEED: 'u_maxSpeed',\n  GAIN: 'u_gain',\n  OFFSET: 'u_offset',\n  IS_FLOAT: 'u_isFloat',\n  RANDOM_SEED: 'u_randomSeed',\n  SPEED_FACTOR: 'u_speedFactor',\n  DROP_RATE: 'u_dropRate',\n  DROP_RATE_BUMP: 'u_dropRateBump',\n  OPACITY: 'u_opacity',\n  ROTATION: DefaultUniform.ROTATION,\n  VIEWPORT_SIZE_PX: DefaultUniform.VIEWPORT_SIZE_PX,\n};\n\n/**\n * Shader attributes.\n * @enum {string}\n */\nexport const A = {\n  POSITION: 'a_position',\n  INDEX: 'a_index',\n};\n\n/**\n * Shader varyings.\n * @enum {string}\n */\nexport const V = {\n  POSITION: 'v_position',\n};\n\n/**\n * @classdesc\n * Experimental WebGL renderer for vector fields.\n * @extends {WebGLTileLayerRenderer<LayerType>}\n */\nclass FlowLayerRenderer extends WebGLTileLayerRenderer {\n  /**\n   * @param {LayerType} layer The tiled field layer.\n   * @param {Options} options The renderer options.\n   */\n  constructor(layer, options) {\n    super(layer, {\n      vertexShader: options.tileVertexShader,\n      fragmentShader: options.tileFragmentShader,\n      cacheSize: options.cacheSize,\n      // TODO: rework the post-processing logic\n      // see https://github.com/openlayers/openlayers/issues/16120\n      postProcesses: [{}],\n      uniforms: {\n        [U.MAX_SPEED]: options.maxSpeed,\n      },\n    });\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.particleColorFragmentShader_ = options.particleColorFragmentShader;\n\n    /**\n     * @type {WebGLTexture|null}\n     * @private\n     */\n    this.velocityTexture_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.particleCountSqrt_ = options.particles\n      ? Math.ceil(Math.sqrt(options.particles))\n      : 256;\n\n    /**\n     * @type {WebGLArrayBuffer}\n     * @private\n     */\n    this.particleIndexBuffer_;\n\n    /**\n     * @type {WebGLArrayBuffer}\n     * @private\n     */\n    this.quadBuffer_;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.particlePositionProgram_;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.particlePositionVertexShader_ = options.particlePositionVertexShader;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.particlePositionFragmentShader_ =\n      options.particlePositionFragmentShader;\n\n    /**\n     * @type {WebGLTexture}\n     * @private\n     */\n    this.previousPositionTexture_;\n\n    /**\n     * @type {WebGLTexture}\n     * @private\n     */\n    this.nextPositionTexture_;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.particleColorProgram_;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.particleColorVertexShader_ = options.particleColorVertexShader;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.particleColorFragmentShader_ = options.particleColorFragmentShader;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.textureProgram_;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.textureVertexShader_ = options.textureVertexShader;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.textureFragmentShader_ = options.textureFragmentShader;\n\n    /**\n     * @type {WebGLTexture}\n     * @private\n     */\n    this.previousTrailsTexture_;\n\n    /**\n     * @type {WebGLTexture}\n     * @private\n     */\n    this.nextTrailsTexture_;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.fadeOpacity_ = 0.996; // how fast the particle trails fade on each frame\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxSpeed_ = options.maxSpeed;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.speedFactor_ = options.speedFactor || 0.001;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.dropRate_ = 0.003; // how often the particles move to a random place\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.dropRateBump_ = 0.01; // drop rate increase relative to individual particle speed\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.tempVec2_ = [0, 0];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.renderedWidth_ = 0;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.renderedHeight_ = 0;\n  }\n\n  /**\n   * @override\n   */\n  afterHelperCreated() {\n    super.afterHelperCreated();\n    const helper = this.helper;\n\n    const gl = helper.getGL();\n    this.framebuffer_ = gl.createFramebuffer();\n\n    const particleCount = this.particleCountSqrt_ * this.particleCountSqrt_;\n    const particleIndices = new Float32Array(particleCount);\n    for (let i = 0; i < particleCount; ++i) {\n      particleIndices[i] = i;\n    }\n    const particleIndexBuffer = new WebGLArrayBuffer(ARRAY_BUFFER, STATIC_DRAW);\n    particleIndexBuffer.setArray(particleIndices);\n    helper.flushBufferData(particleIndexBuffer);\n    this.particleIndexBuffer_ = particleIndexBuffer;\n\n    const quadIndices = new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]);\n    const quadBuffer = new WebGLArrayBuffer(ARRAY_BUFFER, STATIC_DRAW);\n    quadBuffer.setArray(quadIndices);\n    helper.flushBufferData(quadBuffer);\n    this.quadBuffer_ = quadBuffer;\n\n    const particlePositions = new Uint8Array(particleCount * 4);\n    for (let i = 0; i < particlePositions.length; ++i) {\n      particlePositions[i] = Math.floor(Math.random() * 256);\n    }\n\n    this.previousPositionTexture_ = helper.createTexture(\n      [this.particleCountSqrt_, this.particleCountSqrt_],\n      particlePositions,\n      null,\n      true,\n    );\n\n    this.nextPositionTexture_ = helper.createTexture(\n      [this.particleCountSqrt_, this.particleCountSqrt_],\n      particlePositions,\n      null,\n      true,\n    );\n\n    this.particlePositionProgram_ = helper.getProgram(\n      this.particlePositionFragmentShader_,\n      this.particlePositionVertexShader_,\n    );\n\n    this.particleColorProgram_ = helper.getProgram(\n      this.particleColorFragmentShader_,\n      this.particleColorVertexShader_,\n    );\n\n    this.textureProgram_ = helper.getProgram(\n      this.textureFragmentShader_,\n      this.textureVertexShader_,\n    );\n  }\n\n  createSizeDependentTextures_() {\n    const helper = this.helper;\n    const gl = helper.getGL();\n    const canvas = helper.getCanvas();\n    const screenWidth = canvas.width;\n    const screenHeight = canvas.height;\n\n    const blank = new Uint8Array(screenWidth * screenHeight * 4);\n\n    if (this.nextTrailsTexture_) {\n      gl.deleteTexture(this.nextTrailsTexture_);\n    }\n    this.nextTrailsTexture_ = helper.createTexture(\n      [screenWidth, screenHeight],\n      blank,\n      null,\n      true,\n    );\n\n    if (this.previousTrailsTexture_) {\n      gl.deleteTexture(this.previousTrailsTexture_);\n    }\n    this.previousTrailsTexture_ = helper.createTexture(\n      [screenWidth, screenHeight],\n      blank,\n      null,\n      true,\n    );\n  }\n\n  /**\n   * @override\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  beforeFinalize(frameState) {\n    const helper = this.helper;\n    const gl = helper.getGL();\n    const canvas = helper.getCanvas();\n    const screenWidth = canvas.width;\n    const screenHeight = canvas.height;\n\n    if (\n      this.renderedWidth_ != screenWidth ||\n      this.renderedHeight_ != screenHeight\n    ) {\n      this.createSizeDependentTextures_();\n    }\n\n    const size = [screenWidth, screenHeight];\n\n    // copy current frame buffer to the velocity texture\n    this.velocityTexture_ = helper.createTexture(\n      size,\n      null,\n      this.velocityTexture_,\n    );\n    gl.copyTexImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      0,\n      0,\n      screenWidth,\n      screenHeight,\n      0,\n    );\n\n    this.drawParticleTrails_(frameState);\n    this.updateParticlePositions_(frameState);\n\n    frameState.animate = true;\n    this.renderedWidth_ = screenWidth;\n    this.renderedHeight_ = screenHeight;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  drawParticleTrails_(frameState) {\n    const helper = this.helper;\n    const gl = helper.getGL();\n\n    helper.bindFrameBuffer(this.framebuffer_, this.nextTrailsTexture_);\n\n    this.drawTexture_(this.previousTrailsTexture_, this.fadeOpacity_);\n    this.drawParticleColor_(frameState);\n\n    helper.bindInitialFrameBuffer();\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n    this.drawTexture_(this.nextTrailsTexture_, 1);\n    gl.disable(gl.BLEND);\n\n    const current = this.nextTrailsTexture_;\n    this.nextTrailsTexture_ = this.previousTrailsTexture_;\n    this.previousTrailsTexture_ = current;\n  }\n\n  /**\n   * @param {WebGLTexture} texture The texture to draw.\n   * @param {number} opacity The opacity.\n   */\n  drawTexture_(texture, opacity) {\n    const helper = this.helper;\n    const gl = helper.getGL();\n\n    helper.useProgram(this.textureProgram_);\n    helper.bindTexture(texture, 0, U.TEXTURE);\n    helper.bindAttribute(this.quadBuffer_, A.POSITION, 2);\n    this.helper.setUniformFloatValue(U.OPACITY, opacity);\n\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  drawParticleColor_(frameState) {\n    const helper = this.helper;\n    const gl = helper.getGL();\n\n    helper.useProgram(this.particleColorProgram_);\n\n    const particleCount = this.particleCountSqrt_ * this.particleCountSqrt_;\n\n    helper.bindAttribute(this.particleIndexBuffer_, A.INDEX, 1);\n\n    helper.bindTexture(this.previousPositionTexture_, 0, U.POSITION_TEXTURE);\n    helper.bindTexture(this.velocityTexture_, 1, U.VELOCITY_TEXTURE);\n\n    this.helper.setUniformFloatValue(\n      U.PARTICLE_COUNT_SQRT,\n      this.particleCountSqrt_,\n    );\n\n    const rotation = this.tempVec2_;\n    rotation[0] = Math.cos(-frameState.viewState.rotation);\n    rotation[1] = Math.sin(-frameState.viewState.rotation);\n    this.helper.setUniformFloatVec2(U.ROTATION, rotation);\n\n    this.helper.setUniformFloatValue(U.MAX_SPEED, this.maxSpeed_);\n\n    gl.drawArrays(gl.POINTS, 0, particleCount);\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  updateParticlePositions_(frameState) {\n    const helper = this.helper;\n    const gl = helper.getGL();\n\n    helper.useProgram(this.particlePositionProgram_);\n    gl.viewport(0, 0, this.particleCountSqrt_, this.particleCountSqrt_);\n    helper.bindFrameBuffer(this.framebuffer_, this.nextPositionTexture_);\n\n    helper.bindTexture(this.previousPositionTexture_, 0, U.POSITION_TEXTURE);\n    helper.bindTexture(this.velocityTexture_, 1, U.VELOCITY_TEXTURE);\n    helper.bindAttribute(this.quadBuffer_, A.POSITION, 2);\n\n    helper.setUniformFloatValue(U.RANDOM_SEED, Math.random());\n    helper.setUniformFloatValue(U.SPEED_FACTOR, this.speedFactor_);\n    helper.setUniformFloatValue(U.DROP_RATE, this.dropRate_);\n    helper.setUniformFloatValue(U.DROP_RATE_BUMP, this.dropRateBump_);\n\n    const rotation = this.tempVec2_;\n    rotation[0] = Math.cos(-frameState.viewState.rotation);\n    rotation[1] = Math.sin(-frameState.viewState.rotation);\n    this.helper.setUniformFloatVec2(U.ROTATION, rotation);\n\n    const size = frameState.size;\n    this.helper.setUniformFloatVec2(U.VIEWPORT_SIZE_PX, [size[0], size[1]]);\n\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n    const current = this.nextPositionTexture_;\n    this.nextPositionTexture_ = this.previousPositionTexture_;\n    this.previousPositionTexture_ = current;\n  }\n}\n\nexport default FlowLayerRenderer;\n","/**\n * @module ol/layer/Flow\n */\nimport {ColorType} from '../expr/expression.js';\nimport {\n  getStringNumberEquivalent,\n  newCompilationContext,\n  uniformNameForVariable,\n} from '../expr/gpu.js';\nimport {expressionToGlsl} from '../render/webgl/compileUtil.js';\nimport FlowLayerRenderer, {A, U, V} from '../renderer/webgl/FlowLayer.js';\nimport {Attributes as BA, Uniforms as BU} from '../renderer/webgl/TileLayer.js';\nimport BaseTileLayer from './BaseTile.js';\nimport LayerProperty from './Property.js';\n\n/**\n * @typedef {import(\"../source/DataTile.js\").default} SourceType\n */\n\n/**\n * @typedef {Object} Style\n * Translates tile data to rendered pixels.\n *\n * @property {Object<string, (string|number)>} [variables] Style variables.  Each variable must hold a number or string.  These\n * variables can be used in the `color` {@link import(\"../expr/expression.js\").ExpressionValue expression} using\n * the `['var', 'varName']` operator.  To update style variables, use the {@link import(\"./WebGLTile.js\").default#updateStyleVariables} method.\n * @property {import(\"../expr/expression.js\").ExpressionValue} [color] An expression applied to color values.\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} maxSpeed The maximum particle speed.\n * @property {number} [speedFactor=0.001] A larger factor increases the rate at which particles cross the screen.\n * @property {number} [particles=65536] The number of particles to render.\n * @property {Style} [style] Style to apply to the layer.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {SourceType} [source] Source for this layer.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link module:ol/Map~Map#addLayer}.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {number} [cacheSize=512] The internal texture cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n */\n\nconst tileVertexShader = `\n  attribute vec2 ${BA.TEXTURE_COORD};\n  uniform mat4 ${BU.TILE_TRANSFORM};\n  uniform float ${BU.TEXTURE_PIXEL_WIDTH};\n  uniform float ${BU.TEXTURE_PIXEL_HEIGHT};\n  uniform float ${BU.TEXTURE_RESOLUTION};\n  uniform float ${BU.TEXTURE_ORIGIN_X};\n  uniform float ${BU.TEXTURE_ORIGIN_Y};\n  uniform float ${BU.DEPTH};\n\n  varying vec2 v_textureCoord;\n  varying vec2 v_mapCoord;\n\n  void main() {\n    v_textureCoord = ${BA.TEXTURE_COORD};\n    v_mapCoord = vec2(\n      ${BU.TEXTURE_ORIGIN_X} + ${BU.TEXTURE_RESOLUTION} * ${BU.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],\n      ${BU.TEXTURE_ORIGIN_Y} - ${BU.TEXTURE_RESOLUTION} * ${BU.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]\n    );\n    gl_Position = ${BU.TILE_TRANSFORM} * vec4(${BA.TEXTURE_COORD}, ${BU.DEPTH}, 1.0);\n  }\n`;\n\nconst tileFragmentShader = `\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  #else\n  precision mediump float;\n  #endif\n\n  uniform vec4 ${BU.RENDER_EXTENT};\n  uniform float ${U.MAX_SPEED};\n  uniform sampler2D ${BU.TILE_TEXTURE_ARRAY}[1];\n\n  varying vec2 v_textureCoord;\n  varying vec2 v_mapCoord;\n\n  void main() {\n    if (\n      v_mapCoord[0] < ${BU.RENDER_EXTENT}[0] ||\n      v_mapCoord[1] < ${BU.RENDER_EXTENT}[1] ||\n      v_mapCoord[0] > ${BU.RENDER_EXTENT}[2] ||\n      v_mapCoord[1] > ${BU.RENDER_EXTENT}[3]\n    ) {\n      discard;\n    }\n\n    vec4 velocity = texture2D(${BU.TILE_TEXTURE_ARRAY}[0],  v_textureCoord);\n    gl_FragColor = vec4((velocity.xy + ${U.MAX_SPEED}) / (2.0 * ${U.MAX_SPEED}), 0, 1);\n  }\n`;\n\n/**\n * Sets up a varying position for rendering textures.\n */\nconst quadVertexShader = `\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  #else\n  precision mediump float;\n  #endif\n\n  attribute vec2 ${A.POSITION};\n\n  varying vec2 ${V.POSITION};\n\n  void main() {\n    ${V.POSITION} = ${A.POSITION};\n    gl_Position = vec4(1.0 - 2.0 * ${A.POSITION}, 0, 1);\n  }\n`;\n\n/**\n * Sampes a texture and renders it with a new opacity.\n */\nconst textureFragmentShader = `\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  #else\n  precision mediump float;\n  #endif\n\n  uniform sampler2D ${U.TEXTURE};\n  uniform float ${U.OPACITY};\n\n  varying vec2 ${V.POSITION};\n\n  void main() {\n    vec4 color = texture2D(${U.TEXTURE}, 1.0 - ${V.POSITION});\n    gl_FragColor = vec4(floor(255.0 * color * ${U.OPACITY}) / 255.0);\n  }\n`;\n\n/**\n * Samples current particle positions, determines new positions based on velocity, and\n * encodes the new position as a color.\n */\nconst particlePositionFragmentShader = `\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  #else\n  precision mediump float;\n  #endif\n\n  uniform sampler2D ${U.POSITION_TEXTURE};\n  uniform sampler2D ${U.VELOCITY_TEXTURE};\n  uniform float ${U.RANDOM_SEED};\n  uniform float ${U.SPEED_FACTOR};\n  uniform float ${U.DROP_RATE};\n  uniform float ${U.DROP_RATE_BUMP};\n  uniform vec2 ${U.ROTATION};\n  uniform vec2 ${U.VIEWPORT_SIZE_PX};\n\n  varying vec2 ${V.POSITION};\n\n  // pseudo-random generator\n  const vec3 randConstants = vec3(12.9898, 78.233, 4375.85453);\n\n  float rand(const vec2 co) {\n    float t = dot(randConstants.xy, co);\n    return fract(sin(t) * (randConstants.z + t));\n  }\n\n  void main() {\n    vec4 positionColor = texture2D(${U.POSITION_TEXTURE}, ${V.POSITION});\n\n    // decode particle position from pixel RGBA\n    vec2 particlePosition = vec2(\n      positionColor.r / 255.0 + positionColor.b,\n      positionColor.g / 255.0 + positionColor.a\n    );\n\n    vec4 velocityColor = texture2D(${U.VELOCITY_TEXTURE}, particlePosition);\n    if (velocityColor.a == 0.0) {\n      discard;\n    }\n\n    float vx = 2.0 * velocityColor.r - 1.0;\n    float vy = 2.0 * velocityColor.g - 1.0;\n\n    // normalized veloicty (magnitude 0 - 1)\n    vec2 velocity = vec2(\n      vx * ${U.ROTATION}.x - vy * ${U.ROTATION}.y,\n      vx * ${U.ROTATION}.y + vy * ${U.ROTATION}.x\n    );\n\n    // account for aspect ratio (square particle position texture, non-square map)\n    float aspectRatio = ${U.VIEWPORT_SIZE_PX}.x / ${U.VIEWPORT_SIZE_PX}.y;\n    vec2 offset = vec2(velocity.x / aspectRatio, velocity.y) * ${U.SPEED_FACTOR};\n\n    // update particle position, wrapping around the edge\n    particlePosition = fract(1.0 + particlePosition + offset);\n\n    // a random seed to use for the particle drop\n    vec2 seed = (particlePosition + ${V.POSITION}) * ${U.RANDOM_SEED};\n\n    // drop rate is a chance a particle will restart at random position, to avoid degeneration\n    float dropRate = ${U.DROP_RATE} + length(velocity) * ${U.DROP_RATE_BUMP};\n    float drop = step(1.0 - dropRate, rand(seed));\n\n    vec2 randomPosition = vec2(rand(seed + 1.3), rand(seed + 2.1));\n    particlePosition = mix(particlePosition, randomPosition, drop);\n\n    // encode the new particle position back into RGBA\n    gl_FragColor = vec4(\n      fract(particlePosition * 255.0),\n      floor(particlePosition * 255.0) / 255.0\n    );\n  }\n`;\n\n/**\n * Samples the particle position texture to decode the particle position\n * based on pixel color.\n */\nconst particleColorVertexShader = `\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  #else\n  precision mediump float;\n  #endif\n\n  attribute float ${A.INDEX};\n\n  uniform sampler2D ${U.POSITION_TEXTURE};\n  uniform float ${U.PARTICLE_COUNT_SQRT};\n\n  varying vec2 ${V.POSITION};\n\n  void main() {\n    vec4 color = texture2D(\n      ${U.POSITION_TEXTURE},\n      vec2(\n        fract(${A.INDEX} / ${U.PARTICLE_COUNT_SQRT}),\n        floor(${A.INDEX} / ${U.PARTICLE_COUNT_SQRT}) / ${U.PARTICLE_COUNT_SQRT}\n      )\n    );\n\n    ${V.POSITION} = vec2(\n      color.r / 255.0 + color.b,\n      color.g / 255.0 + color.a\n    );\n\n    gl_PointSize = 1.0;\n    gl_Position = vec4(\n      2.0 * ${V.POSITION}.x - 1.0,\n      2.0 * ${V.POSITION}.y - 1.0,\n      0,\n      1\n    );\n  }\n`;\n\n/**\n * @typedef {Object} ParsedStyle\n * @property {string} tileVertexShader The flow tile vertex shader.\n * @property {string} tileFragmentShader The flow tile fragment shader.\n * @property {string} textureVertexShader Generic texture fragment shader.\n * @property {string} textureFragmentShader Generic texture fragment shader.\n * @property {string} particlePositionVertexShader The particle position vertex shader.\n * @property {string} particlePositionFragmentShader The particle position fragment shader.\n * @property {string} particleColorVertexShader The particle color vertex shader.\n * @property {string} particleColorFragmentShader The particle color fragment shader.\n */\n\n/**\n * @param {Style} style The layer style.\n * @return {ParsedStyle} Shaders and uniforms generated from the style.\n */\nfunction parseStyle(style) {\n  const context = newCompilationContext();\n  const pipeline = [];\n\n  if (style.color !== undefined) {\n    const color = expressionToGlsl(context, style.color, ColorType);\n    pipeline.push(`color = ${color};`);\n  }\n\n  const variableNames = Object.keys(context.variables);\n  if (variableNames.length > 1 && !style.variables) {\n    throw new Error(\n      `Missing variables in style (expected ${context.variables})`,\n    );\n  }\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  for (const variableName of variableNames) {\n    if (!(variableName in style.variables)) {\n      throw new Error(`Missing '${variableName}' in style variables`);\n    }\n\n    const uniformName = uniformNameForVariable(variableName);\n    uniforms[uniformName] = function () {\n      let value = style.variables[variableName];\n      if (typeof value === 'string') {\n        value = getStringNumberEquivalent(value);\n      }\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  }\n\n  const uniformDeclarations = Object.keys(uniforms).map(function (name) {\n    return `uniform float ${name};`;\n  });\n\n  const functionDefintions = Object.keys(context.functions).map(\n    function (name) {\n      return context.functions[name];\n    },\n  );\n\n  const particleColorFragmentShader = `\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n\n    uniform sampler2D ${U.VELOCITY_TEXTURE};\n    uniform float ${U.MAX_SPEED};\n    uniform vec2 ${U.ROTATION};\n\n    ${uniformDeclarations.join('\\n')}\n\n    varying vec2 ${V.POSITION};\n    \n    ${functionDefintions.join('\\n')}\n\n    void main() {\n      vec4 velocityColor = texture2D(${U.VELOCITY_TEXTURE}, ${V.POSITION});\n\n      float vx = mix(-${U.MAX_SPEED}, ${U.MAX_SPEED}, velocityColor.r);\n      float vy = mix(-${U.MAX_SPEED}, ${U.MAX_SPEED}, velocityColor.g);\n\n      vec2 velocity = vec2(\n        vx * ${U.ROTATION}.x - vy * ${U.ROTATION}.y,\n        vx * ${U.ROTATION}.y + vy * ${U.ROTATION}.x\n      );\n\n      float a_prop_speed = length(velocity);\n\n      vec4 color;\n\n      ${pipeline.join('\\n')}\n\n      if (color.a == 0.0) {\n        discard;\n      }\n\n      gl_FragColor = color;\n    }\n  `;\n\n  return {\n    tileVertexShader,\n    tileFragmentShader,\n    particleColorVertexShader,\n    particleColorFragmentShader,\n    particlePositionVertexShader: quadVertexShader,\n    particlePositionFragmentShader,\n    textureVertexShader: quadVertexShader,\n    textureFragmentShader,\n  };\n}\n\n/**\n * @type {Array<SourceType>}\n */\nconst sources = [];\n\n/**\n * @classdesc\n * Experimental layer that renders particles moving through a vector field.\n *\n * @extends BaseTileLayer<SourceType, FlowLayerRenderer>\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\n */\nclass FlowLayer extends BaseTileLayer {\n  /**\n   * @param {Options} options Flow layer options.\n   */\n  constructor(options) {\n    const baseOptions = Object.assign({}, options);\n    delete baseOptions.maxSpeed;\n    delete baseOptions.speedFactor;\n    delete baseOptions.particles;\n    super(baseOptions);\n\n    /**\n     * @type {Style}\n     * @private\n     */\n    this.style_ = options.style || {};\n\n    if (!(options.maxSpeed > 0)) {\n      throw new Error('maxSpeed is required');\n    }\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxSpeed_ = options.maxSpeed;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.speedFactor_ = options.speedFactor;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.particles_ = options.particles;\n\n    /**\n     * @type {Object<string, (string|number)>}\n     * @private\n     */\n    this.styleVariables_ = this.style_.variables || {};\n\n    this.addChangeListener(LayerProperty.SOURCE, this.handleSourceUpdate_);\n  }\n\n  /**\n   * @private\n   */\n  handleSourceUpdate_() {\n    if (this.hasRenderer()) {\n      this.getRenderer().clearCache();\n    }\n  }\n\n  /**\n   * Update any variables used by the layer style and trigger a re-render.\n   * @param {Object<string, number>} variables Variables to update.\n   */\n  updateStyleVariables(variables) {\n    Object.assign(this.styleVariables_, variables);\n    this.changed();\n  }\n\n  /**\n   * Gets the sources for this layer, for a given extent and resolution.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array<SourceType>} Sources.\n   */\n  getSources(extent, resolution) {\n    const source = this.getSource();\n    sources[0] = source;\n    return sources;\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    const parsedStyle = parseStyle(this.style_);\n\n    return new FlowLayerRenderer(this, {\n      ...parsedStyle,\n      cacheSize: this.getCacheSize(),\n      maxSpeed: this.maxSpeed_,\n      speedFactor: this.speedFactor_,\n      particles: this.particles_,\n    });\n  }\n}\n\n/**\n * Clean up underlying WebGL resources.\n * @function\n */\nFlowLayer.prototype.dispose;\n\nexport default FlowLayer;\n","/**\n * @module ol/layer/BaseTile\n */\nimport Layer from './Layer.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *   import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {TileSourceType} [source] Source for this layer.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n * @property {number} [cacheSize=512] The internal tile cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n */\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<TileSourceType, RendererType>}\n * @api\n */\nclass BaseTileLayer extends Layer {\n  /**\n   * @param {Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    const cacheSize = options.cacheSize;\n    delete options.cacheSize;\n\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    super(baseOptions);\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true,\n    );\n  }\n\n  /**\n   * @return {number|undefined} The suggested cache size\n   * @protected\n   */\n  getCacheSize() {\n    return this.cacheSize_;\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Deprecated.  Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Deprecated.  Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n\n  /**\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   * @override\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default BaseTileLayer;\n","/**\n * @module ol/tilecoord\n */\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, tileCoord) {\n  if (tileCoord !== undefined) {\n    tileCoord[0] = z;\n    tileCoord[1] = x;\n    tileCoord[2] = y;\n    return tileCoord;\n  }\n  return [z, x, y];\n}\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n  return z + '/' + x + '/' + y;\n}\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nexport function getCacheKeyForTileKey(tileKey) {\n  const [z, x, y] = tileKey\n    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\n    .split(',')\n    .map(Number);\n  return getKeyZXY(z, x, y);\n}\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n  return key.split('/').map(Number);\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n  return hashZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * @param {number} z The tile z coordinate.\n * @param {number} x The tile x coordinate.\n * @param {number} y The tile y coordinate.\n * @return {number} Hash.\n */\nexport function hashZXY(z, x, y) {\n  return (x << z) + y;\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n  const z = tileCoord[0];\n  const x = tileCoord[1];\n  const y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  const tileRange = tileGrid.getFullTileRange(z);\n  if (!tileRange) {\n    return true;\n  }\n  return tileRange.containsXY(x, y);\n}\n","/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n","/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nclass TileRange {\n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   */\n  constructor(minX, maxX, minY, maxY) {\n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  contains(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  containsTileRange(tileRange) {\n    return (\n      this.minX <= tileRange.minX &&\n      tileRange.maxX <= this.maxX &&\n      this.minY <= tileRange.minY &&\n      tileRange.maxY <= this.maxY\n    );\n  }\n\n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  containsXY(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  equals(tileRange) {\n    return (\n      this.minX == tileRange.minX &&\n      this.minY == tileRange.minY &&\n      this.maxX == tileRange.maxX &&\n      this.maxY == tileRange.maxY\n    );\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   */\n  extend(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  }\n\n  /**\n   * @return {number} Height.\n   */\n  getHeight() {\n    return this.maxY - this.minY + 1;\n  }\n\n  /**\n   * @return {import(\"./size.js\").Size} Size.\n   */\n  getSize() {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  /**\n   * @return {number} Width.\n   */\n  getWidth() {\n    return this.maxX - this.minX + 1;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  intersects(tileRange) {\n    return (\n      this.minX <= tileRange.maxX &&\n      this.maxX >= tileRange.minX &&\n      this.minY <= tileRange.maxY &&\n      this.maxY >= tileRange.minY\n    );\n  }\n}\n\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  }\n  return new TileRange(minX, maxX, minY, maxY);\n}\n\nexport default TileRange;\n"],"names":["U","TEXTURE","VELOCITY_TEXTURE","POSITION_TEXTURE","PARTICLE_COUNT_SQRT","MAX_SPEED","GAIN","OFFSET","IS_FLOAT","RANDOM_SEED","SPEED_FACTOR","DROP_RATE","DROP_RATE_BUMP","OPACITY","ROTATION","VIEWPORT_SIZE_PX","A","POSITION","INDEX","V","FlowLayerRenderer","constructor","layer","options","super","vertexShader","tileVertexShader","fragmentShader","tileFragmentShader","cacheSize","postProcesses","uniforms","maxSpeed","this","particleColorFragmentShader_","particleColorFragmentShader","velocityTexture_","particleCountSqrt_","particles","Math","ceil","sqrt","particleIndexBuffer_","quadBuffer_","particlePositionProgram_","particlePositionVertexShader_","particlePositionVertexShader","particlePositionFragmentShader_","particlePositionFragmentShader","previousPositionTexture_","nextPositionTexture_","particleColorProgram_","particleColorVertexShader_","particleColorVertexShader","textureProgram_","textureVertexShader_","textureVertexShader","textureFragmentShader_","textureFragmentShader","previousTrailsTexture_","nextTrailsTexture_","fadeOpacity_","maxSpeed_","speedFactor_","speedFactor","dropRate_","dropRateBump_","tempVec2_","renderedWidth_","renderedHeight_","afterHelperCreated","helper","gl","getGL","framebuffer_","createFramebuffer","particleCount","particleIndices","Float32Array","i","particleIndexBuffer","setArray","flushBufferData","quadIndices","quadBuffer","particlePositions","Uint8Array","length","floor","random","createTexture","getProgram","createSizeDependentTextures_","canvas","getCanvas","screenWidth","width","screenHeight","height","blank","deleteTexture","beforeFinalize","frameState","size","copyTexImage2D","TEXTURE_2D","RGBA","drawParticleTrails_","updateParticlePositions_","animate","bindFrameBuffer","drawTexture_","drawParticleColor_","bindInitialFrameBuffer","clearColor","clear","COLOR_BUFFER_BIT","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","disable","current","texture","opacity","useProgram","bindTexture","bindAttribute","setUniformFloatValue","drawArrays","TRIANGLES","rotation","cos","viewState","sin","setUniformFloatVec2","POINTS","viewport","TEXTURE_COORD","TILE_TRANSFORM","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","TEXTURE_RESOLUTION","TEXTURE_ORIGIN_X","TEXTURE_ORIGIN_Y","DEPTH","RENDER_EXTENT","TILE_TEXTURE_ARRAY","quadVertexShader","parseStyle","style","context","pipeline","undefined","color","push","variableNames","Object","keys","variables","Error","variableName","uniformName","value","uniformDeclarations","map","name","functionDefintions","functions","join","sources","FlowLayer","BaseTile","baseOptions","assign","style_","particles_","styleVariables_","addChangeListener","SOURCE","handleSourceUpdate_","hasRenderer","getRenderer","clearCache","updateStyleVariables","changed","getSources","extent","resolution","source","getSource","createRenderer","parsedStyle","getCacheSize","prototype","dispose","BaseTileLayer","preload","useInterimTilesOnError","on","once","un","cacheSize_","setPreload","setUseInterimTilesOnError","getPreload","get","PRELOAD","set","getUseInterimTilesOnError","USE_INTERIM_TILES_ON_ERROR","getData","pixel","createOrUpdate","z","x","y","tileCoord","getKeyZXY","getKey","hash","hashZXY","withinExtentAndZ","tileGrid","getMinZoom","getMaxZoom","tileRange","getFullTileRange","containsXY","TileRange","minX","maxX","minY","maxY","contains","containsTileRange","equals","extend","getHeight","getSize","getWidth","intersects"],"sourceRoot":""}