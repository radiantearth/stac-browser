{"version":3,"file":"js/7936.4b31a357.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/Tile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/net.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/UTFGrid.js"],"sourcesContent":["/**\n * @module ol/Tile\n */\nimport TileState from './TileState.js';\nimport {easeIn} from './easing.js';\nimport EventType from './events/EventType.js';\nimport EventTarget from './events/Target.js';\nimport {abstract} from './util.js';\n\n/**\n * A function that takes a {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState.js';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   const xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     const data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes a {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * A key assigned to the tile. This is used in conjunction with a source key\n     * to determine if a cached version of this tile may be used by the renderer.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @private\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n\n    /**\n     * @type {boolean}\n     */\n    this.interpolate = !!options.interpolate;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {\n    // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`\n    this.setState(TileState.EMPTY);\n  }\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state === TileState.EMPTY) {\n      // no more state changes\n      return;\n    }\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    this.release();\n    super.disposeInternal();\n  }\n}\n\nexport default Tile;\n","/**\n * @module ol/net\n */\nimport {getUid} from './util.js';\n\n/**\n * Simple JSONP helper. Supports error callbacks and a custom callback param.\n * The error callback will be called when no JSONP is executed after 10 seconds.\n *\n * @param {string} url Request url. A 'callback' query parameter will be\n *     appended.\n * @param {Function} callback Callback on success.\n * @param {Function} [errback] Callback on error.\n * @param {string} [callbackParam] Custom query parameter for the JSONP\n *     callback. Default is 'callback'.\n */\nexport function jsonp(url, callback, errback, callbackParam) {\n  const script = document.createElement('script');\n  const key = 'olc_' + getUid(callback);\n  function cleanup() {\n    delete window[key];\n    script.parentNode.removeChild(script);\n  }\n  script.async = true;\n  script.src =\n    url +\n    (url.includes('?') ? '&' : '?') +\n    (callbackParam || 'callback') +\n    '=' +\n    key;\n  const timer = setTimeout(function () {\n    cleanup();\n    if (errback) {\n      errback();\n    }\n  }, 10000);\n  window[key] = function (data) {\n    clearTimeout(timer);\n    cleanup();\n    callback(data);\n  };\n  document.head.appendChild(script);\n}\n\nexport class ResponseError extends Error {\n  /**\n   * @param {XMLHttpRequest} response The XHR object.\n   */\n  constructor(response) {\n    const message = 'Unexpected response status: ' + response.status;\n    super(message);\n\n    /**\n     * @type {string}\n     */\n    this.name = 'ResponseError';\n\n    /**\n     * @type {XMLHttpRequest}\n     */\n    this.response = response;\n  }\n}\n\nexport class ClientError extends Error {\n  /**\n   * @param {XMLHttpRequest} client The XHR object.\n   */\n  constructor(client) {\n    super('Failed to issue request');\n\n    /**\n     * @type {string}\n     */\n    this.name = 'ClientError';\n\n    /**\n     * @type {XMLHttpRequest}\n     */\n    this.client = client;\n  }\n}\n\n/**\n * @param {string} url The URL.\n * @return {Promise<Object>} A promise that resolves to the JSON response.\n */\nexport function getJSON(url) {\n  return new Promise(function (resolve, reject) {\n    /**\n     * @param {ProgressEvent<XMLHttpRequest>} event The load event.\n     */\n    function onLoad(event) {\n      const client = event.target;\n      // status will be 0 for file:// urls\n      if (!client.status || (client.status >= 200 && client.status < 300)) {\n        let data;\n        try {\n          data = JSON.parse(client.responseText);\n        } catch (err) {\n          const message = 'Error parsing response text as JSON: ' + err.message;\n          reject(new Error(message));\n          return;\n        }\n        resolve(data);\n        return;\n      }\n\n      reject(new ResponseError(client));\n    }\n\n    /**\n     * @param {ProgressEvent<XMLHttpRequest>} event The error event.\n     */\n    function onError(event) {\n      reject(new ClientError(event.target));\n    }\n\n    const client = new XMLHttpRequest();\n    client.addEventListener('load', onLoad);\n    client.addEventListener('error', onError);\n    client.open('GET', url);\n    client.setRequestHeader('Accept', 'application/json');\n    client.send();\n  });\n}\n\n/**\n * @param {string} base The base URL.\n * @param {string} url The potentially relative URL.\n * @return {string} The full URL.\n */\nexport function resolveUrl(base, url) {\n  if (url.includes('://')) {\n    return url;\n  }\n  return new URL(url, base).href;\n}\n\nlet originalXHR;\nexport function overrideXHR(xhr) {\n  if (typeof XMLHttpRequest !== 'undefined') {\n    originalXHR = XMLHttpRequest;\n  }\n  global.XMLHttpRequest = xhr;\n}\n\nexport function restoreXHR() {\n  global.XMLHttpRequest = originalXHR;\n}\n","/**\n * @module ol/source/UTFGrid\n */\n\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport EventType from '../events/EventType.js';\nimport {listenOnce} from '../events.js';\nimport {applyTransform, intersects} from '../extent.js';\nimport {jsonp as requestJSONP} from '../net.js';\nimport {get as getProjection, getTransformFromProjections} from '../proj.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\nimport {createFromTemplates, nullTileUrlFunction} from '../tileurlfunction.js';\nimport TileSource from './Tile.js';\n\n/**\n * @typedef {Object} UTFGridJSON\n * @property {Array<string>} grid The grid.\n * @property {Array<string>} keys The keys.\n * @property {Object<string, Object>} [data] Optional data.\n */\n\nexport class CustomTile extends Tile {\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {import(\"../extent.js\").Extent} extent Extent of the tile.\n   * @param {boolean} preemptive Load the tile when visible (before it's needed).\n   * @param {boolean} jsonp Load the tile as a script.\n   */\n  constructor(tileCoord, state, src, extent, preemptive, jsonp) {\n    super(tileCoord, state);\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = extent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ = preemptive;\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.grid_ = null;\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.keys_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, Object>|undefined}\n     */\n    this.data_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = jsonp;\n  }\n\n  /**\n   * Get the image element for this tile.\n   * @return {HTMLImageElement} Image.\n   */\n  getImage() {\n    return null;\n  }\n\n  /**\n   * Synchronously returns data at given coordinate (if available).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {*} The data.\n   */\n  getData(coordinate) {\n    if (!this.grid_ || !this.keys_) {\n      return null;\n    }\n    const xRelative =\n      (coordinate[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]);\n    const yRelative =\n      (coordinate[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]);\n\n    const row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];\n\n    if (typeof row !== 'string') {\n      return null;\n    }\n\n    let code = row.charCodeAt(Math.floor(xRelative * row.length));\n    if (code >= 93) {\n      code--;\n    }\n    if (code >= 35) {\n      code--;\n    }\n    code -= 32;\n\n    let data = null;\n    if (code in this.keys_) {\n      const id = this.keys_[code];\n      if (this.data_ && id in this.data_) {\n        data = this.data_[id];\n      } else {\n        data = id;\n      }\n    }\n    return data;\n  }\n\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate (or `null` if not yet loaded).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean} [request] If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   */\n  forDataAtCoordinate(coordinate, callback, request) {\n    if (this.state == TileState.EMPTY && request === true) {\n      this.state = TileState.IDLE;\n      listenOnce(this, EventType.CHANGE, (e) => {\n        callback(this.getData(coordinate));\n      });\n      this.loadInternal_();\n    } else {\n      if (request === true) {\n        setTimeout(() => {\n          callback(this.getData(coordinate));\n        }, 0);\n      } else {\n        callback(this.getData(coordinate));\n      }\n    }\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   * @override\n   */\n  getKey() {\n    return this.src_;\n  }\n\n  /**\n   * @private\n   */\n  handleError_() {\n    this.state = TileState.ERROR;\n    this.changed();\n  }\n\n  /**\n   * @param {!UTFGridJSON} json UTFGrid data.\n   * @private\n   */\n  handleLoad_(json) {\n    this.grid_ = json['grid'];\n    this.keys_ = json['keys'];\n    this.data_ = json['data'];\n\n    this.state = TileState.LOADED;\n    this.changed();\n  }\n\n  /**\n   * @private\n   */\n  loadInternal_() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      if (this.jsonp_) {\n        requestJSONP(\n          this.src_,\n          this.handleLoad_.bind(this),\n          this.handleError_.bind(this),\n        );\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', this.src_);\n        client.send();\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {!UTFGridJSON} */ (\n          JSON.parse(client.responseText)\n        );\n      } catch {\n        this.handleError_();\n        return;\n      }\n      this.handleLoad_(response);\n    } else {\n      this.handleError_();\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleError_();\n  }\n\n  /**\n   * @override\n   */\n  load() {\n    if (this.preemptive_) {\n      this.loadInternal_();\n    } else {\n      this.setState(TileState.EMPTY);\n    }\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [preemptive=true]\n * If `true` the UTFGrid source loads the tiles based on their \"visibility\".\n * This improves the speed of response, but increases traffic.\n * Note that if set to `false` (lazy loading), you need to pass `true` as\n * `request` to the `forDataAtCoordinateAndResolution` method otherwise no\n * data will ever be loaded.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {import(\"./TileJSON.js\").Config} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {string} [url] TileJSON endpoint that provides the configuration for this source.\n * Request will be made through JSONP. If not provided, `tileJSON` must be configured.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for UTFGrid interaction data loaded from TileJSON format.\n * @api\n */\nclass UTFGrid extends TileSource {\n  /**\n   * @param {Options} options Source options.\n   */\n  constructor(options) {\n    super({\n      projection: getProjection('EPSG:3857'),\n      state: 'loading',\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ =\n      options.preemptive !== undefined ? options.preemptive : true;\n\n    /**\n     * @private\n     * @type {!import(\"../Tile.js\").UrlFunction}\n     */\n    this.tileUrlFunction_ = nullTileUrlFunction;\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.template_ = undefined;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = options.jsonp || false;\n\n    if (options.url) {\n      if (this.jsonp_) {\n        requestJSONP(\n          options.url,\n          this.handleTileJSONResponse.bind(this),\n          this.handleTileJSONError.bind(this),\n        );\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', options.url);\n        client.send();\n      }\n    } else if (options.tileJSON) {\n      this.handleTileJSONResponse(options.tileJSON);\n    } else {\n      throw new Error('Either `url` or `tileJSON` options must be provided');\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {import(\"./TileJSON.js\").Config} */ (\n          JSON.parse(client.responseText)\n        );\n      } catch {\n        this.handleTileJSONError();\n        return;\n      }\n      this.handleTileJSONResponse(response);\n    } else {\n      this.handleTileJSONError();\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleTileJSONError();\n  }\n\n  /**\n   * Return the template from TileJSON.\n   * @return {string|undefined} The template from TileJSON.\n   * @api\n   */\n  getTemplate() {\n    return this.template_;\n  }\n\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate and resolution (or `null` if not yet loaded or\n   * in case of an error).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean} [request] If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   * @api\n   */\n  forDataAtCoordinateAndResolution(coordinate, resolution, callback, request) {\n    if (this.tileGrid) {\n      const z = this.tileGrid.getZForResolution(resolution, this.zDirection);\n      const tileCoord = this.tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = /** @type {!CustomTile} */ (\n        this.getTile(\n          tileCoord[0],\n          tileCoord[1],\n          tileCoord[2],\n          1,\n          this.getProjection(),\n        )\n      );\n      tile.forDataAtCoordinate(coordinate, callback, request);\n    } else {\n      if (request === true) {\n        setTimeout(function () {\n          callback(null);\n        }, 0);\n      } else {\n        callback(null);\n      }\n    }\n  }\n\n  /**\n   * @protected\n   */\n  handleTileJSONError() {\n    this.setState('error');\n  }\n\n  /**\n   * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse\n   * @protected\n   * @param {import(\"./TileJSON.js\").Config} tileJSON Tile JSON.\n   */\n  handleTileJSONResponse(tileJSON) {\n    const epsg4326Projection = getProjection('EPSG:4326');\n\n    const sourceProjection = this.getProjection();\n    let extent;\n    if (tileJSON['bounds'] !== undefined) {\n      const transform = getTransformFromProjections(\n        epsg4326Projection,\n        sourceProjection,\n      );\n      extent = applyTransform(tileJSON['bounds'], transform);\n    }\n\n    const gridExtent = extentFromProjection(sourceProjection);\n    const minZoom = tileJSON['minzoom'] || 0;\n    const maxZoom = tileJSON['maxzoom'] || 22;\n    const tileGrid = createXYZ({\n      extent: gridExtent,\n      maxZoom: maxZoom,\n      minZoom: minZoom,\n    });\n    this.tileGrid = tileGrid;\n\n    this.template_ = tileJSON['template'];\n\n    const grids = tileJSON['grids'];\n    if (!grids) {\n      this.setState('error');\n      return;\n    }\n\n    this.tileUrlFunction_ = createFromTemplates(grids, tileGrid);\n\n    if (tileJSON['attribution']) {\n      const attributionExtent = extent !== undefined ? extent : gridExtent;\n      this.setAttributions(function (frameState) {\n        if (intersects(attributionExtent, frameState.extent)) {\n          return [tileJSON['attribution']];\n        }\n        return null;\n      });\n    }\n\n    this.setState('ready');\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!CustomTile} Tile.\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tileCoord = [z, x, y];\n    const urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection,\n    );\n    const tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);\n    const tile = new CustomTile(\n      tileCoord,\n      tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\n      tileUrl !== undefined ? tileUrl : '',\n      this.tileGrid.getTileCoordExtent(tileCoord),\n      this.preemptive_,\n      this.jsonp_,\n    );\n    return tile;\n  }\n}\n\nexport default UTFGrid;\n"],"names":["Tile","constructor","tileCoord","state","options","super","this","key","transition_","undefined","transition","transitionStarts_","interpolate","changed","dispatchEvent","CHANGE","release","setState","EMPTY","getKey","getTileCoord","getState","ERROR","Error","load","getAlpha","id","time","start","delta","inTransition","endTransition","disposeInternal","jsonp","url","callback","errback","callbackParam","script","document","createElement","cleanup","window","parentNode","removeChild","async","src","includes","timer","setTimeout","data","clearTimeout","head","appendChild","ResponseError","response","message","status","name","ClientError","client","getJSON","Promise","resolve","reject","onLoad","event","target","JSON","parse","responseText","err","onError","XMLHttpRequest","addEventListener","open","setRequestHeader","send","resolveUrl","base","URL","href","CustomTile","extent","preemptive","src_","extent_","preemptive_","grid_","keys_","data_","jsonp_","getImage","getData","coordinate","xRelative","yRelative","row","Math","floor","length","code","charCodeAt","forDataAtCoordinate","request","IDLE","e","loadInternal_","handleError_","handleLoad_","json","LOADED","LOADING","bind","onXHRLoad_","onXHRError_","UTFGrid","projection","wrapX","zDirection","tileUrlFunction_","template_","handleTileJSONResponse","handleTileJSONError","tileJSON","getTemplate","forDataAtCoordinateAndResolution","resolution","tileGrid","z","getZForResolution","getTileCoordForCoordAndZ","tile","getTile","getProjection","epsg4326Projection","sourceProjection","transform","gridExtent","minZoom","maxZoom","grids","attributionExtent","setAttributions","frameState","x","y","pixelRatio","urlTileCoord","getTileCoordForTileUrlFunction","tileUrl","getTileCoordExtent"],"sourceRoot":""}