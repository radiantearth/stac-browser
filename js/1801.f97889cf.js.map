{"version":3,"file":"js/1801.f97889cf.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/renderer/webgl/PointsLayer.js","webpack://@radiantearth/stac-browser/./node_modules/ol/renderer/webgl/worldUtil.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport ViewHint from '../../ViewHint.js';\nimport {assert} from '../../asserts.js';\nimport {listen, unlistenByKey} from '../../events.js';\nimport {buffer, createEmpty, equals} from '../../extent.js';\nimport BaseVector from '../../layer/BaseVector.js';\nimport {fromUserCoordinate, getUserProjection} from '../../proj.js';\nimport {WebGLWorkerMessageType} from '../../render/webgl/constants.js';\nimport {colorDecodeId, colorEncodeId} from '../../render/webgl/utils.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport {AttributeType, DefaultUniform} from '../../webgl/Helper.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {getWorldParameters} from './worldUtil.js';\n\n/** @typedef {import(\"../../geom/Point.js\").default} Point */\n/** @typedef {import(\"../../Feature\").default<Point>} PointFeature */\n\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(PointFeature, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {PointFeature} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../coordinate.js\").Coordinate} flatCoordinates Point coordinates\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  In the vertex shader as an `attribute` by prefixing it with `a_`\n *  In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {boolean} [hitDetectionEnabled] Whether shader is hit detection aware.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nclass WebGLPointsLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    const projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    /**\n     * @private\n     */\n    this.sourceRevision_ = -1;\n\n    /**\n     * @private\n     */\n    this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    /**\n     * @private\n     */\n    this.indicesBuffer_ = new WebGLArrayBuffer(\n      ELEMENT_ARRAY_BUFFER,\n      DYNAMIC_DRAW,\n    );\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hitDetectionEnabled_ = options.hitDetectionEnabled ?? true;\n\n    const customAttributes = options.attributes\n      ? options.attributes.map(function (attribute) {\n          return {\n            name: 'a_' + attribute.name,\n            size: 1,\n            type: AttributeType.FLOAT,\n          };\n        })\n      : [];\n\n    /**\n     * A list of attributes used by the renderer. By default only the position and\n     * index of the vertex (0 to 3) are required.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.attributes = [\n      {\n        name: 'a_position',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_index',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ];\n\n    if (this.hitDetectionEnabled_) {\n      this.attributes.push({\n        name: 'a_hitColor',\n        size: 4,\n        type: AttributeType.FLOAT,\n      });\n      this.attributes.push({\n        name: 'a_featureUid',\n        size: 1,\n        type: AttributeType.FLOAT,\n      });\n    }\n    this.attributes.push(...customAttributes);\n\n    this.customAttributes = options.attributes ? options.attributes : [];\n\n    /**\n     * @private\n     */\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = projectionMatrixTransform;\n\n    /**\n     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.renderTransform_ = createTransform();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.invertRenderTransform_ = createTransform();\n\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n    this.renderInstructions_ = new Float32Array(0);\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    this.hitRenderTarget_;\n\n    /**\n     * Keep track of latest message sent to worker\n     * @type {number}\n     * @private\n     */\n    this.lastSentId = 0;\n\n    /**\n     * @private\n     */\n    this.worker_ = createWebGLWorker();\n\n    this.worker_.addEventListener(\n      'message',\n      /**\n       * @param {*} event Event.\n       */\n      (event) => {\n        const received = event.data;\n        if (received.type === WebGLWorkerMessageType.GENERATE_POINT_BUFFERS) {\n          const projectionTransform = received.projectionTransform;\n          this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n          this.helper.flushBufferData(this.verticesBuffer_);\n          this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n          this.helper.flushBufferData(this.indicesBuffer_);\n\n          this.renderTransform_ = projectionTransform;\n          makeInverseTransform(\n            this.invertRenderTransform_,\n            this.renderTransform_,\n          );\n          this.renderInstructions_ = new Float32Array(\n            event.data.renderInstructions,\n          );\n          if (received.id === this.lastSentId) {\n            this.ready = true;\n          }\n          this.getLayer().changed();\n        }\n      },\n    );\n\n    /**\n     * This object will be updated when the source changes. Key is uid.\n     * @type {Object<string, FeatureCacheItem>}\n     * @private\n     */\n    this.featureCache_ = {};\n\n    /**\n     * Amount of features in the cache.\n     * @type {number}\n     * @private\n     */\n    this.featureCount_ = 0;\n\n    const source = /** @type {import(\"../../source/Vector.js\").default} */ (\n      this.getLayer().getSource()\n    );\n    /**\n     * @private\n     */\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this,\n      ),\n    ];\n    source.forEachFeature((feature) => {\n      const geometry = feature.getGeometry();\n      if (geometry && geometry.getType() === 'Point') {\n        this.featureCache_[getUid(feature)] = {\n          feature: /** @type {PointFeature} */ (feature),\n          properties: feature.getProperties(),\n          flatCoordinates: /** @type {Point} */ (geometry).getFlatCoordinates(),\n        };\n        this.featureCount_++;\n      }\n    });\n  }\n\n  /**\n   * @override\n   */\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(\n      this.fragmentShader_,\n      this.vertexShader_,\n    );\n\n    if (this.hitDetectionEnabled_) {\n      this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n    }\n\n    // upload buffers again if any\n    if (this.verticesBuffer_.getArray()) {\n      this.helper.flushBufferData(this.verticesBuffer_);\n    }\n    if (this.indicesBuffer_.getArray()) {\n      this.helper.flushBufferData(this.indicesBuffer_);\n    }\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    const geometry = feature.getGeometry();\n    if (geometry && geometry.getType() === 'Point') {\n      this.featureCache_[getUid(feature)] = {\n        feature: /** @type {PointFeature} */ (feature),\n        properties: feature.getProperties(),\n        flatCoordinates: /** @type {Point} */ (geometry).getFlatCoordinates(),\n      };\n      this.featureCount_++;\n    }\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    const featureUid = getUid(feature);\n    const item = this.featureCache_[featureUid];\n    const geometry = feature.getGeometry();\n    if (item) {\n      if (geometry && geometry.getType() === 'Point') {\n        item.properties = feature.getProperties();\n        item.flatCoordinates = /** @type {Point} */ (\n          geometry\n        ).getFlatCoordinates();\n      } else {\n        delete this.featureCache_[featureUid];\n        this.featureCount_--;\n      }\n    } else {\n      if (geometry && geometry.getType() === 'Point') {\n        this.featureCache_[featureUid] = {\n          feature: /** @type {PointFeature} */ (feature),\n          properties: feature.getProperties(),\n          flatCoordinates: /** @type {Point} */ (geometry).getFlatCoordinates(),\n        };\n        this.featureCount_++;\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    const featureUid = getUid(feature);\n    if (featureUid in this.featureCache_) {\n      delete this.featureCache_[featureUid];\n      this.featureCount_--;\n    }\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.featureCache_ = {};\n    this.featureCount_ = 0;\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n    const [startWorld, endWorld, worldWidth] = getWorldParameters(\n      frameState,\n      this.getLayer(),\n    );\n\n    // draw the normal canvas\n    this.renderWorlds(frameState, false, startWorld, endWorld, worldWidth);\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent,\n    );\n\n    if (this.hitDetectionEnabled_) {\n      // draw the hit buffer\n      this.renderWorlds(frameState, true, startWorld, endWorld, worldWidth);\n      this.hitRenderTarget_.clearCachedData();\n    }\n\n    this.postRender(gl, frameState);\n\n    const canvas = this.helper.getCanvas();\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n\n      this.rebuildBuffers_(frameState);\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    this.helper.useProgram(this.program_, frameState);\n    this.helper.prepareDraw(frameState);\n\n    // write new data\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n\n    return true;\n  }\n\n  /**\n   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  rebuildBuffers_(frameState) {\n    // saves the projection transform for the current frame state\n    const projectionTransform = createTransform();\n    this.helper.makeProjectionTransform(frameState, projectionTransform);\n\n    const userProjection = getUserProjection();\n\n    const baseInstructionLength = this.hitDetectionEnabled_ ? 7 : 2; // see below\n    const singleInstructionLength =\n      baseInstructionLength + this.customAttributes.length;\n    const totalSize = singleInstructionLength * this.featureCount_;\n    const renderInstructions =\n      this.renderInstructions_ && this.renderInstructions_.length === totalSize\n        ? this.renderInstructions_\n        : new Float32Array(totalSize);\n    this.renderInstructions_ = null;\n\n    // loop over features to fill the buffer\n    /** @type {import('../../coordinate.js').Coordinate} */\n    let tmpCoords = [];\n    /** @type {Array<number>} */\n    const tmpColor = [];\n    let idx = -1;\n    const projection = frameState.viewState.projection;\n    for (const featureUid in this.featureCache_) {\n      const featureCache = this.featureCache_[featureUid];\n      if (userProjection) {\n        tmpCoords = fromUserCoordinate(\n          featureCache.flatCoordinates,\n          projection,\n        );\n      } else {\n        tmpCoords[0] = featureCache.flatCoordinates[0];\n        tmpCoords[1] = featureCache.flatCoordinates[1];\n      }\n      applyTransform(projectionTransform, tmpCoords);\n\n      renderInstructions[++idx] = tmpCoords[0];\n      renderInstructions[++idx] = tmpCoords[1];\n\n      // for hit detection, the feature uid is saved in the opacity value\n      // and the index of the opacity value is encoded in the color values\n      if (this.hitDetectionEnabled_) {\n        const hitColor = colorEncodeId(idx + 5, tmpColor);\n        renderInstructions[++idx] = hitColor[0];\n        renderInstructions[++idx] = hitColor[1];\n        renderInstructions[++idx] = hitColor[2];\n        renderInstructions[++idx] = hitColor[3];\n        renderInstructions[++idx] = Number(featureUid);\n      }\n\n      // pushing custom attributes\n      for (let j = 0; j < this.customAttributes.length; j++) {\n        const value = this.customAttributes[j].callback(\n          featureCache.feature,\n          featureCache.properties,\n        );\n        renderInstructions[++idx] = value;\n      }\n    }\n\n    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: ++this.lastSentId,\n      type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,\n      renderInstructions: renderInstructions.buffer,\n      customAttributesSize: singleInstructionLength - 2,\n    };\n    // additional properties will be sent back as-is by the worker\n    message['projectionTransform'] = projectionTransform;\n    this.ready = false;\n    this.worker_.postMessage(message, [renderInstructions.buffer]);\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    assert(\n      this.hitDetectionEnabled_,\n      '`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option.',\n    );\n    if (!this.renderInstructions_ || !this.hitDetectionEnabled_) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(\n      frameState.coordinateToPixelTransform,\n      coordinate.slice(),\n    );\n\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const index = colorDecodeId(color);\n    const opacity = this.renderInstructions_[index];\n    const uid = Math.floor(opacity).toString();\n\n    const source = this.getLayer().getSource();\n    const feature = source.getFeatureByUid(uid);\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n    return undefined;\n  }\n\n  /**\n   * Render the world, either to the main framebuffer or to the hit framebuffer\n   * @param {import(\"../../Map.js\").FrameState} frameState current frame state\n   * @param {boolean} forHitDetection whether the rendering is for hit detection\n   * @param {number} startWorld the world to render in the first iteration\n   * @param {number} endWorld the last world to render\n   * @param {number} worldWidth the width of the worlds being rendered\n   */\n  renderWorlds(frameState, forHitDetection, startWorld, endWorld, worldWidth) {\n    let world = startWorld;\n\n    this.helper.useProgram(this.program_, frameState);\n\n    if (forHitDetection) {\n      this.hitRenderTarget_.setSize([\n        Math.floor(frameState.size[0] / 2),\n        Math.floor(frameState.size[1] / 2),\n      ]);\n      this.helper.prepareDrawToRenderTarget(\n        frameState,\n        this.hitRenderTarget_,\n        true,\n      );\n    }\n\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n\n    do {\n      this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n      translateTransform(this.currentTransform_, world * worldWidth, 0);\n      multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n      this.helper.applyUniforms(frameState);\n      this.helper.applyHitDetectionUniform(forHitDetection);\n      const renderCount = this.indicesBuffer_.getSize();\n      this.helper.drawElements(0, renderCount);\n    } while (++world < endWorld);\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n\n  renderDeclutter() {}\n}\n\nexport default WebGLPointsLayerRenderer;\n","import {getWidth} from '../../extent.js';\n\n/**\n * Compute world params\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {any} layer The layer\n * @return {Array<number>} The world start, end and width.\n */\nexport function getWorldParameters(frameState, layer) {\n  const projection = frameState.viewState.projection;\n\n  const vectorSource = layer.getSource();\n  const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n  const projectionExtent = projection.getExtent();\n\n  const extent = frameState.extent;\n  const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n  const endWorld = multiWorld\n    ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n    : 1;\n\n  const startWorld = multiWorld\n    ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n    : 0;\n\n  return [startWorld, endWorld, worldWidth];\n}\n"],"names":["WebGLPointsLayerRenderer","constructor","layer","options","uniforms","projectionMatrixTransform","PROJECTION_MATRIX","super","postProcesses","this","sourceRevision_","verticesBuffer_","indicesBuffer_","vertexShader_","vertexShader","fragmentShader_","fragmentShader","program_","hitDetectionEnabled_","hitDetectionEnabled","customAttributes","attributes","map","attribute","name","size","type","FLOAT","push","previousExtent_","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","Float32Array","hitRenderTarget_","lastSentId","worker_","addEventListener","event","received","data","GENERATE_POINT_BUFFERS","projectionTransform","fromArrayBuffer","vertexBuffer","helper","flushBufferData","indexBuffer","renderInstructions","id","ready","getLayer","changed","featureCache_","featureCount_","source","getSource","sourceListenKeys_","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","forEachFeature","feature","geometry","getGeometry","getType","properties","getProperties","flatCoordinates","getFlatCoordinates","afterHelperCreated","getProgram","getArray","featureUid","item","renderFrame","frameState","gl","getGL","preRender","startWorld","endWorld","worldWidth","renderWorlds","finalizeDraw","dispatchPreComposeEvent","dispatchPostComposeEvent","clearCachedData","postRender","canvas","getCanvas","prepareFrameInternal","vectorSource","viewState","viewNotMoving","viewHints","ANIMATING","INTERACTING","extentChanged","extent","sourceChanged","getRevision","projection","resolution","renderBuffer","getRenderBuffer","loadFeatures","rebuildBuffers_","slice","useProgram","prepareDraw","bindBuffer","enableAttributes","makeProjectionTransform","userProjection","baseInstructionLength","singleInstructionLength","length","totalSize","tmpCoords","tmpColor","idx","featureCache","hitColor","Number","j","value","callback","message","buffer","customAttributesSize","postMessage","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","pixel","coordinateToPixelTransform","readPixel","color","index","opacity","uid","Math","floor","toString","getFeatureByUid","forHitDetection","world","setSize","prepareDrawToRenderTarget","applyUniforms","applyHitDetectionUniform","renderCount","getSize","drawElements","disposeInternal","terminate","forEach","key","renderDeclutter","getWorldParameters","multiWorld","getWrapX","canWrapX","projectionExtent","getExtent","ceil"],"sourceRoot":""}