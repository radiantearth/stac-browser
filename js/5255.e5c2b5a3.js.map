{"version":3,"file":"js/5255.e5c2b5a3.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/compression/index.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/pool.js","webpack://@radiantearth/stac-browser/./node_modules/@petamoriken/float16/src/_util/messages.mjs","webpack://@radiantearth/stac-browser/./node_modules/@petamoriken/float16/src/_util/primordials.mjs","webpack://@radiantearth/stac-browser/./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs","webpack://@radiantearth/stac-browser/./node_modules/@petamoriken/float16/src/_util/converter.mjs","webpack://@radiantearth/stac-browser/./node_modules/@petamoriken/float16/src/DataView.mjs","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/rgb.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/resample.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/geotiffimage.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/dataview64.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/dataslice.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/source/httputils.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/source/basesource.js","webpack://@radiantearth/stac-browser/./node_modules/quick-lru/index.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/utils.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/source/blockedsource.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/source/client/base.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/source/client/fetch.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/source/client/xhr.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/source/client/http.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/source/remote.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/source/filereader.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/geotiff.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/GeoTIFF.js","webpack://@radiantearth/stac-browser/./node_modules/xml-utils/count-substring.js","webpack://@radiantearth/stac-browser/./node_modules/xml-utils/get-attribute.js","webpack://@radiantearth/stac-browser/./node_modules/xml-utils/index-of-match.js","webpack://@radiantearth/stac-browser/./node_modules/xml-utils/index-of-match-end.js","webpack://@radiantearth/stac-browser/./node_modules/xml-utils/find-tag-by-name.js","webpack://@radiantearth/stac-browser/./node_modules/xml-utils/find-tags-by-name.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/globals.js"],"sourcesContent":["const registry = new Map();\n\nexport function addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nexport async function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => import('./raw.js').then((m) => m.default));\naddDecoder(5, () => import('./lzw.js').then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => import('./jpeg.js').then((m) => m.default));\naddDecoder([8, 32946], () => import('./deflate.js').then((m) => m.default));\naddDecoder(32773, () => import('./packbits.js').then((m) => m.default));\naddDecoder(34887, () => import('./lerc.js')\n  .then(async (m) => {\n    await m.zstd.init();\n    return m;\n  })\n  .then((m) => m.default),\n);\naddDecoder(50001, () => import('./webimage.js').then((m) => m.default));\n","import { getDecoder } from './compression/index.js';\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        import('./worker/decoder.js').then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? getDecoder(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\nexport default Pool;\n","export const THIS_IS_NOT_AN_OBJECT = \"This is not an object\";\nexport const THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT = \"This is not a Float16Array object\";\nexport const THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY =\n  \"This constructor is not a subclass of Float16Array\";\nexport const THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT =\n  \"The constructor property value is not an object\";\nexport const SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT =\n  \"Species constructor didn't return TypedArray object\";\nexport const DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH =\n  \"Derived constructor created TypedArray object which was too small length\";\nexport const ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER =\n  \"Attempting to access detached ArrayBuffer\";\nexport const CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT =\n  \"Cannot convert undefined or null to object\";\nexport const CANNOT_MIX_BIGINT_AND_OTHER_TYPES =\n  \"Cannot mix BigInt and other types, use explicit conversions\";\nexport const ITERATOR_PROPERTY_IS_NOT_CALLABLE = \"@@iterator property is not callable\";\nexport const REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE =\n  \"Reduce of empty array with no initial value\";\nexport const THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED =\n  \"The comparison function must be either a function or undefined\";\nexport const OFFSET_IS_OUT_OF_BOUNDS = \"Offset is out of bounds\";\n","/* eslint-disable no-restricted-globals, no-restricted-syntax */\n/* global SharedArrayBuffer */\n\nimport { CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT } from \"./messages.mjs\";\n\n/** @type {<T extends (...args: any) => any>(target: T) => (thisArg: ThisType<T>, ...args: any[]) => any} */\nfunction uncurryThis(target) {\n  return (thisArg, ...args) => {\n    return ReflectApply(target, thisArg, args);\n  };\n}\n\n/** @type {(target: any, key: string | symbol) => (thisArg: any, ...args: any[]) => any} */\nfunction uncurryThisGetter(target, key) {\n  return uncurryThis(\n    ReflectGetOwnPropertyDescriptor(\n      target,\n      key\n    ).get\n  );\n}\n\n// Reflect\nexport const {\n  apply: ReflectApply,\n  construct: ReflectConstruct,\n  defineProperty: ReflectDefineProperty,\n  get: ReflectGet,\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n  getPrototypeOf: ReflectGetPrototypeOf,\n  has: ReflectHas,\n  ownKeys: ReflectOwnKeys,\n  set: ReflectSet,\n  setPrototypeOf: ReflectSetPrototypeOf,\n} = Reflect;\n\n// Proxy\nexport const NativeProxy = Proxy;\n\n// Number\nexport const {\n  EPSILON,\n  MAX_SAFE_INTEGER,\n  isFinite: NumberIsFinite,\n  isNaN: NumberIsNaN,\n} = Number;\n\n// Symbol\nexport const {\n  iterator: SymbolIterator,\n  species: SymbolSpecies,\n  toStringTag: SymbolToStringTag,\n  for: SymbolFor,\n} = Symbol;\n\n// Object\nexport const NativeObject = Object;\nexport const {\n  create: ObjectCreate,\n  defineProperty: ObjectDefineProperty,\n  freeze: ObjectFreeze,\n  is: ObjectIs,\n} = NativeObject;\nconst ObjectPrototype = NativeObject.prototype;\n/** @type {(object: object, key: PropertyKey) => Function | undefined} */\nexport const ObjectPrototype__lookupGetter__ = /** @type {any} */ (ObjectPrototype).__lookupGetter__\n  ? uncurryThis(/** @type {any} */ (ObjectPrototype).__lookupGetter__)\n  : (object, key) => {\n    if (object == null) {\n      throw NativeTypeError(\n        CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n      );\n    }\n\n    let target = NativeObject(object);\n    do {\n      const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n      if (descriptor !== undefined) {\n        if (ObjectHasOwn(descriptor, \"get\")) {\n          return descriptor.get;\n        }\n\n        return;\n      }\n    } while ((target = ReflectGetPrototypeOf(target)) !== null);\n  };\n/** @type {(object: object, key: PropertyKey) => boolean} */\nexport const ObjectHasOwn = /** @type {any} */ (NativeObject).hasOwn ||\n  uncurryThis(ObjectPrototype.hasOwnProperty);\n\n// Array\nconst NativeArray = Array;\nexport const ArrayIsArray = NativeArray.isArray;\nconst ArrayPrototype = NativeArray.prototype;\n/** @type {(array: ArrayLike<unknown>, separator?: string) => string} */\nexport const ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);\n/** @type {<T>(array: T[], ...items: T[]) => number} */\nexport const ArrayPrototypePush = uncurryThis(ArrayPrototype.push);\n/** @type {(array: ArrayLike<unknown>, ...opts: any[]) => string} */\nexport const ArrayPrototypeToLocaleString = uncurryThis(\n  ArrayPrototype.toLocaleString\n);\nexport const NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];\n/** @type {<T>(array: T[]) => IterableIterator<T>} */\nexport const ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);\n\n// Math\nexport const {\n  abs: MathAbs,\n  trunc: MathTrunc,\n} = Math;\n\n// ArrayBuffer\nexport const NativeArrayBuffer = ArrayBuffer;\nexport const ArrayBufferIsView = NativeArrayBuffer.isView;\nconst ArrayBufferPrototype = NativeArrayBuffer.prototype;\n/** @type {(buffer: ArrayBuffer, begin?: number, end?: number) => number} */\nexport const ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);\n/** @type {(buffer: ArrayBuffer) => ArrayBuffer} */\nexport const ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, \"byteLength\");\n\n// SharedArrayBuffer\nexport const NativeSharedArrayBuffer = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : null;\n/** @type {(buffer: SharedArrayBuffer) => SharedArrayBuffer} */\nexport const SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer\n  && uncurryThisGetter(NativeSharedArrayBuffer.prototype, \"byteLength\");\n\n// TypedArray\n/** @typedef {Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|Int8Array|Int16Array|Int32Array|Float32Array|Float64Array|BigUint64Array|BigInt64Array} TypedArray */\n/** @type {any} */\nexport const TypedArray = ReflectGetPrototypeOf(Uint8Array);\nconst TypedArrayFrom = TypedArray.from;\nexport const TypedArrayPrototype = TypedArray.prototype;\nexport const NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nexport const TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nexport const TypedArrayPrototypeValues = uncurryThis(\n  TypedArrayPrototype.values\n);\n/** @type {(typedArray: TypedArray) => IterableIterator<[number, number]>} */\nexport const TypedArrayPrototypeEntries = uncurryThis(\n  TypedArrayPrototype.entries\n);\n/** @type {(typedArray: TypedArray, array: ArrayLike<number>, offset?: number) => void} */\nexport const TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);\n/** @type {<T extends TypedArray>(typedArray: T) => T} */\nexport const TypedArrayPrototypeReverse = uncurryThis(\n  TypedArrayPrototype.reverse\n);\n/** @type {<T extends TypedArray>(typedArray: T, value: number, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);\n/** @type {<T extends TypedArray>(typedArray: T, target: number, start: number, end?: number) => T} */\nexport const TypedArrayPrototypeCopyWithin = uncurryThis(\n  TypedArrayPrototype.copyWithin\n);\n/** @type {<T extends TypedArray>(typedArray: T, compareFn?: (a: number, b: number) => number) => T} */\nexport const TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeSubarray = uncurryThis(\n  TypedArrayPrototype.subarray\n);\n/** @type {((typedArray: TypedArray) => ArrayBuffer)} */\nexport const TypedArrayPrototypeGetBuffer = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"buffer\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nexport const TypedArrayPrototypeGetByteOffset = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"byteOffset\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nexport const TypedArrayPrototypeGetLength = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"length\"\n);\n/** @type {(target: unknown) => string} */\nexport const TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(\n  TypedArrayPrototype,\n  SymbolToStringTag\n);\n\n// Uint8Array\nexport const NativeUint8Array = Uint8Array;\n\n// Uint16Array\nexport const NativeUint16Array = Uint16Array;\n/** @type {Uint16ArrayConstructor[\"from\"]} */\nexport const Uint16ArrayFrom = (...args) => {\n  return ReflectApply(TypedArrayFrom, NativeUint16Array, args);\n};\n\n// Uint32Array\nexport const NativeUint32Array = Uint32Array;\n\n// Float32Array\nexport const NativeFloat32Array = Float32Array;\n\n// ArrayIterator\n/** @type {any} */\nexport const ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());\n/** @type {<T>(arrayIterator: IterableIterator<T>) => IteratorResult<T>} */\nexport const ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);\n\n// Generator\n/** @type {<T = unknown, TReturn = any, TNext = unknown>(generator: Generator<T, TReturn, TNext>, value?: TNext) => T} */\nexport const GeneratorPrototypeNext = uncurryThis((function* () {})().next);\n\n// Iterator\nexport const IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);\n\n// DataView\nconst DataViewPrototype = DataView.prototype;\n/** @type {(dataView: DataView, byteOffset: number, littleEndian?: boolean) => number} */\nexport const DataViewPrototypeGetUint16 = uncurryThis(\n  DataViewPrototype.getUint16\n);\n/** @type {(dataView: DataView, byteOffset: number, value: number, littleEndian?: boolean) => void} */\nexport const DataViewPrototypeSetUint16 = uncurryThis(\n  DataViewPrototype.setUint16\n);\n\n// Error\nexport const NativeTypeError = TypeError;\nexport const NativeRangeError = RangeError;\n\n// WeakSet\n/**\n * Do not construct with arguments to avoid calling the \"add\" method\n * @type {{new <T extends {}>(): WeakSet<T>}}\n */\nexport const NativeWeakSet = WeakSet;\nconst WeakSetPrototype = NativeWeakSet.prototype;\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => Set<T>} */\nexport const WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => boolean} */\nexport const WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);\n\n// WeakMap\n/**\n * Do not construct with arguments to avoid calling the \"set\" method\n * @type {{new <K extends {}, V>(): WeakMap<K, V>}}\n */\nexport const NativeWeakMap = WeakMap;\nconst WeakMapPrototype = NativeWeakMap.prototype;\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => V} */\nexport const WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => boolean} */\nexport const WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K, value: V) => WeakMap} */\nexport const WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);\n","import {\n  ArrayIteratorPrototype,\n  ArrayIteratorPrototypeNext,\n  ArrayPrototypeSymbolIterator,\n  GeneratorPrototypeNext,\n  IteratorPrototype,\n  NativeArrayPrototypeSymbolIterator,\n  NativeWeakMap,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ReflectGetOwnPropertyDescriptor,\n  ReflectOwnKeys,\n  SymbolIterator,\n  WeakMapPrototypeGet,\n  WeakMapPrototypeSet,\n} from \"./primordials.mjs\";\n\n/** @type {WeakMap<{}, IterableIterator<any>>} */\nconst arrayIterators = new NativeWeakMap();\n\nconst SafeIteratorPrototype = ObjectCreate(null, {\n  next: {\n    value: function next() {\n      const arrayIterator = WeakMapPrototypeGet(arrayIterators, this);\n      return ArrayIteratorPrototypeNext(arrayIterator);\n    },\n  },\n\n  [SymbolIterator]: {\n    value: function values() {\n      return this;\n    },\n  },\n});\n\n/**\n * Wrap the Array around the SafeIterator If Array.prototype [@@iterator] has been modified\n * @type {<T>(array: T[]) => Iterable<T>}\n */\nexport function safeIfNeeded(array) {\n  if (\n    array[SymbolIterator] === NativeArrayPrototypeSymbolIterator &&\n    ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext\n  ) {\n    return array;\n  }\n\n  const safe = ObjectCreate(SafeIteratorPrototype);\n  WeakMapPrototypeSet(arrayIterators, safe, ArrayPrototypeSymbolIterator(array));\n  return safe;\n}\n\n/** @type {WeakMap<{}, Generator<any>>} */\nconst generators = new NativeWeakMap();\n\n/** @see https://tc39.es/ecma262/#sec-%arrayiteratorprototype%-object */\nconst DummyArrayIteratorPrototype = ObjectCreate(IteratorPrototype, {\n  next: {\n    value: function next() {\n      const generator = WeakMapPrototypeGet(generators, this);\n      return GeneratorPrototypeNext(generator);\n    },\n    writable: true,\n    configurable: true,\n  },\n});\n\nfor (const key of ReflectOwnKeys(ArrayIteratorPrototype)) {\n  // next method has already defined\n  if (key === \"next\") {\n    continue;\n  }\n\n  // Copy ArrayIteratorPrototype descriptors to DummyArrayIteratorPrototype\n  ObjectDefineProperty(DummyArrayIteratorPrototype, key, ReflectGetOwnPropertyDescriptor(ArrayIteratorPrototype, key));\n}\n\n/**\n * Wrap the Generator around the dummy ArrayIterator\n * @type {<T>(generator: Generator<T>) => IterableIterator<T>}\n */\nexport function wrap(generator) {\n  const dummy = ObjectCreate(DummyArrayIteratorPrototype);\n  WeakMapPrototypeSet(generators, dummy, generator);\n  return dummy;\n}\n","import {\n  EPSILON,\n  MathAbs,\n  NativeArrayBuffer,\n  NativeFloat32Array,\n  NativeUint16Array,\n  NativeUint32Array,\n  NativeUint8Array,\n  NumberIsFinite,\n  NumberIsNaN,\n} from \"./primordials.mjs\";\n\nconst INVERSE_OF_EPSILON = 1 / EPSILON;\n\n/**\n * rounds to the nearest value;\n * if the number falls midway, it is rounded to the nearest value with an even least significant digit\n * @param {number} num\n * @returns {number}\n */\nfunction roundTiesToEven(num) {\n  return (num + INVERSE_OF_EPSILON) - INVERSE_OF_EPSILON;\n}\n\nconst FLOAT16_MIN_VALUE = 6.103515625e-05;\nconst FLOAT16_MAX_VALUE = 65504;\nconst FLOAT16_EPSILON = 0.0009765625;\n\nconst FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE = FLOAT16_EPSILON * FLOAT16_MIN_VALUE;\nconst FLOAT16_EPSILON_DEVIDED_BY_EPSILON = FLOAT16_EPSILON * INVERSE_OF_EPSILON;\n\n/**\n * round a number to a half float number\n * @param {unknown} num - double float\n * @returns {number} half float number\n */\nexport function roundToFloat16(num) {\n  const number = +num;\n\n  // NaN, Infinity, -Infinity, 0, -0\n  if (!NumberIsFinite(number) || number === 0) {\n    return number;\n  }\n\n  // finite except 0, -0\n  const sign = number > 0 ? 1 : -1;\n  const absolute = MathAbs(number);\n\n  // small number\n  if (absolute < FLOAT16_MIN_VALUE) {\n    return sign * roundTiesToEven(absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE) * FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE;\n  }\n\n  const temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute;\n  const result = temp - (temp - absolute);\n\n  // large number\n  if (result > FLOAT16_MAX_VALUE || NumberIsNaN(result)) {\n    return sign * Infinity;\n  }\n\n  return sign * result;\n}\n\n// base algorithm: http://fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst buffer = new NativeArrayBuffer(4);\nconst floatView = new NativeFloat32Array(buffer);\nconst uint32View = new NativeUint32Array(buffer);\n\nconst baseTable = new NativeUint16Array(512);\nconst shiftTable = new NativeUint8Array(512);\n\nfor (let i = 0; i < 256; ++i) {\n  const e = i - 127;\n\n  // very small number (0, -0)\n  if (e < -24) {\n    baseTable[i]         = 0x0000;\n    baseTable[i | 0x100] = 0x8000;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // small number (denorm)\n  } else if (e < -14) {\n    baseTable[i]         =  0x0400 >> (-e - 14);\n    baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n    shiftTable[i]         = -e - 1;\n    shiftTable[i | 0x100] = -e - 1;\n\n  // normal number\n  } else if (e <= 15) {\n    baseTable[i]         =  (e + 15) << 10;\n    baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n\n  // large number (Infinity, -Infinity)\n  } else if (e < 128) {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // stay (NaN, Infinity, -Infinity)\n  } else {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n  }\n}\n\n/**\n * round a number to a half float number bits\n * @param {unknown} num - double float\n * @returns {number} half float number bits\n */\nexport function roundToFloat16Bits(num) {\n  floatView[0] = roundToFloat16(num);\n  const f = uint32View[0];\n  const e = (f >> 23) & 0x1ff;\n  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n}\n\nconst mantissaTable = new NativeUint32Array(2048);\nfor (let i = 1; i < 1024; ++i) {\n  let m = i << 13; // zero pad mantissa bits\n  let e = 0; // zero exponent\n\n  // normalized\n  while ((m & 0x00800000) === 0) {\n    m <<= 1;\n    e -= 0x00800000; // decrement exponent\n  }\n\n  m &= ~0x00800000; // clear leading 1 bit\n  e += 0x38800000; // adjust bias\n\n  mantissaTable[i] = m | e;\n}\nfor (let i = 1024; i < 2048; ++i) {\n  mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n}\n\nconst exponentTable = new NativeUint32Array(64);\nfor (let i = 1; i < 31; ++i) {\n  exponentTable[i] = i << 23;\n}\nexponentTable[31] = 0x47800000;\nexponentTable[32] = 0x80000000;\nfor (let i = 33; i < 63; ++i) {\n  exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n}\nexponentTable[63] = 0xc7800000;\n\nconst offsetTable = new NativeUint16Array(64);\nfor (let i = 1; i < 64; ++i) {\n  if (i !== 32) {\n    offsetTable[i] = 1024;\n  }\n}\n\n/**\n * convert a half float number bits to a number\n * @param {number} float16bits - half float number bits\n * @returns {number} double float\n */\nexport function convertToNumber(float16bits) {\n  const i = float16bits >> 10;\n  uint32View[0] = mantissaTable[offsetTable[i] + (float16bits & 0x3ff)] + exponentTable[i];\n  return floatView[0];\n}\n","import { safeIfNeeded } from \"./_util/arrayIterator.mjs\";\nimport { convertToNumber, roundToFloat16Bits } from \"./_util/converter.mjs\";\nimport {\n  DataViewPrototypeGetUint16,\n  DataViewPrototypeSetUint16,\n} from \"./_util/primordials.mjs\";\n\n/**\n * returns an unsigned 16-bit float at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {[boolean]} opts\n * @returns {number}\n */\nexport function getFloat16(dataView, byteOffset, ...opts) {\n  return convertToNumber(\n    DataViewPrototypeGetUint16(dataView, byteOffset, ...safeIfNeeded(opts))\n  );\n}\n\n/**\n * stores an unsigned 16-bit float value at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {number} value\n * @param {[boolean]} opts\n */\nexport function setFloat16(dataView, byteOffset, value, ...opts) {\n  return DataViewPrototypeSetUint16(\n    dataView,\n    byteOffset,\n    roundToFloat16Bits(value),\n    ...safeIfNeeded(opts)\n  );\n}\n","export function fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nexport function fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nexport function fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nexport function fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n","/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n","/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      if (modelTransformation[1] === 0 && modelTransformation[4] === 0) {\n        return [\n          modelTransformation[0],\n          -modelTransformation[5],\n          modelTransformation[10],\n        ];\n      }\n      return [\n        Math.sqrt((modelTransformation[0] * modelTransformation[0])\n          + (modelTransformation[4] * modelTransformation[4])),\n        -Math.sqrt((modelTransformation[1] * modelTransformation[1])\n          + (modelTransformation[5] * modelTransformation[5])),\n        modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid\n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n\n      const corners = [\n        [0, 0],\n        [0, height],\n        [width, 0],\n        [width, height],\n      ];\n\n      const projected = corners.map(([I, J]) => [\n        d + (a * I) + (b * J),\n        h + (e * I) + (f * J),\n      ]);\n\n      const xs = projected.map((pt) => pt[0]);\n      const ys = projected.map((pt) => pt[1]);\n\n      return [\n        Math.min(...xs),\n        Math.min(...ys),\n        Math.max(...xs),\n        Math.max(...ys),\n      ];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n\n      const x1 = origin[0];\n      const y1 = origin[1];\n\n      const x2 = x1 + (resolution[0] * width);\n      const y2 = y1 + (resolution[1] * height);\n\n      return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n      ];\n    }\n  }\n}\n\nexport default GeoTIFFImage;\n","import { getFloat16 } from '@petamoriken/float16';\n\nexport default class DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return getFloat16(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n","export default class DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n","const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n","/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nexport class BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n","export default class QuickLRU extends Map {\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tif (typeof options.maxAge === 'number' && options.maxAge === 0) {\n\t\t\tthrow new TypeError('`maxAge` must be a number greater than 0');\n\t\t}\n\n\t\t// TODO: Use private class fields when ESLint supports them.\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.maxAge = options.maxAge || Number.POSITIVE_INFINITY;\n\t\tthis.onEviction = options.onEviction;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t// TODO: Use private class methods when targeting Node.js 16.\n\t_emitEvictions(cache) {\n\t\tif (typeof this.onEviction !== 'function') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [key, item] of cache) {\n\t\t\tthis.onEviction(key, item.value);\n\t\t}\n\t}\n\n\t_deleteIfExpired(key, item) {\n\t\tif (typeof item.expiry === 'number' && item.expiry <= Date.now()) {\n\t\t\tif (typeof this.onEviction === 'function') {\n\t\t\t\tthis.onEviction(key, item.value);\n\t\t\t}\n\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_getOrDeleteIfExpired(key, item) {\n\t\tconst deleted = this._deleteIfExpired(key, item);\n\t\tif (deleted === false) {\n\t\t\treturn item.value;\n\t\t}\n\t}\n\n\t_getItemValue(key, item) {\n\t\treturn item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;\n\t}\n\n\t_peek(key, cache) {\n\t\tconst item = cache.get(key);\n\n\t\treturn this._getItemValue(key, item);\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis._emitEvictions(this.oldCache);\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\t_moveToRecent(key, item) {\n\t\tthis.oldCache.delete(key);\n\t\tthis._set(key, item);\n\t}\n\n\t* _entriesAscending() {\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\tconst item = this.cache.get(key);\n\n\t\t\treturn this._getItemValue(key, item);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst item = this.oldCache.get(key);\n\t\t\tif (this._deleteIfExpired(key, item) === false) {\n\t\t\t\tthis._moveToRecent(key, item);\n\t\t\t\treturn item.value;\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key, value, {maxAge = this.maxAge} = {}) {\n\t\tconst expiry =\n\t\t\ttypeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ?\n\t\t\t\tDate.now() + maxAge :\n\t\t\t\tundefined;\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, {\n\t\t\t\tvalue,\n\t\t\t\texpiry\n\t\t\t});\n\t\t} else {\n\t\t\tthis._set(key, {value, expiry});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.cache.get(key));\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.oldCache.get(key));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this._peek(key, this.cache);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this._peek(key, this.oldCache);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\tresize(newSize) {\n\t\tif (!(newSize && newSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tconst items = [...this._entriesAscending()];\n\t\tconst removeCount = items.length - newSize;\n\t\tif (removeCount < 0) {\n\t\t\tthis.cache = new Map(items);\n\t\t\tthis.oldCache = new Map();\n\t\t\tthis._size = items.length;\n\t\t} else {\n\t\t\tif (removeCount > 0) {\n\t\t\t\tthis._emitEvictions(items.slice(0, removeCount));\n\t\t\t}\n\n\t\t\tthis.oldCache = new Map(items.slice(removeCount));\n\t\t\tthis.cache = new Map();\n\t\t\tthis._size = 0;\n\t\t}\n\n\t\tthis.maxSize = newSize;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesDescending() {\n\t\tlet items = [...this.cache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\titems = [...this.oldCache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesAscending() {\n\t\tfor (const [key, value] of this._entriesAscending()) {\n\t\t\tyield [key, value.value];\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (!this._size) {\n\t\t\treturn this.oldCache.size;\n\t\t}\n\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(this._size + oldCacheSize, this.maxSize);\n\t}\n\n\tentries() {\n\t\treturn this.entriesAscending();\n\t}\n\n\tforEach(callbackFunction, thisArgument = this) {\n\t\tfor (const [key, value] of this.entriesAscending()) {\n\t\t\tcallbackFunction.call(thisArgument, value, key, this);\n\t\t}\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn JSON.stringify([...this.entriesAscending()]);\n\t}\n}\n","export function assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nexport function chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nexport function endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nexport function forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nexport function invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nexport function range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nexport function times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nexport function toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nexport function toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nexport function parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nexport async function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nexport function zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nexport class CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nexport const AggregateError = CustomAggregateError;\n","import QuickLRU from 'quick-lru';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new QuickLRU({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n","export class BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nexport class BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<BaseResponse>}\n   */\n  async request({ headers, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\n\nclass FetchResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nexport class FetchClient extends BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  /**\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<FetchResponse>}\n   */\n  async request({ headers, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials: this.credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass XHRResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nexport class XHRClient extends BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, { blockSize, cacheSize });\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n","import { BaseSource } from './basesource.js';\n\nclass FileReaderSource extends BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nexport function makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n","/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\n\nimport { makeRemoteSource, makeCustomSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\nimport { BaseClient, BaseResponse } from './source/client/base.js';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\n\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource(makeCustomSource(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\nexport { GeoTIFFImage };\nexport { BaseClient, BaseResponse };\n","/**\n * @module ol/source/GeoTIFF\n */\nimport {\n  Pool,\n  fromBlob as tiffFromBlob,\n  fromUrl as tiffFromUrl,\n  fromUrls as tiffFromUrls,\n  globals as geotiffGlobals,\n} from 'geotiff';\nimport {error as logError} from '../console.js';\nimport {applyTransform, getCenter, getIntersection} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {fromCode as unitsFromCode} from '../proj/Units.js';\nimport {\n  Projection,\n  createTransformFromCoordinateTransform,\n  get as getCachedProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport {\n  apply as applyMatrix,\n  create as createMatrix,\n  makeInverse,\n  multiply as multiplyTransform,\n} from '../transform.js';\nimport DataTile from './DataTile.js';\n\n/**\n * Determine if an image type is a mask.\n * See https://www.awaresystems.be/imaging/tiff/tifftags/newsubfiletype.html\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} The image is a mask.\n */\nfunction isMask(image) {\n  const fileDirectory = image.fileDirectory;\n  const type = fileDirectory.NewSubfileType || 0;\n  return (type & 4) === 4;\n}\n\n/**\n * @param {true|false|'auto'} preference The convertToRGB option.\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} Use the `image.readRGB()` method.\n */\nfunction readRGB(preference, image) {\n  if (!preference) {\n    return false;\n  }\n  if (preference === true) {\n    return true;\n  }\n  if (image.getSamplesPerPixel() !== 3) {\n    return false;\n  }\n  const interpretation = image.fileDirectory.PhotometricInterpretation;\n  const interpretations = geotiffGlobals.photometricInterpretations;\n  return (\n    interpretation === interpretations.CMYK ||\n    interpretation === interpretations.YCbCr ||\n    interpretation === interpretations.CIELab ||\n    interpretation === interpretations.ICCLab\n  );\n}\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} [url] URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.\n * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\n */\n\n/**\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\n */\n\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\n\nconst STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nconst STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\n\nconst defaultTileSize = 256;\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\n */\n\nlet workerPool;\nfunction getWorkerPool() {\n  if (!workerPool) {\n    workerPool = new Pool();\n  }\n  return workerPool;\n}\n\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\nfunction getBoundingBox(image) {\n  try {\n    return image.getBoundingBox(true);\n  } catch {\n    return [0, 0, image.getWidth(), image.getHeight()];\n  }\n}\n\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\nfunction getOrigin(image) {\n  try {\n    return image.getOrigin().slice(0, 2);\n  } catch {\n    return [0, image.getHeight()];\n  }\n}\n\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {Array<number>} The map x and y units per pixel.\n */\nfunction getResolutions(image, referenceImage) {\n  try {\n    return image.getResolution(referenceImage);\n  } catch {\n    return [\n      referenceImage.getWidth() / image.getWidth(),\n      referenceImage.getHeight() / image.getHeight(),\n    ];\n  }\n}\n\n/**\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @return {import(\"../proj/Projection.js\").default} The image projection.\n */\nfunction getProjection(image) {\n  const geoKeys = image.geoKeys;\n  if (!geoKeys) {\n    return null;\n  }\n\n  if (\n    geoKeys.ProjectedCSTypeGeoKey &&\n    geoKeys.ProjectedCSTypeGeoKey !== 32767\n  ) {\n    const code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units,\n        });\n      }\n    }\n    return projection;\n  }\n\n  if (geoKeys.GeographicTypeGeoKey && geoKeys.GeographicTypeGeoKey !== 32767) {\n    const code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units,\n        });\n      }\n    }\n    return projection;\n  }\n\n  return null;\n}\n\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForTIFF(tiff) {\n  return tiff.getImageCount().then(function (count) {\n    const requests = new Array(count);\n    for (let i = 0; i < count; ++i) {\n      requests[i] = tiff.getImage(i);\n    }\n    return Promise.all(requests);\n  });\n}\n\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @param {Object} options Options for the GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForSource(source, options) {\n  let request;\n  if (source.blob) {\n    request = tiffFromBlob(source.blob);\n  } else if (source.overviews) {\n    request = tiffFromUrls(source.url, source.overviews, options);\n  } else {\n    request = tiffFromUrl(source.url, options);\n  }\n  return request.then(getImagesForTIFF);\n}\n\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n  if (Array.isArray(expected)) {\n    const length = expected.length;\n    if (!Array.isArray(got) || length != got.length) {\n      const error = new Error(message);\n      rejector(error);\n      throw error;\n    }\n    for (let i = 0; i < length; ++i) {\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\n    }\n    return;\n  }\n\n  got = /** @type {number} */ (got);\n  if (Math.abs(expected - got) > tolerance * expected) {\n    throw new Error(message);\n  }\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\nfunction getMinForDataType(array) {\n  if (array instanceof Int8Array) {\n    return -128;\n  }\n  if (array instanceof Int16Array) {\n    return -32768;\n  }\n  if (array instanceof Int32Array) {\n    return -2147483648;\n  }\n  if (array instanceof Float32Array) {\n    return 1.2e-38;\n  }\n  return 0;\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\nfunction getMaxForDataType(array) {\n  if (array instanceof Int8Array) {\n    return 127;\n  }\n  if (array instanceof Uint8Array) {\n    return 255;\n  }\n  if (array instanceof Uint8ClampedArray) {\n    return 255;\n  }\n  if (array instanceof Int16Array) {\n    return 32767;\n  }\n  if (array instanceof Uint16Array) {\n    return 65535;\n  }\n  if (array instanceof Int32Array) {\n    return 2147483647;\n  }\n  if (array instanceof Uint32Array) {\n    return 4294967295;\n  }\n  if (array instanceof Float32Array) {\n    return 3.4e38;\n  }\n  return 255;\n}\n\n/**\n * @typedef {Object} GeoTIFFSourceOptions\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\n * @property {string} [credentials] How credentials shall be handled. See\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\n * By default only a single range is used.\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\n * requested. Only use this when you know the source image to be small enough to fit in memory.\n * @property {number} [blockSize=65536] The block size to use.\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\n * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,\n * CIELab, and ICCLab images will automatically be converted to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Source projection.  If not provided, the GeoTIFF metadata\n * will be read for projection information.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * **Note for users of the full build**: The `GeoTIFF` source requires the\n * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.\n *\n * @api\n */\nclass GeoTIFFSource extends DataTile {\n  /**\n   * @param {Options} options Data tile options.\n   */\n  constructor(options) {\n    super({\n      state: 'loading',\n      tileGrid: null,\n      projection: options.projection || null,\n      transition: options.transition,\n      interpolate: options.interpolate !== false,\n      wrapX: options.wrapX,\n    });\n\n    /**\n     * @type {Array<SourceInfo>}\n     * @private\n     */\n    this.sourceInfo_ = options.sources;\n\n    const numSources = this.sourceInfo_.length;\n\n    /**\n     * @type {Object}\n     * @private\n     */\n    this.sourceOptions_ = options.sourceOptions;\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    this.sourceImagery_ = new Array(numSources);\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    this.sourceMasks_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.resolutionFactors_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.samplesPerPixel_;\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.nodataValues_;\n\n    /**\n     * @type {Array<Array<GDALMetadata>>}\n     * @private\n     */\n    this.metadata_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.normalize_ = options.normalize !== false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.addAlpha_ = false;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {true|false|'auto'}\n     * @private\n     */\n    this.convertToRGB_ = options.convertToRGB || false;\n\n    this.setKey(this.sourceInfo_.map((source) => source.url).join(','));\n\n    const self = this;\n    const requests = new Array(numSources);\n    for (let i = 0; i < numSources; ++i) {\n      requests[i] = getImagesForSource(\n        this.sourceInfo_[i],\n        this.sourceOptions_,\n      );\n    }\n    Promise.all(requests)\n      .then(function (sources) {\n        self.configure_(sources);\n      })\n      .catch(function (error) {\n        logError(error);\n        self.error_ = error;\n        self.setState('error');\n      });\n  }\n\n  /**\n   * @return {Error} A source loading error. When the source state is `error`, use this function\n   * to get more information about the error. To debug a faulty configuration, you may want to use\n   * a listener like\n   * ```js\n   * geotiffSource.on('change', () => {\n   *   if (geotiffSource.getState() === 'error') {\n   *     console.error(geotiffSource.getError());\n   *   }\n   * });\n   * ```\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Determine the projection of the images in this GeoTIFF.\n   * The default implementation looks at the ProjectedCSTypeGeoKey and the GeographicTypeGeoKey\n   * of each image in turn.\n   * You can override this method in a subclass to support more projections.\n   *\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   */\n  determineProjection(sources) {\n    const firstSource = sources[0];\n    for (let i = firstSource.length - 1; i >= 0; --i) {\n      const image = firstSource[i];\n      const projection = getProjection(image);\n      if (projection) {\n        this.projection = projection;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Determine any transform matrix for the images in this GeoTIFF.\n   *\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   */\n  determineTransformMatrix(sources) {\n    const firstSource = sources[0];\n    for (let i = firstSource.length - 1; i >= 0; --i) {\n      const image = firstSource[i];\n      const modelTransformation = image.fileDirectory.ModelTransformation;\n      if (modelTransformation) {\n        // eslint-disable-next-line no-unused-vars\n        const [a, b, c, d, e, f, g, h] = modelTransformation;\n        const matrix = multiplyTransform(\n          multiplyTransform(\n            [\n              1 / Math.sqrt(a * a + e * e),\n              0,\n              0,\n              -1 / Math.sqrt(b * b + f * f),\n              d,\n              h,\n            ],\n            [a, e, b, f, 0, 0],\n          ),\n          [1, 0, 0, 1, -d, -h],\n        );\n        this.transformMatrix = matrix;\n        this.addAlpha_ = true;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n   * must have the same internal tiled structure.\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   * @private\n   */\n  configure_(sources) {\n    let extent;\n    let origin;\n    let commonRenderTileSizes;\n    let commonSourceTileSizes;\n    let resolutions;\n    const samplesPerPixel = new Array(sources.length);\n    const nodataValues = new Array(sources.length);\n    const metadata = new Array(sources.length);\n    let minZoom = 0;\n\n    const sourceCount = sources.length;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const images = [];\n      const masks = [];\n      sources[sourceIndex].forEach((item) => {\n        if (isMask(item)) {\n          masks.push(item);\n        } else {\n          images.push(item);\n        }\n      });\n\n      const imageCount = images.length;\n      if (masks.length > 0 && masks.length !== imageCount) {\n        throw new Error(\n          `Expected one mask per image found ${masks.length} masks and ${imageCount} images`,\n        );\n      }\n\n      let sourceExtent;\n      let sourceOrigin;\n      const sourceTileSizes = new Array(imageCount);\n      const renderTileSizes = new Array(imageCount);\n      const sourceResolutions = new Array(imageCount);\n\n      nodataValues[sourceIndex] = new Array(imageCount);\n      metadata[sourceIndex] = new Array(imageCount);\n\n      for (let imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\n        const image = images[imageIndex];\n        const nodataValue = image.getGDALNoData();\n        metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\n        nodataValues[sourceIndex][imageIndex] = nodataValue;\n\n        const wantedSamples = this.sourceInfo_[sourceIndex].bands;\n        samplesPerPixel[sourceIndex] = wantedSamples\n          ? wantedSamples.length\n          : image.getSamplesPerPixel();\n        const level = imageCount - (imageIndex + 1);\n\n        if (!sourceExtent) {\n          sourceExtent = getBoundingBox(image);\n        }\n\n        if (!sourceOrigin) {\n          sourceOrigin = getOrigin(image);\n        }\n\n        const imageResolutions = getResolutions(image, images[0]);\n        sourceResolutions[level] = imageResolutions[0];\n\n        const sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\n\n        // request larger blocks for untiled layouts\n        if (\n          sourceTileSize[0] !== sourceTileSize[1] &&\n          sourceTileSize[1] < defaultTileSize\n        ) {\n          sourceTileSize[0] = defaultTileSize;\n          sourceTileSize[1] = defaultTileSize;\n        }\n\n        sourceTileSizes[level] = sourceTileSize;\n\n        const aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\n        renderTileSizes[level] = [\n          sourceTileSize[0],\n          sourceTileSize[1] / aspectRatio,\n        ];\n      }\n\n      if (!extent) {\n        extent = sourceExtent;\n      } else {\n        getIntersection(extent, sourceExtent, extent);\n      }\n\n      if (!origin) {\n        origin = sourceOrigin;\n      } else {\n        const message = `Origin mismatch for source ${sourceIndex}, got [${sourceOrigin}] but expected [${origin}]`;\n        assertEqual(origin, sourceOrigin, 0, message, this.viewRejector);\n      }\n\n      if (!resolutions) {\n        resolutions = sourceResolutions;\n        this.resolutionFactors_[sourceIndex] = 1;\n      } else {\n        if (resolutions.length - minZoom > sourceResolutions.length) {\n          minZoom = resolutions.length - sourceResolutions.length;\n        }\n        const resolutionFactor =\n          resolutions[resolutions.length - 1] /\n          sourceResolutions[sourceResolutions.length - 1];\n        this.resolutionFactors_[sourceIndex] = resolutionFactor;\n        const scaledSourceResolutions = sourceResolutions.map(\n          (resolution) => (resolution *= resolutionFactor),\n        );\n        const message = `Resolution mismatch for source ${sourceIndex}, got [${scaledSourceResolutions}] but expected [${resolutions}]`;\n        assertEqual(\n          resolutions.slice(minZoom, resolutions.length),\n          scaledSourceResolutions,\n          0.02,\n          message,\n          this.viewRejector,\n        );\n      }\n\n      if (!commonRenderTileSizes) {\n        commonRenderTileSizes = renderTileSizes;\n      } else {\n        assertEqual(\n          commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length),\n          renderTileSizes,\n          0.01,\n          `Tile size mismatch for source ${sourceIndex}`,\n          this.viewRejector,\n        );\n      }\n\n      if (!commonSourceTileSizes) {\n        commonSourceTileSizes = sourceTileSizes;\n      } else {\n        assertEqual(\n          commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length),\n          sourceTileSizes,\n          0,\n          `Tile size mismatch for source ${sourceIndex}`,\n          this.viewRejector,\n        );\n      }\n\n      this.sourceImagery_[sourceIndex] = images.reverse();\n      this.sourceMasks_[sourceIndex] = masks.reverse();\n    }\n\n    for (let i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n      const sourceImagery = this.sourceImagery_[i];\n      while (sourceImagery.length < resolutions.length) {\n        sourceImagery.unshift(undefined);\n      }\n    }\n\n    if (!this.getProjection()) {\n      this.determineProjection(sources);\n    }\n    this.determineTransformMatrix(sources);\n\n    this.samplesPerPixel_ = samplesPerPixel;\n    this.nodataValues_ = nodataValues;\n    this.metadata_ = metadata;\n\n    // decide if we need to add an alpha band to handle nodata\n    outer: for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      // option 1: source is configured with a nodata value\n      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\n        this.addAlpha_ = true;\n        break;\n      }\n      if (this.sourceMasks_[sourceIndex].length) {\n        this.addAlpha_ = true;\n        break;\n      }\n\n      const values = nodataValues[sourceIndex];\n\n      // option 2: check image metadata for limited bands\n      const bands = this.sourceInfo_[sourceIndex].bands;\n      if (bands) {\n        for (let i = 0; i < bands.length; ++i) {\n          if (values[bands[i] - 1] !== null) {\n            this.addAlpha_ = true;\n            break outer;\n          }\n        }\n        continue;\n      }\n\n      // option 3: check image metadata for all bands\n      for (let imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n        if (values[imageIndex] !== null) {\n          this.addAlpha_ = true;\n          break outer;\n        }\n      }\n    }\n\n    let bandCount = this.addAlpha_ ? 1 : 0;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      bandCount += samplesPerPixel[sourceIndex];\n    }\n    this.bandCount = bandCount;\n\n    const tileGrid = new TileGrid({\n      extent: extent,\n      minZoom: minZoom,\n      origin: origin,\n      resolutions: resolutions,\n      tileSizes: commonRenderTileSizes,\n    });\n\n    this.tileGrid = tileGrid;\n    this.setTileSizes(commonSourceTileSizes);\n\n    this.setLoader(this.loadTile_.bind(this));\n    this.setState('ready');\n\n    const zoom = 1;\n    if (resolutions.length === 2) {\n      resolutions = [resolutions[0], resolutions[1], resolutions[1] / 2];\n    } else if (resolutions.length === 1) {\n      resolutions = [resolutions[0] * 2, resolutions[0], resolutions[0] / 2];\n    }\n\n    let viewExtent = extent;\n    if (this.transformMatrix) {\n      const matrix = makeInverse(createMatrix(), this.transformMatrix.slice());\n      const transformFn = createTransformFromCoordinateTransform((input) =>\n        applyMatrix(matrix, input),\n      );\n      viewExtent = applyTransform(extent, transformFn);\n    }\n\n    this.viewResolver({\n      showFullExtent: true,\n      projection: this.projection,\n      resolutions: resolutions,\n      center: toUserCoordinate(getCenter(viewExtent), this.projection),\n      extent: toUserExtent(viewExtent, this.projection),\n      zoom: zoom,\n    });\n  }\n\n  /**\n   * @param {number} z The z tile index.\n   * @param {number} x The x tile index.\n   * @param {number} y The y tile index.\n   * @param {import('./DataTile.js').LoaderOptions} options The loader options.\n   * @return {Promise} The composed tile data.\n   * @private\n   */\n  loadTile_(z, x, y, options) {\n    const sourceTileSize = this.getTileSize(z);\n    const sourceCount = this.sourceImagery_.length;\n    const requests = new Array(sourceCount * 2);\n    const nodataValues = this.nodataValues_;\n    const sourceInfo = this.sourceInfo_;\n    const pool = getWorkerPool();\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const source = sourceInfo[sourceIndex];\n      const resolutionFactor = this.resolutionFactors_[sourceIndex];\n      const pixelBounds = [\n        Math.round(x * (sourceTileSize[0] * resolutionFactor)),\n        Math.round(y * (sourceTileSize[1] * resolutionFactor)),\n        Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)),\n        Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor)),\n      ];\n      const image = this.sourceImagery_[sourceIndex][z];\n      let samples;\n      if (source.bands) {\n        samples = source.bands.map(function (bandNumber) {\n          return bandNumber - 1;\n        });\n      }\n\n      /** @type {number|Array<number>} */\n      let fillValue;\n      if ('nodata' in source && source.nodata !== null) {\n        fillValue = source.nodata;\n      } else {\n        if (!samples) {\n          fillValue = nodataValues[sourceIndex];\n        } else {\n          fillValue = samples.map(function (sampleIndex) {\n            return nodataValues[sourceIndex][sampleIndex];\n          });\n        }\n      }\n\n      const readOptions = {\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: samples,\n        fillValue: fillValue,\n        pool: pool,\n        interleave: false,\n        signal: options.signal,\n      };\n      if (readRGB(this.convertToRGB_, image)) {\n        requests[sourceIndex] = image.readRGB(readOptions);\n      } else {\n        requests[sourceIndex] = image.readRasters(readOptions);\n      }\n\n      // requests after `sourceCount` are for mask data (if any)\n      const maskIndex = sourceCount + sourceIndex;\n      const mask = this.sourceMasks_[sourceIndex][z];\n      if (!mask) {\n        requests[maskIndex] = Promise.resolve(null);\n        continue;\n      }\n\n      requests[maskIndex] = mask.readRasters({\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: [0],\n        pool: pool,\n        interleave: false,\n      });\n    }\n\n    return Promise.all(requests)\n      .then(this.composeTile_.bind(this, sourceTileSize))\n      .catch(function (error) {\n        logError(error);\n        throw error;\n      });\n  }\n\n  /**\n   * @param {import(\"../size.js\").Size} sourceTileSize The source tile size.\n   * @param {Array} sourceSamples The source samples.\n   * @return {import(\"../DataTile.js\").Data} The composed tile data.\n   * @private\n   */\n  composeTile_(sourceTileSize, sourceSamples) {\n    const metadata = this.metadata_;\n    const sourceInfo = this.sourceInfo_;\n    const sourceCount = this.sourceImagery_.length;\n    const bandCount = this.bandCount;\n    const samplesPerPixel = this.samplesPerPixel_;\n    const nodataValues = this.nodataValues_;\n    const normalize = this.normalize_;\n    const addAlpha = this.addAlpha_;\n\n    const pixelCount = sourceTileSize[0] * sourceTileSize[1];\n    const dataLength = pixelCount * bandCount;\n\n    /** @type {Uint8Array|Float32Array} */\n    let data;\n    if (normalize) {\n      data = new Uint8Array(dataLength);\n    } else {\n      data = new Float32Array(dataLength);\n    }\n\n    let dataIndex = 0;\n    for (let pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n      let transparent = addAlpha;\n      for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n        const source = sourceInfo[sourceIndex];\n\n        let min = source.min;\n        let max = source.max;\n        let gain, bias;\n        if (normalize) {\n          const stats = metadata[sourceIndex][0];\n          if (min === undefined) {\n            if (stats && STATISTICS_MINIMUM in stats) {\n              min = parseFloat(stats[STATISTICS_MINIMUM]);\n            } else {\n              min = getMinForDataType(sourceSamples[sourceIndex][0]);\n            }\n          }\n          if (max === undefined) {\n            if (stats && STATISTICS_MAXIMUM in stats) {\n              max = parseFloat(stats[STATISTICS_MAXIMUM]);\n            } else {\n              max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n            }\n          }\n\n          gain = 255 / (max - min);\n          bias = -min * gain;\n        }\n\n        for (\n          let sampleIndex = 0;\n          sampleIndex < samplesPerPixel[sourceIndex];\n          ++sampleIndex\n        ) {\n          const sourceValue =\n            sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n\n          let value;\n          if (normalize) {\n            value = clamp(gain * sourceValue + bias, 0, 255);\n          } else {\n            value = sourceValue;\n          }\n\n          if (!addAlpha) {\n            data[dataIndex] = value;\n          } else {\n            let nodata = source.nodata;\n            if (nodata === undefined) {\n              let bandIndex;\n              if (source.bands) {\n                bandIndex = source.bands[sampleIndex] - 1;\n              } else {\n                bandIndex = sampleIndex;\n              }\n              nodata = nodataValues[sourceIndex][bandIndex];\n            }\n\n            const nodataIsNaN = isNaN(nodata);\n            if (\n              (!nodataIsNaN && sourceValue !== nodata) ||\n              (nodataIsNaN && !isNaN(sourceValue))\n            ) {\n              transparent = false;\n              data[dataIndex] = value;\n            }\n          }\n          dataIndex++;\n        }\n        if (!transparent) {\n          const maskIndex = sourceCount + sourceIndex;\n          const mask = sourceSamples[maskIndex];\n          if (mask && !mask[0][pixelIndex]) {\n            transparent = true;\n          }\n        }\n      }\n      if (addAlpha) {\n        if (!transparent) {\n          data[dataIndex] = 255;\n        }\n        dataIndex++;\n      }\n    }\n\n    return data;\n  }\n}\n\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\nGeoTIFFSource.prototype.getView;\n\nexport default GeoTIFFSource;\n","function countSubstring(string, substring) {\n  const pattern = new RegExp(substring, \"g\");\n  const match = string.match(pattern);\n  return match ? match.length : 0;\n}\n\nmodule.exports = countSubstring;\nmodule.exports.default = countSubstring;\n","function getAttribute(tag, attributeName, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) console.log(\"[xml-utils] getting \" + attributeName + \" in \" + tag);\n\n  const xml = typeof tag === \"object\" ? tag.outer : tag;\n\n  // only search for attributes in the opening tag\n  const opening = xml.slice(0, xml.indexOf(\">\") + 1);\n\n  const quotechars = ['\"', \"'\"];\n  for (let i = 0; i < quotechars.length; i++) {\n    const char = quotechars[i];\n    const pattern = attributeName + \"\\\\=\" + char + \"([^\" + char + \"]*)\" + char;\n    if (debug) console.log(\"[xml-utils] pattern:\", pattern);\n\n    const re = new RegExp(pattern);\n    const match = re.exec(opening);\n    if (debug) console.log(\"[xml-utils] match:\", match);\n    if (match) return match[1];\n  }\n}\n\nmodule.exports = getAttribute;\nmodule.exports.default = getAttribute;\n","function indexOfMatch(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index;\n  else return -1;\n}\n\nmodule.exports = indexOfMatch;\nmodule.exports.default = indexOfMatch;\n","function indexOfMatchEnd(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index + match[0].length - 1;\n  else return -1;\n}\n\nmodule.exports = indexOfMatchEnd;\nmodule.exports.default = indexOfMatchEnd;\n","const indexOfMatch = require(\"./index-of-match.js\");\nconst indexOfMatchEnd = require(\"./index-of-match-end.js\");\nconst countSubstring = require(\"./count-substring.js\");\n\nfunction findTagByName(xml, tagName, options) {\n  const debug = (options && options.debug) || false;\n  const nested = !(options && typeof options.nested === false);\n\n  const startIndex = (options && options.startIndex) || 0;\n\n  if (debug) console.log(\"[xml-utils] starting findTagByName with\", tagName, \" and \", options);\n\n  const start = indexOfMatch(xml, `\\<${tagName}[ \\n\\>\\/]`, startIndex);\n  if (debug) console.log(\"[xml-utils] start:\", start);\n  if (start === -1) return undefined;\n\n  const afterStart = xml.slice(start + tagName.length);\n\n  let relativeEnd = indexOfMatchEnd(afterStart, \"^[^<]*[ /]>\", 0);\n\n  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === \"/\";\n  if (debug) console.log(\"[xml-utils] selfClosing:\", selfClosing);\n\n  if (selfClosing === false) {\n    // check if tag has subtags with the same name\n    if (nested) {\n      let startIndex = 0;\n      let openings = 1;\n      let closings = 0;\n      while ((relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", startIndex)) !== -1) {\n        const clip = afterStart.substring(startIndex, relativeEnd + 1);\n        openings += countSubstring(clip, \"<\" + tagName + \"[ \\n\\t>]\");\n        closings += countSubstring(clip, \"</\" + tagName + \">\");\n        // we can't have more openings than closings\n        if (closings >= openings) break;\n        startIndex = relativeEnd;\n      }\n    } else {\n      relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", 0);\n    }\n  }\n\n  const end = start + tagName.length + relativeEnd + 1;\n  if (debug) console.log(\"[xml-utils] end:\", end);\n  if (end === -1) return undefined;\n\n  const outer = xml.slice(start, end);\n  // tag is like <gml:identifier codeSpace=\"OGP\">urn:ogc:def:crs:EPSG::32617</gml:identifier>\n\n  let inner;\n  if (selfClosing) {\n    inner = null;\n  } else {\n    inner = outer.slice(outer.indexOf(\">\") + 1, outer.lastIndexOf(\"<\"));\n  }\n\n  return { inner, outer, start, end };\n}\n\nmodule.exports = findTagByName;\nmodule.exports.default = findTagByName;\n","const findTagByName = require(\"./find-tag-by-name.js\");\n\nfunction findTagsByName(xml, tagName, options) {\n  const tags = [];\n  const debug = (options && options.debug) || false;\n  const nested = options && typeof options.nested === \"boolean\" ? options.nested : true;\n  let startIndex = (options && options.startIndex) || 0;\n  let tag;\n  while ((tag = findTagByName(xml, tagName, { debug, startIndex }))) {\n    if (nested) {\n      startIndex = tag.start + 1 + tagName.length;\n    } else {\n      startIndex = tag.end;\n    }\n    tags.push(tag);\n  }\n  if (debug) console.log(\"findTagsByName found\", tags.length, \"tags\");\n  return tags;\n}\n\nmodule.exports = findTagsByName;\nmodule.exports.default = findTagsByName;\n","export const fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nexport const fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34264: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34736: 'DOUBLE',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nexport const arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nexport const fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nexport const fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nexport const ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nexport const LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nexport const LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n  Zstandard: 2,\n};\n\nexport const geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nexport const geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n"],"names":["registry","Map","addDecoder","cases","importFn","Array","isArray","forEach","c","set","async","getDecoder","fileDirectory","get","Compression","Error","Decoder","undefined","then","m","default","zstd","init","defaultPoolSize","navigator","hardwareConcurrency","Pool","constructor","size","createWorker","this","workers","_awaitingDecoder","messageId","Promise","resolve","module","create","i","push","worker","idle","decode","buffer","decoder","find","candidate","Math","floor","random","id","onMessage","e","data","decoded","removeEventListener","addEventListener","postMessage","destroy","terminate","CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT","uncurryThis","target","thisArg","args","ReflectApply","uncurryThisGetter","key","ReflectGetOwnPropertyDescriptor","apply","construct","ReflectConstruct","defineProperty","ReflectDefineProperty","ReflectGet","getOwnPropertyDescriptor","getPrototypeOf","ReflectGetPrototypeOf","has","ReflectHas","ownKeys","ReflectOwnKeys","ReflectSet","setPrototypeOf","ReflectSetPrototypeOf","Reflect","EPSILON","MAX_SAFE_INTEGER","isFinite","isNaN","Number","iterator","SymbolIterator","species","SymbolSpecies","toStringTag","SymbolToStringTag","for","SymbolFor","Symbol","NativeObject","Object","ObjectDefineProperty","freeze","ObjectFreeze","is","ObjectIs","ObjectPrototype","prototype","ObjectHasOwn","__lookupGetter__","hasOwn","hasOwnProperty","NativeArray","ArrayPrototype","NativeArrayPrototypeSymbolIterator","join","toLocaleString","ArrayPrototypeSymbolIterator","abs","trunc","MathTrunc","NativeArrayBuffer","ArrayBuffer","ArrayBufferPrototype","isView","NativeSharedArrayBuffer","slice","SharedArrayBuffer","TypedArray","Uint8Array","TypedArrayPrototype","from","NativeUint8Array","keys","values","entries","reverse","fill","copyWithin","sort","subarray","NativeUint16Array","Uint16Array","NativeUint32Array","Uint32Array","NativeFloat32Array","Float32Array","ArrayIteratorPrototype","ArrayIteratorPrototypeNext","next","GeneratorPrototypeNext","IteratorPrototype","DataViewPrototype","DataView","DataViewPrototypeGetUint16","getUint16","NativeTypeError","setUint16","TypeError","NativeWeakSet","WeakSet","WeakSetPrototype","NativeWeakMap","add","WeakMap","WeakMapPrototype","WeakMapPrototypeGet","arrayIterators","SafeIteratorPrototype","value","arrayIterator","array","safe","generators","DummyArrayIteratorPrototype","generator","writable","configurable","floatView","uint32View","baseTable","shiftTable","mantissaTable","exponentTable","offsetTable","convertToNumber","float16bits","getFloat16","dataView","byteOffset","opts","fromWhiteIsZero","raster","max","width","height","rgbRaster","j","length","fromBlackIsZero","fromPalette","colorMap","greenOffset","blueOffset","mapIndex","fromCMYK","cmykRaster","y","k","fromYCbCr","yCbCrRaster","Uint8ClampedArray","cb","cr","Xn","Yn","Zn","fromCIELab","cieLabRaster","L","a_","b_","r","g","b","x","z","min","copyNewSize","samplesPerPixel","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","map","newArray","cy","round","cx","lerp","v0","v1","t","resampleBilinear","rawY","yl","yh","ceil","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","toLowerCase","resampleNearestInterleaved","valueArray","samples","resampleBilinearInterleaved","resampleInterleaved","sum","start","end","s","arrayForType","format","bitsPerSample","Int8Array","Int16Array","Int32Array","Float64Array","needsNormalization","normalizeArray","inBuffer","planarConfiguration","tileWidth","tileHeight","view","outSize","samplesToTransfer","outArray","bitMask","parseInt","repeat","pixelBitSkip","bitsPerLine","lineBitOffset","pixelBitOffset","bitOffset","outIndex","innerBitOffset","getUint8","raw","getUint32","GeoTIFFImage","geoKeys","littleEndian","cache","source","tiles","isTiled","StripOffsets","PlanarConfiguration","getFileDirectory","getGeoKeys","getWidth","ImageWidth","getHeight","ImageLength","getSamplesPerPixel","SamplesPerPixel","getTileWidth","TileWidth","getTileHeight","TileLength","RowsPerStrip","getBlockWidth","getBlockHeight","getBytesPerPixel","bytes","BitsPerSample","getSampleByteSize","RangeError","getReaderForSample","sampleIndex","SampleFormat","getInt8","getInt16","getInt32","offset","getFloat32","getFloat64","getSampleFormat","getBitsPerSample","getArrayForSample","getTileOrStrip","sample","poolOrDecoder","signal","numTilesPerRow","numTilesPerCol","index","byteCount","TileOffsets","TileByteCounts","StripByteCounts","fetch","request","sampleFormat","_readRaster","imageWindow","interleave","resampleMethod","imageWidth","imageHeight","minXTile","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","srcSampleOffsets","sampleReaders","promises","yTile","xTile","getPromise","si","promise","tile","blockHeight","firstLine","firstCol","lastLine","lastCol","reader","ymax","xmax","pixelOffset","call","windowCoordinate","all","resampled","readRasters","window","wnd","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","reject","result","readRGB","enableAlpha","pi","PhotometricInterpretation","RGB","ExtraSamples","Unspecified","WhiteIsZero","BlackIsZero","Palette","CMYK","YCbCr","CIELab","subOptions","ColorMap","red","green","blue","getTiePoints","ModelTiepoint","tiePoints","getGDALMetadata","metadata","GDAL_METADATA","string","items","filter","item","inner","getGDALNoData","GDAL_NODATA","substring","getOrigin","modelTransformation","ModelTransformation","getResolution","referenceImage","modelPixelScale","ModelPixelScale","sqrt","refResX","refResY","refResZ","pixelIsArea","GTRasterTypeGeoKey","getBoundingBox","tilegrid","a","d","f","h","corners","projected","I","J","xs","pt","ys","origin","resolution","x1","y1","x2","y2","DataView64","arrayBuffer","_dataView","getUint64","left","right","combined","isSafeInteger","getInt64","isNegative","carrying","byte","DataSlice","sliceOffset","bigTiff","_sliceOffset","_littleEndian","_bigTiff","sliceTop","byteLength","covers","readUint8","readInt8","readUint16","readInt16","readUint32","readInt32","readFloat32","readFloat64","readUint64","readInt64","readOffset","CRLFCRLF","itemsToObject","fromEntries","obj","parseHeaders","text","split","line","kv","str","trim","parseContentType","rawContentType","type","rawParams","paramsItems","param","params","parseContentRange","rawContentRange","total","match","parseByteRanges","responseArrayBuffer","boundary","TextDecoder","out","startBoundary","endBoundary","startsWith","innerText","substr","endOfHeaders","indexOf","headers","startOfData","fileSize","BaseSource","slices","fetchSlice","close","QuickLRU","options","super","maxSize","maxAge","POSITIVE_INFINITY","onEviction","oldCache","_size","_emitEvictions","_deleteIfExpired","expiry","Date","now","delete","_getOrDeleteIfExpired","deleted","_getItemValue","_peek","_set","_moveToRecent","_entriesAscending","peek","clear","resize","newSize","removeCount","entriesDescending","entriesAscending","oldCacheSize","callbackFunction","thisArgument","JSON","stringify","wait","milliseconds","setTimeout","zip","A","B","AbortError","captureStackTrace","name","CustomAggregateError","errors","message","AggregateError","Block","top","BlockGroup","blockIds","BlockedSource","blockSize","cacheSize","blockCache","blockId","block","evictedBlocks","blockRequests","blockIdsToFetch","Set","abortedBlockIds","missingBlockIds","allBlockIds","firstBlockOffset","current","fetchBlocks","missingRequests","allSettled","abortedBlockRequests","aborted","blocks","failedBlocks","requiredBlocks","readSliceData","groups","groupBlocks","groupRequests","groupIndex","group","response","blockOffset","o","err","sortedBlockIds","lastBlockId","blockIdLow","blockIdHigh","sliceData","sliceView","delta","topDelta","usedBlockLength","blockInnerOffset","rangeInnerOffset","blockView","BaseResponse","ok","status","getHeader","headerName","getData","BaseClient","url","FetchResponse","FetchClient","credentials","XHRResponse","xhr","getResponseHeader","XHRClient","constructRequest","XMLHttpRequest","open","responseType","setRequestHeader","onload","onerror","onabort","send","abort","HttpResponse","dataPromise","statusCode","HttpClient","parsedUrl","httpApi","protocol","resolveData","chunks","on","chunk","Buffer","concat","RemoteSource","client","maxRanges","allowFullFile","_fileSize","fetchSlices","Range","byteRanges","first","others","maybeWrapInBlockedSource","makeFetchSource","blockOptions","makeXHRSource","makeHttpSource","makeRemoteSource","forceXHR","clientOptions","FileReaderSource","file","blob","FileReader","event","readAsArrayBuffer","makeFileReaderSource","getFieldTypeLength","fieldType","BYTE","ASCII","SBYTE","UNDEFINED","SHORT","SSHORT","LONG","SLONG","FLOAT","IFD","RATIONAL","SRATIONAL","DOUBLE","LONG8","SLONG8","IFD8","parseGeoKeyDirectory","rawGeoKeyDirectory","GeoKeyDirectory","geoKeyDirectory","location","count","getValues","dataSlice","readMethod","fieldTypeLength","ImageFileDirectory","nextIFDByteOffset","GeoTIFFImageIndexError","GeoTIFFBase","resX","resY","bbox","firstImage","getImage","usedImage","imageCount","getImageCount","imgBBox","oX","oY","rX","rY","usedBBox","allImages","image","SubfileType","subfileType","NewSubfileType","newSubfileType","imgResX","imgResY","imageResX","imageResY","GeoTIFF","firstIFDOffset","ifdRequests","ghostValues","getSlice","fallbackSize","parseFileDirectoryAt","entrySize","offsetSize","numDirEntries","byteSize","entryCount","fieldTag","typeCount","fieldValues","valueOffset","actualOffset","fieldDataSlice","requestIFD","previousIfd","ifd","hasNext","getGhostValues","detectionString","heuristicAreaSize","valuesString","metadataSize","fullString","fromSource","headerData","BOM","magicNumber","offsetByteSize","MultiGeoTIFF","mainFile","overviewFiles","imageFiles","fileDirectoriesPerFile","fileDirectoriesPerFileParsing","parseFileDirectoriesPerFile","requests","visited","relativeIndex","imageFile","ii","imageCounts","reduce","ifds","fromUrl","fromBlob","fromUrls","mainUrl","overviewUrls","isMask","preference","interpretation","interpretations","ICCLab","STATISTICS_MAXIMUM","STATISTICS_MINIMUM","defaultTileSize","workerPool","getWorkerPool","getResolutions","getProjection","ProjectedCSTypeGeoKey","code","projection","units","ProjLinearUnitsGeoKey","GeographicTypeGeoKey","GeogAngularUnitsGeoKey","getImagesForTIFF","tiff","getImagesForSource","overviews","assertEqual","expected","got","tolerance","rejector","error","getMinForDataType","getMaxForDataType","GeoTIFFSource","DataTile","state","tileGrid","transition","interpolate","wrapX","sourceInfo_","sources","numSources","sourceOptions_","sourceOptions","sourceImagery_","sourceMasks_","resolutionFactors_","samplesPerPixel_","nodataValues_","metadata_","normalize_","normalize","addAlpha_","error_","convertToRGB_","convertToRGB","setKey","self","configure_","catch","setState","getError","determineProjection","firstSource","determineTransformMatrix","matrix","transformMatrix","extent","commonRenderTileSizes","commonSourceTileSizes","resolutions","nodataValues","minZoom","sourceCount","sourceIndex","images","masks","sourceExtent","sourceOrigin","sourceTileSizes","renderTileSizes","sourceResolutions","imageIndex","nodataValue","wantedSamples","bands","level","imageResolutions","sourceTileSize","aspectRatio","viewRejector","resolutionFactor","scaledSourceResolutions","sourceImagery","unshift","outer","nodata","bandCount","TileGrid","tileSizes","setTileSizes","setLoader","loadTile_","bind","zoom","viewExtent","transformFn","input","viewResolver","showFullExtent","center","getTileSize","sourceInfo","pixelBounds","bandNumber","readOptions","maskIndex","mask","composeTile_","sourceSamples","addAlpha","pixelCount","dataLength","dataIndex","pixelIndex","transparent","gain","bias","stats","parseFloat","sourceValue","bandIndex","nodataIsNaN","getView","countSubstring","pattern","RegExp","exports","getAttribute","tag","attributeName","debug","console","log","xml","opening","quotechars","char","re","exec","indexOfMatch","startIndex","indexOfMatchEnd","findTagByName","tagName","nested","afterStart","relativeEnd","selfClosing","openings","closings","clip","lastIndexOf","findTagsByName","tags","fieldTagNames","fieldTags","arrayFields","StripRowCounts","SubIFDs","fieldTypeNames","fieldTypes","photometricInterpretations","TransparencyMask","ExtraSamplesValues","Assocalpha","Unassalpha","LercParameters","Version","AddCompression","LercAddCompression","None","Deflate","Zstandard","geoKeyNames"],"sourceRoot":""}