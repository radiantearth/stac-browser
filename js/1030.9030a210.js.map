{"version":3,"file":"js/1030.9030a210.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/compression/packbits.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/predictor.js","webpack://@radiantearth/stac-browser/./node_modules/geotiff/dist-module/compression/basedecoder.js"],"sourcesContent":["import BaseDecoder from './basedecoder.js';\n\nexport default class PackbitsDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    const dataView = new DataView(buffer);\n    const out = [];\n\n    for (let i = 0; i < buffer.byteLength; ++i) {\n      let header = dataView.getInt8(i);\n      if (header < 0) {\n        const next = dataView.getUint8(i + 1);\n        header = -header;\n        for (let j = 0; j <= header; ++j) {\n          out.push(next);\n        }\n        i += 1;\n      } else {\n        for (let j = 0; j <= header; ++j) {\n          out.push(dataView.getUint8(i + j + 1));\n        }\n        i += header + 1;\n      }\n    }\n    return new Uint8Array(out).buffer;\n  }\n}\n","function decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n","import { applyPredictor } from '../predictor.js';\n\nexport default class BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return applyPredictor(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n"],"names":["PackbitsDecoder","decodeBlock","buffer","dataView","DataView","out","i","byteLength","header","getInt8","next","getUint8","j","push","Uint8Array","decodeRowAcc","row","stride","length","offset","decodeRowFloatingPoint","bytesPerSample","index","count","wc","copy","slice","b","applyPredictor","block","predictor","width","height","bitsPerSample","planarConfiguration","Error","Uint16Array","Uint32Array","BaseDecoder","decode","fileDirectory","decoded","this","Predictor","isTiled","StripOffsets","tileWidth","TileWidth","ImageWidth","tileHeight","TileLength","RowsPerStrip","ImageLength","BitsPerSample","PlanarConfiguration"],"sourceRoot":""}