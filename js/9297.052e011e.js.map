{"version":3,"file":"js/9297.052e011e.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/xml.js","webpack://@radiantearth/stac-browser/./node_modules/ol/format/XML.js","webpack://@radiantearth/stac-browser/./node_modules/ol/format/xlink.js","webpack://@radiantearth/stac-browser/./node_modules/ol/format/xsd.js","webpack://@radiantearth/stac-browser/./node_modules/ol/format/OWS.js","webpack://@radiantearth/stac-browser/./node_modules/ol/format/WMTSCapabilities.js"],"sourcesContent":["/**\n * @module ol/xml\n */\nimport {extend} from './array.js';\n\n/**\n * When using {@link module:ol/xml.makeChildAppender} or\n * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Element} node Node.\n */\n\n/**\n * @typedef {function(Element, Array<*>): void} Parser\n */\n\n/**\n * @typedef {function(Element, *, Array<*>): void} Serializer\n */\n\n/**\n * @type {string}\n */\nexport const XML_SCHEMA_INSTANCE_URI =\n  'http://www.w3.org/2001/XMLSchema-instance';\n\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\nexport function createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\nexport function getAllTextContent(node, normalizeWhitespace) {\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n  if (\n    node.nodeType == Node.CDATA_SECTION_NODE ||\n    node.nodeType == Node.TEXT_NODE\n  ) {\n    if (normalizeWhitespace) {\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      accumulator.push(node.nodeValue);\n    }\n  } else {\n    let n;\n    for (n = node.firstChild; n; n = n.nextSibling) {\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\n    }\n  }\n  return accumulator;\n}\n\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\nexport function isDocument(object) {\n  return 'documentElement' in object;\n}\n\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\nexport function getAttributeNS(node, namespaceURI, name) {\n  return node.getAttributeNS(namespaceURI, name) || '';\n}\n\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\nexport function parse(xml) {\n  return new DOMParser().parseFromString(xml, 'application/xml');\n}\n\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayExtender(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        extend(array, value);\n      }\n    }\n  );\n}\n\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayPusher(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeReplacer(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        objectStack[objectStack.length - 1] = value;\n      }\n    }\n  );\n}\n\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertyPusher(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        let array;\n        if (name in object) {\n          array = object[name];\n        } else {\n          array = [];\n          object[name] = array;\n        }\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertySetter(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        object[name] = value;\n      }\n    }\n  );\n}\n\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeChildAppender(nodeWriter, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {*} value Value to be written.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, value, objectStack) {\n      nodeWriter.call(thisArg ?? this, node, value, objectStack);\n      const parent = /** @type {NodeStackItem} */ (\n        objectStack[objectStack.length - 1]\n      );\n      const parentNode = parent.node;\n      parentNode.appendChild(node);\n    }\n  );\n}\n\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the\n * `nodeWriter` called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeArraySerializer(nodeWriter, thisArg) {\n  let serializersNS, nodeFactory;\n  return function (node, value, objectStack) {\n    if (serializersNS === undefined) {\n      serializersNS = {};\n      const serializers = {};\n      serializers[node.localName] = nodeWriter;\n      serializersNS[node.namespaceURI] = serializers;\n      nodeFactory = makeSimpleNodeFactory(node.localName);\n    }\n    serialize(serializersNS, nodeFactory, value, objectStack);\n  };\n}\n\n/**\n * Create a node factory which can use the `keys` passed to\n * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string} [fixedNodeName] Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string} [fixedNamespaceURI] Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\nexport function makeSimpleNodeFactory(fixedNodeName, fixedNamespaceURI) {\n  return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [newNodeName] Node name.\n     * @return {Node} Node.\n     */\n    function (value, objectStack, newNodeName) {\n      const context = /** @type {NodeStackItem} */ (\n        objectStack[objectStack.length - 1]\n      );\n      const node = context.node;\n      let nodeName = fixedNodeName;\n      if (nodeName === undefined) {\n        nodeName = newNodeName;\n      }\n\n      const namespaceURI =\n        fixedNamespaceURI !== undefined ? fixedNamespaceURI : node.namespaceURI;\n      return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\n    }\n  );\n}\n\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nexport const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n\n/**\n * Create an array of `values` to be used with {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `key` argument.\n * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<*>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n */\nexport function makeSequence(object, orderedKeys) {\n  const length = orderedKeys.length;\n  const sequence = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    sequence[i] = object[orderedKeys[i]];\n  }\n  return sequence;\n}\n\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>} [structureNS] Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\nexport function makeStructureNS(namespaceURIs, structure, structureNS) {\n  structureNS = structureNS !== undefined ? structureNS : {};\n  let i, ii;\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n    structureNS[namespaceURIs[i]] = structure;\n  }\n  return structureNS;\n}\n\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n */\nexport function parseNode(parsersNS, node, objectStack, thisArg) {\n  let n;\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n    const parsers = parsersNS[n.namespaceURI];\n    if (parsers !== undefined) {\n      const parser = parsers[n.localName];\n      if (parser !== undefined) {\n        parser.call(thisArg, n, objectStack);\n      }\n    }\n  }\n}\n\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\nexport function pushParseAndPop(object, parsersNS, node, objectStack, thisArg) {\n  objectStack.push(object);\n  parseNode(parsersNS, node, objectStack, thisArg);\n  return /** @type {T} */ (objectStack.pop());\n}\n\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\nexport function serialize(\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg,\n) {\n  const length = (keys !== undefined ? keys : values).length;\n  let value, node;\n  for (let i = 0; i < length; ++i) {\n    value = values[i];\n    if (value !== undefined) {\n      node = nodeFactory.call(\n        thisArg,\n        value,\n        objectStack,\n        keys !== undefined ? keys[i] : undefined,\n      );\n      if (node !== undefined) {\n        serializersNS[node.namespaceURI][node.localName].call(\n          thisArg,\n          node,\n          value,\n          objectStack,\n        );\n      }\n    }\n  }\n}\n\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\nexport function pushSerializeAndPop(\n  object,\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg,\n) {\n  objectStack.push(object);\n  serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg);\n  return /** @type {O|undefined} */ (objectStack.pop());\n}\n\nlet xmlSerializer_ = undefined;\n\n/**\n * Register a XMLSerializer. Can be used  to inject a XMLSerializer\n * where there is no globally available implementation.\n *\n * @param {XMLSerializer} xmlSerializer A XMLSerializer.\n * @api\n */\nexport function registerXMLSerializer(xmlSerializer) {\n  xmlSerializer_ = xmlSerializer;\n}\n\n/**\n * @return {XMLSerializer} The XMLSerializer.\n */\nexport function getXMLSerializer() {\n  if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {\n    xmlSerializer_ = new XMLSerializer();\n  }\n  return xmlSerializer_;\n}\n\nlet document_ = undefined;\n\n/**\n * Register a Document to use when creating nodes for XML serializations. Can be used\n * to inject a Document where there is no globally available implementation.\n *\n * @param {Document} document A Document.\n * @api\n */\nexport function registerDocument(document) {\n  document_ = document;\n}\n\n/**\n * Get a document that should be used when creating nodes for XML serializations.\n * @return {Document} The document.\n */\nexport function getDocument() {\n  if (document_ === undefined && typeof document !== 'undefined') {\n    document_ = document.implementation.createDocument('', '', null);\n  }\n  return document_;\n}\n","/**\n * @module ol/format/XML\n */\nimport {abstract} from '../util.js';\nimport {isDocument, parse} from '../xml.js';\n\n/**\n * @classdesc\n * Generic format for reading non-feature XML data\n *\n * @abstract\n */\nclass XML {\n  /**\n   * Read the source document.\n   *\n   * @param {Document|Element|string} source The XML source.\n   * @return {Object|null} An object representing the source.\n   * @api\n   */\n  read(source) {\n    if (!source) {\n      return null;\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFromDocument(doc);\n    }\n    if (isDocument(source)) {\n      return this.readFromDocument(/** @type {Document} */ (source));\n    }\n    return this.readFromNode(/** @type {Element} */ (source));\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {Object|null} Object\n   */\n  readFromDocument(doc) {\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readFromNode(/** @type {Element} */ (n));\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @abstract\n   * @param {Element} node Node.\n   * @return {Object|null} Object\n   */\n  readFromNode(node) {\n    abstract();\n  }\n}\n\nexport default XML;\n","/**\n * @module ol/format/xlink\n */\n\n/**\n * @const\n * @type {string}\n */\nconst NAMESPACE_URI = 'http://www.w3.org/1999/xlink';\n\n/**\n * @param {Element} node Node.\n * @return {string|null} href.\n */\nexport function readHref(node) {\n  return node.getAttributeNS(NAMESPACE_URI, 'href');\n}\n","/**\n * @module ol/format/xsd\n */\nimport {padNumber} from '../string.js';\nimport {getAllTextContent, getDocument} from '../xml.js';\n\n/**\n * @param {Node} node Node.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBoolean(node) {\n  const s = getAllTextContent(node, false);\n  return readBooleanString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBooleanString(string) {\n  const m = /^\\s*(true|1)|(false|0)\\s*$/.exec(string);\n  if (m) {\n    return m[1] !== undefined || false;\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} DateTime in seconds.\n */\nexport function readDateTime(node) {\n  const s = getAllTextContent(node, false);\n  const dateTime = Date.parse(s);\n  return isNaN(dateTime) ? undefined : dateTime / 1000;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimal(node) {\n  const s = getAllTextContent(node, false);\n  return readDecimalString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimalString(string) {\n  // FIXME check spec\n  const m = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)\\s*$/i.exec(string);\n  if (m) {\n    return parseFloat(m[1]);\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Non negative integer.\n */\nexport function readPositiveInteger(node) {\n  const s = getAllTextContent(node, false);\n  return readNonNegativeIntegerString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Non negative integer.\n */\nexport function readNonNegativeIntegerString(string) {\n  const m = /^\\s*(\\d+)\\s*$/.exec(string);\n  if (m) {\n    return parseInt(m[1], 10);\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {string|undefined} String.\n */\nexport function readString(node) {\n  return getAllTextContent(node, false).trim();\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the boolean to.\n * @param {boolean} bool Boolean.\n */\nexport function writeBooleanTextNode(node, bool) {\n  writeStringTextNode(node, bool ? '1' : '0');\n}\n\n/**\n * @param {Node} node Node to append a CDATA Section with the string to.\n * @param {string} string String.\n */\nexport function writeCDATASection(node, string) {\n  node.appendChild(getDocument().createCDATASection(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the dateTime to.\n * @param {number} dateTime DateTime in seconds.\n */\nexport function writeDateTimeTextNode(node, dateTime) {\n  const date = new Date(dateTime * 1000);\n  const string =\n    date.getUTCFullYear() +\n    '-' +\n    padNumber(date.getUTCMonth() + 1, 2) +\n    '-' +\n    padNumber(date.getUTCDate(), 2) +\n    'T' +\n    padNumber(date.getUTCHours(), 2) +\n    ':' +\n    padNumber(date.getUTCMinutes(), 2) +\n    ':' +\n    padNumber(date.getUTCSeconds(), 2) +\n    'Z';\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} decimal Decimal.\n */\nexport function writeDecimalTextNode(node, decimal) {\n  const string = decimal.toPrecision();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} nonNegativeInteger Non negative integer.\n */\nexport function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {\n  const string = nonNegativeInteger.toString();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\nconst whiteSpaceStart = /^\\s/;\nconst whiteSpaceEnd = /\\s$/;\nconst cdataCharacters = /(\\n|\\t|\\r|<|&| {2})/;\n\n/**\n * @param {Node} node Node to append a TextNode with the string to.\n * @param {string} string String.\n */\nexport function writeStringTextNode(node, string) {\n  if (\n    typeof string === 'string' &&\n    (whiteSpaceStart.test(string) ||\n      whiteSpaceEnd.test(string) ||\n      cdataCharacters.test(string))\n  ) {\n    string.split(']]>').forEach((part, i, a) => {\n      if (i < a.length - 1) {\n        part += ']]';\n      }\n      if (i > 0) {\n        part = '>' + part;\n      }\n      writeCDATASection(node, part);\n    });\n  } else {\n    node.appendChild(getDocument().createTextNode(string));\n  }\n}\n","/**\n * @module ol/format/OWS\n */\nimport {\n  makeObjectPropertyPusher,\n  makeObjectPropertySetter,\n  makeStructureNS,\n  pushParseAndPop,\n} from '../xml.js';\nimport XML from './XML.js';\nimport {readHref} from './xlink.js';\nimport {readString} from './xsd.js';\n\n/**\n * @const\n * @type {Array<null|string>}\n */\nconst NAMESPACE_URIS = [null, 'http://www.opengis.net/ows/1.1'];\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'ServiceIdentification': makeObjectPropertySetter(readServiceIdentification),\n  'ServiceProvider': makeObjectPropertySetter(readServiceProvider),\n  'OperationsMetadata': makeObjectPropertySetter(readOperationsMetadata),\n});\n\nclass OWS extends XML {\n  constructor() {\n    super();\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Object|null} Object\n   * @override\n   */\n  readFromNode(node) {\n    const owsObject = pushParseAndPop({}, PARSERS, node, []);\n    return owsObject ? owsObject : null;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst ADDRESS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'DeliveryPoint': makeObjectPropertySetter(readString),\n  'City': makeObjectPropertySetter(readString),\n  'AdministrativeArea': makeObjectPropertySetter(readString),\n  'PostalCode': makeObjectPropertySetter(readString),\n  'Country': makeObjectPropertySetter(readString),\n  'ElectronicMailAddress': makeObjectPropertySetter(readString),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst ALLOWED_VALUES_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Value': makeObjectPropertyPusher(readValue),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst CONSTRAINT_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'AllowedValues': makeObjectPropertySetter(readAllowedValues),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst CONTACT_INFO_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Phone': makeObjectPropertySetter(readPhone),\n  'Address': makeObjectPropertySetter(readAddress),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst DCP_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'HTTP': makeObjectPropertySetter(readHttp),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst HTTP_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Get': makeObjectPropertyPusher(readGet),\n  'Post': undefined, // TODO\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst OPERATION_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'DCP': makeObjectPropertySetter(readDcp),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst OPERATIONS_METADATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Operation': readOperation,\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PHONE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Voice': makeObjectPropertySetter(readString),\n  'Facsimile': makeObjectPropertySetter(readString),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst REQUEST_METHOD_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Constraint': makeObjectPropertyPusher(readConstraint),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst SERVICE_CONTACT_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'IndividualName': makeObjectPropertySetter(readString),\n  'PositionName': makeObjectPropertySetter(readString),\n  'ContactInfo': makeObjectPropertySetter(readContactInfo),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst SERVICE_IDENTIFICATION_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Abstract': makeObjectPropertySetter(readString),\n  'AccessConstraints': makeObjectPropertySetter(readString),\n  'Fees': makeObjectPropertySetter(readString),\n  'Title': makeObjectPropertySetter(readString),\n  'ServiceTypeVersion': makeObjectPropertySetter(readString),\n  'ServiceType': makeObjectPropertySetter(readString),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst SERVICE_PROVIDER_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'ProviderName': makeObjectPropertySetter(readString),\n  'ProviderSite': makeObjectPropertySetter(readHref),\n  'ServiceContact': makeObjectPropertySetter(readServiceContact),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The address.\n */\nfunction readAddress(node, objectStack) {\n  return pushParseAndPop({}, ADDRESS_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The values.\n */\nfunction readAllowedValues(node, objectStack) {\n  return pushParseAndPop({}, ALLOWED_VALUES_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The constraint.\n */\nfunction readConstraint(node, objectStack) {\n  const name = node.getAttribute('name');\n  if (!name) {\n    return undefined;\n  }\n  return pushParseAndPop({'name': name}, CONSTRAINT_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The contact info.\n */\nfunction readContactInfo(node, objectStack) {\n  return pushParseAndPop({}, CONTACT_INFO_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The DCP.\n */\nfunction readDcp(node, objectStack) {\n  return pushParseAndPop({}, DCP_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The GET object.\n */\nfunction readGet(node, objectStack) {\n  const href = readHref(node);\n  if (!href) {\n    return undefined;\n  }\n  return pushParseAndPop(\n    {'href': href},\n    REQUEST_METHOD_PARSERS,\n    node,\n    objectStack,\n  );\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The HTTP object.\n */\nfunction readHttp(node, objectStack) {\n  return pushParseAndPop({}, HTTP_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The operation.\n */\nfunction readOperation(node, objectStack) {\n  const name = node.getAttribute('name');\n  const value = pushParseAndPop({}, OPERATION_PARSERS, node, objectStack);\n  if (!value) {\n    return undefined;\n  }\n  const object = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  object[name] = value;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The operations metadata.\n */\nfunction readOperationsMetadata(node, objectStack) {\n  return pushParseAndPop({}, OPERATIONS_METADATA_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The phone.\n */\nfunction readPhone(node, objectStack) {\n  return pushParseAndPop({}, PHONE_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The service identification.\n */\nfunction readServiceIdentification(node, objectStack) {\n  return pushParseAndPop({}, SERVICE_IDENTIFICATION_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The service contact.\n */\nfunction readServiceContact(node, objectStack) {\n  return pushParseAndPop({}, SERVICE_CONTACT_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} The service provider.\n */\nfunction readServiceProvider(node, objectStack) {\n  return pushParseAndPop({}, SERVICE_PROVIDER_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {string|undefined} The value.\n */\nfunction readValue(node, objectStack) {\n  return readString(node);\n}\n\nexport default OWS;\n","/**\n * @module ol/format/WMTSCapabilities\n */\nimport {boundingExtent} from '../extent.js';\nimport {\n  makeArrayPusher,\n  makeObjectPropertyPusher,\n  makeObjectPropertySetter,\n  makeStructureNS,\n  pushParseAndPop,\n} from '../xml.js';\nimport OWS from './OWS.js';\nimport XML from './XML.js';\nimport {readHref} from './xlink.js';\nimport {readDecimal, readPositiveInteger, readString} from './xsd.js';\n\n/**\n * @const\n * @type {Array<null|string>}\n */\nconst NAMESPACE_URIS = [null, 'http://www.opengis.net/wmts/1.0'];\n\n/**\n * @const\n * @type {Array<null|string>}\n */\nconst OWS_NAMESPACE_URIS = [null, 'http://www.opengis.net/ows/1.1'];\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Contents': makeObjectPropertySetter(readContents),\n});\n\n/**\n * @classdesc\n * Format for reading WMTS capabilities data.\n *\n * @api\n */\nclass WMTSCapabilities extends XML {\n  constructor() {\n    super();\n\n    /**\n     * @type {OWS}\n     * @private\n     */\n    this.owsParser_ = new OWS();\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Object|null} Object\n   * @override\n   */\n  readFromNode(node) {\n    let version = node.getAttribute('version');\n    if (version) {\n      version = version.trim();\n    }\n    let WMTSCapabilityObject = this.owsParser_.readFromNode(node);\n    if (!WMTSCapabilityObject) {\n      return null;\n    }\n    WMTSCapabilityObject['version'] = version;\n    WMTSCapabilityObject = pushParseAndPop(\n      WMTSCapabilityObject,\n      PARSERS,\n      node,\n      [],\n    );\n    return WMTSCapabilityObject ? WMTSCapabilityObject : null;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst CONTENTS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Layer': makeObjectPropertyPusher(readLayer),\n  'TileMatrixSet': makeObjectPropertyPusher(readTileMatrixSet),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LAYER_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'Style': makeObjectPropertyPusher(readStyle),\n    'Format': makeObjectPropertyPusher(readString),\n    'TileMatrixSetLink': makeObjectPropertyPusher(readTileMatrixSetLink),\n    'Dimension': makeObjectPropertyPusher(readDimensions),\n    'ResourceURL': makeObjectPropertyPusher(readResourceUrl),\n  },\n  makeStructureNS(OWS_NAMESPACE_URIS, {\n    'Title': makeObjectPropertySetter(readString),\n    'Abstract': makeObjectPropertySetter(readString),\n    'WGS84BoundingBox': makeObjectPropertySetter(readBoundingBox),\n    'BoundingBox': makeObjectPropertyPusher(readBoundingBoxWithCrs),\n    'Identifier': makeObjectPropertySetter(readString),\n  }),\n);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst STYLE_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'LegendURL': makeObjectPropertyPusher(readLegendUrl),\n  },\n  makeStructureNS(OWS_NAMESPACE_URIS, {\n    'Title': makeObjectPropertySetter(readString),\n    'Identifier': makeObjectPropertySetter(readString),\n  }),\n);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst TMS_LINKS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'TileMatrixSet': makeObjectPropertySetter(readString),\n  'TileMatrixSetLimits': makeObjectPropertySetter(readTileMatrixLimitsList),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst TMS_LIMITS_LIST_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'TileMatrixLimits': makeArrayPusher(readTileMatrixLimits),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst TMS_LIMITS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'TileMatrix': makeObjectPropertySetter(readString),\n  'MinTileRow': makeObjectPropertySetter(readPositiveInteger),\n  'MaxTileRow': makeObjectPropertySetter(readPositiveInteger),\n  'MinTileCol': makeObjectPropertySetter(readPositiveInteger),\n  'MaxTileCol': makeObjectPropertySetter(readPositiveInteger),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst DIMENSION_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'Default': makeObjectPropertySetter(readString),\n    'Value': makeObjectPropertyPusher(readString),\n  },\n  makeStructureNS(OWS_NAMESPACE_URIS, {\n    'Identifier': makeObjectPropertySetter(readString),\n  }),\n);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst WGS84_BBOX_READERS = makeStructureNS(OWS_NAMESPACE_URIS, {\n  'LowerCorner': makeArrayPusher(readCoordinates),\n  'UpperCorner': makeArrayPusher(readCoordinates),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst TMS_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'WellKnownScaleSet': makeObjectPropertySetter(readString),\n    'TileMatrix': makeObjectPropertyPusher(readTileMatrix),\n  },\n  makeStructureNS(OWS_NAMESPACE_URIS, {\n    'SupportedCRS': makeObjectPropertySetter(readString),\n    'Identifier': makeObjectPropertySetter(readString),\n    'BoundingBox': makeObjectPropertySetter(readBoundingBox),\n  }),\n);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst TM_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'TopLeftCorner': makeObjectPropertySetter(readCoordinates),\n    'ScaleDenominator': makeObjectPropertySetter(readDecimal),\n    'TileWidth': makeObjectPropertySetter(readPositiveInteger),\n    'TileHeight': makeObjectPropertySetter(readPositiveInteger),\n    'MatrixWidth': makeObjectPropertySetter(readPositiveInteger),\n    'MatrixHeight': makeObjectPropertySetter(readPositiveInteger),\n  },\n  makeStructureNS(OWS_NAMESPACE_URIS, {\n    'Identifier': makeObjectPropertySetter(readString),\n  }),\n);\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Attribution object.\n */\nfunction readContents(node, objectStack) {\n  return pushParseAndPop({}, CONTENTS_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Layers object.\n */\nfunction readLayer(node, objectStack) {\n  return pushParseAndPop({}, LAYER_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Tile Matrix Set object.\n */\nfunction readTileMatrixSet(node, objectStack) {\n  return pushParseAndPop({}, TMS_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Style object.\n */\nfunction readStyle(node, objectStack) {\n  const style = pushParseAndPop({}, STYLE_PARSERS, node, objectStack);\n  if (!style) {\n    return undefined;\n  }\n  const isDefault = node.getAttribute('isDefault') === 'true';\n  style['isDefault'] = isDefault;\n  return style;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Tile Matrix Set Link object.\n */\nfunction readTileMatrixSetLink(node, objectStack) {\n  return pushParseAndPop({}, TMS_LINKS_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Dimension object.\n */\nfunction readDimensions(node, objectStack) {\n  return pushParseAndPop({}, DIMENSION_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Resource URL object.\n */\nfunction readResourceUrl(node, objectStack) {\n  const format = node.getAttribute('format');\n  const template = node.getAttribute('template');\n  const resourceType = node.getAttribute('resourceType');\n  const resource = {};\n  if (format) {\n    resource['format'] = format;\n  }\n  if (template) {\n    resource['template'] = template;\n  }\n  if (resourceType) {\n    resource['resourceType'] = resourceType;\n  }\n  return resource;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} BBox object.\n */\nfunction readBoundingBox(node, objectStack) {\n  const coordinates = pushParseAndPop(\n    [],\n    WGS84_BBOX_READERS,\n    node,\n    objectStack,\n  );\n  if (coordinates.length != 2) {\n    return undefined;\n  }\n  return boundingExtent(coordinates);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} BBox object.\n */\nfunction readBoundingBoxWithCrs(node, objectStack) {\n  const crs = node.getAttribute('crs');\n  const coordinates = pushParseAndPop(\n    [],\n    WGS84_BBOX_READERS,\n    node,\n    objectStack,\n  );\n  if (coordinates.length != 2) {\n    return undefined;\n  }\n  return {extent: boundingExtent(coordinates), crs: crs};\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Legend object.\n */\nfunction readLegendUrl(node, objectStack) {\n  const legend = {};\n  legend['format'] = node.getAttribute('format');\n  legend['href'] = readHref(node);\n  return legend;\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Coordinates object.\n */\nfunction readCoordinates(node, objectStack) {\n  const coordinates = readString(node).split(/\\s+/);\n  if (!coordinates || coordinates.length != 2) {\n    return undefined;\n  }\n  const x = +coordinates[0];\n  const y = +coordinates[1];\n  if (isNaN(x) || isNaN(y)) {\n    return undefined;\n  }\n  return [x, y];\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} TileMatrix object.\n */\nfunction readTileMatrix(node, objectStack) {\n  return pushParseAndPop({}, TM_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} TileMatrixSetLimits Object.\n */\nfunction readTileMatrixLimitsList(node, objectStack) {\n  return pushParseAndPop([], TMS_LIMITS_LIST_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} TileMatrixLimits Array.\n */\nfunction readTileMatrixLimits(node, objectStack) {\n  return pushParseAndPop({}, TMS_LIMITS_PARSERS, node, objectStack);\n}\n\nexport default WMTSCapabilities;\n"],"names":["createElementNS","namespaceURI","qualifiedName","node","normalizeWhitespace","getAllTextContent_","join","accumulator","nodeType","Node","CDATA_SECTION_NODE","TEXT_NODE","push","String","nodeValue","replace","n","firstChild","nextSibling","isDocument","object","parse","xml","DOMParser","parseFromString","makeArrayPusher","valueReader","thisArg","objectStack","value","call","this","undefined","array","length","makeObjectPropertyPusher","property","name","localName","makeObjectPropertySetter","makeSimpleNodeFactory","fixedNodeName","fixedNamespaceURI","newNodeName","context","nodeName","makeStructureNS","namespaceURIs","structure","structureNS","i","ii","parseNode","parsersNS","firstElementChild","nextElementSibling","parsers","parser","pushParseAndPop","pop","document_","document","implementation","createDocument","XML","read","source","doc","readFromDocument","readFromNode","ELEMENT_NODE","NAMESPACE_URI","readHref","getAttributeNS","readDecimal","s","readDecimalString","string","m","exec","parseFloat","readPositiveInteger","readNonNegativeIntegerString","parseInt","readString","trim","NAMESPACE_URIS","PARSERS","readServiceIdentification","readServiceProvider","readOperationsMetadata","OWS","constructor","super","owsObject","ADDRESS_PARSERS","ALLOWED_VALUES_PARSERS","readValue","CONSTRAINT_PARSERS","readAllowedValues","CONTACT_INFO_PARSERS","readPhone","readAddress","DCP_PARSERS","readHttp","HTTP_PARSERS","readGet","OPERATION_PARSERS","readDcp","OPERATIONS_METADATA_PARSERS","readOperation","PHONE_PARSERS","REQUEST_METHOD_PARSERS","readConstraint","SERVICE_CONTACT_PARSERS","readContactInfo","SERVICE_IDENTIFICATION_PARSERS","SERVICE_PROVIDER_PARSERS","readServiceContact","getAttribute","href","OWS_NAMESPACE_URIS","readContents","WMTSCapabilities","owsParser_","version","WMTSCapabilityObject","CONTENTS_PARSERS","readLayer","readTileMatrixSet","LAYER_PARSERS","readStyle","readTileMatrixSetLink","readDimensions","readResourceUrl","readBoundingBox","readBoundingBoxWithCrs","STYLE_PARSERS","readLegendUrl","TMS_LINKS_PARSERS","readTileMatrixLimitsList","TMS_LIMITS_LIST_PARSERS","readTileMatrixLimits","TMS_LIMITS_PARSERS","DIMENSION_PARSERS","WGS84_BBOX_READERS","readCoordinates","TMS_PARSERS","readTileMatrix","TM_PARSERS","style","isDefault","format","template","resourceType","resource","coordinates","crs","extent","legend","split","x","y","isNaN"],"sourceRoot":""}