{"version":3,"file":"js/5544.025b8c21.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/renderer/canvas/VectorTileLayer.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/VectorTile.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {ascending} from '../../array.js';\nimport {wrapX} from '../../coordinate.js';\nimport {\n  boundingExtent,\n  buffer,\n  containsExtent,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup, {\n  DECLUTTER,\n} from '../../render/canvas/ExecutorGroup.js';\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {toSize} from '../../size.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply,\n  reset as resetTransform,\n  scale,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport {\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],\n  'hybrid': ['Polygon', 'LineString'],\n  'vector': [],\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst VECTOR_REPLAYS = {\n  'hybrid': ['Image', 'Text', 'Default'],\n  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'],\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n * @extends {CanvasTileLayerRenderer<import(\"../../layer/VectorTile.js\").default<import('../../source/VectorTile.js').default<import('../../Feature.js').FeatureLike>>>}\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   * @param {import(\"./TileLayer.js\").Options} options Options.\n   */\n  constructor(layer, options) {\n    super(layer, options);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedOpacity_ = 1;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {Array<ZIndexContext>}\n     */\n    this.tileClipContexts_ = null;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @override\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    this.updateExecutorGroup_(\n      tile,\n      frameState.pixelRatio,\n      frameState.viewState.projection,\n    );\n    if (this.tileImageNeedsRender_(tile)) {\n      this.renderTileImage_(tile, frameState);\n    }\n    super.drawTile(tile, frameState, x, y, w, h, gutter, transition);\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @override\n   */\n  getTile(z, x, y, frameState) {\n    const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n      this.getOrCreateTile(z, x, y, frameState)\n    );\n    if (!tile) {\n      return null;\n    }\n\n    const viewState = frameState.viewState;\n    const resolution = viewState.resolution;\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    if (hifi || !tile.wantedResolution) {\n      tile.wantedResolution = resolution;\n    }\n    return tile;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    const layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ !== layerRevision) {\n      this.renderedLayerRevision_ = layerRevision;\n      this.renderedTiles.length = 0;\n    }\n    return super.prepareFrame(frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateExecutorGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const revision = layer.getRevision();\n    const renderOrder = layer.getRenderOrder() || null;\n\n    const resolution = tile.wantedResolution;\n    const builderState = tile.getReplayState(layer);\n    if (\n      !builderState.dirty &&\n      builderState.renderedResolution === resolution &&\n      builderState.renderedRevision == revision &&\n      builderState.renderedRenderOrder == renderOrder\n    ) {\n      return;\n    }\n\n    const source = layer.getSource();\n    const declutter = !!layer.getDeclutter();\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    const layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    builderState.dirty = false;\n    for (let t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      const sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent =\n        sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const builderExtent = buffer(\n        sharedExtent,\n        layer.getRenderBuffer() * resolution,\n        this.tempExtent,\n      );\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent)\n        ? null\n        : builderExtent;\n      const builderGroup = new CanvasBuilderGroup(\n        0,\n        sharedExtent,\n        resolution,\n        pixelRatio,\n      );\n      const squaredTolerance = getSquaredRenderTolerance(\n        resolution,\n        pixelRatio,\n      );\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @param {number} [index] Render order index.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function (feature, index) {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            builderGroup,\n            declutter,\n            index,\n          );\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n        if (\n          !bufferedExtent ||\n          intersects(bufferedExtent, feature.getGeometry().getExtent())\n        ) {\n          render.call(this, feature, i);\n        }\n      }\n      const executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      const replayExtent =\n        layer.getRenderMode() !== 'vector' &&\n        declutter &&\n        sourceTiles.length === 1\n          ? null\n          : sharedExtent;\n      const renderingReplayGroup = new CanvasExecutorGroup(\n        replayExtent,\n        resolution,\n        pixelRatio,\n        source.getOverlaps(),\n        executorGroupInstructions,\n        layer.getRenderBuffer(),\n        true,\n      );\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    const source = layer.getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n\n    const hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      let key = feature.getId();\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          }),\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    const renderedTiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const layerUid = getUid(layer);\n    const declutter = layer.getDeclutter();\n    const declutteredFeatures = declutter\n      ? frameState.declutter?.[declutter]?.all().map((item) => item.value)\n      : null;\n    let found;\n    foundFeature: for (let i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      const tile = renderedTiles[i];\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      if (!intersects(tileExtent, hitExtent)) {\n        continue;\n      }\n\n      const executorGroups = tile.executorGroups[layerUid];\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        found = executorGroups[t].forEachFeatureAtCoordinate(\n          coordinate,\n          resolution,\n          rotation,\n          hitTolerance,\n          featureCallback,\n          declutteredFeatures,\n        );\n        if (found) {\n          break foundFeature;\n        }\n      }\n    }\n    return found;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature.js\").FeatureLike>>} Promise that resolves with an array of features.\n   * @override\n   */\n  getFeatures(pixel) {\n    if (this.renderedTiles.length === 0) {\n      return Promise.resolve([]);\n    }\n    return new Promise((resolve, reject) => {\n      const layer = this.getLayer();\n      const source = layer.getSource();\n      const projection = this.renderedProjection;\n      const projectionExtent = projection.getExtent();\n      const resolution = this.renderedResolution;\n      const tileGrid = source.getTileGridForProjection(projection);\n      const coordinate = applyTransform(\n        this.renderedPixelToCoordinateTransform_,\n        pixel.slice(),\n      );\n      const tileCoordString = tileGrid\n        .getTileCoordForCoordAndResolution(coordinate, resolution)\n        .toString();\n      const tile =\n        /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n          this.renderedTiles\n        ).find(\n          (tile) =>\n            tile.tileCoord.toString() === tileCoordString &&\n            tile.getState() === TileState.LOADED,\n        );\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n      if (\n        source.getWrapX() &&\n        projection.canWrapX() &&\n        !containsExtent(\n          projectionExtent,\n          tileGrid.getTileCoordExtent(tile.tileCoord),\n        )\n      ) {\n        wrapX(coordinate, projection);\n      }\n      const layerUid = getUid(layer);\n      const extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      const corner = getTopLeft(extent);\n      const tilePixel = [\n        (coordinate[0] - corner[0]) / resolution,\n        (corner[1] - coordinate[1]) / resolution,\n      ];\n      const features = tile\n        .getSourceTiles()\n        .reduce(\n          (accumulator, sourceTile) =>\n            accumulator.concat(sourceTile.getFeatures()),\n          /** @type {Array<import(\"../../Feature.js\").FeatureLike>} */ ([]),\n        );\n      let hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n      if (!hitDetectionImageData) {\n        const tileSize = toSize(\n          tileGrid.getTileSize(\n            tileGrid.getZForResolution(resolution, source.zDirection),\n          ),\n        );\n        const rotation = this.renderedRotation_;\n        const transforms = [\n          this.getRenderTransform(\n            tileGrid.getTileCoordCenter(tile.wrappedTileCoord),\n            resolution,\n            0,\n            HIT_DETECT_RESOLUTION,\n            tileSize[0] * HIT_DETECT_RESOLUTION,\n            tileSize[1] * HIT_DETECT_RESOLUTION,\n            0,\n          ),\n        ];\n        hitDetectionImageData = createHitDetectionImageData(\n          tileSize,\n          transforms,\n          features,\n          layer.getStyleFunction(),\n          tileGrid.getTileCoordExtent(tile.wrappedTileCoord),\n          tile.getReplayState(layer).renderedResolution,\n          rotation,\n        );\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    });\n  }\n\n  /**\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @return {Array<import('../../Feature.js').FeatureLike>} Features.\n   */\n  getFeaturesInExtent(extent) {\n    /** @type {Array<import('../../Feature.js').FeatureLike>} */\n    const features = [];\n    const tileCache = this.getTileCache();\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      this.frameState.viewState.projection,\n    );\n    const z = tileGrid.getZForResolution(this.renderedResolution);\n    /** @type {Object<string, true>} */\n    const visitedSourceTiles = {};\n    tileCache.forEach((tile) => {\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const sourceTiles = tile.getSourceTiles();\n      for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        const sourceTile = sourceTiles[i];\n        const key = sourceTile.getKey();\n        if (key in visitedSourceTiles) {\n          continue;\n        }\n        visitedSourceTiles[key] = true;\n        const tileCoord = sourceTile.tileCoord;\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          const tileFeatures = sourceTile.getFeatures();\n          if (tileFeatures) {\n            for (let j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              const candidate = tileFeatures[j];\n              const geometry = candidate.getGeometry();\n              if (intersects(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @override\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   */\n  renderDeclutter(frameState, layerState) {\n    const context = this.context;\n    const alpha = context.globalAlpha;\n    context.globalAlpha = layerState.opacity;\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const scaledCanvasSize = [\n      this.context.canvas.width,\n      this.context.canvas.height,\n    ];\n    const declutter = this.getLayer().getDeclutter();\n    const declutterTree = declutter\n      ? frameState.declutter?.[declutter]\n      : undefined;\n    const layerUid = getUid(this.getLayer());\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    for (let i = 0, ii = tiles.length; i < ii; ++i) {\n      const tile = tiles[i];\n      const executorGroups = tile.executorGroups[layerUid];\n      if (executorGroups) {\n        for (let j = executorGroups.length - 1; j >= 0; --j) {\n          executorGroups[j].execute(\n            this.context,\n            scaledCanvasSize,\n            this.getTileRenderTransform(tile, frameState),\n            frameState.viewState.rotation,\n            hifi,\n            DECLUTTER,\n            declutterTree,\n          );\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderDeferredInternal(frameState) {\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const layerUid = getUid(this.getLayer());\n    const executorGroups = tiles.reduce((acc, tile, index) => {\n      tile.executorGroups[layerUid].forEach((executorGroup) =>\n        acc.push({\n          executorGroup,\n          index,\n        }),\n      );\n      return acc;\n    }, /** @type {Array<{executorGroup: CanvasExecutorGroup, index: number}>} */ ([]));\n\n    const executorGroupZIndexContexts = executorGroups.map(({executorGroup}) =>\n      executorGroup.getDeferredZIndexContexts(),\n    );\n    /** @type {Object<number, true>} */\n    const usedZIndices = {};\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroupZindexContext =\n        executorGroups[i].executorGroup.getDeferredZIndexContexts();\n      for (const key in executorGroupZindexContext) {\n        usedZIndices[key] = true;\n      }\n    }\n    const zIndexKeys = Object.keys(usedZIndices).map(Number).sort(ascending);\n    zIndexKeys.forEach((zIndex) => {\n      executorGroupZIndexContexts.forEach((zIndexContexts, i) => {\n        if (!zIndexContexts[zIndex]) {\n          return;\n        }\n        zIndexContexts[zIndex].forEach((zIndexContext) => {\n          const {executorGroup, index} = executorGroups[i];\n          const context = executorGroup.getRenderedContext();\n          const alpha = context.globalAlpha;\n          context.globalAlpha = this.renderedOpacity_;\n          const tileClipContext = this.tileClipContexts_[index];\n          if (tileClipContext) {\n            tileClipContext.draw(context);\n          }\n          zIndexContext.draw(context);\n          if (tileClipContext) {\n            context.restore();\n          }\n          context.globalAlpha = alpha;\n          zIndexContext.clear();\n        });\n        zIndexContexts[zIndex].length = 0;\n      });\n    });\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile The tile\n   * @param {import('../../Map.js').FrameState} frameState Current frame state\n   * @return {import('../../transform.js').Transform} Transform to use to render this tile\n   */\n  getTileRenderTransform(tile, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    const size = frameState.size;\n    const width = Math.round(size[0] * pixelRatio);\n    const height = Math.round(size[1] * pixelRatio);\n\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n    const tileCoord = tile.tileCoord;\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const worldOffset =\n      tileGrid.getTileCoordExtent(tileCoord, this.tempExtent)[0] -\n      tileExtent[0];\n    const transform = multiply(\n      scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio),\n      this.getRenderTransform(\n        center,\n        resolution,\n        rotation,\n        pixelRatio,\n        width,\n        height,\n        worldOffset,\n      ),\n    );\n    return transform;\n  }\n\n  /**\n   * Render the vectors for this layer.\n   * @param {CanvasRenderingContext2D} context Target context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  postRender(context, frameState) {\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n\n    this.renderedPixelToCoordinateTransform_ =\n      frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n    this.renderedOpacity_ =\n      frameState.layerStatesArray[frameState.layerIndex].opacity;\n\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const renderMode = layer.getRenderMode();\n    const alpha = context.globalAlpha;\n    context.globalAlpha = this.renderedOpacity_;\n    const declutter = layer.getDeclutter();\n    const replayTypes = declutter\n      ? VECTOR_REPLAYS[renderMode].filter((type) => !DECLUTTER.includes(type))\n      : VECTOR_REPLAYS[renderMode];\n    const viewState = frameState.viewState;\n    const rotation = viewState.rotation;\n    const tileSource = layer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection,\n    );\n\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const clips = [];\n    const clipZs = [];\n    const tileClipContexts = [];\n    const layerUid = getUid(layer);\n    let ready = true;\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile = tiles[i];\n      ready = ready && !tile.getReplayState(layer).dirty;\n      const executorGroups = tile.executorGroups[layerUid].filter((group) =>\n        group.hasExecutors(replayTypes),\n      );\n      if (executorGroups.length === 0) {\n        continue;\n      }\n      const transform = this.getTileRenderTransform(tile, frameState);\n      const currentZ = tile.tileCoord[0];\n      let contextSaved = false;\n      // Clip mask for regions in this tile that already filled by a higher z tile\n      const currentClip = executorGroups[0].getClipCoords(transform);\n      let clipContext = context;\n      let tileClipContext;\n      if (currentClip) {\n        tileClipContext = new ZIndexContext();\n        clipContext = tileClipContext.getContext();\n        for (let j = 0, jj = clips.length; j < jj; ++j) {\n          if (z !== currentZ && currentZ < clipZs[j]) {\n            const clip = clips[j];\n            if (\n              intersects(\n                [\n                  currentClip[0],\n                  currentClip[3],\n                  currentClip[4],\n                  currentClip[7],\n                ],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                clipContext.save();\n                contextSaved = true;\n              }\n              clipContext.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              clipContext.moveTo(currentClip[0], currentClip[1]);\n              clipContext.lineTo(currentClip[2], currentClip[3]);\n              clipContext.lineTo(currentClip[4], currentClip[5]);\n              clipContext.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              clipContext.moveTo(clip[6], clip[7]);\n              clipContext.lineTo(clip[4], clip[5]);\n              clipContext.lineTo(clip[2], clip[3]);\n              clipContext.lineTo(clip[0], clip[1]);\n              clipContext.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n      }\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        executorGroup.execute(\n          context,\n          [context.canvas.width, context.canvas.height],\n          transform,\n          rotation,\n          hifi,\n          replayTypes,\n          frameState.declutter?.[declutter],\n        );\n      }\n      if (contextSaved) {\n        if (clipContext === context) {\n          clipContext.restore();\n        } else {\n          tileClipContexts[i] = tileClipContext;\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n    this.ready = ready;\n    this.tileClipContexts_ = tileClipContexts;\n    if (!frameState.declutter) {\n      this.renderDeferredInternal(frameState);\n    }\n\n    super.postRender(context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {boolean} [declutter] Enable decluttering.\n   * @param {number} [index] Render order index.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    declutter,\n    index,\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            undefined,\n            declutter,\n            index,\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        undefined,\n        declutter,\n        index,\n      );\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  tileImageNeedsRender_(tile) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    if (layer.getRenderMode() === 'vector') {\n      return false;\n    }\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const resolution = tile.wantedResolution;\n    return (\n      replayState.renderedTileResolution !== resolution ||\n      replayState.renderedTileRevision !== revision\n    );\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  renderTileImage_(tile, frameState) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source = layer.getSource();\n    let pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const renderPixelRatio =\n      (frameState.pixelRatio / tile.wantedResolution) * tileResolution;\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext();\n\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.round(\n      Math.max(pixelRatio, renderPixelRatio / pixelRatio),\n    );\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      const canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tempExtent);\n    const pixelScale = renderPixelRatio / resolution;\n    const transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroup = executorGroups[i];\n      executorGroup.execute(\n        context,\n        [\n          context.canvas.width * renderScale,\n          context.canvas.height * renderScale,\n        ],\n        transform,\n        0,\n        true,\n        IMAGE_REPLAYS[layer.getRenderMode()],\n        null,\n      );\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  }\n}\n\nexport default CanvasVectorTileLayerRenderer;\n","/**\n * @module ol/layer/VectorTile\n */\nimport {assert} from '../asserts.js';\nimport CanvasVectorTileLayerRenderer from '../renderer/canvas/VectorTileLayer.js';\nimport BaseVectorLayer from './BaseVector.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} VectorTileLayerOnSignature\n */\n\n/**\n * @typedef {'hybrid' | 'vector'} VectorTileRenderType\n */\n\n/***\n * @template T\n * @typedef {T extends import(\"../source/VectorTile.js\").default<infer U extends import(\"../Feature.js\").FeatureLike> ? U : never} ExtractedFeatureType\n */\n\n/**\n * @template {import(\"../source/VectorTile.js\").default<FeatureType>} [VectorTileSourceType=import(\"../source/VectorTile.js\").default<*>]\n * @template {import(\"../Feature\").FeatureLike} [FeatureType=ExtractedFeatureType<VectorTileSourceType>]\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the\n * renderer when getting features from the vector tile for the rendering or hit-detection.\n * Recommended value: Vector tiles are usually generated with a buffer, so this value should match\n * the largest possible buffer of the used tiles. It should be at least the size of the largest\n * point symbol or line width.\n * @property {VectorTileRenderType} [renderMode='hybrid'] Render mode for vector tiles:\n *  `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom\n *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on\n *    rotated views, but get lifted above all polygon and line elements.\n *  `'vector'`: Everything is rendered as vectors and the original render order is maintained. Use\n *    this mode for improved performance and visual epxerience on vector tile layers with not too many\n *    rendered features (e.g. for highlighting a subset of features of another layer with the same\n *    source).\n * @property {VectorTileSourceType} [source] Source.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * @property {boolean|string|number} [declutter=false] Declutter images and text. Any truthy value will enable\n * decluttering. Within a layer, a feature rendered before another has higher priority. All layers with the\n * same `declutter` value will be decluttered together. The priority is determined by the drawing order of the\n * layers with the same `declutter` value. Higher in the layer stack means higher priority. To declutter distinct\n * layers or groups of layers separately, use different truthy values for `declutter`.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer\n * style. When set to `null`, only\n * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style\n * which will be used if this is not set.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no\n * background will be rendered.\n * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be\n * recreated during animations. This means that no vectors will be shown clipped, but the setting\n * will have a performance impact for large amounts of vector data. When set to `false`, batches\n * will be recreated when no animation is active.\n * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be\n * recreated during interactions. See also `updateWhileAnimating`.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n * @property {number} [cacheSize=0] The internal tile cache size.  If too small, this will auto-grow to hold\n * two zoom levels worth of tiles.\n */\n\n/**\n * @classdesc\n * Layer for vector tile data that is rendered client-side.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/VectorTile.js\").default<FeatureType>} [VectorTileSourceType=import(\"../source/VectorTile.js\").default<*>]\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=ExtractedFeatureType<VectorTileSourceType>]\n * @extends {BaseVectorLayer<FeatureType, VectorTileSourceType, CanvasVectorTileLayerRenderer>}\n * @api\n */\nclass VectorTileLayer extends BaseVectorLayer {\n  /**\n   * @param {Options<VectorTileSourceType, FeatureType>} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n    delete baseOptions.preload;\n    const cacheSize = options.cacheSize === undefined ? 0 : options.cacheSize;\n    delete options.cacheSize;\n    delete baseOptions.useInterimTilesOnError;\n\n    super(baseOptions);\n\n    /***\n     * @type {VectorTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {VectorTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {VectorTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n\n    const renderMode = options.renderMode || 'hybrid';\n    assert(\n      renderMode == 'hybrid' || renderMode == 'vector',\n      \"`renderMode` must be `'hybrid'` or `'vector'`\",\n    );\n\n    /**\n     * @private\n     * @type {VectorTileRenderType}\n     */\n    this.renderMode_ = renderMode;\n\n    this.setPreload(options.preload ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true,\n    );\n\n    /**\n     * @return {import(\"./Base.js\").BackgroundColor} Background color.\n     * @function\n     * @api\n     */\n    this.getBackground;\n\n    /**\n     * @param {import(\"./Base.js\").BackgroundColor} background Background color.\n     * @function\n     * @api\n     */\n    this.setBackground;\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    return new CanvasVectorTileLayerRenderer(this, {\n      cacheSize: this.cacheSize_,\n    });\n  }\n\n  /**\n   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise\n   * that resolves with an array of features. The array will either contain the topmost feature\n   * when a hit was detected, or it will be empty.\n   *\n   * The hit detection algorithm used for this method is optimized for performance, but is less\n   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import(\"../Map.js\").default#getFeaturesAtPixel}.\n   * Text is not considered, and icons are only represented by their bounding box instead of the exact\n   * image.\n   *\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with an array of features.\n   * @api\n   * @override\n   */\n  getFeatures(pixel) {\n    return super.getFeatures(pixel);\n  }\n\n  /**\n   * Get features whose bounding box intersects the provided extent. Only features for cached\n   * tiles for the last rendered zoom level are available in the source. So this method is only\n   * suitable for requesting tiles for extents that are currently rendered.\n   *\n   * Features are returned in random tile order and as they are included in the tiles. This means\n   * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   */\n  getFeaturesInExtent(extent) {\n    return /** @type {Array<FeatureType>} */ (\n      /** @type {*} */ (this.getRenderer().getFeaturesInExtent(extent))\n    );\n  }\n\n  /**\n   * @return {VectorTileRenderType} The render mode.\n   */\n  getRenderMode() {\n    return this.renderMode_;\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Deprecated.  Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Deprecated.  Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n}\n\nexport default VectorTileLayer;\n"],"names":["IMAGE_REPLAYS","VECTOR_REPLAYS","CanvasVectorTileLayerRenderer","constructor","layer","options","super","this","boundHandleStyleImageChange_","handleStyleImageChange_","bind","renderedLayerRevision_","renderedPixelToCoordinateTransform_","renderedRotation_","renderedOpacity_","tmpTransform_","tileClipContexts_","drawTile","tile","frameState","x","y","w","h","gutter","transition","updateExecutorGroup_","pixelRatio","viewState","projection","tileImageNeedsRender_","renderTileImage_","getTile","z","getOrCreateTile","resolution","viewHints","hifi","ViewHint","ANIMATING","INTERACTING","wantedResolution","prepareFrame","layerRevision","getLayer","getRevision","renderedTiles","length","revision","renderOrder","getRenderOrder","builderState","getReplayState","dirty","renderedResolution","renderedRevision","renderedRenderOrder","source","getSource","declutter","getDeclutter","sourceTileGrid","getTileGrid","tileGrid","getTileGridForProjection","tileExtent","getTileCoordExtent","wrappedTileCoord","sourceTiles","getSourceTiles","layerUid","hitDetectionImageData","executorGroups","t","tt","sourceTile","getState","TileState","LOADED","sourceTileCoord","tileCoord","sourceTileExtent","sharedExtent","builderExtent","getRenderBuffer","tempExtent","bufferedExtent","builderGroup","squaredTolerance","render","feature","index","styles","styleFunction","getStyleFunction","renderFeature","features","getFeatures","sort","i","ii","getGeometry","getExtent","call","executorGroupInstructions","finish","replayExtent","getRenderMode","renderingReplayGroup","getOverlaps","push","forEachFeatureAtCoordinate","coordinate","hitTolerance","callback","matches","rotation","undefined","hitExtent","featureCallback","geometry","distanceSq","key","getId","match","splice","lastIndexOf","declutteredFeatures","all","map","item","value","found","foundFeature","pixel","Promise","resolve","reject","renderedProjection","projectionExtent","slice","tileCoordString","getTileCoordForCoordAndResolution","toString","find","loadingSourceTiles","getWrapX","canWrapX","extent","corner","tilePixel","reduce","accumulator","concat","tileSize","getTileSize","getZForResolution","zDirection","transforms","getRenderTransform","getTileCoordCenter","getFeaturesInExtent","tileCache","getTileCache","getCount","visitedSourceTiles","forEach","getKey","tileFeatures","j","jj","candidate","handleFontsChanged","getVisible","changed","event","renderIfReadyAndVisible","renderDeclutter","layerState","context","alpha","globalAlpha","opacity","scaledCanvasSize","canvas","width","height","declutterTree","tiles","execute","getTileRenderTransform","renderDeferredInternal","acc","executorGroup","executorGroupZIndexContexts","getDeferredZIndexContexts","usedZIndices","executorGroupZindexContext","zIndexKeys","Object","keys","Number","zIndex","zIndexContexts","zIndexContext","getRenderedContext","tileClipContext","draw","restore","clear","center","size","Math","round","worldOffset","transform","inversePixelTransform","postRender","pixelToCoordinateTransform","layerStatesArray","layerIndex","renderMode","replayTypes","filter","type","includes","tileSource","clips","clipZs","tileClipContexts","ready","group","hasExecutors","currentZ","contextSaved","currentClip","getClipCoords","clipContext","ZIndexContext","getContext","clip","save","beginPath","moveTo","lineTo","loading","Array","isArray","replayState","renderedTileResolution","renderedTileRevision","tileResolution","getResolution","renderPixelRatio","max","getTilePixelSize","renderScale","canvasTransform","setTransform","apply","pixelScale","VectorTileLayer","BaseVector","baseOptions","assign","preload","cacheSize","useInterimTilesOnError","on","once","un","cacheSize_","renderMode_","setPreload","setUseInterimTilesOnError","getBackground","setBackground","createRenderer","getRenderer","getPreload","get","TileProperty","PRELOAD","getUseInterimTilesOnError","USE_INTERIM_TILES_ON_ERROR","set"],"sourceRoot":""}