{"version":3,"file":"js/1918.4d478a25.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/tilegrid.js","webpack://@radiantearth/stac-browser/./node_modules/ol/Tile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/DataTile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/Tile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/GeoTIFF.js","webpack://@radiantearth/stac-browser/./node_modules/ol/vec/mat4.js"],"sourcesContent":["/**\n * @module ol/tilegrid\n */\nimport {\n  containsCoordinate,\n  createOrUpdate,\n  getCorner,\n  getHeight,\n  getWidth,\n} from './extent.js';\nimport {METERS_PER_UNIT, get as getProjection} from './proj.js';\nimport {toSize} from './size.js';\nimport TileGrid from './tilegrid/TileGrid.js';\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\n\nexport {TileGrid};\nexport {default as WMTS} from './tilegrid/WMTS.js';\n\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n  let tileGrid = projection.getDefaultTileGrid();\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n  return tileGrid;\n}\n\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n  const z = tileCoord[0];\n  const center = tileGrid.getTileCoordCenter(tileCoord);\n  const projectionExtent = extentFromProjection(projection);\n  if (!containsCoordinate(projectionExtent, center)) {\n    const worldWidth = getWidth(projectionExtent);\n    const worldsAway = Math.ceil(\n      (projectionExtent[0] - center[0]) / worldWidth,\n    );\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\n  }\n  return tileCoord;\n}\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, maxZoom, tileSize, corner) {\n  corner = corner !== undefined ? corner : 'top-left';\n\n  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);\n\n  return new TileGrid({\n    extent: extent,\n    origin: getCorner(extent, corner),\n    resolutions: resolutions,\n    tileSize: tileSize,\n  });\n}\n\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions} [options] Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(options) {\n  const xyzOptions = options || {};\n\n  const extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n\n  const gridOptions = {\n    extent: extent,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(\n      extent,\n      xyzOptions.maxZoom,\n      xyzOptions.tileSize,\n      xyzOptions.maxResolution,\n    ),\n  };\n  return new TileGrid(gridOptions);\n}\n\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number} [maxResolution] Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {\n  maxZoom = maxZoom !== undefined ? maxZoom : DEFAULT_MAX_ZOOM;\n  tileSize = toSize(tileSize !== undefined ? tileSize : DEFAULT_TILE_SIZE);\n\n  const height = getHeight(extent);\n  const width = getWidth(extent);\n\n  maxResolution =\n    maxResolution > 0\n      ? maxResolution\n      : Math.max(width / tileSize[0], height / tileSize[1]);\n\n  const length = maxZoom + 1;\n  const resolutions = new Array(length);\n  for (let z = 0; z < length; ++z) {\n    resolutions[z] = maxResolution / Math.pow(2, z);\n  }\n  return resolutions;\n}\n\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, maxZoom, tileSize, corner) {\n  const extent = extentFromProjection(projection);\n  return createForExtent(extent, maxZoom, tileSize, corner);\n}\n\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n  projection = getProjection(projection);\n  let extent = projection.getExtent();\n  if (!extent) {\n    const half =\n      (180 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit();\n    extent = createOrUpdate(-half, -half, half, half);\n  }\n  return extent;\n}\n","/**\n * @module ol/Tile\n */\nimport TileState from './TileState.js';\nimport {easeIn} from './easing.js';\nimport EventType from './events/EventType.js';\nimport EventTarget from './events/Target.js';\nimport {abstract} from './util.js';\n\n/**\n * A function that takes a {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState.js';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   const xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     const data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes a {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * A key assigned to the tile. This is used in conjunction with a source key\n     * to determine if a cached version of this tile may be used by the renderer.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @private\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n\n    /**\n     * @type {boolean}\n     */\n    this.interpolate = !!options.interpolate;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {\n    // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`\n    this.setState(TileState.EMPTY);\n  }\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state === TileState.EMPTY) {\n      // no more state changes\n      return;\n    }\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    this.release();\n    super.disposeInternal();\n  }\n}\n\nexport default Tile;\n","/**\n * @module ol/DataTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\n\n/**\n * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike\n */\n\n/**\n * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike\n */\n\n/**\n * Data that can be used with a DataTile.\n * @typedef {ArrayLike|ImageLike} Data\n */\n\n/**\n * @param {Data} data Tile data.\n * @return {ImageLike|null} The image-like data.\n */\nexport function asImageLike(data) {\n  return data instanceof Image ||\n    data instanceof HTMLCanvasElement ||\n    data instanceof HTMLVideoElement ||\n    data instanceof ImageBitmap\n    ? data\n    : null;\n}\n\n/**\n * @param {Data} data Tile data.\n * @return {ArrayLike|null} The array-like data.\n */\nexport function asArrayLike(data) {\n  return data instanceof Uint8Array ||\n    data instanceof Uint8ClampedArray ||\n    data instanceof Float32Array ||\n    data instanceof DataView\n    ? data\n    : null;\n}\n\n/**\n * This is set as the cancellation reason when a tile is disposed.\n */\nexport const disposedError = new Error('disposed');\n\n/**\n * @type {CanvasRenderingContext2D|null}\n */\nlet sharedContext = null;\n\n/**\n * @param {ImageLike} image The image.\n * @return {Uint8ClampedArray} The data.\n */\nexport function toArray(image) {\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(\n      image.width,\n      image.height,\n      undefined,\n      {willReadFrequently: true},\n    );\n  }\n  const canvas = sharedContext.canvas;\n  const width = image.width;\n  if (canvas.width !== width) {\n    canvas.width = width;\n  }\n  const height = image.height;\n  if (canvas.height !== height) {\n    canvas.height = height;\n  }\n  sharedContext.clearRect(0, 0, width, height);\n  sharedContext.drawImage(image, 0, 0);\n  return sharedContext.getImageData(0, 0, width, height).data;\n}\n\n/**\n * @type {import('./size.js').Size}\n */\nconst defaultSize = [256, 256];\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,\n * the promise should not resolve until the image is loaded.\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {import('./size.js').Size} [size=[256, 256]] Tile size.\n * @property {AbortController} [controller] An abort controller.\n * @api\n */\n\nclass DataTile extends Tile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    const state = TileState.IDLE;\n\n    super(options.tileCoord, state, {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    });\n\n    /**\n     * @type {function(): Promise<Data>}\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @type {Data}\n     * @private\n     */\n    this.data_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {import('./size.js').Size|null}\n     * @private\n     */\n    this.size_ = options.size || null;\n\n    /**\n     * @type {AbortController|null}\n     * @private\n     */\n    this.controller_ = options.controller || null;\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('./size.js').Size} Tile size.\n   */\n  getSize() {\n    if (this.size_) {\n      return this.size_;\n    }\n    const imageData = asImageLike(this.data_);\n    if (imageData) {\n      return [imageData.width, imageData.height];\n    }\n    return defaultSize;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {Data} Tile data.\n   * @api\n   */\n  getData() {\n    return this.data_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @api\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Load the tile data.\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    const self = this;\n    this.loader_()\n      .then(function (data) {\n        self.data_ = data;\n        self.state = TileState.LOADED;\n        self.changed();\n      })\n      .catch(function (error) {\n        self.error_ = error;\n        self.state = TileState.ERROR;\n        self.changed();\n      });\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    if (this.controller_) {\n      this.controller_.abort(disposedError);\n      this.controller_ = null;\n    }\n    super.disposeInternal();\n  }\n}\n\nexport default DataTile;\n","/**\n * @module ol/source/Tile\n */\nimport Event from '../events/Event.js';\nimport {scale as scaleSize, toSize} from '../size.js';\nimport {withinExtentAndZ} from '../tilecoord.js';\nimport {\n  getForProjection as getTileGridForProjection,\n  wrapX,\n} from '../tilegrid.js';\nimport {abstract, getUid} from '../util.js';\nimport Source from './Source.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./TileEventType\").TileSourceEventTypes, TileSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     import(\"./TileEventType\").TileSourceEventTypes, Return>} TileSourceOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./Source.js\").State} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {boolean} [wrapX=false] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n *\n * @template {import(\"../Tile.js\").default} [TileType=import(\"../Tile.js\").default]\n * @abstract\n * @api\n */\nclass TileSource extends Source {\n  /**\n   * @param {Options} options SourceTile source options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: options.projection,\n      state: options.state,\n      wrapX: options.wrapX,\n      interpolate: options.interpolate,\n    });\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {TileSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilePixelRatio_ =\n      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n\n    /**\n     * @type {import(\"../tilegrid/TileGrid.js\").default|null}\n     * @protected\n     */\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n\n    const tileSize = [256, 256];\n    if (this.tileGrid) {\n      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);\n    }\n\n    /**\n     * @protected\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize = [0, 0];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.key_ = options.key || getUid(this);\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").Options}\n     */\n    this.tileOptions = {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    };\n\n    /**\n     * zDirection hint, read by the renderer. Indicates which resolution should be used\n     * by a renderer if the views resolution does not match any resolution of the tile source.\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n     * will be used. If -1, the nearest higher resolution will be used.\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\n     */\n    this.zDirection = options.zDirection ? options.zDirection : 0;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  getGutterForProjection(projection) {\n    return 0;\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   */\n  getKey() {\n    return this.key_;\n  }\n\n  /**\n   * Set the value to be used as the key for all tiles in the source.\n   * @param {string} key The key for tiles.\n   * @protected\n   */\n  setKey(key) {\n    if (this.key_ !== key) {\n      this.key_ = key;\n      this.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   * @override\n   */\n  getResolutions(projection) {\n    const tileGrid = projection\n      ? this.getTileGridForProjection(projection)\n      : this.tileGrid;\n    if (!tileGrid) {\n      return null;\n    }\n    return tileGrid.getResolutions();\n  }\n\n  /**\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {TileType|null} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    return abstract();\n  }\n\n  /**\n   * Return the tile grid of the tile source.\n   * @return {import(\"../tilegrid/TileGrid.js\").default|null} Tile grid.\n   * @api\n   */\n  getTileGrid() {\n    return this.tileGrid;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    if (!this.tileGrid) {\n      return getTileGridForProjection(projection);\n    }\n    return this.tileGrid;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source. Subclasses may override this\n   * method, which is meant to return a supported pixel ratio that matches the\n   * provided `pixelRatio` as close as possible.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return this.tilePixelRatio_;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    if (tilePixelRatio == 1) {\n      return tileSize;\n    }\n    return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n  }\n\n  /**\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n   * is outside the resolution and extent range of the tile grid, `null` will be\n   * returned.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n   *     null if no tile URL should be created for the passed `tileCoord`.\n   */\n  getTileCoordForTileUrlFunction(tileCoord, projection) {\n    const gridProjection =\n      projection !== undefined ? projection : this.getProjection();\n    const tileGrid =\n      projection !== undefined\n        ? this.getTileGridForProjection(gridProjection)\n        : this.tileGrid || this.getTileGridForProjection(gridProjection);\n    if (this.getWrapX() && gridProjection.isGlobal()) {\n      tileCoord = wrapX(tileGrid, tileCoord, gridProjection);\n    }\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n  }\n\n  /**\n   * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.\n   * @api\n   */\n  clear() {}\n\n  /**\n   * @override\n   */\n  refresh() {\n    this.clear();\n    super.refresh();\n  }\n}\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\nexport class TileSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Tile.js\").default} tile The tile.\n   */\n  constructor(type, tile) {\n    super(type);\n\n    /**\n     * The tile related to the event.\n     * @type {import(\"../Tile.js\").default}\n     * @api\n     */\n    this.tile = tile;\n  }\n}\n\nexport default TileSource;\n","/**\n * @module ol/source/GeoTIFF\n */\nimport {\n  Pool,\n  fromBlob as tiffFromBlob,\n  fromUrl as tiffFromUrl,\n  fromUrls as tiffFromUrls,\n  globals as geotiffGlobals,\n} from 'geotiff';\nimport {error as logError} from '../console.js';\nimport {applyTransform, getCenter, getIntersection} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {fromCode as unitsFromCode} from '../proj/Units.js';\nimport {\n  Projection,\n  createTransformFromCoordinateTransform,\n  get as getCachedProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport {\n  apply as applyMatrix,\n  create as createMatrix,\n  makeInverse,\n  multiply as multiplyTransform,\n} from '../transform.js';\nimport DataTile from './DataTile.js';\n\n/**\n * Determine if an image type is a mask.\n * See https://www.awaresystems.be/imaging/tiff/tifftags/newsubfiletype.html\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} The image is a mask.\n */\nfunction isMask(image) {\n  const fileDirectory = image.fileDirectory;\n  const type = fileDirectory.NewSubfileType || 0;\n  return (type & 4) === 4;\n}\n\n/**\n * @param {true|false|'auto'} preference The convertToRGB option.\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} Use the `image.readRGB()` method.\n */\nfunction readRGB(preference, image) {\n  if (!preference) {\n    return false;\n  }\n  if (preference === true) {\n    return true;\n  }\n  if (image.getSamplesPerPixel() !== 3) {\n    return false;\n  }\n  const interpretation = image.fileDirectory.PhotometricInterpretation;\n  const interpretations = geotiffGlobals.photometricInterpretations;\n  return (\n    interpretation === interpretations.CMYK ||\n    interpretation === interpretations.YCbCr ||\n    interpretation === interpretations.CIELab ||\n    interpretation === interpretations.ICCLab\n  );\n}\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} [url] URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.\n * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\n */\n\n/**\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\n */\n\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\n\nconst STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nconst STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\n\nconst defaultTileSize = 256;\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\n */\n\nlet workerPool;\nfunction getWorkerPool() {\n  if (!workerPool) {\n    workerPool = new Pool();\n  }\n  return workerPool;\n}\n\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\nfunction getBoundingBox(image) {\n  try {\n    return image.getBoundingBox(true);\n  } catch {\n    return [0, 0, image.getWidth(), image.getHeight()];\n  }\n}\n\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\nfunction getOrigin(image) {\n  try {\n    return image.getOrigin().slice(0, 2);\n  } catch {\n    return [0, image.getHeight()];\n  }\n}\n\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {Array<number>} The map x and y units per pixel.\n */\nfunction getResolutions(image, referenceImage) {\n  try {\n    return image.getResolution(referenceImage);\n  } catch {\n    return [\n      referenceImage.getWidth() / image.getWidth(),\n      referenceImage.getHeight() / image.getHeight(),\n    ];\n  }\n}\n\n/**\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @return {import(\"../proj/Projection.js\").default} The image projection.\n */\nfunction getProjection(image) {\n  const geoKeys = image.geoKeys;\n  if (!geoKeys) {\n    return null;\n  }\n\n  if (\n    geoKeys.ProjectedCSTypeGeoKey &&\n    geoKeys.ProjectedCSTypeGeoKey !== 32767\n  ) {\n    const code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units,\n        });\n      }\n    }\n    return projection;\n  }\n\n  if (geoKeys.GeographicTypeGeoKey && geoKeys.GeographicTypeGeoKey !== 32767) {\n    const code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units,\n        });\n      }\n    }\n    return projection;\n  }\n\n  return null;\n}\n\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForTIFF(tiff) {\n  return tiff.getImageCount().then(function (count) {\n    const requests = new Array(count);\n    for (let i = 0; i < count; ++i) {\n      requests[i] = tiff.getImage(i);\n    }\n    return Promise.all(requests);\n  });\n}\n\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @param {Object} options Options for the GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForSource(source, options) {\n  let request;\n  if (source.blob) {\n    request = tiffFromBlob(source.blob);\n  } else if (source.overviews) {\n    request = tiffFromUrls(source.url, source.overviews, options);\n  } else {\n    request = tiffFromUrl(source.url, options);\n  }\n  return request.then(getImagesForTIFF);\n}\n\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n  if (Array.isArray(expected)) {\n    const length = expected.length;\n    if (!Array.isArray(got) || length != got.length) {\n      const error = new Error(message);\n      rejector(error);\n      throw error;\n    }\n    for (let i = 0; i < length; ++i) {\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\n    }\n    return;\n  }\n\n  got = /** @type {number} */ (got);\n  if (Math.abs(expected - got) > tolerance * expected) {\n    throw new Error(message);\n  }\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\nfunction getMinForDataType(array) {\n  if (array instanceof Int8Array) {\n    return -128;\n  }\n  if (array instanceof Int16Array) {\n    return -32768;\n  }\n  if (array instanceof Int32Array) {\n    return -2147483648;\n  }\n  if (array instanceof Float32Array) {\n    return 1.2e-38;\n  }\n  return 0;\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\nfunction getMaxForDataType(array) {\n  if (array instanceof Int8Array) {\n    return 127;\n  }\n  if (array instanceof Uint8Array) {\n    return 255;\n  }\n  if (array instanceof Uint8ClampedArray) {\n    return 255;\n  }\n  if (array instanceof Int16Array) {\n    return 32767;\n  }\n  if (array instanceof Uint16Array) {\n    return 65535;\n  }\n  if (array instanceof Int32Array) {\n    return 2147483647;\n  }\n  if (array instanceof Uint32Array) {\n    return 4294967295;\n  }\n  if (array instanceof Float32Array) {\n    return 3.4e38;\n  }\n  return 255;\n}\n\n/**\n * @typedef {Object} GeoTIFFSourceOptions\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\n * @property {string} [credentials] How credentials shall be handled. See\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\n * By default only a single range is used.\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\n * requested. Only use this when you know the source image to be small enough to fit in memory.\n * @property {number} [blockSize=65536] The block size to use.\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\n * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,\n * CIELab, and ICCLab images will automatically be converted to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Source projection.  If not provided, the GeoTIFF metadata\n * will be read for projection information.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * **Note for users of the full build**: The `GeoTIFF` source requires the\n * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.\n *\n * @api\n */\nclass GeoTIFFSource extends DataTile {\n  /**\n   * @param {Options} options Data tile options.\n   */\n  constructor(options) {\n    super({\n      state: 'loading',\n      tileGrid: null,\n      projection: options.projection || null,\n      transition: options.transition,\n      interpolate: options.interpolate !== false,\n      wrapX: options.wrapX,\n    });\n\n    /**\n     * @type {Array<SourceInfo>}\n     * @private\n     */\n    this.sourceInfo_ = options.sources;\n\n    const numSources = this.sourceInfo_.length;\n\n    /**\n     * @type {Object}\n     * @private\n     */\n    this.sourceOptions_ = options.sourceOptions;\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    this.sourceImagery_ = new Array(numSources);\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    this.sourceMasks_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.resolutionFactors_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.samplesPerPixel_;\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.nodataValues_;\n\n    /**\n     * @type {Array<Array<GDALMetadata>>}\n     * @private\n     */\n    this.metadata_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.normalize_ = options.normalize !== false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.addAlpha_ = false;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {true|false|'auto'}\n     * @private\n     */\n    this.convertToRGB_ = options.convertToRGB || false;\n\n    this.setKey(this.sourceInfo_.map((source) => source.url).join(','));\n\n    const self = this;\n    const requests = new Array(numSources);\n    for (let i = 0; i < numSources; ++i) {\n      requests[i] = getImagesForSource(\n        this.sourceInfo_[i],\n        this.sourceOptions_,\n      );\n    }\n    Promise.all(requests)\n      .then(function (sources) {\n        self.configure_(sources);\n      })\n      .catch(function (error) {\n        logError(error);\n        self.error_ = error;\n        self.setState('error');\n      });\n  }\n\n  /**\n   * @return {Error} A source loading error. When the source state is `error`, use this function\n   * to get more information about the error. To debug a faulty configuration, you may want to use\n   * a listener like\n   * ```js\n   * geotiffSource.on('change', () => {\n   *   if (geotiffSource.getState() === 'error') {\n   *     console.error(geotiffSource.getError());\n   *   }\n   * });\n   * ```\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Determine the projection of the images in this GeoTIFF.\n   * The default implementation looks at the ProjectedCSTypeGeoKey and the GeographicTypeGeoKey\n   * of each image in turn.\n   * You can override this method in a subclass to support more projections.\n   *\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   */\n  determineProjection(sources) {\n    const firstSource = sources[0];\n    for (let i = firstSource.length - 1; i >= 0; --i) {\n      const image = firstSource[i];\n      const projection = getProjection(image);\n      if (projection) {\n        this.projection = projection;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Determine any transform matrix for the images in this GeoTIFF.\n   *\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   */\n  determineTransformMatrix(sources) {\n    const firstSource = sources[0];\n    for (let i = firstSource.length - 1; i >= 0; --i) {\n      const image = firstSource[i];\n      const modelTransformation = image.fileDirectory.ModelTransformation;\n      if (modelTransformation) {\n        // eslint-disable-next-line no-unused-vars\n        const [a, b, c, d, e, f, g, h] = modelTransformation;\n        const matrix = multiplyTransform(\n          multiplyTransform(\n            [\n              1 / Math.sqrt(a * a + e * e),\n              0,\n              0,\n              -1 / Math.sqrt(b * b + f * f),\n              d,\n              h,\n            ],\n            [a, e, b, f, 0, 0],\n          ),\n          [1, 0, 0, 1, -d, -h],\n        );\n        this.transformMatrix = matrix;\n        this.addAlpha_ = true;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n   * must have the same internal tiled structure.\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   * @private\n   */\n  configure_(sources) {\n    let extent;\n    let origin;\n    let commonRenderTileSizes;\n    let commonSourceTileSizes;\n    let resolutions;\n    const samplesPerPixel = new Array(sources.length);\n    const nodataValues = new Array(sources.length);\n    const metadata = new Array(sources.length);\n    let minZoom = 0;\n\n    const sourceCount = sources.length;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const images = [];\n      const masks = [];\n      sources[sourceIndex].forEach((item) => {\n        if (isMask(item)) {\n          masks.push(item);\n        } else {\n          images.push(item);\n        }\n      });\n\n      const imageCount = images.length;\n      if (masks.length > 0 && masks.length !== imageCount) {\n        throw new Error(\n          `Expected one mask per image found ${masks.length} masks and ${imageCount} images`,\n        );\n      }\n\n      let sourceExtent;\n      let sourceOrigin;\n      const sourceTileSizes = new Array(imageCount);\n      const renderTileSizes = new Array(imageCount);\n      const sourceResolutions = new Array(imageCount);\n\n      nodataValues[sourceIndex] = new Array(imageCount);\n      metadata[sourceIndex] = new Array(imageCount);\n\n      for (let imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\n        const image = images[imageIndex];\n        const nodataValue = image.getGDALNoData();\n        metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\n        nodataValues[sourceIndex][imageIndex] = nodataValue;\n\n        const wantedSamples = this.sourceInfo_[sourceIndex].bands;\n        samplesPerPixel[sourceIndex] = wantedSamples\n          ? wantedSamples.length\n          : image.getSamplesPerPixel();\n        const level = imageCount - (imageIndex + 1);\n\n        if (!sourceExtent) {\n          sourceExtent = getBoundingBox(image);\n        }\n\n        if (!sourceOrigin) {\n          sourceOrigin = getOrigin(image);\n        }\n\n        const imageResolutions = getResolutions(image, images[0]);\n        sourceResolutions[level] = imageResolutions[0];\n\n        const sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\n\n        // request larger blocks for untiled layouts\n        if (\n          sourceTileSize[0] !== sourceTileSize[1] &&\n          sourceTileSize[1] < defaultTileSize\n        ) {\n          sourceTileSize[0] = defaultTileSize;\n          sourceTileSize[1] = defaultTileSize;\n        }\n\n        sourceTileSizes[level] = sourceTileSize;\n\n        const aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\n        renderTileSizes[level] = [\n          sourceTileSize[0],\n          sourceTileSize[1] / aspectRatio,\n        ];\n      }\n\n      if (!extent) {\n        extent = sourceExtent;\n      } else {\n        getIntersection(extent, sourceExtent, extent);\n      }\n\n      if (!origin) {\n        origin = sourceOrigin;\n      } else {\n        const message = `Origin mismatch for source ${sourceIndex}, got [${sourceOrigin}] but expected [${origin}]`;\n        assertEqual(origin, sourceOrigin, 0, message, this.viewRejector);\n      }\n\n      if (!resolutions) {\n        resolutions = sourceResolutions;\n        this.resolutionFactors_[sourceIndex] = 1;\n      } else {\n        if (resolutions.length - minZoom > sourceResolutions.length) {\n          minZoom = resolutions.length - sourceResolutions.length;\n        }\n        const resolutionFactor =\n          resolutions[resolutions.length - 1] /\n          sourceResolutions[sourceResolutions.length - 1];\n        this.resolutionFactors_[sourceIndex] = resolutionFactor;\n        const scaledSourceResolutions = sourceResolutions.map(\n          (resolution) => (resolution *= resolutionFactor),\n        );\n        const message = `Resolution mismatch for source ${sourceIndex}, got [${scaledSourceResolutions}] but expected [${resolutions}]`;\n        assertEqual(\n          resolutions.slice(minZoom, resolutions.length),\n          scaledSourceResolutions,\n          0.02,\n          message,\n          this.viewRejector,\n        );\n      }\n\n      if (!commonRenderTileSizes) {\n        commonRenderTileSizes = renderTileSizes;\n      } else {\n        assertEqual(\n          commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length),\n          renderTileSizes,\n          0.01,\n          `Tile size mismatch for source ${sourceIndex}`,\n          this.viewRejector,\n        );\n      }\n\n      if (!commonSourceTileSizes) {\n        commonSourceTileSizes = sourceTileSizes;\n      } else {\n        assertEqual(\n          commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length),\n          sourceTileSizes,\n          0,\n          `Tile size mismatch for source ${sourceIndex}`,\n          this.viewRejector,\n        );\n      }\n\n      this.sourceImagery_[sourceIndex] = images.reverse();\n      this.sourceMasks_[sourceIndex] = masks.reverse();\n    }\n\n    for (let i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n      const sourceImagery = this.sourceImagery_[i];\n      while (sourceImagery.length < resolutions.length) {\n        sourceImagery.unshift(undefined);\n      }\n    }\n\n    if (!this.getProjection()) {\n      this.determineProjection(sources);\n    }\n    this.determineTransformMatrix(sources);\n\n    this.samplesPerPixel_ = samplesPerPixel;\n    this.nodataValues_ = nodataValues;\n    this.metadata_ = metadata;\n\n    // decide if we need to add an alpha band to handle nodata\n    outer: for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      // option 1: source is configured with a nodata value\n      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\n        this.addAlpha_ = true;\n        break;\n      }\n      if (this.sourceMasks_[sourceIndex].length) {\n        this.addAlpha_ = true;\n        break;\n      }\n\n      const values = nodataValues[sourceIndex];\n\n      // option 2: check image metadata for limited bands\n      const bands = this.sourceInfo_[sourceIndex].bands;\n      if (bands) {\n        for (let i = 0; i < bands.length; ++i) {\n          if (values[bands[i] - 1] !== null) {\n            this.addAlpha_ = true;\n            break outer;\n          }\n        }\n        continue;\n      }\n\n      // option 3: check image metadata for all bands\n      for (let imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n        if (values[imageIndex] !== null) {\n          this.addAlpha_ = true;\n          break outer;\n        }\n      }\n    }\n\n    let bandCount = this.addAlpha_ ? 1 : 0;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      bandCount += samplesPerPixel[sourceIndex];\n    }\n    this.bandCount = bandCount;\n\n    const tileGrid = new TileGrid({\n      extent: extent,\n      minZoom: minZoom,\n      origin: origin,\n      resolutions: resolutions,\n      tileSizes: commonRenderTileSizes,\n    });\n\n    this.tileGrid = tileGrid;\n    this.setTileSizes(commonSourceTileSizes);\n\n    this.setLoader(this.loadTile_.bind(this));\n    this.setState('ready');\n\n    const zoom = 1;\n    if (resolutions.length === 2) {\n      resolutions = [resolutions[0], resolutions[1], resolutions[1] / 2];\n    } else if (resolutions.length === 1) {\n      resolutions = [resolutions[0] * 2, resolutions[0], resolutions[0] / 2];\n    }\n\n    let viewExtent = extent;\n    if (this.transformMatrix) {\n      const matrix = makeInverse(createMatrix(), this.transformMatrix.slice());\n      const transformFn = createTransformFromCoordinateTransform((input) =>\n        applyMatrix(matrix, input),\n      );\n      viewExtent = applyTransform(extent, transformFn);\n    }\n\n    this.viewResolver({\n      showFullExtent: true,\n      projection: this.projection,\n      resolutions: resolutions,\n      center: toUserCoordinate(getCenter(viewExtent), this.projection),\n      extent: toUserExtent(viewExtent, this.projection),\n      zoom: zoom,\n    });\n  }\n\n  /**\n   * @param {number} z The z tile index.\n   * @param {number} x The x tile index.\n   * @param {number} y The y tile index.\n   * @param {import('./DataTile.js').LoaderOptions} options The loader options.\n   * @return {Promise} The composed tile data.\n   * @private\n   */\n  loadTile_(z, x, y, options) {\n    const sourceTileSize = this.getTileSize(z);\n    const sourceCount = this.sourceImagery_.length;\n    const requests = new Array(sourceCount * 2);\n    const nodataValues = this.nodataValues_;\n    const sourceInfo = this.sourceInfo_;\n    const pool = getWorkerPool();\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const source = sourceInfo[sourceIndex];\n      const resolutionFactor = this.resolutionFactors_[sourceIndex];\n      const pixelBounds = [\n        Math.round(x * (sourceTileSize[0] * resolutionFactor)),\n        Math.round(y * (sourceTileSize[1] * resolutionFactor)),\n        Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)),\n        Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor)),\n      ];\n      const image = this.sourceImagery_[sourceIndex][z];\n      let samples;\n      if (source.bands) {\n        samples = source.bands.map(function (bandNumber) {\n          return bandNumber - 1;\n        });\n      }\n\n      /** @type {number|Array<number>} */\n      let fillValue;\n      if ('nodata' in source && source.nodata !== null) {\n        fillValue = source.nodata;\n      } else {\n        if (!samples) {\n          fillValue = nodataValues[sourceIndex];\n        } else {\n          fillValue = samples.map(function (sampleIndex) {\n            return nodataValues[sourceIndex][sampleIndex];\n          });\n        }\n      }\n\n      const readOptions = {\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: samples,\n        fillValue: fillValue,\n        pool: pool,\n        interleave: false,\n        signal: options.signal,\n      };\n      if (readRGB(this.convertToRGB_, image)) {\n        requests[sourceIndex] = image.readRGB(readOptions);\n      } else {\n        requests[sourceIndex] = image.readRasters(readOptions);\n      }\n\n      // requests after `sourceCount` are for mask data (if any)\n      const maskIndex = sourceCount + sourceIndex;\n      const mask = this.sourceMasks_[sourceIndex][z];\n      if (!mask) {\n        requests[maskIndex] = Promise.resolve(null);\n        continue;\n      }\n\n      requests[maskIndex] = mask.readRasters({\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: [0],\n        pool: pool,\n        interleave: false,\n      });\n    }\n\n    return Promise.all(requests)\n      .then(this.composeTile_.bind(this, sourceTileSize))\n      .catch(function (error) {\n        logError(error);\n        throw error;\n      });\n  }\n\n  /**\n   * @param {import(\"../size.js\").Size} sourceTileSize The source tile size.\n   * @param {Array} sourceSamples The source samples.\n   * @return {import(\"../DataTile.js\").Data} The composed tile data.\n   * @private\n   */\n  composeTile_(sourceTileSize, sourceSamples) {\n    const metadata = this.metadata_;\n    const sourceInfo = this.sourceInfo_;\n    const sourceCount = this.sourceImagery_.length;\n    const bandCount = this.bandCount;\n    const samplesPerPixel = this.samplesPerPixel_;\n    const nodataValues = this.nodataValues_;\n    const normalize = this.normalize_;\n    const addAlpha = this.addAlpha_;\n\n    const pixelCount = sourceTileSize[0] * sourceTileSize[1];\n    const dataLength = pixelCount * bandCount;\n\n    /** @type {Uint8Array|Float32Array} */\n    let data;\n    if (normalize) {\n      data = new Uint8Array(dataLength);\n    } else {\n      data = new Float32Array(dataLength);\n    }\n\n    let dataIndex = 0;\n    for (let pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n      let transparent = addAlpha;\n      for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n        const source = sourceInfo[sourceIndex];\n\n        let min = source.min;\n        let max = source.max;\n        let gain, bias;\n        if (normalize) {\n          const stats = metadata[sourceIndex][0];\n          if (min === undefined) {\n            if (stats && STATISTICS_MINIMUM in stats) {\n              min = parseFloat(stats[STATISTICS_MINIMUM]);\n            } else {\n              min = getMinForDataType(sourceSamples[sourceIndex][0]);\n            }\n          }\n          if (max === undefined) {\n            if (stats && STATISTICS_MAXIMUM in stats) {\n              max = parseFloat(stats[STATISTICS_MAXIMUM]);\n            } else {\n              max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n            }\n          }\n\n          gain = 255 / (max - min);\n          bias = -min * gain;\n        }\n\n        for (\n          let sampleIndex = 0;\n          sampleIndex < samplesPerPixel[sourceIndex];\n          ++sampleIndex\n        ) {\n          const sourceValue =\n            sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n\n          let value;\n          if (normalize) {\n            value = clamp(gain * sourceValue + bias, 0, 255);\n          } else {\n            value = sourceValue;\n          }\n\n          if (!addAlpha) {\n            data[dataIndex] = value;\n          } else {\n            let nodata = source.nodata;\n            if (nodata === undefined) {\n              let bandIndex;\n              if (source.bands) {\n                bandIndex = source.bands[sampleIndex] - 1;\n              } else {\n                bandIndex = sampleIndex;\n              }\n              nodata = nodataValues[sourceIndex][bandIndex];\n            }\n\n            const nodataIsNaN = isNaN(nodata);\n            if (\n              (!nodataIsNaN && sourceValue !== nodata) ||\n              (nodataIsNaN && !isNaN(sourceValue))\n            ) {\n              transparent = false;\n              data[dataIndex] = value;\n            }\n          }\n          dataIndex++;\n        }\n        if (!transparent) {\n          const maskIndex = sourceCount + sourceIndex;\n          const mask = sourceSamples[maskIndex];\n          if (mask && !mask[0][pixelIndex]) {\n            transparent = true;\n          }\n        }\n      }\n      if (addAlpha) {\n        if (!transparent) {\n          data[dataIndex] = 255;\n        }\n        dataIndex++;\n      }\n    }\n\n    return data;\n  }\n}\n\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\nGeoTIFFSource.prototype.getView;\n\nexport default GeoTIFFSource;\n","/**\n * @module ol/vec/mat4\n */\n\n/** @typedef {Array<number>} Mat4 */\n\n/**\n * @return {Mat4} \"4x4 matrix representing a 3D identity transform.\"\n */\nexport function create() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n\n/**\n * @param {Mat4} mat4 Flattened 4x4 matrix receiving the result.\n * @param {import(\"../transform.js\").Transform} transform Transformation matrix.\n * @return {Mat4} \"2D transformation matrix as flattened 4x4 matrix.\"\n */\nexport function fromTransform(mat4, transform) {\n  mat4[0] = transform[0];\n  mat4[1] = transform[1];\n  mat4[4] = transform[2];\n  mat4[5] = transform[3];\n  mat4[12] = transform[4];\n  mat4[13] = transform[5];\n  return mat4;\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @param {Mat4} [out] mat4 frustum matrix will be written into\n * @return {Mat4} out\n */\nexport function orthographic(left, right, bottom, top, near, far, out) {\n  out = out ?? create();\n  const lr = 1 / (left - right),\n    bt = 1 / (bottom - top),\n    nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Scales the mat4 by the dimensions in the given vec3\n *\n * @param {Mat4} m The matrix to scale.\n * @param {number} x How much to scale in the x direction.\n * @param {number} y How much to scale in the y direction.\n * @param {number} z How much to scale in the z direction.\n * @param {Mat4} [out] The matrix to write to.\n * @return {Mat4} out\n */\nexport function scale(m, x, y, z, out) {\n  out = out ?? create();\n  out[0] = m[0] * x;\n  out[1] = m[1] * x;\n  out[2] = m[2] * x;\n  out[3] = m[3] * x;\n  out[4] = m[4] * y;\n  out[5] = m[5] * y;\n  out[6] = m[6] * y;\n  out[7] = m[7] * y;\n  out[8] = m[8] * z;\n  out[9] = m[9] * z;\n  out[10] = m[10] * z;\n  out[11] = m[11] * z;\n  out[12] = m[12];\n  out[13] = m[13];\n  out[14] = m[14];\n  out[15] = m[15];\n  return out;\n}\n\n/**\n * Translate a matrix.\n *\n * @param {Mat4} m the matrix to translate\n * @param {number} x How much to translate in the x direction.\n * @param {number} y How much to translate in the y direction.\n * @param {number} z How much to translate in the z direction.\n * @param {Mat4} [out] the receiving matrix\n * @return {Mat4} out\n */\nexport function translate(m, x, y, z, out) {\n  out = out ?? create();\n  let a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;\n\n  if (m === out) {\n    out[12] = m[0] * x + m[4] * y + m[8] * z + m[12];\n    out[13] = m[1] * x + m[5] * y + m[9] * z + m[13];\n    out[14] = m[2] * x + m[6] * y + m[10] * z + m[14];\n    out[15] = m[3] * x + m[7] * y + m[11] * z + m[15];\n  } else {\n    a00 = m[0];\n    a01 = m[1];\n    a02 = m[2];\n    a03 = m[3];\n    a10 = m[4];\n    a11 = m[5];\n    a12 = m[6];\n    a13 = m[7];\n    a20 = m[8];\n    a21 = m[9];\n    a22 = m[10];\n    a23 = m[11];\n\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n\n    out[12] = a00 * x + a10 * y + a20 * z + m[12];\n    out[13] = a01 * x + a11 * y + a21 * z + m[13];\n    out[14] = a02 * x + a12 * y + a22 * z + m[14];\n    out[15] = a03 * x + a13 * y + a23 * z + m[15];\n  }\n\n  return out;\n}\n\n/**\n * @param {number} x x translation.\n * @param {number} y y translation.\n * @param {number} z z translation.\n * @param {Mat4} [out] optional matrix to store result\n * @return {Mat4} out\n */\nexport function translation(x, y, z, out) {\n  out = out ?? create();\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = x;\n  out[13] = y;\n  out[14] = z;\n  out[15] = 1;\n\n  return out;\n}\n"],"names":["getForProjection","projection","tileGrid","getDefaultTileGrid","createForProjection","setDefaultTileGrid","wrapX","tileCoord","z","center","getTileCoordCenter","projectionExtent","extentFromProjection","worldWidth","worldsAway","Math","ceil","getTileCoordForCoordAndZ","createForExtent","extent","maxZoom","tileSize","corner","undefined","resolutions","resolutionsFromExtent","origin","createXYZ","options","xyzOptions","getExtent","gridOptions","minZoom","maxResolution","height","width","max","length","Array","pow","half","degrees","getMetersPerUnit","Tile","constructor","state","super","this","key","transition_","transition","transitionStarts_","interpolate","changed","dispatchEvent","CHANGE","release","setState","EMPTY","getKey","getTileCoord","getState","ERROR","Error","load","getAlpha","id","time","start","delta","inTransition","endTransition","disposeInternal","asImageLike","data","Image","HTMLCanvasElement","HTMLVideoElement","ImageBitmap","asArrayLike","Uint8Array","Uint8ClampedArray","Float32Array","DataView","disposedError","sharedContext","toArray","image","willReadFrequently","canvas","clearRect","drawImage","getImageData","defaultSize","DataTile","IDLE","loader_","loader","data_","error_","size_","size","controller_","controller","getSize","imageData","getData","getError","LOADING","self","then","LOADED","catch","error","abort","TileSource","attributions","attributionsCollapsible","on","once","un","tilePixelRatio_","tilePixelRatio","getTileSize","getMinZoom","tmpSize","key_","tileOptions","zDirection","getGutterForProjection","setKey","getResolutions","getTileGridForProjection","getTile","x","y","pixelRatio","getTileGrid","getTilePixelRatio","getTilePixelSize","getTileCoordForTileUrlFunction","gridProjection","getProjection","getWrapX","isGlobal","clear","refresh","TileSourceEvent","type","tile","isMask","fileDirectory","NewSubfileType","readRGB","preference","getSamplesPerPixel","interpretation","PhotometricInterpretation","interpretations","CMYK","YCbCr","CIELab","ICCLab","STATISTICS_MAXIMUM","STATISTICS_MINIMUM","defaultTileSize","workerPool","getWorkerPool","getBoundingBox","getWidth","getHeight","getOrigin","slice","referenceImage","getResolution","geoKeys","ProjectedCSTypeGeoKey","code","units","ProjLinearUnitsGeoKey","GeographicTypeGeoKey","GeogAngularUnitsGeoKey","getImagesForTIFF","tiff","getImageCount","count","requests","i","getImage","Promise","all","getImagesForSource","source","request","blob","overviews","url","assertEqual","expected","got","tolerance","message","rejector","isArray","abs","getMinForDataType","array","Int8Array","Int16Array","Int32Array","getMaxForDataType","Uint16Array","Uint32Array","GeoTIFFSource","sourceInfo_","sources","numSources","sourceOptions_","sourceOptions","sourceImagery_","sourceMasks_","resolutionFactors_","samplesPerPixel_","nodataValues_","metadata_","normalize_","normalize","addAlpha_","convertToRGB_","convertToRGB","map","join","configure_","determineProjection","firstSource","determineTransformMatrix","modelTransformation","ModelTransformation","a","b","c","d","e","f","g","h","matrix","sqrt","transformMatrix","commonRenderTileSizes","commonSourceTileSizes","samplesPerPixel","nodataValues","metadata","sourceCount","sourceIndex","images","masks","forEach","item","push","imageCount","sourceExtent","sourceOrigin","sourceTileSizes","renderTileSizes","sourceResolutions","imageIndex","nodataValue","getGDALNoData","getGDALMetadata","wantedSamples","bands","level","imageResolutions","sourceTileSize","getTileWidth","getTileHeight","aspectRatio","viewRejector","resolutionFactor","scaledSourceResolutions","resolution","reverse","ii","sourceImagery","unshift","outer","nodata","values","bandCount","tileSizes","setTileSizes","setLoader","loadTile_","bind","zoom","viewExtent","transformFn","input","viewResolver","showFullExtent","sourceInfo","pool","pixelBounds","round","samples","fillValue","bandNumber","sampleIndex","readOptions","window","interleave","signal","readRasters","maskIndex","mask","resolve","composeTile_","sourceSamples","addAlpha","pixelCount","dataLength","dataIndex","pixelIndex","transparent","gain","bias","min","stats","parseFloat","sourceValue","value","bandIndex","nodataIsNaN","isNaN","prototype","getView","create","fromTransform","mat4","transform","orthographic","left","right","bottom","top","near","far","out","lr","bt","nf","scale","m","translate","a00","a01","a02","a03","a10","a11","a12","a13","a20","a21","a22","a23","translation"],"ignoreList":[],"sourceRoot":""}