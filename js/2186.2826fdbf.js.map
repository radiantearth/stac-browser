{"version":3,"file":"js/2186.2826fdbf.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/net.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/OGCMapTile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/TileEventType.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/TileImage.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/UrlTile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/ogcTileUtil.js"],"sourcesContent":["/**\n * @module ol/net\n */\nimport {getUid} from './util.js';\n\n/**\n * Simple JSONP helper. Supports error callbacks and a custom callback param.\n * The error callback will be called when no JSONP is executed after 10 seconds.\n *\n * @param {string} url Request url. A 'callback' query parameter will be\n *     appended.\n * @param {Function} callback Callback on success.\n * @param {Function} [errback] Callback on error.\n * @param {string} [callbackParam] Custom query parameter for the JSONP\n *     callback. Default is 'callback'.\n */\nexport function jsonp(url, callback, errback, callbackParam) {\n  const script = document.createElement('script');\n  const key = 'olc_' + getUid(callback);\n  function cleanup() {\n    delete window[key];\n    script.parentNode.removeChild(script);\n  }\n  script.async = true;\n  script.src =\n    url +\n    (url.includes('?') ? '&' : '?') +\n    (callbackParam || 'callback') +\n    '=' +\n    key;\n  const timer = setTimeout(function () {\n    cleanup();\n    if (errback) {\n      errback();\n    }\n  }, 10000);\n  window[key] = function (data) {\n    clearTimeout(timer);\n    cleanup();\n    callback(data);\n  };\n  document.head.appendChild(script);\n}\n\nexport class ResponseError extends Error {\n  /**\n   * @param {XMLHttpRequest} response The XHR object.\n   */\n  constructor(response) {\n    const message = 'Unexpected response status: ' + response.status;\n    super(message);\n\n    /**\n     * @type {string}\n     */\n    this.name = 'ResponseError';\n\n    /**\n     * @type {XMLHttpRequest}\n     */\n    this.response = response;\n  }\n}\n\nexport class ClientError extends Error {\n  /**\n   * @param {XMLHttpRequest} client The XHR object.\n   */\n  constructor(client) {\n    super('Failed to issue request');\n\n    /**\n     * @type {string}\n     */\n    this.name = 'ClientError';\n\n    /**\n     * @type {XMLHttpRequest}\n     */\n    this.client = client;\n  }\n}\n\n/**\n * @param {string} url The URL.\n * @return {Promise<Object>} A promise that resolves to the JSON response.\n */\nexport function getJSON(url) {\n  return new Promise(function (resolve, reject) {\n    /**\n     * @param {ProgressEvent<XMLHttpRequest>} event The load event.\n     */\n    function onLoad(event) {\n      const client = event.target;\n      // status will be 0 for file:// urls\n      if (!client.status || (client.status >= 200 && client.status < 300)) {\n        let data;\n        try {\n          data = JSON.parse(client.responseText);\n        } catch (err) {\n          const message = 'Error parsing response text as JSON: ' + err.message;\n          reject(new Error(message));\n          return;\n        }\n        resolve(data);\n        return;\n      }\n\n      reject(new ResponseError(client));\n    }\n\n    /**\n     * @param {ProgressEvent<XMLHttpRequest>} event The error event.\n     */\n    function onError(event) {\n      reject(new ClientError(event.target));\n    }\n\n    const client = new XMLHttpRequest();\n    client.addEventListener('load', onLoad);\n    client.addEventListener('error', onError);\n    client.open('GET', url);\n    client.setRequestHeader('Accept', 'application/json');\n    client.send();\n  });\n}\n\n/**\n * @param {string} base The base URL.\n * @param {string} url The potentially relative URL.\n * @return {string} The full URL.\n */\nexport function resolveUrl(base, url) {\n  if (url.includes('://')) {\n    return url;\n  }\n  return new URL(url, base).href;\n}\n\nlet originalXHR;\nexport function overrideXHR(xhr) {\n  if (typeof XMLHttpRequest !== 'undefined') {\n    originalXHR = XMLHttpRequest;\n  }\n  global.XMLHttpRequest = xhr;\n}\n\nexport function restoreXHR() {\n  global.XMLHttpRequest = originalXHR;\n}\n","/**\n * @module ol/source/OGCMapTile\n */\nimport {error as logError} from '../console.js';\nimport TileImage from './TileImage.js';\nimport {getTileSetInfo} from './ogcTileUtil.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} url URL to the OGC Map Tileset endpoint.\n * @property {Object} [context] A lookup of values to use in the tile URL template.  The `{tileMatrix}`\n * (zoom level), `{tileRow}`, and `{tileCol}` variables in the URL will always be provided by the source.\n * @property {string} [mediaType] The content type for the tiles (e.g. \"image/png\").  If not provided,\n * the source will try to find a link with rel=\"item\" that uses a supported image type.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. By default, the projection\n * will be derived from the `crs` of the `tileMatrixSet`.  You can override this by supplying\n * a projection to the constructor.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(tile, src) {\n *   tile.getImage().src = src;\n * };\n * ```\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {Array<string>} [collections] A list of geospatial data sub-resources to include. If not provided, the entire dataset will\n * be included. This option is not applicable when requesting the tileset for a single collection.\n */\n\n/**\n * @classdesc\n * Layer source for map tiles from an [OGC API - Tiles](https://ogcapi.ogc.org/tiles/) service that provides \"map\" type tiles.\n * The service must conform to at least the core (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/core)\n * and tileset (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/tileset) conformance classes. For supporting the `collections`\n * option, the service must conform to the collections selection\n * (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/collections-selection) conformance class.\n * @api\n */\nclass OGCMapTile extends TileImage {\n  /**\n   * @param {Options} options OGC map tile options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate: options.interpolate,\n      projection: options.projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      state: 'loading',\n      tileLoadFunction: options.tileLoadFunction,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n    });\n\n    const sourceInfo = {\n      url: options.url,\n      projection: this.getProjection(),\n      mediaType: options.mediaType,\n      context: options.context || null,\n      collections: options.collections,\n    };\n\n    getTileSetInfo(sourceInfo)\n      .then(this.handleTileSetInfo_.bind(this))\n      .catch(this.handleError_.bind(this));\n  }\n\n  /**\n   * @param {import(\"./ogcTileUtil.js\").TileSetInfo} tileSetInfo Tile set info.\n   * @private\n   */\n  handleTileSetInfo_(tileSetInfo) {\n    this.tileGrid = tileSetInfo.grid;\n    this.projection = tileSetInfo.projection;\n    this.setTileUrlFunction(tileSetInfo.urlFunction, tileSetInfo.urlTemplate);\n    this.setState('ready');\n  }\n\n  /**\n   * @private\n   * @param {Error} error The error.\n   */\n  handleError_(error) {\n    logError(error);\n    this.setState('error');\n  }\n}\n\nexport default OGCMapTile;\n","/**\n * @module ol/source/TileEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a tile starts loading.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\n   * @api\n   */\n  TILELOADSTART: 'tileloadstart',\n\n  /**\n   * Triggered when a tile finishes loading, either when its data is loaded,\n   * or when loading was aborted because the tile is no longer needed.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadend\n   * @api\n   */\n  TILELOADEND: 'tileloadend',\n\n  /**\n   * Triggered if tile loading results in an error. Note that this is not the\n   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}\n   * for details.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\n   * @api\n   */\n  TILELOADERROR: 'tileloaderror',\n};\n\n/**\n * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes\n */\n","/**\n * @module ol/source/TileImage\n */\nimport ImageTile from '../ImageTile.js';\nimport TileState from '../TileState.js';\nimport EventType from '../events/EventType.js';\nimport {equivalent, get as getProjection} from '../proj.js';\nimport ReprojTile from '../reproj/Tile.js';\nimport {getForProjection as getTileGridForProjection} from '../tilegrid.js';\nimport {getUid} from '../util.js';\nimport UrlTile from './UrlTile.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"./Source.js\").State} [state] Source state.\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/ImageTile~ImageTile}.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile\n * service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Deprecated.  Use an ImageTile source and provide a function\n * for the url option instead.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to\n * request out-of-bounds tiles from the server. When set to `false`, only one\n * world will be rendered. When set to `true`, tiles will be requested for one\n * world only, but they will be wrapped horizontally to render multiple worlds.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [key] Optional tile key for proper cache fetching\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @deprecated Use the ol/source/ImageTile.js instead.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nclass TileImage extends UrlTile {\n  /**\n   * @param {!Options} options Image tile options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction\n        ? options.tileLoadFunction\n        : defaultTileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate:\n        options.interpolate !== undefined ? options.interpolate : true,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @protected\n     * @type {?string}\n     */\n    this.crossOrigin =\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    /**\n     * @protected\n     * @type {typeof ImageTile}\n     */\n    this.tileClass =\n      options.tileClass !== undefined ? options.tileClass : ImageTile;\n\n    /**\n     * @protected\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGridForProjection = {};\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderReprojectionEdges_ = false;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   * @override\n   */\n  getGutterForProjection(projection) {\n    if (\n      this.getProjection() &&\n      projection &&\n      !equivalent(this.getProjection(), projection)\n    ) {\n      return 0;\n    }\n    return this.getGutter();\n  }\n\n  /**\n   * @return {number} Gutter.\n   */\n  getGutter() {\n    return 0;\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   * @override\n   */\n  getKey() {\n    let key = super.getKey();\n    if (!this.getInterpolate()) {\n      key += ':disable-interpolation';\n    }\n    return key;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @override\n   */\n  getTileGridForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n      return this.tileGrid;\n    }\n    const projKey = getUid(projection);\n    if (!(projKey in this.tileGridForProjection)) {\n      this.tileGridForProjection[projKey] =\n        getTileGridForProjection(projection);\n    }\n    return this.tileGridForProjection[projKey];\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {string} key The key set on the tile.\n   * @return {!ImageTile} Tile.\n   * @private\n   */\n  createTile_(z, x, y, pixelRatio, projection, key) {\n    const tileCoord = [z, x, y];\n    const urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection,\n    );\n    const tileUrl = urlTileCoord\n      ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection)\n      : undefined;\n    const tile = new this.tileClass(\n      tileCoord,\n      tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\n      tileUrl !== undefined ? tileUrl : '',\n      this.crossOrigin,\n      this.tileLoadFunction,\n      this.tileOptions,\n    );\n    tile.key = key;\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!(ImageTile|ReprojTile)} Tile.\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (\n      !sourceProjection ||\n      !projection ||\n      equivalent(sourceProjection, projection)\n    ) {\n      return this.getTileInternal(\n        z,\n        x,\n        y,\n        pixelRatio,\n        sourceProjection || projection,\n      );\n    }\n    const tileCoord = [z, x, y];\n    const key = this.getKey();\n    const sourceTileGrid = this.getTileGridForProjection(sourceProjection);\n    const targetTileGrid = this.getTileGridForProjection(projection);\n    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection,\n    );\n    const tile = new ReprojTile(\n      sourceProjection,\n      sourceTileGrid,\n      projection,\n      targetTileGrid,\n      tileCoord,\n      wrappedTileCoord,\n      this.getTilePixelRatio(pixelRatio),\n      this.getGutter(),\n      (z, x, y, pixelRatio) =>\n        this.getTileInternal(z, x, y, pixelRatio, sourceProjection),\n      this.reprojectionErrorThreshold_,\n      this.renderReprojectionEdges_,\n      this.tileOptions,\n    );\n    tile.key = key;\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {!import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!ImageTile} Tile.\n   * @protected\n   */\n  getTileInternal(z, x, y, pixelRatio, projection) {\n    const key = this.getKey();\n    return this.createTile_(z, x, y, pixelRatio, projection, key);\n  }\n\n  /**\n   * Sets whether to render reprojection edges or not (usually for debugging).\n   * @param {boolean} render Render the edges.\n   * @api\n   */\n  setRenderReprojectionEdges(render) {\n    if (this.renderReprojectionEdges_ == render) {\n      return;\n    }\n    this.renderReprojectionEdges_ = render;\n    this.changed();\n  }\n\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  setTileGridForProjection(projection, tilegrid) {\n    const proj = getProjection(projection);\n    if (proj) {\n      const projKey = getUid(proj);\n      if (!(projKey in this.tileGridForProjection)) {\n        this.tileGridForProjection[projKey] = tilegrid;\n      }\n    }\n  }\n}\n\n/**\n * @param {ImageTile} imageTile Image tile.\n * @param {string} src Source.\n */\nfunction defaultTileLoadFunction(imageTile, src) {\n  /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src =\n    src;\n}\n\nexport default TileImage;\n","/**\n * @module ol/source/UrlTile\n */\nimport TileState from '../TileState.js';\nimport {createFromTemplates} from '../tileurlfunction.js';\nimport {expandUrl} from '../uri.js';\nimport {getUid} from '../util.js';\nimport TileSource, {TileSourceEvent} from './Tile.js';\nimport TileEventType from './TileEventType.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./Source.js\").State} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {import(\"../Tile.js\").LoadFunction} tileLoadFunction TileLoadFunction.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Deprecated.  Use an ImageTile source and provide a function\n * for the url option instead.\n * @property {string} [url] Url.\n * @property {Array<string>} [urls] Urls.\n * @property {boolean} [wrapX=true] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @deprecated Use the ol/source/ImageTile.js instead.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n */\nclass UrlTile extends TileSource {\n  /**\n   * @param {Options} options Image tile options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tilePixelRatio: options.tilePixelRatio,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.generateTileUrlFunction_ =\n      this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction = options.tileLoadFunction;\n\n    if (options.tileUrlFunction) {\n      this.tileUrlFunction = options.tileUrlFunction;\n    }\n\n    /**\n     * @protected\n     * @type {!Array<string>|null}\n     */\n    this.urls = null;\n\n    if (options.urls) {\n      this.setUrls(options.urls);\n    } else if (options.url) {\n      this.setUrl(options.url);\n    }\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Return the tile load function of the source.\n   * @return {import(\"../Tile.js\").LoadFunction} TileLoadFunction\n   * @api\n   */\n  getTileLoadFunction() {\n    return this.tileLoadFunction;\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Return the tile URL function of the source.\n   * @return {import(\"../Tile.js\").UrlFunction} TileUrlFunction\n   * @api\n   */\n  getTileUrlFunction() {\n    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction\n      ? this.tileUrlFunction.bind(this)\n      : this.tileUrlFunction;\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Return the URLs used for this source.\n   * When a tileUrlFunction is used instead of url or urls,\n   * null will be returned.\n   * @return {!Array<string>|null} URLs.\n   * @api\n   */\n  getUrls() {\n    return this.urls;\n  }\n\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   * @protected\n   */\n  handleTileChange(event) {\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n    const uid = getUid(tile);\n    const tileState = tile.getState();\n    let type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type =\n        tileState == TileState.ERROR\n          ? TileEventType.TILELOADERROR\n          : tileState == TileState.LOADED\n            ? TileEventType.TILELOADEND\n            : undefined;\n    }\n    if (type != undefined) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Set the tile load function of the source.\n   * @param {import(\"../Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @api\n   */\n  setTileLoadFunction(tileLoadFunction) {\n    this.tileLoadFunction = tileLoadFunction;\n    this.changed();\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Set the tile URL function of the source.\n   * @param {import(\"../Tile.js\").UrlFunction} tileUrlFunction Tile URL function.\n   * @param {string} [key] Optional new tile key for the source.\n   * @api\n   */\n  setTileUrlFunction(tileUrlFunction, key) {\n    this.tileUrlFunction = tileUrlFunction;\n    if (typeof key !== 'undefined') {\n      this.setKey(key);\n    } else {\n      this.changed();\n    }\n  }\n\n  /**\n   * Set the URL to use for requests.\n   * @param {string} url URL.\n   * @api\n   */\n  setUrl(url) {\n    const urls = expandUrl(url);\n    this.urls = urls;\n    this.setUrls(urls);\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Set the URLs to use for requests.\n   * @param {Array<string>} urls URLs.\n   * @api\n   */\n  setUrls(urls) {\n    this.urls = urls;\n    const key = urls.join('\\n');\n    if (this.generateTileUrlFunction_) {\n      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);\n    } else {\n      this.setKey(key);\n    }\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {string|undefined} Tile URL.\n   */\n  tileUrlFunction(tileCoord, pixelRatio, projection) {\n    return undefined;\n  }\n}\n\nexport default UrlTile;\n","/**\n * @module ol/source/ogcTileUtil\n */\n\nimport {error as logError} from '../console.js';\nimport {getIntersection as intersectExtents} from '../extent.js';\nimport {getJSON, resolveUrl} from '../net.js';\nimport {get as getProjection} from '../proj.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\n\n/**\n * See https://ogcapi.ogc.org/tiles/.\n */\n\n/**\n * @typedef {'map' | 'vector'} TileType\n */\n\n/**\n * @typedef {'topLeft' | 'bottomLeft'} CornerOfOrigin\n */\n\n/**\n * @typedef {Object} TileSet\n * @property {TileType} dataType Type of data represented in the tileset.\n * @property {string} [tileMatrixSetDefinition] Reference to a tile matrix set definition.\n * @property {TileMatrixSet} [tileMatrixSet] Tile matrix set definition.\n * @property {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.\n * @property {Array<Link>} links Tileset links.\n */\n\n/**\n * @typedef {Object} Link\n * @property {string} rel The link rel attribute.\n * @property {string} href The link URL.\n * @property {string} type The link type.\n */\n\n/**\n * @typedef {Object} TileMatrixSetLimit\n * @property {string} tileMatrix The tile matrix id.\n * @property {number} minTileRow The minimum tile row.\n * @property {number} maxTileRow The maximum tile row.\n * @property {number} minTileCol The minimum tile column.\n * @property {number} maxTileCol The maximum tile column.\n */\n\n/**\n * @typedef {Object} TileMatrixSet\n * @property {string} id The tile matrix set identifier.\n * @property {string|CrsUri|CrsWkt|CrsReferenceSystem} crs The coordinate reference system.\n * @property {Array<string>} [orderedAxes] Axis order.\n * @property {Array<TileMatrix>} tileMatrices Array of tile matrices.\n */\n\n/**\n * @typedef {Object} CrsUri\n * @property {string} uri Reference to one coordinate reference system (CRS).\n */\n\n/**\n * @typedef {Object} CrsWkt\n * @property {Object} wkt JSON encoding for WKT representation of CRS 2.0.\n */\n\n/**\n * @typedef {Object} CrsReferenceSystem\n * @property {Object} referenceSystem Data structure as defined in the MD_ReferenceSystem of the ISO 19115.\n */\n\n/**\n * @typedef {Object} TileMatrix\n * @property {string} id The tile matrix identifier.\n * @property {number} cellSize The pixel resolution (map units per pixel).\n * @property {Array<number>} pointOfOrigin The map location of the matrix origin.\n * @property {CornerOfOrigin} [cornerOfOrigin='topLeft'] The corner of the matrix that represents the origin ('topLeft' or 'bottomLeft').\n * @property {number} matrixWidth The number of columns.\n * @property {number} matrixHeight The number of rows.\n * @property {number} tileWidth The pixel width of a tile.\n * @property {number} tileHeight The pixel height of a tile.\n */\n\n/**\n * @type {Object<string, boolean>}\n */\nconst knownMapMediaTypes = {\n  'image/png': true,\n  'image/jpeg': true,\n  'image/gif': true,\n  'image/webp': true,\n};\n\n/**\n * @type {Object<string, boolean>}\n */\nconst knownVectorMediaTypes = {\n  'application/vnd.mapbox-vector-tile': true,\n  'application/geo+json': true,\n};\n\n/**\n * @typedef {Object} TileSetInfo\n * @property {string} urlTemplate The tile URL template.\n * @property {import(\"../proj/Projection.js\").default} projection The source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} grid The tile grid.\n * @property {import(\"../Tile.js\").UrlFunction} urlFunction The tile URL function.\n */\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} url The tile set URL.\n * @property {string} mediaType The preferred tile media type.\n * @property {Array<string>} [supportedMediaTypes] The supported media types.\n * @property {import(\"../proj/Projection.js\").default} projection The source projection.\n * @property {Object} [context] Optional context for constructing the URL.\n * @property {Array<string>} [collections] Optional collections to append the URL with.\n */\n\n/**\n * @param {string} tileUrlTemplate Tile URL template.\n * @param {Array<string>} collections List of collections to include as query parameter.\n * @return {string} The tile URL template with appended collections query parameter.\n */\nexport function appendCollectionsQueryParam(tileUrlTemplate, collections) {\n  if (!collections.length) {\n    return tileUrlTemplate;\n  }\n\n  // making sure we can always construct a URL instance.\n  const url = new URL(tileUrlTemplate, 'file:/');\n\n  if (url.pathname.split('/').includes('collections')) {\n    logError(\n      'The \"collections\" query parameter cannot be added to collection endpoints',\n    );\n    return tileUrlTemplate;\n  }\n  // According to conformance class\n  // http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/collections-selection\n  // commata in the identifiers of the `collections` query parameter\n  // need to be URLEncoded, while the commata separating the identifiers\n  // should not.\n  const encodedCollections = collections\n    .map((c) => encodeURIComponent(c))\n    .join(',');\n\n  url.searchParams.append('collections', encodedCollections);\n  const baseUrl = tileUrlTemplate.split('?')[0];\n  const queryParams = decodeURIComponent(url.searchParams.toString());\n  return `${baseUrl}?${queryParams}`;\n}\n\n/**\n * @param {Array<Link>} links Tileset links.\n * @param {string} [mediaType] The preferred media type.\n * @param {Array<string>} [collections] Optional collections to append the URL with.\n * @return {string} The tile URL template.\n */\nexport function getMapTileUrlTemplate(links, mediaType, collections) {\n  let tileUrlTemplate;\n  let fallbackUrlTemplate;\n  for (let i = 0; i < links.length; ++i) {\n    const link = links[i];\n    if (link.rel === 'item') {\n      if (link.type === mediaType) {\n        tileUrlTemplate = link.href;\n        break;\n      }\n      if (knownMapMediaTypes[link.type]) {\n        fallbackUrlTemplate = link.href;\n      } else if (!fallbackUrlTemplate && link.type.startsWith('image/')) {\n        fallbackUrlTemplate = link.href;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate) {\n    if (fallbackUrlTemplate) {\n      tileUrlTemplate = fallbackUrlTemplate;\n    } else {\n      throw new Error('Could not find \"item\" link');\n    }\n  }\n\n  if (collections) {\n    tileUrlTemplate = appendCollectionsQueryParam(tileUrlTemplate, collections);\n  }\n\n  return tileUrlTemplate;\n}\n\n/**\n * @param {Array<Link>} links Tileset links.\n * @param {string} [mediaType] The preferred media type.\n * @param {Array<string>} [supportedMediaTypes] The media types supported by the parser.\n * @param {Array<string>} [collections] Optional collections to append the URL with.\n * @return {string} The tile URL template.\n */\nexport function getVectorTileUrlTemplate(\n  links,\n  mediaType,\n  supportedMediaTypes,\n  collections,\n) {\n  let tileUrlTemplate;\n  let fallbackUrlTemplate;\n\n  /**\n   * Lookup of URL by media type.\n   * @type {Object<string, string>}\n   */\n  const hrefLookup = {};\n\n  for (let i = 0; i < links.length; ++i) {\n    const link = links[i];\n    hrefLookup[link.type] = link.href;\n    if (link.rel === 'item') {\n      if (link.type === mediaType) {\n        tileUrlTemplate = link.href;\n        break;\n      }\n      if (knownVectorMediaTypes[link.type]) {\n        fallbackUrlTemplate = link.href;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate && supportedMediaTypes) {\n    for (let i = 0; i < supportedMediaTypes.length; ++i) {\n      const supportedMediaType = supportedMediaTypes[i];\n      if (hrefLookup[supportedMediaType]) {\n        tileUrlTemplate = hrefLookup[supportedMediaType];\n        break;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate) {\n    if (fallbackUrlTemplate) {\n      tileUrlTemplate = fallbackUrlTemplate;\n    } else {\n      throw new Error('Could not find \"item\" link');\n    }\n  }\n\n  if (collections) {\n    tileUrlTemplate = appendCollectionsQueryParam(tileUrlTemplate, collections);\n  }\n\n  return tileUrlTemplate;\n}\n\n/**\n * @param {SourceInfo} sourceInfo The source info.\n * @param {TileMatrixSet} tileMatrixSet Tile matrix set.\n * @param {string} tileUrlTemplate Tile URL template.\n * @param {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.\n * @return {TileSetInfo} Tile set info.\n */\nfunction parseTileMatrixSet(\n  sourceInfo,\n  tileMatrixSet,\n  tileUrlTemplate,\n  tileMatrixSetLimits,\n) {\n  let projection = sourceInfo.projection;\n  if (!projection) {\n    if (typeof tileMatrixSet.crs === 'string') {\n      projection = getProjection(tileMatrixSet.crs);\n    } else if ('uri' in tileMatrixSet.crs) {\n      projection = getProjection(tileMatrixSet.crs.uri);\n    }\n    if (!projection) {\n      throw new Error(`Unsupported CRS: ${JSON.stringify(tileMatrixSet.crs)}`);\n    }\n  }\n  const orderedAxes = tileMatrixSet.orderedAxes;\n  const axisOrientation = orderedAxes\n    ? orderedAxes\n        .slice(0, 2)\n        .map((s) => s.replace(/E|X|Lon/i, 'e').replace(/N|Y|Lat/i, 'n'))\n        .join('')\n    : projection.getAxisOrientation();\n  const backwards = !axisOrientation.startsWith('en');\n\n  const matrices = tileMatrixSet.tileMatrices;\n\n  /**\n   * @type {Object<string, TileMatrix>}\n   */\n  const matrixLookup = {};\n  for (let i = 0; i < matrices.length; ++i) {\n    const matrix = matrices[i];\n    matrixLookup[matrix.id] = matrix;\n  }\n\n  /**\n   * @type {Object<string, TileMatrixSetLimit>}\n   */\n  const limitLookup = {};\n\n  /**\n   * @type {Array<string>}\n   */\n  const matrixIds = [];\n\n  if (tileMatrixSetLimits) {\n    for (let i = 0; i < tileMatrixSetLimits.length; ++i) {\n      const limit = tileMatrixSetLimits[i];\n      const id = limit.tileMatrix;\n      matrixIds.push(id);\n      limitLookup[id] = limit;\n    }\n  } else {\n    for (let i = 0; i < matrices.length; ++i) {\n      const id = matrices[i].id;\n      matrixIds.push(id);\n    }\n  }\n\n  const length = matrixIds.length;\n  const origins = new Array(length);\n  const resolutions = new Array(length);\n  const sizes = new Array(length);\n  const tileSizes = new Array(length);\n  const extent = [-Infinity, -Infinity, Infinity, Infinity];\n\n  for (let i = 0; i < length; ++i) {\n    const id = matrixIds[i];\n    const matrix = matrixLookup[id];\n    const origin = matrix.pointOfOrigin;\n    if (backwards) {\n      origins[i] = [origin[1], origin[0]];\n    } else {\n      origins[i] = origin;\n    }\n    resolutions[i] = matrix.cellSize;\n    sizes[i] = [matrix.matrixWidth, matrix.matrixHeight];\n    tileSizes[i] = [matrix.tileWidth, matrix.tileHeight];\n    const limit = limitLookup[id];\n    if (limit) {\n      const tileMapWidth = matrix.cellSize * matrix.tileWidth;\n      const minX = origins[i][0] + limit.minTileCol * tileMapWidth;\n      const maxX = origins[i][0] + (limit.maxTileCol + 1) * tileMapWidth;\n\n      const tileMapHeight = matrix.cellSize * matrix.tileHeight;\n      const upsideDown = matrix.cornerOfOrigin === 'bottomLeft';\n\n      let minY;\n      let maxY;\n      if (upsideDown) {\n        minY = origins[i][1] + limit.minTileRow * tileMapHeight;\n        maxY = origins[i][1] + (limit.maxTileRow + 1) * tileMapHeight;\n      } else {\n        minY = origins[i][1] - (limit.maxTileRow + 1) * tileMapHeight;\n        maxY = origins[i][1] - limit.minTileRow * tileMapHeight;\n      }\n\n      intersectExtents(extent, [minX, minY, maxX, maxY], extent);\n    }\n  }\n\n  const tileGrid = new TileGrid({\n    origins: origins,\n    resolutions: resolutions,\n    sizes: sizes,\n    tileSizes: tileSizes,\n    extent: tileMatrixSetLimits ? extent : undefined,\n  });\n\n  const context = sourceInfo.context;\n  const base = sourceInfo.url;\n\n  /** @type {import('../Tile.js').UrlFunction} */\n  function tileUrlFunction(tileCoord, pixelRatio, projection) {\n    if (!tileCoord) {\n      return undefined;\n    }\n\n    const id = matrixIds[tileCoord[0]];\n    const matrix = matrixLookup[id];\n    const upsideDown = matrix.cornerOfOrigin === 'bottomLeft';\n\n    const localContext = {\n      tileMatrix: id,\n      tileCol: tileCoord[1],\n      tileRow: upsideDown ? -tileCoord[2] - 1 : tileCoord[2],\n    };\n\n    if (tileMatrixSetLimits) {\n      const limit = limitLookup[matrix.id];\n      if (\n        localContext.tileCol < limit.minTileCol ||\n        localContext.tileCol > limit.maxTileCol ||\n        localContext.tileRow < limit.minTileRow ||\n        localContext.tileRow > limit.maxTileRow\n      ) {\n        return undefined;\n      }\n    }\n\n    Object.assign(localContext, context);\n\n    const url = tileUrlTemplate.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n      return localContext[p];\n    });\n\n    return resolveUrl(base, url);\n  }\n\n  return {\n    grid: tileGrid,\n    projection: projection,\n    urlTemplate: tileUrlTemplate,\n    urlFunction: tileUrlFunction,\n  };\n}\n\n/**\n * @param {SourceInfo} sourceInfo The source info.\n * @param {TileSet} tileSet Tile set.\n * @return {TileSetInfo|Promise<TileSetInfo>} Tile set info.\n */\nfunction parseTileSetMetadata(sourceInfo, tileSet) {\n  const tileMatrixSetLimits = tileSet.tileMatrixSetLimits;\n  /** @type {string} */\n  let tileUrlTemplate;\n\n  if (tileSet.dataType === 'map') {\n    tileUrlTemplate = getMapTileUrlTemplate(\n      tileSet.links,\n      sourceInfo.mediaType,\n      sourceInfo.collections,\n    );\n  } else if (tileSet.dataType === 'vector') {\n    tileUrlTemplate = getVectorTileUrlTemplate(\n      tileSet.links,\n      sourceInfo.mediaType,\n      sourceInfo.supportedMediaTypes,\n      sourceInfo.collections,\n    );\n  } else {\n    throw new Error('Expected tileset data type to be \"map\" or \"vector\"');\n  }\n\n  if (tileSet.tileMatrixSet) {\n    return parseTileMatrixSet(\n      sourceInfo,\n      tileSet.tileMatrixSet,\n      tileUrlTemplate,\n      tileMatrixSetLimits,\n    );\n  }\n\n  const tileMatrixSetLink = tileSet.links.find(\n    (link) =>\n      link.rel === 'http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme',\n  );\n  if (!tileMatrixSetLink) {\n    throw new Error(\n      'Expected http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme link or tileMatrixSet',\n    );\n  }\n  const tileMatrixSetDefinition = tileMatrixSetLink.href;\n\n  const url = resolveUrl(sourceInfo.url, tileMatrixSetDefinition);\n  return getJSON(url).then(function (tileMatrixSet) {\n    return parseTileMatrixSet(\n      sourceInfo,\n      tileMatrixSet,\n      tileUrlTemplate,\n      tileMatrixSetLimits,\n    );\n  });\n}\n\n/**\n * @param {SourceInfo} sourceInfo Source info.\n * @return {Promise<TileSetInfo>} Tile set info.\n */\nexport function getTileSetInfo(sourceInfo) {\n  return getJSON(sourceInfo.url).then(function (tileSet) {\n    return parseTileSetMetadata(sourceInfo, tileSet);\n  });\n}\n"],"names":["jsonp","url","callback","errback","callbackParam","script","document","createElement","key","cleanup","window","parentNode","removeChild","async","src","includes","timer","setTimeout","data","clearTimeout","head","appendChild","ResponseError","Error","constructor","response","message","status","super","this","name","ClientError","client","getJSON","Promise","resolve","reject","onLoad","event","target","JSON","parse","responseText","err","onError","XMLHttpRequest","addEventListener","open","setRequestHeader","send","resolveUrl","base","URL","href","OGCMapTile","options","attributions","cacheSize","crossOrigin","interpolate","projection","reprojectionErrorThreshold","state","tileLoadFunction","wrapX","undefined","transition","sourceInfo","getProjection","mediaType","context","collections","getTileSetInfo","then","handleTileSetInfo_","bind","catch","handleError_","tileSetInfo","tileGrid","grid","setTileUrlFunction","urlFunction","urlTemplate","setState","error","TILELOADSTART","TILELOADEND","TILELOADERROR","TileImage","defaultTileLoadFunction","tilePixelRatio","tileUrlFunction","urls","attributionsCollapsible","zDirection","tileClass","tileGridForProjection","reprojectionErrorThreshold_","renderReprojectionEdges_","getGutterForProjection","getGutter","getKey","getInterpolate","getTileGridForProjection","thisProj","projKey","createTile_","z","x","y","pixelRatio","tileCoord","urlTileCoord","getTileCoordForTileUrlFunction","tileUrl","tile","IDLE","EMPTY","tileOptions","CHANGE","handleTileChange","getTile","sourceProjection","getTileInternal","sourceTileGrid","targetTileGrid","wrappedTileCoord","getTilePixelRatio","setRenderReprojectionEdges","render","changed","setTileGridForProjection","tilegrid","proj","imageTile","getImage","UrlTile","generateTileUrlFunction_","prototype","setUrls","setUrl","tileLoadingKeys_","getTileLoadFunction","getTileUrlFunction","Object","getPrototypeOf","getUrls","uid","tileState","getState","type","LOADING","ERROR","LOADED","dispatchEvent","TileSourceEvent","setTileLoadFunction","setKey","join","knownMapMediaTypes","knownVectorMediaTypes","appendCollectionsQueryParam","tileUrlTemplate","length","pathname","split","encodedCollections","map","c","encodeURIComponent","searchParams","append","baseUrl","queryParams","decodeURIComponent","toString","getMapTileUrlTemplate","links","fallbackUrlTemplate","i","link","rel","startsWith","getVectorTileUrlTemplate","supportedMediaTypes","hrefLookup","supportedMediaType","parseTileMatrixSet","tileMatrixSet","tileMatrixSetLimits","crs","uri","stringify","orderedAxes","axisOrientation","slice","s","replace","getAxisOrientation","backwards","matrices","tileMatrices","matrixLookup","matrix","id","limitLookup","matrixIds","limit","tileMatrix","push","origins","Array","resolutions","sizes","tileSizes","extent","Infinity","origin","pointOfOrigin","cellSize","matrixWidth","matrixHeight","tileWidth","tileHeight","tileMapWidth","minX","minTileCol","maxX","maxTileCol","tileMapHeight","upsideDown","cornerOfOrigin","minY","maxY","minTileRow","maxTileRow","localContext","tileCol","tileRow","assign","m","p","parseTileSetMetadata","tileSet","dataType","tileMatrixSetLink","find","tileMatrixSetDefinition"],"sourceRoot":""}