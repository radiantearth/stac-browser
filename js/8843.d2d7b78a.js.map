{"version":3,"file":"js/8843.d2d7b78a.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/Tile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/ImageTile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/reproj/Tile.js"],"sourcesContent":["/**\n * @module ol/Tile\n */\nimport TileState from './TileState.js';\nimport {easeIn} from './easing.js';\nimport EventType from './events/EventType.js';\nimport EventTarget from './events/Target.js';\nimport {abstract} from './util.js';\n\n/**\n * A function that takes a {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState.js';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   const xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     const data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes a {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * A key assigned to the tile. This is used in conjunction with a source key\n     * to determine if a cached version of this tile may be used by the renderer.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @private\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n\n    /**\n     * @type {boolean}\n     */\n    this.interpolate = !!options.interpolate;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {\n    // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`\n    this.setState(TileState.EMPTY);\n  }\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state === TileState.EMPTY) {\n      // no more state changes\n      return;\n    }\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    this.release();\n    super.disposeInternal();\n  }\n}\n\nexport default Tile;\n","/**\n * @module ol/ImageTile\n */\nimport {listenImage} from './Image.js';\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\n    super(tileCoord, state, options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n   */\n  setImage(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   *\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\n   * that checks for error status codes and reloads only when the status code is\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\n   * made already:\n   *\n   * ```js\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\n   * const retries = {};\n   * source.setTileLoadFunction((tile, src) => {\n   *   const image = tile.getImage();\n   *   fetch(src)\n   *     .then((response) => {\n   *       if (retryCodes.includes(response.status)) {\n   *         retries[src] = (retries[src] || 0) + 1;\n   *         if (retries[src] <= 3) {\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\n   *         }\n   *         return Promise.reject();\n   *       }\n   *       return response.blob();\n   *     })\n   *     .then((blob) => {\n   *       const imageUrl = URL.createObjectURL(blob);\n   *       image.src = imageUrl;\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\n   *     })\n   *     .catch(() => tile.setState(3)); // error\n   * });\n   * ```\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(\n        this.image_,\n        this.handleImageLoad_.bind(this),\n        this.handleImageError_.bind(this),\n      );\n    }\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    this.unlistenImage_();\n    this.image_ = null;\n    super.disposeInternal();\n  }\n}\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n","/**\n * @module ol/reproj/Tile\n */\n\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport {releaseCanvas} from '../dom.js';\nimport EventType from '../events/EventType.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport Triangulation from './Triangulation.js';\nimport {ERROR_THRESHOLD} from './common.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {import(\"../ImageTile.js\").default} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    options,\n  ) {\n    super(tileCoord, TileState.IDLE, options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceProj.getExtent()\n      : undefined;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (tile && tile.getState() == TileState.LOADED) {\n        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n        extent[0] += source.offset;\n        extent[2] += source.offset;\n        const clipExtent = this.clipExtent_?.slice();\n        if (clipExtent) {\n          clipExtent[0] += source.offset;\n          clipExtent[2] += source.offset;\n        }\n        sources.push({\n          extent: extent,\n          clipExtent: clipExtent,\n          image: tile.getImage(),\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_,\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_,\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate,\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(({tile}) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = listen(tile, EventType.CHANGE, (e) => {\n            const state = tile.getState();\n            if (\n              state == TileState.LOADED ||\n              state == TileState.ERROR ||\n              state == TileState.EMPTY\n            ) {\n              unlistenByKey(sourceListenKey);\n              leftToLoad--;\n              if (leftToLoad === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          });\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function ({tile}, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   * @override\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\nexport default ReprojTile;\n"],"names":["Tile","constructor","tileCoord","state","options","super","this","key","transition_","undefined","transition","transitionStarts_","interpolate","changed","dispatchEvent","CHANGE","release","setState","EMPTY","getKey","getTileCoord","getState","ERROR","Error","load","getAlpha","id","time","start","delta","inTransition","endTransition","disposeInternal","ImageTile","src","crossOrigin","tileLoadFunction","crossOrigin_","src_","image_","Image","unlisten_","tileLoadFunction_","getImage","setImage","element","LOADED","unlistenImage_","handleImageError_","getBlankImage","handleImageLoad_","image","naturalWidth","naturalHeight","IDLE","LOADING","bind","ctx","fillStyle","fillRect","canvas","ReprojTile","sourceProj","sourceTileGrid","targetProj","targetTileGrid","wrappedTileCoord","pixelRatio","gutter","getTileFunction","errorThreshold","renderEdges","renderEdges_","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","clipExtent_","canWrapX","getExtent","targetExtent","getTileCoordExtent","maxTargetExtent","maxSourceExtent","limitedTargetExtent","sourceProjExtent","targetResolution","getResolution","sourceResolution","isFinite","errorThresholdInPixels","triangulation_","getTriangles","length","getZForResolution","sourceExtent","calculateSourceExtent","worldWidth","worldsAway","Math","floor","sourceExtents","slice","forEach","extent","sourceRange","getTileRangeForExtentAndZ","srcX","minX","maxX","srcY","minY","maxY","tile","offset","push","reproject_","sources","source","clipExtent","z","size","getTileSize","width","height","leftToLoad","sourceListenKey","e","unlistenSources_","setTimeout","i","arr","getContext"],"sourceRoot":""}