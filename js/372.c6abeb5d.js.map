{"version":3,"file":"js/372.c6abeb5d.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/tilegrid.js","webpack://@radiantearth/stac-browser/./node_modules/ol/structs/LRUCache.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/BaseTile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/DataTile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/Tile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/resolution.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/common.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/Image.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/Tile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/ImageCanvas.js","webpack://@radiantearth/stac-browser/./node_modules/ol/renderer/canvas/ImageLayer.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/BaseImage.js","webpack://@radiantearth/stac-browser/./node_modules/ol/reproj/Image.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/Image.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/Raster.js"],"sourcesContent":["/**\n * @module ol/tilegrid\n */\nimport {\n  containsCoordinate,\n  createOrUpdate,\n  getCorner,\n  getHeight,\n  getWidth,\n} from './extent.js';\nimport {METERS_PER_UNIT, get as getProjection} from './proj.js';\nimport {toSize} from './size.js';\nimport TileGrid from './tilegrid/TileGrid.js';\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\n\nexport {TileGrid};\nexport {default as WMTS} from './tilegrid/WMTS.js';\n\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n  let tileGrid = projection.getDefaultTileGrid();\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n  return tileGrid;\n}\n\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n  const z = tileCoord[0];\n  const center = tileGrid.getTileCoordCenter(tileCoord);\n  const projectionExtent = extentFromProjection(projection);\n  if (!containsCoordinate(projectionExtent, center)) {\n    const worldWidth = getWidth(projectionExtent);\n    const worldsAway = Math.ceil(\n      (projectionExtent[0] - center[0]) / worldWidth,\n    );\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\n  }\n  return tileCoord;\n}\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, maxZoom, tileSize, corner) {\n  corner = corner !== undefined ? corner : 'top-left';\n\n  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);\n\n  return new TileGrid({\n    extent: extent,\n    origin: getCorner(extent, corner),\n    resolutions: resolutions,\n    tileSize: tileSize,\n  });\n}\n\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions} [options] Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(options) {\n  const xyzOptions = options || {};\n\n  const extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n\n  const gridOptions = {\n    extent: extent,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(\n      extent,\n      xyzOptions.maxZoom,\n      xyzOptions.tileSize,\n      xyzOptions.maxResolution,\n    ),\n  };\n  return new TileGrid(gridOptions);\n}\n\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number} [maxResolution] Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {\n  maxZoom = maxZoom !== undefined ? maxZoom : DEFAULT_MAX_ZOOM;\n  tileSize = toSize(tileSize !== undefined ? tileSize : DEFAULT_TILE_SIZE);\n\n  const height = getHeight(extent);\n  const width = getWidth(extent);\n\n  maxResolution =\n    maxResolution > 0\n      ? maxResolution\n      : Math.max(width / tileSize[0], height / tileSize[1]);\n\n  const length = maxZoom + 1;\n  const resolutions = new Array(length);\n  for (let z = 0; z < length; ++z) {\n    resolutions[z] = maxResolution / Math.pow(2, z);\n  }\n  return resolutions;\n}\n\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, maxZoom, tileSize, corner) {\n  const extent = extentFromProjection(projection);\n  return createForExtent(extent, maxZoom, tileSize, corner);\n}\n\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n  projection = getProjection(projection);\n  let extent = projection.getExtent();\n  if (!extent) {\n    const half =\n      (180 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit();\n    extent = createOrUpdate(-half, -half, half, half);\n  }\n  return extent;\n}\n","/**\n * @module ol/structs/LRUCache\n */\n\nimport Disposable from '../Disposable.js';\nimport {assert} from '../asserts.js';\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Entry|null} newer Newer.\n * @property {Entry|null} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nclass LRUCache {\n  /**\n   * @param {number} [highWaterMark] High water mark.\n   */\n  constructor(highWaterMark) {\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n\n  deleteOldest() {\n    const entry = this.pop();\n    if (entry instanceof Disposable) {\n      entry.dispose();\n    }\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  }\n\n  /**\n   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},\n   * the entry will be disposed.\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n   */\n  expireCache(keep) {\n    while (this.canExpireCache()) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    while (this.oldest_) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  }\n\n  /**\n   * @param {function(T, string, LRUCache<T>): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   */\n  forEach(f) {\n    let entry = this.oldest_;\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {*} [options] Options (reserved for subclasses).\n   * @return {T} Value.\n   */\n  get(key, options) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      return entry.value_;\n    }\n    if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  }\n\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  remove(key) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {Entry} */ (entry.older);\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.count_;\n  }\n\n  /**\n   * @return {Array<string>} Keys.\n   */\n  getKeys() {\n    const keys = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  }\n\n  /**\n   * @return {Array<T>} Values.\n   */\n  getValues() {\n    const values = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  }\n\n  /**\n   * @return {T} Last value.\n   */\n  peekLast() {\n    return this.oldest_.value_;\n  }\n\n  /**\n   * @return {string} Last key.\n   */\n  peekLastKey() {\n    return this.oldest_.key_;\n  }\n\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  peekFirstKey() {\n    return this.newest_.key_;\n  }\n\n  /**\n   * Return an entry without updating least recently used time.\n   * @param {string} key Key.\n   * @return {T|undefined} Value.\n   */\n  peek(key) {\n    return this.entries_[key]?.value_;\n  }\n\n  /**\n   * @return {T} value Value.\n   */\n  pop() {\n    const entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  replace(key, value) {\n    this.get(key); // update `newest_`\n    this.entries_[key].value_ = value;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  set(key, value) {\n    assert(\n      !(key in this.entries_),\n      'Tried to set a value for a key that is used already',\n    );\n    const entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value,\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  }\n\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n  setSize(size) {\n    this.highWaterMark = size;\n  }\n}\n\nexport default LRUCache;\n","/**\n * @module ol/layer/BaseTile\n */\nimport Layer from './Layer.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *   import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {TileSourceType} [source] Source for this layer.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n * @property {number} [cacheSize=512] The internal tile cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n */\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<TileSourceType, RendererType>}\n * @api\n */\nclass BaseTileLayer extends Layer {\n  /**\n   * @param {Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    const cacheSize = options.cacheSize;\n    delete options.cacheSize;\n\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    super(baseOptions);\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true,\n    );\n  }\n\n  /**\n   * @return {number|undefined} The suggested cache size\n   * @protected\n   */\n  getCacheSize() {\n    return this.cacheSize_;\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Deprecated.  Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Deprecated.  Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n\n  /**\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   * @override\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default BaseTileLayer;\n","/**\n * @module ol/DataTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\n\n/**\n * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike\n */\n\n/**\n * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike\n */\n\n/**\n * Data that can be used with a DataTile.\n * @typedef {ArrayLike|ImageLike} Data\n */\n\n/**\n * @param {Data} data Tile data.\n * @return {ImageLike|null} The image-like data.\n */\nexport function asImageLike(data) {\n  return data instanceof Image ||\n    data instanceof HTMLCanvasElement ||\n    data instanceof HTMLVideoElement ||\n    data instanceof ImageBitmap\n    ? data\n    : null;\n}\n\n/**\n * @param {Data} data Tile data.\n * @return {ArrayLike|null} The array-like data.\n */\nexport function asArrayLike(data) {\n  return data instanceof Uint8Array ||\n    data instanceof Uint8ClampedArray ||\n    data instanceof Float32Array ||\n    data instanceof DataView\n    ? data\n    : null;\n}\n\n/**\n * This is set as the cancellation reason when a tile is disposed.\n */\nexport const disposedError = new Error('disposed');\n\n/**\n * @type {CanvasRenderingContext2D|null}\n */\nlet sharedContext = null;\n\n/**\n * @param {ImageLike} image The image.\n * @return {Uint8ClampedArray} The data.\n */\nexport function toArray(image) {\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(\n      image.width,\n      image.height,\n      undefined,\n      {willReadFrequently: true},\n    );\n  }\n  const canvas = sharedContext.canvas;\n  const width = image.width;\n  if (canvas.width !== width) {\n    canvas.width = width;\n  }\n  const height = image.height;\n  if (canvas.height !== height) {\n    canvas.height = height;\n  }\n  sharedContext.clearRect(0, 0, width, height);\n  sharedContext.drawImage(image, 0, 0);\n  return sharedContext.getImageData(0, 0, width, height).data;\n}\n\n/**\n * @type {import('./size.js').Size}\n */\nconst defaultSize = [256, 256];\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,\n * the promise should not resolve until the image is loaded.\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {import('./size.js').Size} [size=[256, 256]] Tile size.\n * @property {AbortController} [controller] An abort controller.\n * @api\n */\n\nclass DataTile extends Tile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    const state = TileState.IDLE;\n\n    super(options.tileCoord, state, {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    });\n\n    /**\n     * @type {function(): Promise<Data>}\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @type {Data}\n     * @private\n     */\n    this.data_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {import('./size.js').Size|null}\n     * @private\n     */\n    this.size_ = options.size || null;\n\n    /**\n     * @type {AbortController|null}\n     * @private\n     */\n    this.controller_ = options.controller || null;\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('./size.js').Size} Tile size.\n   */\n  getSize() {\n    if (this.size_) {\n      return this.size_;\n    }\n    const imageData = asImageLike(this.data_);\n    if (imageData) {\n      return [imageData.width, imageData.height];\n    }\n    return defaultSize;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {Data} Tile data.\n   * @api\n   */\n  getData() {\n    return this.data_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @api\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Load the tile data.\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    const self = this;\n    this.loader_()\n      .then(function (data) {\n        self.data_ = data;\n        self.state = TileState.LOADED;\n        self.changed();\n      })\n      .catch(function (error) {\n        self.error_ = error;\n        self.state = TileState.ERROR;\n        self.changed();\n      });\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    if (this.controller_) {\n      this.controller_.abort(disposedError);\n      this.controller_ = null;\n    }\n    super.disposeInternal();\n  }\n}\n\nexport default DataTile;\n","/**\n * @module ol/layer/Tile\n */\nimport CanvasTileLayerRenderer from '../renderer/canvas/TileLayer.js';\nimport BaseTileLayer from './BaseTile.js';\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} [TileSourceType=import(\"../source/Tile.js\").default]\n * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>\n * @api\n */\nclass TileLayer extends BaseTileLayer {\n  /**\n   * @param {import(\"./BaseTile.js\").Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    return new CanvasTileLayerRenderer(this, {\n      cacheSize: this.getCacheSize(),\n    });\n  }\n}\n\nexport default TileLayer;\n","/**\n * @module ol/resolution\n */\n\n/**\n * @typedef {number|Array<number>} ResolutionLike\n */\n\n/**\n * @param {ResolutionLike} resolution Resolution.\n * @return {number} Resolution.\n */\nexport function fromResolutionLike(resolution) {\n  if (Array.isArray(resolution)) {\n    return Math.min(...resolution);\n  }\n  return resolution;\n}\n","/**\n * @module ol/source/common\n */\n\n/**\n * Default WMS version.\n * @type {string}\n */\nexport const DEFAULT_WMS_VERSION = '1.3.0';\n\n/**\n * Number of decimal digits to consider in integer values when rounding.\n * @type {number}\n */\nexport const DECIMALS = 4;\n","/**\n * @module ol/layer/Image\n */\nimport CanvasImageLayerRenderer from '../renderer/canvas/ImageLayer.js';\nimport BaseImageLayer from './BaseImage.js';\n\n/**\n * @classdesc\n * Server-rendered images that are available for arbitrary extents and\n * resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Image.js\").default} ImageSourceType\n * @extends {BaseImageLayer<ImageSourceType, CanvasImageLayerRenderer>}\n * @api\n */\nclass ImageLayer extends BaseImageLayer {\n  /**\n   * @param {import(\"./BaseImage.js\").Options<ImageSourceType>} [options] Layer options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    return new CanvasImageLayerRenderer(this);\n  }\n\n  /**\n   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the\n   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the\n   * source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   * @override\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default ImageLayer;\n","/**\n * @module ol/source/Tile\n */\nimport Event from '../events/Event.js';\nimport {scale as scaleSize, toSize} from '../size.js';\nimport {withinExtentAndZ} from '../tilecoord.js';\nimport {\n  getForProjection as getTileGridForProjection,\n  wrapX,\n} from '../tilegrid.js';\nimport {abstract, getUid} from '../util.js';\nimport Source from './Source.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./TileEventType\").TileSourceEventTypes, TileSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     import(\"./TileEventType\").TileSourceEventTypes, Return>} TileSourceOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./Source.js\").State} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {boolean} [wrapX=false] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n *\n * @template {import(\"../Tile.js\").default} [TileType=import(\"../Tile.js\").default]\n * @abstract\n * @api\n */\nclass TileSource extends Source {\n  /**\n   * @param {Options} options SourceTile source options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: options.projection,\n      state: options.state,\n      wrapX: options.wrapX,\n      interpolate: options.interpolate,\n    });\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {TileSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilePixelRatio_ =\n      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n\n    /**\n     * @type {import(\"../tilegrid/TileGrid.js\").default|null}\n     * @protected\n     */\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n\n    const tileSize = [256, 256];\n    if (this.tileGrid) {\n      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);\n    }\n\n    /**\n     * @protected\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize = [0, 0];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.key_ = options.key || getUid(this);\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").Options}\n     */\n    this.tileOptions = {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    };\n\n    /**\n     * zDirection hint, read by the renderer. Indicates which resolution should be used\n     * by a renderer if the views resolution does not match any resolution of the tile source.\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n     * will be used. If -1, the nearest higher resolution will be used.\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\n     */\n    this.zDirection = options.zDirection ? options.zDirection : 0;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  getGutterForProjection(projection) {\n    return 0;\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   */\n  getKey() {\n    return this.key_;\n  }\n\n  /**\n   * Set the value to be used as the key for all tiles in the source.\n   * @param {string} key The key for tiles.\n   * @protected\n   */\n  setKey(key) {\n    if (this.key_ !== key) {\n      this.key_ = key;\n      this.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   * @override\n   */\n  getResolutions(projection) {\n    const tileGrid = projection\n      ? this.getTileGridForProjection(projection)\n      : this.tileGrid;\n    if (!tileGrid) {\n      return null;\n    }\n    return tileGrid.getResolutions();\n  }\n\n  /**\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {TileType|null} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    return abstract();\n  }\n\n  /**\n   * Return the tile grid of the tile source.\n   * @return {import(\"../tilegrid/TileGrid.js\").default|null} Tile grid.\n   * @api\n   */\n  getTileGrid() {\n    return this.tileGrid;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    if (!this.tileGrid) {\n      return getTileGridForProjection(projection);\n    }\n    return this.tileGrid;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source. Subclasses may override this\n   * method, which is meant to return a supported pixel ratio that matches the\n   * provided `pixelRatio` as close as possible.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return this.tilePixelRatio_;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    if (tilePixelRatio == 1) {\n      return tileSize;\n    }\n    return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n  }\n\n  /**\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n   * is outside the resolution and extent range of the tile grid, `null` will be\n   * returned.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n   *     null if no tile URL should be created for the passed `tileCoord`.\n   */\n  getTileCoordForTileUrlFunction(tileCoord, projection) {\n    const gridProjection =\n      projection !== undefined ? projection : this.getProjection();\n    const tileGrid =\n      projection !== undefined\n        ? this.getTileGridForProjection(gridProjection)\n        : this.tileGrid || this.getTileGridForProjection(gridProjection);\n    if (this.getWrapX() && gridProjection.isGlobal()) {\n      tileCoord = wrapX(tileGrid, tileCoord, gridProjection);\n    }\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n  }\n\n  /**\n   * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.\n   * @api\n   */\n  clear() {}\n\n  /**\n   * @override\n   */\n  refresh() {\n    this.clear();\n    super.refresh();\n  }\n}\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\nexport class TileSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Tile.js\").default} tile The tile.\n   */\n  constructor(type, tile) {\n    super(type);\n\n    /**\n     * The tile related to the event.\n     * @type {import(\"../Tile.js\").default}\n     * @api\n     */\n    this.tile = tile;\n  }\n}\n\nexport default TileSource;\n","/**\n * @module ol/ImageCanvas\n */\nimport ImageWrapper from './Image.js';\nimport ImageState from './ImageState.js';\n\n/**\n * A function that is called to trigger asynchronous canvas drawing.  It is\n * called with a \"done\" callback that should be called when drawing is done.\n * If any error occurs during drawing, the \"done\" callback should be called with\n * that error.\n *\n * @typedef {function(function(Error=): void): void} Loader\n */\n\nclass ImageCanvas extends ImageWrapper {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {HTMLCanvasElement} canvas Canvas.\n   * @param {Loader} [loader] Optional loader function to\n   *     support asynchronous canvas drawing.\n   */\n  constructor(extent, resolution, pixelRatio, canvas, loader) {\n    const state = loader !== undefined ? ImageState.IDLE : ImageState.LOADED;\n\n    super(extent, resolution, pixelRatio, state);\n\n    /**\n     * Optional canvas loader function.\n     * @type {?Loader}\n     * @private\n     */\n    this.loader_ = loader !== undefined ? loader : null;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = canvas;\n\n    /**\n     * @private\n     * @type {?Error}\n     */\n    this.error_ = null;\n  }\n\n  /**\n   * Get any error associated with asynchronous rendering.\n   * @return {?Error} Any error that occurred during rendering.\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Handle async drawing complete.\n   * @param {Error} [err] Any error during drawing.\n   * @private\n   */\n  handleLoad_(err) {\n    if (err) {\n      this.error_ = err;\n      this.state = ImageState.ERROR;\n    } else {\n      this.state = ImageState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state == ImageState.IDLE) {\n      this.state = ImageState.LOADING;\n      this.changed();\n      this.loader_(this.handleLoad_.bind(this));\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Canvas element.\n   * @override\n   */\n  getImage() {\n    return this.canvas_;\n  }\n}\n\nexport default ImageCanvas;\n","/**\n * @module ol/renderer/canvas/ImageLayer\n */\nimport ImageState from '../../ImageState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  containsCoordinate,\n  containsExtent,\n  getHeight,\n  getIntersection,\n  getWidth,\n  intersects as intersectsExtent,\n  isEmpty,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport CanvasLayerRenderer from './Layer.js';\n\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nclass CanvasImageLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\n   */\n  constructor(imageLayer) {\n    super(imageLayer);\n\n    /**\n     * @protected\n     * @type {?import(\"../../Image.js\").default}\n     */\n    this.image = null;\n  }\n\n  /**\n   * @return {import('../../DataTile.js').ImageLike} Image.\n   */\n  getImage() {\n    return !this.image ? null : this.image.getImage();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n\n    const imageSource = this.getLayer().getSource();\n\n    const hints = frameState.viewHints;\n\n    let renderedExtent = frameState.extent;\n    if (layerState.extent !== undefined) {\n      renderedExtent = getIntersection(\n        renderedExtent,\n        fromUserExtent(layerState.extent, viewState.projection),\n      );\n    }\n\n    if (\n      !hints[ViewHint.ANIMATING] &&\n      !hints[ViewHint.INTERACTING] &&\n      !isEmpty(renderedExtent)\n    ) {\n      if (imageSource) {\n        const projection = viewState.projection;\n        const image = imageSource.getImage(\n          renderedExtent,\n          viewResolution,\n          pixelRatio,\n          projection,\n        );\n        if (image) {\n          if (this.loadImage(image)) {\n            this.image = image;\n          } else if (image.getState() === ImageState.EMPTY) {\n            this.image = null;\n          }\n        }\n      } else {\n        this.image = null;\n      }\n    }\n\n    return !!this.image;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const imageExtent = this.image.getExtent();\n    const img = this.image.getImage();\n\n    const imageMapWidth = getWidth(imageExtent);\n    const col = Math.floor(\n      img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth),\n    );\n    if (col < 0 || col >= img.width) {\n      return null;\n    }\n\n    const imageMapHeight = getHeight(imageExtent);\n    const row = Math.floor(\n      img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight),\n    );\n    if (row < 0 || row >= img.height) {\n      return null;\n    }\n\n    return this.getImageData(img, col, row);\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    const image = this.image;\n    const imageExtent = image.getExtent();\n    const imageResolution = image.getResolution();\n    const [imageResolutionX, imageResolutionY] = Array.isArray(imageResolution)\n      ? imageResolution\n      : [imageResolution, imageResolution];\n    const imagePixelRatio = image.getPixelRatio();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewCenter = viewState.center;\n    const viewResolution = viewState.resolution;\n    const scaleX =\n      (pixelRatio * imageResolutionX) / (viewResolution * imagePixelRatio);\n    const scaleY =\n      (pixelRatio * imageResolutionY) / (viewResolution * imagePixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const context = this.getRenderContext(frameState);\n\n    // clipped rendering if layer extent is set\n    let clipped = false;\n    let render = true;\n    if (layerState.extent) {\n      const layerExtent = fromUserExtent(\n        layerState.extent,\n        viewState.projection,\n      );\n      render = intersectsExtent(layerExtent, frameState.extent);\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    const img = image.getImage();\n\n    const transform = composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      scaleX,\n      scaleY,\n      0,\n      (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolutionX,\n      (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolutionY,\n    );\n\n    this.renderedResolution = (imageResolutionY * pixelRatio) / imagePixelRatio;\n\n    const dw = img.width * transform[0];\n    const dh = img.height * transform[3];\n\n    if (!this.getLayer().getSource().getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n    if (render && dw >= 0.5 && dh >= 0.5) {\n      const dx = transform[4];\n      const dy = transform[5];\n      const opacity = layerState.opacity;\n      if (opacity !== 1) {\n        context.save();\n        context.globalAlpha = opacity;\n      }\n      context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);\n      if (opacity !== 1) {\n        context.restore();\n      }\n    }\n    this.postRender(this.context, frameState);\n\n    if (clipped) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    return this.container;\n  }\n}\n\nexport default CanvasImageLayerRenderer;\n","/**\n * @module ol/layer/BaseImage\n */\nimport Layer from './Layer.js';\n\n/**\n * @template {import(\"../source/Image.js\").default} ImageSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {ImageSourceType} [source] Source for this layer.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Server-rendered images that are available for arbitrary extents and\n * resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Image.js\").default} ImageSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<ImageSourceType, RendererType>}\n * @api\n */\nclass BaseImageLayer extends Layer {\n  /**\n   * @param {Options<ImageSourceType>} [options] Layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super(options);\n  }\n}\n\nexport default BaseImageLayer;\n","/**\n * @module ol/reproj/Image\n */\n\nimport ImageWrapper from '../Image.js';\nimport ImageState from '../ImageState.js';\nimport EventType from '../events/EventType.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {\n  getCenter,\n  getHeight,\n  getIntersection,\n  getWidth,\n  isEmpty,\n} from '../extent.js';\nimport {\n  calculateSourceResolution,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {fromResolutionLike} from '../resolution.js';\nimport Triangulation from './Triangulation.js';\nimport {ERROR_THRESHOLD} from './common.js';\n\n/**\n * @typedef {function(import(\"../extent.js\").Extent, number, number) : import(\"../Image.js\").default} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected image.\n * See {@link module:ol/source/Image~ImageSource}.\n */\nclass ReprojImage extends ImageWrapper {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection (of the data).\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent.\n   * @param {number} targetResolution Target resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {FunctionType} getImageFunction\n   *     Function returning source images (extent, resolution, pixelRatio).\n   * @param {boolean} interpolate Use linear interpolation when resampling.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    targetResolution,\n    pixelRatio,\n    getImageFunction,\n    interpolate,\n  ) {\n    let maxSourceExtent = sourceProj.getExtent();\n    if (maxSourceExtent && sourceProj.canWrapX()) {\n      maxSourceExtent = maxSourceExtent.slice();\n      maxSourceExtent[0] = -Infinity;\n      maxSourceExtent[2] = Infinity;\n    }\n    let maxTargetExtent = targetProj.getExtent();\n    if (maxTargetExtent && targetProj.canWrapX()) {\n      maxTargetExtent = maxTargetExtent.slice();\n      maxTargetExtent[0] = -Infinity;\n      maxTargetExtent[2] = Infinity;\n    }\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    const targetCenter = getCenter(limitedTargetExtent);\n    const sourceResolution = calculateSourceResolution(\n      sourceProj,\n      targetProj,\n      targetCenter,\n      targetResolution,\n    );\n\n    const errorThresholdInPixels = ERROR_THRESHOLD;\n\n    const triangulation = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n    );\n\n    const sourceExtent = triangulation.calculateSourceExtent();\n    const sourceImage = isEmpty(sourceExtent)\n      ? null\n      : getImageFunction(sourceExtent, sourceResolution, pixelRatio);\n    const state = sourceImage ? ImageState.IDLE : ImageState.EMPTY;\n    const sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;\n\n    super(targetExtent, targetResolution, sourcePixelRatio, state);\n\n    /**\n     * @private\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.targetProj_ = targetProj;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = triangulation;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.targetResolution_ = targetResolution;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.targetExtent_ = targetExtent;\n\n    /**\n     * @private\n     * @type {import(\"../Image.js\").default}\n     */\n    this.sourceImage_ = sourceImage;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourcePixelRatio_ = sourcePixelRatio;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.interpolate_ = interpolate;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.sourceListenerKey_ = null;\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    if (this.state == ImageState.LOADING) {\n      this.unlistenSource_();\n    }\n    super.disposeInternal();\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image.\n   * @override\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  getProjection() {\n    return this.targetProj_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sourceState = this.sourceImage_.getState();\n    if (sourceState == ImageState.LOADED) {\n      const width = getWidth(this.targetExtent_) / this.targetResolution_;\n      const height = getHeight(this.targetExtent_) / this.targetResolution_;\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.sourcePixelRatio_,\n        fromResolutionLike(this.sourceImage_.getResolution()),\n        this.maxSourceExtent_,\n        this.targetResolution_,\n        this.targetExtent_,\n        this.triangulation_,\n        [\n          {\n            extent: this.sourceImage_.getExtent(),\n            image: this.sourceImage_.getImage(),\n          },\n        ],\n        0,\n        undefined,\n        this.interpolate_,\n        true,\n      );\n    }\n    this.state = sourceState;\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state == ImageState.IDLE) {\n      this.state = ImageState.LOADING;\n      this.changed();\n\n      const sourceState = this.sourceImage_.getState();\n      if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {\n        this.reproject_();\n      } else {\n        this.sourceListenerKey_ = listen(\n          this.sourceImage_,\n          EventType.CHANGE,\n          (e) => {\n            const sourceState = this.sourceImage_.getState();\n            if (\n              sourceState == ImageState.LOADED ||\n              sourceState == ImageState.ERROR\n            ) {\n              this.unlistenSource_();\n              this.reproject_();\n            }\n          },\n        );\n        this.sourceImage_.load();\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSource_() {\n    unlistenByKey(\n      /** @type {!import(\"../events.js\").EventsKey} */ (\n        this.sourceListenerKey_\n      ),\n    );\n    this.sourceListenerKey_ = null;\n  }\n}\n\nexport default ReprojImage;\n","/**\n * @module ol/source/Image\n */\nimport ImageWrapper from '../Image.js';\nimport ImageState from '../ImageState.js';\nimport {linearFindNearest} from '../array.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport {\n  containsExtent,\n  equals,\n  getCenter,\n  getForViewAndSize,\n  getHeight,\n  getWidth,\n} from '../extent.js';\nimport {ceil} from '../math.js';\nimport {equivalent} from '../proj.js';\nimport ReprojImage from '../reproj/Image.js';\nimport {fromResolutionLike} from '../resolution.js';\nimport Source from './Source.js';\nimport {DECIMALS} from './common.js';\n\n/**\n * @enum {string}\n */\nexport const ImageSourceEventType = {\n  /**\n   * Triggered when an image starts loading.\n   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart\n   * @api\n   */\n  IMAGELOADSTART: 'imageloadstart',\n\n  /**\n   * Triggered when an image finishes loading.\n   * @event module:ol/source/Image.ImageSourceEvent#imageloadend\n   * @api\n   */\n  IMAGELOADEND: 'imageloadend',\n\n  /**\n   * Triggered if image loading results in an error.\n   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror\n   * @api\n   */\n  IMAGELOADERROR: 'imageloaderror',\n};\n\n/**\n * @typedef {'imageloadend'|'imageloaderror'|'imageloadstart'} ImageSourceEventTypes\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Image~ImageSource} instances are instances of this\n * type.\n */\nexport class ImageSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Image.js\").default} image The image.\n   */\n  constructor(type, image) {\n    super(type);\n\n    /**\n     * The image related to the event.\n     * @type {import(\"../Image.js\").default}\n     * @api\n     */\n    this.image = image;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<ImageSourceEventTypes, ImageSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types\n *     |ImageSourceEventTypes, Return>} ImageSourceOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../Image.js\").Loader} [loader] Loader. Can either be a custom loader, or one of the\n * loaders created with a `createLoader()` function ({@link module:ol/source/wms.createLoader wms},\n * {@link module:ol/source/arcgisRest.createLoader arcgisRest}, {@link module:ol/source/mapguide.createLoader mapguide},\n * {@link module:ol/source/static.createLoader static}).\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {Array<number>} [resolutions] Resolutions.\n * @property {import(\"./Source.js\").State} [state] State.\n */\n\n/**\n * @classdesc\n * Base class for sources providing a single image.\n * @fires module:ol/source/Image.ImageSourceEvent\n * @api\n */\nclass ImageSource extends Source {\n  /**\n   * @param {Options} options Single image source options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      projection: options.projection,\n      state: options.state,\n      interpolate:\n        options.interpolate !== undefined ? options.interpolate : true,\n    });\n\n    /***\n     * @type {ImageSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ImageSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ImageSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @protected\n     * @type {import(\"../Image.js\").Loader}\n     */\n    this.loader = options.loader || null;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.resolutions_ =\n      options.resolutions !== undefined ? options.resolutions : null;\n\n    /**\n     * @private\n     * @type {import(\"../reproj/Image.js\").default}\n     */\n    this.reprojectedImage_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.reprojectedRevision_ = 0;\n\n    /**\n     * @protected\n     * @type {import(\"../Image.js\").default}\n     */\n    this.image = null;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.wantedExtent_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.wantedResolution_;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.static_ = options.loader ? options.loader.length === 0 : false;\n\n    /**\n     * @private\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.wantedProjection_ = null;\n  }\n\n  /**\n   * @return {Array<number>|null} Resolutions.\n   * @override\n   */\n  getResolutions() {\n    return this.resolutions_;\n  }\n\n  /**\n   * @param {Array<number>|null} resolutions Resolutions.\n   */\n  setResolutions(resolutions) {\n    this.resolutions_ = resolutions;\n  }\n\n  /**\n   * @protected\n   * @param {number} resolution Resolution.\n   * @return {number} Resolution.\n   */\n  findNearestResolution(resolution) {\n    const resolutions = this.getResolutions();\n    if (resolutions) {\n      const idx = linearFindNearest(resolutions, resolution, 0);\n      resolution = resolutions[idx];\n    }\n    return resolution;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../Image.js\").default} Single image.\n   */\n  getImage(extent, resolution, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (\n      !sourceProjection ||\n      !projection ||\n      equivalent(sourceProjection, projection)\n    ) {\n      if (sourceProjection) {\n        projection = sourceProjection;\n      }\n\n      return this.getImageInternal(extent, resolution, pixelRatio, projection);\n    }\n    if (this.reprojectedImage_) {\n      if (\n        this.reprojectedRevision_ == this.getRevision() &&\n        equivalent(this.reprojectedImage_.getProjection(), projection) &&\n        this.reprojectedImage_.getResolution() == resolution &&\n        equals(this.reprojectedImage_.getExtent(), extent)\n      ) {\n        return this.reprojectedImage_;\n      }\n      this.reprojectedImage_.dispose();\n      this.reprojectedImage_ = null;\n    }\n\n    this.reprojectedImage_ = new ReprojImage(\n      sourceProjection,\n      projection,\n      extent,\n      resolution,\n      pixelRatio,\n      (extent, resolution, pixelRatio) =>\n        this.getImageInternal(extent, resolution, pixelRatio, sourceProjection),\n      this.getInterpolate(),\n    );\n    this.reprojectedRevision_ = this.getRevision();\n\n    return this.reprojectedImage_;\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../Image.js\").default} Single image.\n   * @protected\n   */\n  getImageInternal(extent, resolution, pixelRatio, projection) {\n    if (this.loader) {\n      const requestExtent = getRequestExtent(extent, resolution, pixelRatio, 1);\n      const requestResolution = this.findNearestResolution(resolution);\n      if (\n        this.image &&\n        (this.static_ ||\n          (this.wantedProjection_ === projection &&\n            ((this.wantedExtent_ &&\n              containsExtent(this.wantedExtent_, requestExtent)) ||\n              containsExtent(this.image.getExtent(), requestExtent)) &&\n            ((this.wantedResolution_ &&\n              fromResolutionLike(this.wantedResolution_) ===\n                requestResolution) ||\n              fromResolutionLike(this.image.getResolution()) ===\n                requestResolution)))\n      ) {\n        return this.image;\n      }\n      this.wantedProjection_ = projection;\n      this.wantedExtent_ = requestExtent;\n      this.wantedResolution_ = requestResolution;\n      this.image = new ImageWrapper(\n        requestExtent,\n        requestResolution,\n        pixelRatio,\n        this.loader,\n      );\n      this.image.addEventListener(\n        EventType.CHANGE,\n        this.handleImageChange.bind(this),\n      );\n    }\n    return this.image;\n  }\n\n  /**\n   * Handle image change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   * @protected\n   */\n  handleImageChange(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    let type;\n    switch (image.getState()) {\n      case ImageState.LOADING:\n        this.loading = true;\n        type = ImageSourceEventType.IMAGELOADSTART;\n        break;\n      case ImageState.LOADED:\n        this.loading = false;\n        type = ImageSourceEventType.IMAGELOADEND;\n        break;\n      case ImageState.ERROR:\n        this.loading = false;\n        type = ImageSourceEventType.IMAGELOADERROR;\n        break;\n      default:\n        return;\n    }\n    if (this.hasListener(type)) {\n      this.dispatchEvent(new ImageSourceEvent(type, image));\n    }\n  }\n}\n\n/**\n * Default image load function for image sources that use import(\"../Image.js\").Image image\n * instances.\n * @param {import(\"../Image.js\").default} image Image.\n * @param {string} src Source.\n */\nexport function defaultImageLoadFunction(image, src) {\n  /** @type {HTMLImageElement|HTMLVideoElement} */ (image.getImage()).src = src;\n}\n\n/**\n * Adjusts the extent so it aligns with pixel boundaries.\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {number} resolution Reolution.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} ratio Ratio between request size and view size.\n * @return {import(\"../extent.js\").Extent} Request extent.\n */\nexport function getRequestExtent(extent, resolution, pixelRatio, ratio) {\n  const imageResolution = resolution / pixelRatio;\n  const center = getCenter(extent);\n  const viewWidth = ceil(getWidth(extent) / imageResolution, DECIMALS);\n  const viewHeight = ceil(getHeight(extent) / imageResolution, DECIMALS);\n  const marginWidth = ceil(((ratio - 1) * viewWidth) / 2, DECIMALS);\n  const requestWidth = viewWidth + 2 * marginWidth;\n  const marginHeight = ceil(((ratio - 1) * viewHeight) / 2, DECIMALS);\n  const requestHeight = viewHeight + 2 * marginHeight;\n  return getForViewAndSize(center, imageResolution, 0, [\n    requestWidth,\n    requestHeight,\n  ]);\n}\n\nexport default ImageSource;\n","/**\n * @module ol/source/Raster\n */\nimport Disposable from '../Disposable.js';\nimport ImageCanvas from '../ImageCanvas.js';\nimport TileQueue from '../TileQueue.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport {equals, getCenter, getHeight, getWidth} from '../extent.js';\nimport ImageLayer from '../layer/Image.js';\nimport TileLayer from '../layer/Tile.js';\nimport {create as createTransform} from '../transform.js';\nimport {getUid} from '../util.js';\nimport ImageSource from './Image.js';\nimport Source from './Source.js';\nimport TileSource from './Tile.js';\n\n/**\n * @typedef {Object} MinionData\n * @property {Array<ArrayBuffer>} buffers Array of buffers.\n * @property {Object} meta Operation metadata.\n * @property {boolean} imageOps The operation is an image operation.\n * @property {number} width The width of the image.\n * @property {number} height The height of the image.\n */\n\n/* istanbul ignore next */\n/**\n * Create a function for running operations.  This function is serialized for\n * use in a worker.\n * @param {function(Array, Object):*} operation The operation.\n * @return {function(MinionData):ArrayBuffer} A function that takes an object with\n * buffers, meta, imageOps, width, and height properties and returns an array\n * buffer.\n */\nfunction createMinion(operation) {\n  return function (data) {\n    // bracket notation for minification support\n    const buffers = data['buffers'];\n    const meta = data['meta'];\n    const imageOps = data['imageOps'];\n    const width = data['width'];\n    const height = data['height'];\n\n    const numBuffers = buffers.length;\n    const numBytes = buffers[0].byteLength;\n\n    if (imageOps) {\n      const images = new Array(numBuffers);\n      for (let b = 0; b < numBuffers; ++b) {\n        images[b] = new ImageData(\n          new Uint8ClampedArray(buffers[b]),\n          width,\n          height,\n        );\n      }\n      const output = operation(images, meta).data;\n      return output.buffer;\n    }\n\n    const output = new Uint8ClampedArray(numBytes);\n    const arrays = new Array(numBuffers);\n    const pixels = new Array(numBuffers);\n    for (let b = 0; b < numBuffers; ++b) {\n      arrays[b] = new Uint8ClampedArray(buffers[b]);\n      pixels[b] = [0, 0, 0, 0];\n    }\n    for (let i = 0; i < numBytes; i += 4) {\n      for (let j = 0; j < numBuffers; ++j) {\n        const array = arrays[j];\n        pixels[j][0] = array[i];\n        pixels[j][1] = array[i + 1];\n        pixels[j][2] = array[i + 2];\n        pixels[j][3] = array[i + 3];\n      }\n      const pixel = operation(pixels, meta);\n      output[i] = pixel[0];\n      output[i + 1] = pixel[1];\n      output[i + 2] = pixel[2];\n      output[i + 3] = pixel[3];\n    }\n    return output.buffer;\n  };\n}\n\n/**\n * Create a worker for running operations.\n * @param {ProcessorOptions} config Processor options.\n * @param {function(MessageEvent): void} onMessage Called with a message event.\n * @return {Worker} The worker.\n */\nfunction createWorker(config, onMessage) {\n  const lib = Object.keys(config.lib || {}).map(function (name) {\n    return 'const ' + name + ' = ' + config.lib[name].toString() + ';';\n  });\n\n  const lines = lib.concat([\n    'const __minion__ = (' + createMinion.toString() + ')(',\n    config.operation.toString(),\n    ');',\n    'self.addEventListener(\"message\", function(event) {',\n    '  const buffer = __minion__(event.data);',\n    '  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);',\n    '});',\n  ]);\n\n  const worker = new Worker(\n    typeof Blob === 'undefined'\n      ? 'data:text/javascript;base64,' +\n        Buffer.from(lines.join('\\n'), 'binary').toString('base64')\n      : URL.createObjectURL(new Blob(lines, {type: 'text/javascript'})),\n  );\n  worker.addEventListener('message', onMessage);\n  return worker;\n}\n\n/**\n * @typedef {Object} FauxMessageEvent\n * @property {Object} data Message data.\n */\n\n/**\n * Create a faux worker for running operations.\n * @param {ProcessorOptions} config Configuration.\n * @param {function(FauxMessageEvent): void} onMessage Called with a message event.\n * @return {Object} The faux worker.\n */\nfunction createFauxWorker(config, onMessage) {\n  const minion = createMinion(config.operation);\n  let terminated = false;\n  return {\n    postMessage: function (data) {\n      setTimeout(function () {\n        if (terminated) {\n          return;\n        }\n        onMessage({data: {buffer: minion(data), meta: data['meta']}});\n      }, 0);\n    },\n    terminate: function () {\n      terminated = true;\n    },\n  };\n}\n\n/**\n * @typedef {function(Error, ImageData, (Object|Array<Object>)): void} JobCallback\n */\n\n/**\n * @typedef {Object} Job\n * @property {Object} meta Job metadata.\n * @property {Array<ImageData>} inputs Array of input data.\n * @property {JobCallback} callback Called when the job is complete.\n */\n\n/**\n * @typedef {Object} ProcessorOptions\n * @property {number} threads Number of workers to spawn.\n * @property {Operation} operation The operation.\n * @property {Object<string, Function>} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} queue The number of queued jobs to allow.\n * @property {boolean} [imageOps=false] Pass all the image data to the operation instead of a single pixel.\n */\n\n/**\n * @classdesc\n * A processor runs pixel or image operations in workers.\n */\nexport class Processor extends Disposable {\n  /**\n   * @param {ProcessorOptions} config Configuration.\n   */\n  constructor(config) {\n    super();\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.imageOps_ = !!config.imageOps;\n    let threads;\n    if (config.threads === 0) {\n      threads = 0;\n    } else if (this.imageOps_) {\n      threads = 1;\n    } else {\n      threads = config.threads || 1;\n    }\n\n    /**\n     * @type {Array<Worker>}\n     */\n    const workers = new Array(threads);\n    if (threads) {\n      for (let i = 0; i < threads; ++i) {\n        workers[i] = createWorker(config, this.onWorkerMessage_.bind(this, i));\n      }\n    } else {\n      workers[0] = createFauxWorker(\n        config,\n        this.onWorkerMessage_.bind(this, 0),\n      );\n    }\n    /**\n     * @type {Array<Worker>}\n     * @private\n     */\n    this.workers_ = workers;\n\n    /**\n     * @type {Array<Job>}\n     * @private\n     */\n    this.queue_ = [];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxQueueLength_ = config.queue || Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    this.running_ = 0;\n\n    /**\n     * @type {Object<number, any>}\n     * @private\n     */\n    this.dataLookup_ = {};\n\n    /**\n     * @type {Job|null}\n     * @private\n     */\n    this.job_ = null;\n  }\n\n  /**\n   * Run operation on input data.\n   * @param {Array<ImageData>} inputs Array of image data.\n   * @param {Object} meta A user data object.  This is passed to all operations\n   *     and must be serializable.\n   * @param {function(Error, ImageData, Object): void} callback Called when work\n   *     completes.  The first argument is any error.  The second is the ImageData\n   *     generated by operations.  The third is the user data object.\n   */\n  process(inputs, meta, callback) {\n    this.enqueue_({\n      inputs: inputs,\n      meta: meta,\n      callback: callback,\n    });\n    this.dispatch_();\n  }\n\n  /**\n   * Add a job to the queue.\n   * @param {Job} job The job.\n   */\n  enqueue_(job) {\n    this.queue_.push(job);\n    while (this.queue_.length > this.maxQueueLength_) {\n      this.queue_.shift().callback(null, null);\n    }\n  }\n\n  /**\n   * Dispatch a job.\n   */\n  dispatch_() {\n    if (this.running_ || this.queue_.length === 0) {\n      return;\n    }\n\n    const job = this.queue_.shift();\n    this.job_ = job;\n    const width = job.inputs[0].width;\n    const height = job.inputs[0].height;\n    const buffers = job.inputs.map(function (input) {\n      return input.data.buffer;\n    });\n    const threads = this.workers_.length;\n    this.running_ = threads;\n    if (threads === 1) {\n      this.workers_[0].postMessage(\n        {\n          buffers: buffers,\n          meta: job.meta,\n          imageOps: this.imageOps_,\n          width: width,\n          height: height,\n        },\n        buffers,\n      );\n      return;\n    }\n\n    const length = job.inputs[0].data.length;\n    const segmentLength = 4 * Math.ceil(length / 4 / threads);\n    for (let i = 0; i < threads; ++i) {\n      const offset = i * segmentLength;\n      const slices = [];\n      for (let j = 0, jj = buffers.length; j < jj; ++j) {\n        slices.push(buffers[j].slice(offset, offset + segmentLength));\n      }\n      this.workers_[i].postMessage(\n        {\n          buffers: slices,\n          meta: job.meta,\n          imageOps: this.imageOps_,\n          width: width,\n          height: height,\n        },\n        slices,\n      );\n    }\n  }\n\n  /**\n   * Handle messages from the worker.\n   * @param {number} index The worker index.\n   * @param {MessageEvent} event The message event.\n   */\n  onWorkerMessage_(index, event) {\n    if (this.disposed) {\n      return;\n    }\n    this.dataLookup_[index] = event.data;\n    --this.running_;\n    if (this.running_ === 0) {\n      this.resolveJob_();\n    }\n  }\n\n  /**\n   * Resolve a job.  If there are no more worker threads, the processor callback\n   * will be called.\n   */\n  resolveJob_() {\n    const job = this.job_;\n    const threads = this.workers_.length;\n    let data, meta;\n    if (threads === 1) {\n      data = new Uint8ClampedArray(this.dataLookup_[0]['buffer']);\n      meta = this.dataLookup_[0]['meta'];\n    } else {\n      const length = job.inputs[0].data.length;\n      data = new Uint8ClampedArray(length);\n      meta = new Array(threads);\n      const segmentLength = 4 * Math.ceil(length / 4 / threads);\n      for (let i = 0; i < threads; ++i) {\n        const buffer = this.dataLookup_[i]['buffer'];\n        const offset = i * segmentLength;\n        data.set(new Uint8ClampedArray(buffer), offset);\n        meta[i] = this.dataLookup_[i]['meta'];\n      }\n    }\n    this.job_ = null;\n    this.dataLookup_ = {};\n    job.callback(\n      null,\n      new ImageData(data, job.inputs[0].width, job.inputs[0].height),\n      meta,\n    );\n    this.dispatch_();\n  }\n\n  /**\n   * Terminate all workers associated with the processor.\n   * @override\n   */\n  disposeInternal() {\n    for (let i = 0; i < this.workers_.length; ++i) {\n      this.workers_[i].terminate();\n    }\n    this.workers_.length = 0;\n  }\n}\n\n/**\n * A function that takes an array of input data, performs some operation, and\n * returns an array of output data.\n * For `pixel` type operations, the function will be called with an array of\n * pixels, where each pixel is an array of four numbers (`[r, g, b, a]`) in the\n * range of 0 - 255. It should return a single pixel array.\n * For `'image'` type operations, functions will be called with an array of\n * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData)\n * and should return a single\n * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).\n * The operations\n * are called with a second \"data\" argument, which can be used for storage.  The\n * data object is accessible from raster events, where it can be initialized in\n * \"beforeoperations\" and accessed again in \"afteroperations\".\n *\n * @typedef {function((Array<Array<number>>|Array<ImageData>), Object):\n *     (Array<number>|ImageData)} Operation\n */\n\n/**\n * @enum {string}\n */\nconst RasterEventType = {\n  /**\n   * Triggered before operations are run.  Listeners will receive an event object with\n   * a `data` property that can be used to make data available to operations.\n   * @event module:ol/source/Raster.RasterSourceEvent#beforeoperations\n   * @api\n   */\n  BEFOREOPERATIONS: 'beforeoperations',\n\n  /**\n   * Triggered after operations are run.  Listeners will receive an event object with\n   * a `data` property.  If more than one thread is used, `data` will be an array of\n   * objects.  If a single thread is used, `data` will be a single object.\n   * @event module:ol/source/Raster.RasterSourceEvent#afteroperations\n   * @api\n   */\n  AFTEROPERATIONS: 'afteroperations',\n};\n\n/**\n * @typedef {'pixel' | 'image'} RasterOperationType\n * Raster operation type. Supported values are `'pixel'` and `'image'`.\n */\n\n/**\n * @typedef {import(\"./Image.js\").ImageSourceEventTypes|'beforeoperations'|'afteroperations'} RasterSourceEventTypes\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Raster~RasterSource} instances are instances of this\n * type.\n */\nexport class RasterSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n   * @param {Object|Array<Object>} data An object made available to operations.  For \"afteroperations\" evenets\n   * this will be an array of objects if more than one thread is used.\n   */\n  constructor(type, frameState, data) {\n    super(type);\n\n    /**\n     * The raster extent.\n     * @type {import(\"../extent.js\").Extent}\n     * @api\n     */\n    this.extent = frameState.extent;\n\n    /**\n     * The pixel resolution (map units per pixel).\n     * @type {number}\n     * @api\n     */\n    this.resolution = frameState.viewState.resolution / frameState.pixelRatio;\n\n    /**\n     * An object made available to all operations.  This can be used by operations\n     * as a storage object (e.g. for calculating statistics).\n     * @type {Object}\n     * @api\n     */\n    this.data = data;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources Input\n * sources or layers.  For vector data, use an VectorImage layer.\n * @property {Operation} [operation] Raster operation.\n * The operation will be called with data from input sources\n * and the output will be assigned to the raster source.\n * @property {Object} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} [threads] By default, operations will be run in a single worker thread.\n * To avoid using workers altogether, set `threads: 0`.  For pixel operations, operations can\n * be run in multiple worker threads.  Note that there is additional overhead in\n * transferring data to multiple workers, and that depending on the user's\n * system, it may not be possible to parallelize the work.\n * @property {RasterOperationType} [operationType='pixel'] Operation type.\n * Supported values are `'pixel'` and `'image'`.  By default,\n * `'pixel'` operations are assumed, and operations will be called with an\n * array of pixels from input sources.  If set to `'image'`, operations will\n * be called with an array of ImageData objects from input sources.\n * @property {Array<number>|null} [resolutions] Resolutions. If specified, raster operations will only\n * be run at the given resolutions.  By default, the resolutions of the first source with resolutions\n * specified will be used, if any. Set to `null` to use any view resolution instead.\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Image.js\").ImageSourceEventTypes, import(\"./Image.js\").ImageSourceEvent, Return> &\n *   import(\"../Observable\").OnSignature<RasterSourceEventTypes, RasterSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types\n *     |RasterSourceEventTypes, Return>} RasterSourceOnSignature\n */\n\n/**\n * @classdesc\n * A source that transforms data from any number of input sources using an\n * {@link module:ol/source/Raster~Operation} function to transform input pixel values into\n * output pixel values.\n *\n * @fires module:ol/source/Raster.RasterSourceEvent\n * @api\n */\nclass RasterSource extends ImageSource {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    super({\n      projection: null,\n    });\n\n    /***\n     * @type {RasterSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {RasterSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {RasterSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {Processor}\n     */\n    this.processor_ = null;\n\n    /**\n     * @private\n     * @type {RasterOperationType}\n     */\n    this.operationType_ =\n      options.operationType !== undefined ? options.operationType : 'pixel';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.threads_ = options.threads !== undefined ? options.threads : 1;\n\n    /**\n     * @private\n     * @type {Array<import(\"../layer/Layer.js\").default>}\n     */\n    this.layers_ = createLayers(options.sources);\n\n    const changed = this.changed.bind(this);\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      this.layers_[i].addEventListener(EventType.CHANGE, changed);\n    }\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.useResolutions_ = options.resolutions !== null;\n\n    /**\n     * @private\n     * @type {import(\"../TileQueue.js\").default}\n     */\n    this.tileQueue_ = new TileQueue(function () {\n      return 1;\n    }, this.processSources_.bind(this));\n\n    /**\n     * The most recently requested frame state.\n     * @type {import(\"../Map.js\").FrameState}\n     * @private\n     */\n    this.requestedFrameState_;\n\n    /**\n     * The most recently rendered image canvas.\n     * @type {import(\"../ImageCanvas.js\").default}\n     * @private\n     */\n    this.renderedImageCanvas_ = null;\n\n    /**\n     * The most recently rendered revision.\n     * @type {number}\n     * @private\n     */\n    this.renderedRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").FrameState}\n     */\n    this.frameState_ = {\n      animate: false,\n      coordinateToPixelTransform: createTransform(),\n      declutter: null,\n      extent: null,\n      index: 0,\n      layerIndex: 0,\n      layerStatesArray: getLayerStatesArray(this.layers_),\n      pixelRatio: 1,\n      pixelToCoordinateTransform: createTransform(),\n      postRenderFunctions: [],\n      size: [0, 0],\n      tileQueue: this.tileQueue_,\n      time: Date.now(),\n      usedTiles: {},\n      viewState: /** @type {import(\"../View.js\").State} */ ({\n        rotation: 0,\n      }),\n      viewHints: [],\n      wantedTiles: {},\n      mapId: getUid(this),\n      renderTargets: {},\n    };\n\n    this.setAttributions(function (frameState) {\n      /** @type {Array<string>} */\n      const attributions = [];\n      for (let i = 0, iMax = options.sources.length; i < iMax; ++i) {\n        const sourceOrLayer = options.sources[i];\n        const source =\n          sourceOrLayer instanceof Source\n            ? sourceOrLayer\n            : sourceOrLayer.getSource();\n        if (!source) {\n          continue;\n        }\n        const sourceAttributions = source.getAttributions()?.(frameState);\n        if (typeof sourceAttributions === 'string') {\n          attributions.push(sourceAttributions);\n        } else if (sourceAttributions !== undefined) {\n          attributions.push(...sourceAttributions);\n        }\n      }\n      return attributions;\n    });\n\n    if (options.operation !== undefined) {\n      this.setOperation(options.operation, options.lib);\n    }\n  }\n\n  /**\n   * Set the operation.\n   * @param {Operation} operation New operation.\n   * @param {Object} [lib] Functions that will be available to operations run\n   *     in a worker.\n   * @api\n   */\n  setOperation(operation, lib) {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n\n    this.processor_ = new Processor({\n      operation: operation,\n      imageOps: this.operationType_ === 'image',\n      queue: 1,\n      lib: lib,\n      threads: this.threads_,\n    });\n    this.changed();\n  }\n\n  /**\n   * Update the stored frame state.\n   * @param {import(\"../extent.js\").Extent} extent The view extent (in map units).\n   * @param {number} resolution The view resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n   * @return {import(\"../Map.js\").FrameState} The updated frame state.\n   * @private\n   */\n  updateFrameState_(extent, resolution, projection) {\n    const frameState = /** @type {import(\"../Map.js\").FrameState} */ (\n      Object.assign({}, this.frameState_)\n    );\n\n    frameState.viewState = /** @type {import(\"../View.js\").State} */ (\n      Object.assign({}, frameState.viewState)\n    );\n\n    const center = getCenter(extent);\n\n    frameState.size[0] = Math.ceil(getWidth(extent) / resolution);\n    frameState.size[1] = Math.ceil(getHeight(extent) / resolution);\n    frameState.extent = [\n      center[0] - (frameState.size[0] * resolution) / 2,\n      center[1] - (frameState.size[1] * resolution) / 2,\n      center[0] + (frameState.size[0] * resolution) / 2,\n      center[1] + (frameState.size[1] * resolution) / 2,\n    ];\n    frameState.time = Date.now();\n\n    const viewState = frameState.viewState;\n    viewState.center = center;\n    viewState.projection = projection;\n    viewState.resolution = resolution;\n    return frameState;\n  }\n\n  /**\n   * Determine if all sources are ready.\n   * @return {boolean} All sources are ready.\n   * @private\n   */\n  allSourcesReady_() {\n    let ready = true;\n    let source;\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      source = this.layers_[i].getSource();\n      if (!source || source.getState() !== 'ready') {\n        ready = false;\n        break;\n      }\n    }\n    return ready;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../ImageCanvas.js\").default} Single image.\n   * @override\n   */\n  getImage(extent, resolution, pixelRatio, projection) {\n    if (!this.allSourcesReady_()) {\n      return null;\n    }\n\n    this.tileQueue_.loadMoreTiles(16, 16);\n\n    resolution = this.findNearestResolution(resolution);\n    const frameState = this.updateFrameState_(extent, resolution, projection);\n    this.requestedFrameState_ = frameState;\n\n    // check if we can't reuse the existing ol/ImageCanvas\n    if (this.renderedImageCanvas_) {\n      const renderedResolution = this.renderedImageCanvas_.getResolution();\n      const renderedExtent = this.renderedImageCanvas_.getExtent();\n      if (\n        resolution !== renderedResolution ||\n        !equals(frameState.extent, renderedExtent)\n      ) {\n        this.renderedImageCanvas_ = null;\n      }\n    }\n\n    if (\n      !this.renderedImageCanvas_ ||\n      this.getRevision() !== this.renderedRevision_\n    ) {\n      this.processSources_();\n    }\n\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    }\n\n    return this.renderedImageCanvas_;\n  }\n\n  /**\n   * Start processing source data.\n   * @private\n   */\n  processSources_() {\n    const frameState = this.requestedFrameState_;\n    const len = this.layers_.length;\n    const imageDatas = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      frameState.layerIndex = i;\n      frameState.renderTargets = {};\n      const imageData = getImageData(this.layers_[i], frameState);\n      if (imageData) {\n        imageDatas[i] = imageData;\n      } else {\n        return;\n      }\n    }\n\n    const data = {};\n    this.dispatchEvent(\n      new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data),\n    );\n    this.processor_.process(\n      imageDatas,\n      data,\n      this.onWorkerComplete_.bind(this, frameState),\n    );\n  }\n\n  /**\n   * Called when pixel processing is complete.\n   * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n   * @param {Error} err Any error during processing.\n   * @param {ImageData} output The output image data.\n   * @param {Object|Array<Object>} data The user data (or an array if more than one thread).\n   * @private\n   */\n  onWorkerComplete_(frameState, err, output, data) {\n    if (err || !output) {\n      return;\n    }\n\n    // do nothing if extent or resolution changed\n    const extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    if (\n      resolution !== this.requestedFrameState_.viewState.resolution ||\n      !equals(extent, this.requestedFrameState_.extent)\n    ) {\n      return;\n    }\n\n    let context;\n    if (this.renderedImageCanvas_) {\n      context = this.renderedImageCanvas_.getImage().getContext('2d');\n    } else {\n      const width = Math.round(getWidth(extent) / resolution);\n      const height = Math.round(getHeight(extent) / resolution);\n      context = createCanvasContext2D(width, height);\n      this.renderedImageCanvas_ = new ImageCanvas(\n        extent,\n        resolution,\n        1,\n        context.canvas,\n      );\n    }\n    context.putImageData(output, 0, 0);\n\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    } else {\n      this.changed();\n    }\n    this.renderedRevision_ = this.getRevision();\n\n    this.dispatchEvent(\n      new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data),\n    );\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   * @override\n   */\n  getResolutions(projection) {\n    if (!this.useResolutions_) {\n      return null;\n    }\n    let resolutions = super.getResolutions();\n    if (!resolutions) {\n      for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n        const source = this.layers_[i].getSource();\n        resolutions = source.getResolutions(projection);\n        if (resolutions) {\n          break;\n        }\n      }\n    }\n    return resolutions;\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n    super.disposeInternal();\n  }\n}\n\n/**\n * Clean up and unregister the worker.\n * @function\n * @api\n */\nRasterSource.prototype.dispose;\n\n/**\n * A reusable canvas context.\n * @type {CanvasRenderingContext2D}\n * @private\n */\nlet sharedContext = null;\n\n/**\n * Get image data from a layer.\n * @param {import(\"../layer/Layer.js\").default} layer Layer to render.\n * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n * @return {ImageData} The image data.\n */\nfunction getImageData(layer, frameState) {\n  const renderer = layer.getRenderer();\n  if (!renderer) {\n    throw new Error('Unsupported layer type: ' + layer);\n  }\n\n  if (!renderer.prepareFrame(frameState)) {\n    return null;\n  }\n  const width = frameState.size[0];\n  const height = frameState.size[1];\n  if (width === 0 || height === 0) {\n    return null;\n  }\n  const container = renderer.renderFrame(frameState, null);\n  let element;\n  if (container instanceof HTMLCanvasElement) {\n    element = container;\n  } else {\n    if (container) {\n      element = container.firstElementChild;\n    }\n    if (!(element instanceof HTMLCanvasElement)) {\n      throw new Error('Unsupported rendered element: ' + element);\n    }\n    if (element.width === width && element.height === height) {\n      const context = element.getContext('2d');\n      return context.getImageData(0, 0, width, height);\n    }\n  }\n\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(width, height, undefined, {\n      willReadFrequently: true,\n    });\n  } else {\n    const canvas = sharedContext.canvas;\n    if (canvas.width !== width || canvas.height !== height) {\n      sharedContext = createCanvasContext2D(width, height, undefined, {\n        willReadFrequently: true,\n      });\n    } else {\n      sharedContext.clearRect(0, 0, width, height);\n    }\n  }\n  sharedContext.drawImage(element, 0, 0, width, height);\n  return sharedContext.getImageData(0, 0, width, height);\n}\n\n/**\n * Get a list of layer states from a list of layers.\n * @param {Array<import(\"../layer/Layer.js\").default>} layers Layers.\n * @return {Array<import(\"../layer/Layer.js\").State>} The layer states.\n */\nfunction getLayerStatesArray(layers) {\n  return layers.map(function (layer) {\n    return layer.getLayerState();\n  });\n}\n\n/**\n * Create layers for all sources.\n * @param {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources The sources.\n * @return {Array<import(\"../layer/Layer.js\").default>} Array of layers.\n */\nfunction createLayers(sources) {\n  const len = sources.length;\n  const layers = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    layers[i] = createLayer(sources[i]);\n  }\n  return layers;\n}\n\n/**\n * Create a layer for the provided source.\n * @param {import(\"./Source.js\").default|import(\"../layer/Layer.js\").default} layerOrSource The layer or source.\n * @return {import(\"../layer/Layer.js\").default} The layer.\n */\nfunction createLayer(layerOrSource) {\n  // @type {import(\"../layer/Layer.js\").default}\n  let layer;\n  if (layerOrSource instanceof Source) {\n    if (layerOrSource instanceof TileSource) {\n      layer = new TileLayer({source: layerOrSource});\n    } else if (layerOrSource instanceof ImageSource) {\n      layer = new ImageLayer({source: layerOrSource});\n    }\n  } else {\n    layer = layerOrSource;\n  }\n  return layer;\n}\n\nexport default RasterSource;\n"],"names":["getForProjection","projection","tileGrid","getDefaultTileGrid","createForProjection","setDefaultTileGrid","wrapX","tileCoord","z","center","getTileCoordCenter","projectionExtent","extentFromProjection","worldWidth","worldsAway","Math","ceil","getTileCoordForCoordAndZ","createForExtent","extent","maxZoom","tileSize","corner","undefined","resolutions","resolutionsFromExtent","origin","createXYZ","options","xyzOptions","getExtent","gridOptions","minZoom","maxResolution","height","width","max","length","Array","pow","half","degrees","getMetersPerUnit","LRUCache","constructor","highWaterMark","this","count_","entries_","oldest_","newest_","deleteOldest","entry","pop","dispose","canExpireCache","getCount","expireCache","keep","clear","containsKey","key","hasOwnProperty","forEach","f","value_","key_","newer","get","older","remove","getKeys","keys","i","getValues","values","peekLast","peekLastKey","peekFirstKey","peek","replace","value","set","setSize","size","BaseTileLayer","baseOptions","Object","assign","cacheSize","preload","useInterimTilesOnError","super","on","once","un","cacheSize_","setPreload","setUseInterimTilesOnError","getCacheSize","getPreload","PRELOAD","getUseInterimTilesOnError","USE_INTERIM_TILES_ON_ERROR","getData","pixel","asImageLike","data","Image","HTMLCanvasElement","HTMLVideoElement","ImageBitmap","asArrayLike","Uint8Array","Uint8ClampedArray","Float32Array","DataView","disposedError","Error","sharedContext","toArray","image","willReadFrequently","canvas","clearRect","drawImage","getImageData","defaultSize","DataTile","state","IDLE","transition","interpolate","loader_","loader","data_","error_","size_","controller_","controller","getSize","imageData","getError","load","ERROR","LOADING","changed","self","then","LOADED","catch","error","disposeInternal","abort","TileLayer","createRenderer","fromResolutionLike","resolution","isArray","min","DEFAULT_WMS_VERSION","DECIMALS","ImageLayer","TileSource","attributions","attributionsCollapsible","tilePixelRatio_","tilePixelRatio","getTileSize","getMinZoom","tmpSize","tileOptions","zDirection","getGutterForProjection","getKey","setKey","getResolutions","getTileGridForProjection","getTile","x","y","pixelRatio","getTileGrid","getTilePixelRatio","getTilePixelSize","getTileCoordForTileUrlFunction","gridProjection","getProjection","getWrapX","isGlobal","refresh","TileSourceEvent","type","tile","ImageCanvas","canvas_","handleLoad_","err","bind","getImage","CanvasImageLayerRenderer","imageLayer","prepareFrame","frameState","layerState","layerStatesArray","layerIndex","viewState","viewResolution","imageSource","getLayer","getSource","hints","viewHints","renderedExtent","ANIMATING","INTERACTING","loadImage","getState","EMPTY","layer","coordinate","pixelToCoordinateTransform","slice","layerExtent","imageExtent","img","imageMapWidth","col","floor","imageMapHeight","row","renderFrame","target","imageResolution","getResolution","imageResolutionX","imageResolutionY","imagePixelRatio","getPixelRatio","viewCenter","scaleX","scaleY","prepareContainer","context","getRenderContext","clipped","render","clipUnrotated","transform","tempTransform","renderedResolution","dw","dh","getInterpolate","imageSmoothingEnabled","preRender","dx","dy","opacity","save","globalAlpha","restore","postRender","container","BaseImageLayer","ReprojImage","sourceProj","targetProj","targetExtent","targetResolution","getImageFunction","maxSourceExtent","canWrapX","Infinity","maxTargetExtent","limitedTargetExtent","targetCenter","sourceResolution","errorThresholdInPixels","triangulation","Triangulation","sourceExtent","calculateSourceExtent","sourceImage","ImageState","sourcePixelRatio","targetProj_","maxSourceExtent_","triangulation_","targetResolution_","targetExtent_","sourceImage_","sourcePixelRatio_","interpolate_","sourceListenerKey_","unlistenSource_","reproject_","sourceState","EventType","CHANGE","e","ImageSourceEventType","IMAGELOADSTART","IMAGELOADEND","IMAGELOADERROR","ImageSourceEvent","Event","ImageSource","Source","resolutions_","reprojectedImage_","reprojectedRevision_","wantedExtent_","wantedResolution_","static_","wantedProjection_","setResolutions","findNearestResolution","idx","sourceProjection","getImageInternal","getRevision","requestExtent","getRequestExtent","requestResolution","addEventListener","handleImageChange","event","loading","hasListener","dispatchEvent","defaultImageLoadFunction","src","ratio","viewWidth","viewHeight","marginWidth","requestWidth","marginHeight","requestHeight","createMinion","operation","buffers","meta","imageOps","numBuffers","numBytes","byteLength","images","b","ImageData","output","buffer","arrays","pixels","j","array","createWorker","config","onMessage","lib","map","name","toString","lines","concat","worker","Worker","Blob","Buffer","from","join","URL","createObjectURL","createFauxWorker","minion","terminated","postMessage","setTimeout","terminate","Processor","threads","imageOps_","workers","onWorkerMessage_","workers_","queue_","maxQueueLength_","queue","running_","dataLookup_","job_","process","inputs","callback","enqueue_","dispatch_","job","push","shift","input","segmentLength","offset","slices","jj","index","disposed","resolveJob_","RasterEventType","BEFOREOPERATIONS","AFTEROPERATIONS","RasterSourceEvent","RasterSource","processor_","operationType_","operationType","threads_","layers_","createLayers","sources","ii","useResolutions_","tileQueue_","processSources_","requestedFrameState_","renderedImageCanvas_","renderedRevision_","frameState_","animate","coordinateToPixelTransform","declutter","getLayerStatesArray","postRenderFunctions","tileQueue","time","Date","now","usedTiles","rotation","wantedTiles","mapId","renderTargets","setAttributions","iMax","sourceOrLayer","source","sourceAttributions","getAttributions","setOperation","updateFrameState_","allSourcesReady_","ready","loadMoreTiles","requestAnimationFrame","len","imageDatas","onWorkerComplete_","getContext","round","putImageData","prototype","renderer","getRenderer","element","firstElementChild","layers","getLayerState","createLayer","layerOrSource"],"sourceRoot":""}