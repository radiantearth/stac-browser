"use strict";(self["webpackChunk_radiantearth_stac_browser"]=self["webpackChunk_radiantearth_stac_browser"]||[]).push([[2808,3614,5360,9721],{12585:function(e,t,r){r.r(t),r.d(t,{default:function(){return g}});var i=r(49825),n=r(27557),o=r(34835),a=r(20259),s=r(63722),l=r(90130),c=r(34799);const _={TEXTURE:"u_texture",VELOCITY_TEXTURE:"u_velocityTexture",POSITION_TEXTURE:"u_positionTexture",PARTICLE_COUNT_SQRT:"u_particleCountSqrt",MAX_SPEED:"u_maxSpeed",GAIN:"u_gain",OFFSET:"u_offset",IS_FLOAT:"u_isFloat",RANDOM_SEED:"u_randomSeed",SPEED_FACTOR:"u_speedFactor",DROP_RATE:"u_dropRate",DROP_RATE_BUMP:"u_dropRateBump",OPACITY:"u_opacity",ROTATION:s.M8.ROTATION,VIEWPORT_SIZE_PX:s.M8.VIEWPORT_SIZE_PX},u={POSITION:"a_position",INDEX:"a_index"},h={POSITION:"v_position"};class T extends c.Ay{constructor(e,t){super(e,{vertexShader:t.tileVertexShader,fragmentShader:t.tileFragmentShader,cacheSize:t.cacheSize,postProcesses:[{}],uniforms:{[_.MAX_SPEED]:t.maxSpeed}}),this.particleColorFragmentShader_=t.particleColorFragmentShader,this.velocityTexture_=null,this.particleCountSqrt_=t.particles?Math.ceil(Math.sqrt(t.particles)):256,this.particleIndexBuffer_,this.quadBuffer_,this.particlePositionProgram_,this.particlePositionVertexShader_=t.particlePositionVertexShader,this.particlePositionFragmentShader_=t.particlePositionFragmentShader,this.previousPositionTexture_,this.nextPositionTexture_,this.particleColorProgram_,this.particleColorVertexShader_=t.particleColorVertexShader,this.particleColorFragmentShader_=t.particleColorFragmentShader,this.textureProgram_,this.textureVertexShader_=t.textureVertexShader,this.textureFragmentShader_=t.textureFragmentShader,this.previousTrailsTexture_,this.nextTrailsTexture_,this.fadeOpacity_=.996,this.maxSpeed_=t.maxSpeed,this.speedFactor_=t.speedFactor||.001,this.dropRate_=.003,this.dropRateBump_=.01,this.tempVec2_=[0,0],this.renderedWidth_=0,this.renderedHeight_=0}afterHelperCreated(){super.afterHelperCreated();const e=this.helper,t=e.getGL();this.framebuffer_=t.createFramebuffer();const r=this.particleCountSqrt_*this.particleCountSqrt_,i=new Float32Array(r);for(let a=0;a<r;++a)i[a]=a;const n=new a.Ay(l.H7,l.Ek);n.setArray(i),e.flushBufferData(n),this.particleIndexBuffer_=n;const o=new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]),s=new a.Ay(l.H7,l.Ek);s.setArray(o),e.flushBufferData(s),this.quadBuffer_=s;const c=new Uint8Array(4*r);for(let a=0;a<c.length;++a)c[a]=Math.floor(256*Math.random());this.previousPositionTexture_=e.createTexture([this.particleCountSqrt_,this.particleCountSqrt_],c,null,!0),this.nextPositionTexture_=e.createTexture([this.particleCountSqrt_,this.particleCountSqrt_],c,null,!0),this.particlePositionProgram_=e.getProgram(this.particlePositionFragmentShader_,this.particlePositionVertexShader_),this.particleColorProgram_=e.getProgram(this.particleColorFragmentShader_,this.particleColorVertexShader_),this.textureProgram_=e.getProgram(this.textureFragmentShader_,this.textureVertexShader_)}createSizeDependentTextures_(){const e=this.helper,t=e.getGL(),r=e.getCanvas(),i=r.width,n=r.height,o=new Uint8Array(i*n*4);this.nextTrailsTexture_&&t.deleteTexture(this.nextTrailsTexture_),this.nextTrailsTexture_=e.createTexture([i,n],o,null,!0),this.previousTrailsTexture_&&t.deleteTexture(this.previousTrailsTexture_),this.previousTrailsTexture_=e.createTexture([i,n],o,null,!0)}beforeFinalize(e){const t=this.helper,r=t.getGL(),i=t.getCanvas(),n=i.width,o=i.height;this.renderedWidth_==n&&this.renderedHeight_==o||this.createSizeDependentTextures_();const a=[n,o];this.velocityTexture_=t.createTexture(a,null,this.velocityTexture_),r.copyTexImage2D(r.TEXTURE_2D,0,r.RGBA,0,0,n,o,0),this.drawParticleTrails_(e),this.updateParticlePositions_(e),e.animate=!0,this.renderedWidth_=n,this.renderedHeight_=o}drawParticleTrails_(e){const t=this.helper,r=t.getGL();t.bindFrameBuffer(this.framebuffer_,this.nextTrailsTexture_),this.drawTexture_(this.previousTrailsTexture_,this.fadeOpacity_),this.drawParticleColor_(e),t.bindInitialFrameBuffer(),r.clearColor(0,0,0,0),r.clear(r.COLOR_BUFFER_BIT),r.enable(r.BLEND),r.blendFunc(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA),this.drawTexture_(this.nextTrailsTexture_,1),r.disable(r.BLEND);const i=this.nextTrailsTexture_;this.nextTrailsTexture_=this.previousTrailsTexture_,this.previousTrailsTexture_=i}drawTexture_(e,t){const r=this.helper,i=r.getGL();r.useProgram(this.textureProgram_),r.bindTexture(e,0,_.TEXTURE),r.bindAttribute(this.quadBuffer_,u.POSITION,2),this.helper.setUniformFloatValue(_.OPACITY,t),i.drawArrays(i.TRIANGLES,0,6)}drawParticleColor_(e){const t=this.helper,r=t.getGL();t.useProgram(this.particleColorProgram_);const i=this.particleCountSqrt_*this.particleCountSqrt_;t.bindAttribute(this.particleIndexBuffer_,u.INDEX,1),t.bindTexture(this.previousPositionTexture_,0,_.POSITION_TEXTURE),t.bindTexture(this.velocityTexture_,1,_.VELOCITY_TEXTURE),this.helper.setUniformFloatValue(_.PARTICLE_COUNT_SQRT,this.particleCountSqrt_);const n=this.tempVec2_;n[0]=Math.cos(-e.viewState.rotation),n[1]=Math.sin(-e.viewState.rotation),this.helper.setUniformFloatVec2(_.ROTATION,n),this.helper.setUniformFloatValue(_.MAX_SPEED,this.maxSpeed_),r.drawArrays(r.POINTS,0,i)}updateParticlePositions_(e){const t=this.helper,r=t.getGL();t.useProgram(this.particlePositionProgram_),r.viewport(0,0,this.particleCountSqrt_,this.particleCountSqrt_),t.bindFrameBuffer(this.framebuffer_,this.nextPositionTexture_),t.bindTexture(this.previousPositionTexture_,0,_.POSITION_TEXTURE),t.bindTexture(this.velocityTexture_,1,_.VELOCITY_TEXTURE),t.bindAttribute(this.quadBuffer_,u.POSITION,2),t.setUniformFloatValue(_.RANDOM_SEED,Math.random()),t.setUniformFloatValue(_.SPEED_FACTOR,this.speedFactor_),t.setUniformFloatValue(_.DROP_RATE,this.dropRate_),t.setUniformFloatValue(_.DROP_RATE_BUMP,this.dropRateBump_);const i=this.tempVec2_;i[0]=Math.cos(-e.viewState.rotation),i[1]=Math.sin(-e.viewState.rotation),this.helper.setUniformFloatVec2(_.ROTATION,i);const n=e.size;this.helper.setUniformFloatVec2(_.VIEWPORT_SIZE_PX,[n[0],n[1]]),r.drawArrays(r.TRIANGLES,0,6);const o=this.nextPositionTexture_;this.nextPositionTexture_=this.previousPositionTexture_,this.previousPositionTexture_=o}}var d=T,E=r(22808),p=r(75332);const m=`\n  attribute vec2 ${c.eS.TEXTURE_COORD};\n  uniform mat4 ${c.gF.TILE_TRANSFORM};\n  uniform float ${c.gF.TEXTURE_PIXEL_WIDTH};\n  uniform float ${c.gF.TEXTURE_PIXEL_HEIGHT};\n  uniform float ${c.gF.TEXTURE_RESOLUTION};\n  uniform float ${c.gF.TEXTURE_ORIGIN_X};\n  uniform float ${c.gF.TEXTURE_ORIGIN_Y};\n  uniform float ${c.gF.DEPTH};\n\n  varying vec2 v_textureCoord;\n  varying vec2 v_mapCoord;\n\n  void main() {\n    v_textureCoord = ${c.eS.TEXTURE_COORD};\n    v_mapCoord = vec2(\n      ${c.gF.TEXTURE_ORIGIN_X} + ${c.gF.TEXTURE_RESOLUTION} * ${c.gF.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],\n      ${c.gF.TEXTURE_ORIGIN_Y} - ${c.gF.TEXTURE_RESOLUTION} * ${c.gF.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]\n    );\n    gl_Position = ${c.gF.TILE_TRANSFORM} * vec4(${c.eS.TEXTURE_COORD}, ${c.gF.DEPTH}, 1.0);\n  }\n`,f=`\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  #else\n  precision mediump float;\n  #endif\n\n  uniform vec4 ${c.gF.RENDER_EXTENT};\n  uniform float ${_.MAX_SPEED};\n  uniform sampler2D ${c.gF.TILE_TEXTURE_ARRAY}[1];\n\n  varying vec2 v_textureCoord;\n  varying vec2 v_mapCoord;\n\n  void main() {\n    if (\n      v_mapCoord[0] < ${c.gF.RENDER_EXTENT}[0] ||\n      v_mapCoord[1] < ${c.gF.RENDER_EXTENT}[1] ||\n      v_mapCoord[0] > ${c.gF.RENDER_EXTENT}[2] ||\n      v_mapCoord[1] > ${c.gF.RENDER_EXTENT}[3]\n    ) {\n      discard;\n    }\n\n    vec4 velocity = texture2D(${c.gF.TILE_TEXTURE_ARRAY}[0],  v_textureCoord);\n    gl_FragColor = vec4((velocity.xy + ${_.MAX_SPEED}) / (2.0 * ${_.MAX_SPEED}), 0, 1);\n  }\n`,O=`\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  #else\n  precision mediump float;\n  #endif\n\n  attribute vec2 ${u.POSITION};\n\n  varying vec2 ${h.POSITION};\n\n  void main() {\n    ${h.POSITION} = ${u.POSITION};\n    gl_Position = vec4(1.0 - 2.0 * ${u.POSITION}, 0, 1);\n  }\n`,x=`\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  #else\n  precision mediump float;\n  #endif\n\n  uniform sampler2D ${_.TEXTURE};\n  uniform float ${_.OPACITY};\n\n  varying vec2 ${h.POSITION};\n\n  void main() {\n    vec4 color = texture2D(${_.TEXTURE}, 1.0 - ${h.POSITION});\n    gl_FragColor = vec4(floor(255.0 * color * ${_.OPACITY}) / 255.0);\n  }\n`,I=`\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  #else\n  precision mediump float;\n  #endif\n\n  uniform sampler2D ${_.POSITION_TEXTURE};\n  uniform sampler2D ${_.VELOCITY_TEXTURE};\n  uniform float ${_.RANDOM_SEED};\n  uniform float ${_.SPEED_FACTOR};\n  uniform float ${_.DROP_RATE};\n  uniform float ${_.DROP_RATE_BUMP};\n  uniform vec2 ${_.ROTATION};\n  uniform vec2 ${_.VIEWPORT_SIZE_PX};\n\n  varying vec2 ${h.POSITION};\n\n  // pseudo-random generator\n  const vec3 randConstants = vec3(12.9898, 78.233, 4375.85453);\n\n  float rand(const vec2 co) {\n    float t = dot(randConstants.xy, co);\n    return fract(sin(t) * (randConstants.z + t));\n  }\n\n  void main() {\n    vec4 positionColor = texture2D(${_.POSITION_TEXTURE}, ${h.POSITION});\n\n    // decode particle position from pixel RGBA\n    vec2 particlePosition = vec2(\n      positionColor.r / 255.0 + positionColor.b,\n      positionColor.g / 255.0 + positionColor.a\n    );\n\n    vec4 velocityColor = texture2D(${_.VELOCITY_TEXTURE}, particlePosition);\n    if (velocityColor.a == 0.0) {\n      discard;\n    }\n\n    float vx = 2.0 * velocityColor.r - 1.0;\n    float vy = 2.0 * velocityColor.g - 1.0;\n\n    // normalized veloicty (magnitude 0 - 1)\n    vec2 velocity = vec2(\n      vx * ${_.ROTATION}.x - vy * ${_.ROTATION}.y,\n      vx * ${_.ROTATION}.y + vy * ${_.ROTATION}.x\n    );\n\n    // account for aspect ratio (square particle position texture, non-square map)\n    float aspectRatio = ${_.VIEWPORT_SIZE_PX}.x / ${_.VIEWPORT_SIZE_PX}.y;\n    vec2 offset = vec2(velocity.x / aspectRatio, velocity.y) * ${_.SPEED_FACTOR};\n\n    // update particle position, wrapping around the edge\n    particlePosition = fract(1.0 + particlePosition + offset);\n\n    // a random seed to use for the particle drop\n    vec2 seed = (particlePosition + ${h.POSITION}) * ${_.RANDOM_SEED};\n\n    // drop rate is a chance a particle will restart at random position, to avoid degeneration\n    float dropRate = ${_.DROP_RATE} + length(velocity) * ${_.DROP_RATE_BUMP};\n    float drop = step(1.0 - dropRate, rand(seed));\n\n    vec2 randomPosition = vec2(rand(seed + 1.3), rand(seed + 2.1));\n    particlePosition = mix(particlePosition, randomPosition, drop);\n\n    // encode the new particle position back into RGBA\n    gl_FragColor = vec4(\n      fract(particlePosition * 255.0),\n      floor(particlePosition * 255.0) / 255.0\n    );\n  }\n`,R=`\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  #else\n  precision mediump float;\n  #endif\n\n  attribute float ${u.INDEX};\n\n  uniform sampler2D ${_.POSITION_TEXTURE};\n  uniform float ${_.PARTICLE_COUNT_SQRT};\n\n  varying vec2 ${h.POSITION};\n\n  void main() {\n    vec4 color = texture2D(\n      ${_.POSITION_TEXTURE},\n      vec2(\n        fract(${u.INDEX} / ${_.PARTICLE_COUNT_SQRT}),\n        floor(${u.INDEX} / ${_.PARTICLE_COUNT_SQRT}) / ${_.PARTICLE_COUNT_SQRT}\n      )\n    );\n\n    ${h.POSITION} = vec2(\n      color.r / 255.0 + color.b,\n      color.g / 255.0 + color.a\n    );\n\n    gl_PointSize = 1.0;\n    gl_Position = vec4(\n      2.0 * ${h.POSITION}.x - 1.0,\n      2.0 * ${h.POSITION}.y - 1.0,\n      0,\n      1\n    );\n  }\n`;function S(e){const t=(0,n.z0)(),r=[];if(void 0!==e.color){const n=(0,o.s2)(t,e.color,i.mE);r.push(`color = ${n};`)}const a=Object.keys(t.variables);if(a.length>1&&!e.variables)throw new Error(`Missing variables in style (expected ${t.variables})`);const s={};for(const i of a){if(!(i in e.variables))throw new Error(`Missing '${i}' in style variables`);const t=(0,n.Sl)(i);s[t]=function(){let t=e.variables[i];return"string"===typeof t&&(t=(0,n.Lm)(t)),void 0!==t?t:-9999999}}const l=Object.keys(s).map(function(e){return`uniform float ${e};`}),c=Object.keys(t.functions).map(function(e){return t.functions[e]}),u=`\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n\n    uniform sampler2D ${_.VELOCITY_TEXTURE};\n    uniform float ${_.MAX_SPEED};\n    uniform vec2 ${_.ROTATION};\n\n    ${l.join("\n")}\n\n    varying vec2 ${h.POSITION};\n    \n    ${c.join("\n")}\n\n    void main() {\n      vec4 velocityColor = texture2D(${_.VELOCITY_TEXTURE}, ${h.POSITION});\n\n      float vx = mix(-${_.MAX_SPEED}, ${_.MAX_SPEED}, velocityColor.r);\n      float vy = mix(-${_.MAX_SPEED}, ${_.MAX_SPEED}, velocityColor.g);\n\n      vec2 velocity = vec2(\n        vx * ${_.ROTATION}.x - vy * ${_.ROTATION}.y,\n        vx * ${_.ROTATION}.y + vy * ${_.ROTATION}.x\n      );\n\n      float a_prop_speed = length(velocity);\n\n      vec4 color;\n\n      ${r.join("\n")}\n\n      if (color.a == 0.0) {\n        discard;\n      }\n\n      gl_FragColor = color;\n    }\n  `;return{tileVertexShader:m,tileFragmentShader:f,particleColorVertexShader:R,particleColorFragmentShader:u,particlePositionVertexShader:O,particlePositionFragmentShader:I,textureVertexShader:O,textureFragmentShader:x}}const P=[];class v extends E["default"]{constructor(e){const t=Object.assign({},e);if(delete t.maxSpeed,delete t.speedFactor,delete t.particles,super(t),this.style_=e.style||{},!(e.maxSpeed>0))throw new Error("maxSpeed is required");this.maxSpeed_=e.maxSpeed,this.speedFactor_=e.speedFactor,this.particles_=e.particles,this.styleVariables_=this.style_.variables||{},this.addChangeListener(p["default"].SOURCE,this.handleSourceUpdate_)}handleSourceUpdate_(){this.hasRenderer()&&this.getRenderer().clearCache()}updateStyleVariables(e){Object.assign(this.styleVariables_,e),this.changed()}getSources(e,t){const r=this.getSource();return P[0]=r,P}createRenderer(){const e=S(this.style_);return new d(this,{...e,cacheSize:this.getCacheSize(),maxSpeed:this.maxSpeed_,speedFactor:this.speedFactor_,particles:this.particles_})}}v.prototype.dispose;var g=v},22808:function(e,t,r){r.r(t);var i=r(60764),n=r(45360);class o extends i["default"]{constructor(e){e=e||{};const t=Object.assign({},e),r=e.cacheSize;delete e.cacheSize,delete t.preload,delete t.useInterimTilesOnError,super(t),this.on,this.once,this.un,this.cacheSize_=r,this.setPreload(void 0!==e.preload?e.preload:0),this.setUseInterimTilesOnError(void 0===e.useInterimTilesOnError||e.useInterimTilesOnError)}getCacheSize(){return this.cacheSize_}getPreload(){return this.get(n["default"].PRELOAD)}setPreload(e){this.set(n["default"].PRELOAD,e)}getUseInterimTilesOnError(){return this.get(n["default"].USE_INTERIM_TILES_ON_ERROR)}setUseInterimTilesOnError(e){this.set(n["default"].USE_INTERIM_TILES_ON_ERROR,e)}getData(e){return super.getData(e)}}t["default"]=o},40186:function(e,t,r){function i(e,t,r,i){return void 0!==i?(i[0]=e,i[1]=t,i[2]=r,i):[e,t,r]}function n(e,t,r){return e+"/"+t+"/"+r}function o(e){return n(e[0],e[1],e[2])}function a(e){return s(e[0],e[1],e[2])}function s(e,t,r){return(t<<e)+r}function l(e,t){const r=e[0],i=e[1],n=e[2];if(t.getMinZoom()>r||r>t.getMaxZoom())return!1;const o=t.getFullTileRange(r);return!o||o.containsXY(i,n)}r.d(t,{N:function(){return i},N5:function(){return l},_T:function(){return s},dp:function(){return n},i7:function(){return o},tW:function(){return a}})},45360:function(e,t,r){r.r(t),t["default"]={PRELOAD:"preload",USE_INTERIM_TILES_ON_ERROR:"useInterimTilesOnError"}},91110:function(e,t,r){r.d(t,{N:function(){return n}});class i{constructor(e,t,r,i){this.minX=e,this.maxX=t,this.minY=r,this.maxY=i}contains(e){return this.containsXY(e[1],e[2])}containsTileRange(e){return this.minX<=e.minX&&e.maxX<=this.maxX&&this.minY<=e.minY&&e.maxY<=this.maxY}containsXY(e,t){return this.minX<=e&&e<=this.maxX&&this.minY<=t&&t<=this.maxY}equals(e){return this.minX==e.minX&&this.minY==e.minY&&this.maxX==e.maxX&&this.maxY==e.maxY}extend(e){e.minX<this.minX&&(this.minX=e.minX),e.maxX>this.maxX&&(this.maxX=e.maxX),e.minY<this.minY&&(this.minY=e.minY),e.maxY>this.maxY&&(this.maxY=e.maxY)}getHeight(){return this.maxY-this.minY+1}getSize(){return[this.getWidth(),this.getHeight()]}getWidth(){return this.maxX-this.minX+1}intersects(e){return this.minX<=e.maxX&&this.maxX>=e.minX&&this.minY<=e.maxY&&this.maxY>=e.minY}}function n(e,t,r,n,o){return void 0!==o?(o.minX=e,o.maxX=t,o.minY=r,o.maxY=n,o):new i(e,t,r,n)}t.A=i}}]);
//# sourceMappingURL=9721.5f8395fd.js.map