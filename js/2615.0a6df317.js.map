{"version":3,"file":"js/2615.0a6df317.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/source/TileEventType.js","webpack://@radiantearth/stac-browser/./node_modules/ol/webgl/Canvas.js","webpack://@radiantearth/stac-browser/./node_modules/ol/reproj/glreproj.js","webpack://@radiantearth/stac-browser/./node_modules/ol/reproj/DataTile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/DataTile.js"],"sourcesContent":["/**\n * @module ol/source/TileEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a tile starts loading.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\n   * @api\n   */\n  TILELOADSTART: 'tileloadstart',\n\n  /**\n   * Triggered when a tile finishes loading, either when its data is loaded,\n   * or when loading was aborted because the tile is no longer needed.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadend\n   * @api\n   */\n  TILELOADEND: 'tileloadend',\n\n  /**\n   * Triggered if tile loading results in an error. Note that this is not the\n   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}\n   * for details.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\n   * @api\n   */\n  TILELOADERROR: 'tileloaderror',\n};\n\n/**\n * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes\n */\n","import * as mat4 from '../vec/mat4.js';\n\n/**\n * @module ol/webgl/Canvas\n */\n\nconst VERTEX_SHADER = `\n  attribute vec4 a_position;\n  attribute vec4 a_texcoord;\n\n  uniform mat4 u_matrix;\n  uniform mat4 u_textureMatrix;\n\n  varying vec2 v_texcoord;\n\n  void main() {\n    gl_Position = u_matrix * a_position;\n    vec2 texcoord = (u_textureMatrix * a_texcoord).xy;\n    v_texcoord = texcoord;\n  }\n`;\n\nconst FRAGMENT_SHADER = `\n  precision mediump float;\n\n  varying vec2 v_texcoord;\n\n  uniform sampler2D u_texture;\n\n  void main() {\n    if (\n      v_texcoord.x < 0.0 ||\n      v_texcoord.y < 0.0 ||\n      v_texcoord.x > 1.0 ||\n      v_texcoord.y > 1.0\n    ) {\n      discard;\n    }\n    gl_FragColor = texture2D(u_texture, v_texcoord);\n  }\n`;\n\n/** @typedef {import(\"../transform.js\").Transform} Matrix */\n\n/**\n * Canvas-like operations implemented in webgl.\n */\nexport class Canvas {\n  /**\n   * @param {WebGLRenderingContext} gl Context to render in.\n   */\n  constructor(gl) {\n    /**\n     * @private\n     * @type {WebGLRenderingContext}\n     */\n    this.gl_ = gl;\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.program_ = createProgram(gl, FRAGMENT_SHADER, VERTEX_SHADER);\n\n    this.positionLocation = gl.getAttribLocation(this.program_, 'a_position');\n    this.texcoordLocation = gl.getAttribLocation(this.program_, 'a_texcoord');\n\n    this.matrixLocation = gl.getUniformLocation(this.program_, 'u_matrix');\n    this.textureMatrixLocation = gl.getUniformLocation(\n      this.program_,\n      'u_textureMatrix',\n    );\n    this.textureLocation = gl.getUniformLocation(this.program_, 'u_texture');\n\n    this.positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n\n    this.positions = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array(this.positions),\n      gl.STATIC_DRAW,\n    );\n\n    this.texcoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);\n\n    this.texcoords = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array(this.texcoords),\n      gl.STATIC_DRAW,\n    );\n  }\n\n  /**\n   * 2dContext drawImage call implemented in webgl.\n   * Unlike images, textures do not have a width and height associated\n   * with them so we'll pass in the width and height of the texture.\n   *\n   * @param {WebGLTexture} tex Image to draw.\n   * @param {number} texWidth Image width.\n   * @param {number} texHeight Image height.\n   * @param {number} srcX Top-left x-point to read src image.\n   * @param {number} srcY Top-left y-point to read src image.\n   * @param {number} [srcWidth] Width of source to read.\n   * @param {number} [srcHeight] Height of source to read.\n   * @param {number} [dstX] Top-left x-point of destination.\n   * @param {number} [dstY] Top-left y-point of destination.\n   * @param {number} [dstWidth] Width of written image in destination.\n   * @param {number} [dstHeight] Height of written image in destination.\n   * @param {number} [width] Width of canvas.\n   * @param {number} [height] Height of canvas.\n   */\n  drawImage(\n    tex,\n    texWidth,\n    texHeight,\n    srcX,\n    srcY,\n    srcWidth,\n    srcHeight,\n    dstX,\n    dstY,\n    dstWidth,\n    dstHeight,\n    width,\n    height,\n  ) {\n    const gl = this.gl_;\n\n    if (dstX === undefined) {\n      dstX = srcX;\n    }\n    if (dstY === undefined) {\n      dstY = srcY;\n    }\n    if (srcWidth === undefined) {\n      srcWidth = texWidth;\n    }\n    if (srcHeight === undefined) {\n      srcHeight = texHeight;\n    }\n    if (dstWidth === undefined) {\n      dstWidth = srcWidth;\n    }\n    if (dstHeight === undefined) {\n      dstHeight = srcHeight;\n    }\n    if (width === undefined) {\n      width = gl.canvas.width;\n    }\n    if (height === undefined) {\n      height = gl.canvas.height;\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n\n    gl.useProgram(this.program_);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n    gl.enableVertexAttribArray(this.positionLocation);\n    gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);\n    gl.enableVertexAttribArray(this.texcoordLocation);\n    gl.vertexAttribPointer(this.texcoordLocation, 2, gl.FLOAT, false, 0, 0);\n\n    // matrix for converting pixels to clip space\n    let matrix = mat4.orthographic(0, width, 0, height, -1, 1);\n    matrix = mat4.translate(matrix, dstX, dstY, 0);\n    matrix = mat4.scale(matrix, dstWidth, dstHeight, 1);\n    gl.uniformMatrix4fv(this.matrixLocation, false, matrix);\n\n    let texMatrix = mat4.translation(srcX / texWidth, srcY / texHeight, 0);\n    texMatrix = mat4.scale(\n      texMatrix,\n      srcWidth / texWidth,\n      srcHeight / texHeight,\n      1,\n    );\n\n    gl.uniformMatrix4fv(this.textureMatrixLocation, false, texMatrix);\n    gl.uniform1i(this.textureLocation, 0);\n    gl.drawArrays(gl.TRIANGLES, 0, this.positions.length / 2);\n  }\n}\n\n/**\n * @param {WebGLRenderingContext} gl Rendering Context.\n * @param {GLenum} type Type of shader.\n * @param {string} source source of shader.\n * @return {WebGLShader} [progam] The program.\n */\nfunction createShader(gl, type, source) {\n  const shader = gl.createShader(type);\n\n  if (shader === null) {\n    throw new Error('Shader compilation failed');\n  }\n\n  gl.shaderSource(shader, source);\n\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    const log = gl.getShaderInfoLog(shader);\n    if (log === null) {\n      throw new Error('Shader info log creation failed');\n    }\n    throw new Error(log);\n  }\n\n  return shader;\n}\n\n/**\n * @param {WebGLRenderingContext} gl Rendering Context.\n * @param {string} fragmentSource Fragment shader source.\n * @param {string} vertexSource Vertex shader source.\n * @return {WebGLProgram} [progam] The program.\n */\nexport function createProgram(gl, fragmentSource, vertexSource) {\n  const program = gl.createProgram();\n\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\n  if (program === null) {\n    throw new Error('Program creation failed');\n  }\n\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    const log = gl.getProgramInfoLog(program);\n    if (log === null) {\n      throw new Error('Program info log creation failed');\n    }\n    throw new Error();\n  }\n  return program;\n}\n","/**\n * @module ol/reproj/glreproj\n */\nimport {\n  createEmpty,\n  extend,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from '../extent.js';\nimport {WORKER_OFFSCREEN_CANVAS} from '../has.js';\nimport * as mat4 from '../vec/mat4.js';\nimport {Canvas as WebGLCanvas, createProgram} from '../webgl/Canvas.js';\n\nconst EDGE_VERTEX_SHADER = `\n  attribute vec4 a_position;\n\n  uniform mat4 u_matrix;\n\n  void main() {\n     gl_Position = u_matrix * a_position;\n  }\n`;\nconst EDGE_FRAGMENT_SHADER = `\n  precision mediump float;\n\n  uniform vec4 u_val;\n  void main() {\n     gl_FragColor = u_val;\n  }\n`;\n\nconst TRIANGLE_VERTEX_SHADER = `\n  attribute vec4 a_position;\n  attribute vec2 a_texcoord;\n\n  varying vec2 v_texcoord;\n\n  uniform mat4 u_matrix;\n\n  void main() {\n     gl_Position = u_matrix * a_position;\n     v_texcoord = a_texcoord;\n  }\n`;\nconst TRIANGLE_FRAGMENT_SHADER = `\n  precision mediump float;\n\n  varying vec2 v_texcoord;\n\n  uniform sampler2D u_texture;\n\n  void main() {\n    if (v_texcoord.x < 0.0 || v_texcoord.x > 1.0 || v_texcoord.y < 0.0 || v_texcoord.y > 1.0) {\n      discard;\n    }\n    gl_FragColor = texture2D(u_texture, v_texcoord);\n  }\n`;\n\n/**\n * Create an html canvas element and returns its webgl context.\n * @param {number} [width] Canvas width.\n * @param {number} [height] Canvas height.\n * @param {Array<HTMLCanvasElement | OffscreenCanvas>} [canvasPool] Canvas pool to take existing canvas from.\n * @param {WebGLContextAttributes} [settings] CanvasRenderingContext2DSettings\n * @return {WebGLRenderingContext} The context.\n */\nexport function createCanvasContextWebGL(width, height, canvasPool, settings) {\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\n  let canvas;\n  if (canvasPool && canvasPool.length) {\n    canvas = /** @type {HTMLCanvasElement} */ (canvasPool.shift());\n  } else if (WORKER_OFFSCREEN_CANVAS) {\n    canvas = new OffscreenCanvas(width || 300, height || 300);\n  } else {\n    canvas = document.createElement('canvas');\n  }\n  if (width) {\n    canvas.width = width;\n  }\n  if (height) {\n    canvas.height = height;\n  }\n  //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n  return /** @type {WebGLRenderingContext} */ (\n    canvas.getContext('webgl', settings)\n  );\n}\n\n/**\n * Releases canvas memory to avoid exceeding memory limits in Safari.\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\n * @param {WebGLRenderingContext} gl Context.\n */\nexport function releaseGLCanvas(gl) {\n  const canvas = gl.canvas;\n  canvas.width = 1;\n  canvas.height = 1;\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n}\n\n/**\n * @type {Array<HTMLCanvasElement | OffscreenCanvas>}\n */\nexport const canvasGLPool = [];\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"../extent.js\").Extent} extent Extent.\n * @property {import(\"../extent.js\").Extent} [clipExtent] Clip extent.\n * @property {WebGLTexture} texture Texture.\n * @property {number} width Width of texture.\n * @property {number} height Height of texture.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {WebGLRenderingContext} gl the context to render in.\n * @param {number} width_ Width of the canvas.\n * @param {number} height_ Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"../extent.js\").Extent} targetExtent Target extent (tile).\n * @param {import(\"../reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {number} dataType What kind of data is the textures, must be gl.FLOAT or gl.UNSIGNED_BYTE\n * TODO: Allow setting renderEdges value in the data as this is done in \"data-space\".\n * @param {boolean | Array<number>} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @param {boolean} [drawSingle] Draw single source images directly without stitchTexture.\n * @return {{framebuffer: WebGLFramebuffer, width: number, height: number, texture: WebGLTexture}} Canvas with reprojected data.\n */\nexport function render(\n  gl,\n  width_,\n  height_,\n  pixelRatio,\n  sourceResolution,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  dataType,\n  renderEdges,\n  interpolate,\n  drawSingle,\n) {\n  const width = Math.round(pixelRatio * width_);\n  const height = Math.round(pixelRatio * height_);\n  gl.canvas.width = width;\n  gl.canvas.height = height;\n\n  /** @type {WebGLFramebuffer | null} */\n  let resultFrameBuffer;\n  /** @type {WebGLTexture | null} */\n  let resultTexture;\n  {\n    resultTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, resultTexture);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    if (interpolate) {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    } else {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    }\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      width,\n      height,\n      0,\n      gl.RGBA,\n      dataType,\n      null,\n    );\n\n    resultFrameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      resultTexture,\n      0,\n    );\n  }\n\n  if (resultFrameBuffer === null) {\n    throw new Error('Could not create framebuffer');\n  }\n  if (resultTexture === null) {\n    throw new Error('Could not create texture');\n  }\n\n  if (sources.length === 0) {\n    return {\n      width,\n      height,\n      framebuffer: resultFrameBuffer,\n      texture: resultTexture,\n    };\n  }\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  /** @type {WebGLTexture | null} */\n  let stitchTexture;\n  /** @type {number} */\n  let stitchWidth;\n  /** @type {number} */\n  let stitchHeight;\n  const stitchScale = 1 / sourceResolution;\n\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\n    stitchTexture = gl.createTexture();\n    if (resultTexture === null) {\n      throw new Error('Could not create texture');\n    }\n    stitchWidth = Math.round(getWidth(sourceDataExtent) * stitchScale);\n    stitchHeight = Math.round(getHeight(sourceDataExtent) * stitchScale);\n\n    // Make sure we do not exceed the max texture size by lowering the resolution for this image.\n    // https://github.com/openlayers/openlayers/pull/15860#issuecomment-2254123580\n    const maxTexSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    const largeSide = Math.max(stitchWidth, stitchHeight);\n    const scaleFactor = largeSide > maxTexSize ? maxTexSize / largeSide : 1;\n    const stitchWidthFixed = Math.round(stitchWidth * scaleFactor);\n    const stitchHeightFixed = Math.round(stitchHeight * scaleFactor);\n\n    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    if (interpolate) {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    } else {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    }\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      stitchWidthFixed,\n      stitchHeightFixed,\n      0,\n      gl.RGBA,\n      dataType,\n      null,\n    );\n\n    const fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      stitchTexture,\n      0,\n    );\n    const webGLCanvas = new WebGLCanvas(gl);\n\n    sources.forEach(function (src, i, arr) {\n      const xPos =\n        (src.extent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;\n      const yPos =\n        -(src.extent[3] - sourceDataExtent[3]) * stitchScale * scaleFactor;\n      const srcWidth = getWidth(src.extent) * stitchScale * scaleFactor;\n      const srcHeight = getHeight(src.extent) * stitchScale * scaleFactor;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n      gl.viewport(0, 0, stitchWidthFixed, stitchHeightFixed);\n\n      if (src.clipExtent) {\n        const xPos =\n          (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;\n        const yPos =\n          -(src.clipExtent[3] - sourceDataExtent[3]) *\n          stitchScale *\n          scaleFactor;\n        const width = getWidth(src.clipExtent) * stitchScale * scaleFactor;\n        const height = getHeight(src.clipExtent) * stitchScale * scaleFactor;\n        gl.enable(gl.SCISSOR_TEST);\n        gl.scissor(\n          interpolate ? xPos : Math.round(xPos),\n          interpolate ? yPos : Math.round(yPos),\n          interpolate ? width : Math.round(xPos + width) - Math.round(xPos),\n          interpolate ? height : Math.round(yPos + height) - Math.round(yPos),\n        );\n      }\n\n      webGLCanvas.drawImage(\n        src.texture,\n        src.width,\n        src.height,\n        gutter,\n        gutter,\n        src.width - 2 * gutter,\n        src.height - 2 * gutter,\n        interpolate ? xPos : Math.round(xPos),\n        interpolate ? yPos : Math.round(yPos),\n        interpolate ? srcWidth : Math.round(xPos + srcWidth) - Math.round(xPos),\n        interpolate\n          ? srcHeight\n          : Math.round(yPos + srcHeight) - Math.round(yPos),\n        stitchWidthFixed,\n        stitchHeightFixed,\n      );\n\n      gl.disable(gl.SCISSOR_TEST);\n    });\n    gl.deleteFramebuffer(fb);\n  } else {\n    stitchTexture = sources[0].texture;\n    stitchWidth = sources[0].width;\n    stitchHeight = sources[0].width;\n  }\n\n  const targetTopLeft = getTopLeft(targetExtent);\n  const sourceTopLeft = getTopLeft(sourceDataExtent);\n\n  const getUVs = (\n    /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ target,\n  ) => {\n    const u0 =\n      ((target[0][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\n    const v0 =\n      (-(target[0][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\n    const u1 =\n      ((target[1][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\n    const v1 =\n      (-(target[1][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\n    const u2 =\n      ((target[2][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\n    const v2 =\n      (-(target[2][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\n    return {u1, v1, u0, v0, u2, v2};\n  };\n\n  gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);\n  gl.viewport(0, 0, width, height);\n\n  // Draw source to reprojtile\n  {\n    /** @type {Array<number>} */\n    const vertices = [];\n    /** @type {Array<number>} */\n    const texcoords = [];\n\n    const triProgram = createProgram(\n      gl,\n      TRIANGLE_FRAGMENT_SHADER,\n      TRIANGLE_VERTEX_SHADER,\n    );\n    gl.useProgram(triProgram);\n\n    // Bind image\n    const textureLocation = gl.getUniformLocation(triProgram, 'u_texture');\n    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);\n\n    // Tell the shader to get the texture from texture unit 0\n    gl.uniform1i(textureLocation, 0);\n\n    // Calculate vert and tex coordinates.\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const source = triangle.source;\n      const target = triangle.target;\n      // Make sure that everything is on pixel boundaries\n      const {u1, v1, u0, v0, u2, v2} = getUVs(target);\n\n      const su0 =\n        (source[0][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv0 =\n        -(source[0][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n      const su1 =\n        (source[1][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv1 =\n        -(source[1][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n      const su2 =\n        (source[2][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv2 =\n        -(source[2][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n\n      vertices.push(u1, v1, u0, v0, u2, v2);\n      texcoords.push(su1, sv1, su0, sv0, su2, sv2);\n    });\n\n    // Convert pixel space to clip space.\n    const matrix = mat4.orthographic(0, width, height, 0, -1, 1);\n    const matrixLocation = gl.getUniformLocation(triProgram, 'u_matrix');\n    gl.uniformMatrix4fv(matrixLocation, false, matrix);\n\n    const positionLocation = gl.getAttribLocation(triProgram, 'a_position');\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(positionLocation);\n\n    const texcoordLocation = gl.getAttribLocation(triProgram, 'a_texcoord');\n    const texcoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(texcoordLocation);\n\n    gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);\n  }\n\n  if (renderEdges) {\n    const edgeProgram = createProgram(\n      gl,\n      EDGE_FRAGMENT_SHADER,\n      EDGE_VERTEX_SHADER,\n    );\n    gl.useProgram(edgeProgram);\n    const matrix = mat4.orthographic(0, width, height, 0, -1, 1);\n    const matrixLocation = gl.getUniformLocation(edgeProgram, 'u_matrix');\n    gl.uniformMatrix4fv(matrixLocation, false, matrix);\n\n    const burnval = Array.isArray(renderEdges) ? renderEdges : [0, 0, 0, 255];\n    const burnvalLocation = gl.getUniformLocation(edgeProgram, 'u_val');\n    const isFloat = true;\n    if (isFloat) {\n      gl.uniform4fv(burnvalLocation, burnval);\n    } else {\n      gl.uniform4iv(burnvalLocation, burnval);\n    }\n\n    const positionLocation = gl.getAttribLocation(edgeProgram, 'a_position');\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(positionLocation);\n\n    /** @type {Array<number>} */\n    const lines = triangulation.getTriangles().reduce(function (\n      /** @type {Array<number>} */ lines,\n      triangle,\n    ) {\n      const target = triangle.target;\n      const {u1, v1, u0, v0, u2, v2} = getUVs(target);\n\n      return lines.concat([u1, v1, u0, v0, u0, v0, u2, v2, u2, v2, u1, v1]);\n    }, []);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lines), gl.STATIC_DRAW);\n    gl.drawArrays(gl.LINES, 0, lines.length / 2);\n  }\n\n  return {\n    width,\n    height,\n    framebuffer: resultFrameBuffer,\n    texture: resultTexture,\n  };\n}\n","/**\n * @module ol/reproj/DataTile\n */\n\nimport DataTile, {asArrayLike, asImageLike, toArray} from '../DataTile.js';\nimport TileState from '../TileState.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport EventType from '../events/EventType.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {calculateSourceExtentResolution} from '../reproj.js';\nimport Triangulation from './Triangulation.js';\nimport {ERROR_THRESHOLD} from './common.js';\nimport {\n  canvasGLPool,\n  createCanvasContextWebGL,\n  releaseGLCanvas,\n  render as renderReprojected,\n} from './glreproj.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {DataTile} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\n * @property {number} pixelRatio Pixel ratio.\n * @property {number} gutter Gutter of the source tiles.\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {import(\"../transform.js\").Transform} [transformMatrix] Source transform matrix.\n * @property {boolean} [renderEdges] Render reprojection edges.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected data tile.\n * See {@link module:ol/source/DataTile~DataTileSource}.\n *\n */\nclass ReprojDataTile extends DataTile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    super({\n      tileCoord: options.tileCoord,\n      loader: () => Promise.resolve(new Uint8ClampedArray(4)),\n      interpolate: options.interpolate,\n      transition: options.transition,\n    });\n\n    /**\n     * @private\n     * @type {boolean | Array<number>}\n     */\n    this.renderEdges_ =\n      options.renderEdges !== undefined ? options.renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter;\n\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     * @private\n     */\n    this.reprojData_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.reprojError_ = null;\n\n    /**\n     * @type {import('../size.js').Size}\n     * @private\n     */\n    this.reprojSize_ = undefined;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = options.sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = options.targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const sourceProj = options.sourceProj;\n    const sourceProjExtent = sourceProj.getExtent();\n    const sourceTileGridExtent = options.sourceTileGrid.getExtent();\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceTileGridExtent\n        ? getIntersection(sourceProjExtent, sourceTileGridExtent)\n        : sourceProjExtent\n      : sourceTileGridExtent;\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = this.targetTileGrid_.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const targetProj = options.targetProj;\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      options.errorThreshold !== undefined\n        ? options.errorThreshold\n        : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n      options.transformMatrix,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n        const getTile = options.getTileFunction;\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('../size.js').Size} Tile size.\n   * @override\n   */\n  getSize() {\n    return this.reprojSize_;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {import(\"../DataTile.js\").Data} Tile data.\n   * @override\n   */\n  getData() {\n    return this.reprojData_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @override\n   */\n  getError() {\n    return this.reprojError_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const dataSources = [];\n    let imageLike = false;\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const size = tile.getSize();\n      const gutter = this.gutter_;\n      /**\n       * @type {import(\"../DataTile.js\").ArrayLike}\n       */\n      let tileData;\n      const arrayData = asArrayLike(tile.getData());\n      if (arrayData) {\n        tileData = arrayData;\n      } else {\n        imageLike = true;\n        tileData = toArray(asImageLike(tile.getData()));\n      }\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\n      const isFloat = tileData instanceof Float32Array;\n      const pixelCount = pixelSize[0] * pixelSize[1];\n      const DataType = isFloat ? Float32Array : Uint8ClampedArray;\n      const tileDataR = new DataType(tileData.buffer);\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n      const bytesPerPixel = (bytesPerElement * tileDataR.length) / pixelCount;\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\n      const bandCount = Math.floor(\n        bytesPerRow / bytesPerElement / pixelSize[0],\n      );\n      const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n      extent[0] += source.offset;\n      extent[2] += source.offset;\n      const clipExtent = this.clipExtent_?.slice();\n      if (clipExtent) {\n        clipExtent[0] += source.offset;\n        clipExtent[2] += source.offset;\n      }\n      dataSources.push({\n        extent: extent,\n        clipExtent: clipExtent,\n        data: tileDataR,\n        dataType: DataType,\n        bytesPerPixel: bytesPerPixel,\n        pixelSize: pixelSize,\n        bandCount: bandCount,\n      });\n    });\n    this.sourceTiles_.length = 0;\n\n    if (dataSources.length === 0) {\n      this.state = TileState.ERROR;\n      this.changed();\n      return;\n    }\n\n    const z = this.wrappedTileCoord_[0];\n    const size = this.targetTileGrid_.getTileSize(z);\n    const targetWidth = typeof size === 'number' ? size : size[0];\n    const targetHeight = typeof size === 'number' ? size : size[1];\n    const outWidth = targetWidth * this.pixelRatio_;\n    const outHeight = targetHeight * this.pixelRatio_;\n    const targetResolution = this.targetTileGrid_.getResolution(z);\n    const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n\n    const bandCount = dataSources[0].bandCount;\n    const dataR = new dataSources[0].dataType(bandCount * outWidth * outHeight);\n\n    const gl = createCanvasContextWebGL(outWidth, outHeight, canvasGLPool, {\n      premultipliedAlpha: false,\n      antialias: false,\n    });\n\n    let willInterpolate;\n    const format = gl.RGBA;\n    let textureType;\n    if (dataSources[0].dataType == Float32Array) {\n      textureType = gl.FLOAT;\n      gl.getExtension('WEBGL_color_buffer_float');\n      gl.getExtension('OES_texture_float');\n      gl.getExtension('EXT_float_blend');\n      const extension = gl.getExtension('OES_texture_float_linear');\n      const canInterpolate = extension !== null;\n      willInterpolate = canInterpolate && this.interpolate;\n    } else {\n      textureType = gl.UNSIGNED_BYTE;\n      willInterpolate = this.interpolate;\n    }\n\n    const BANDS_PR_REPROJ = 4;\n    const reprojs = Math.ceil(bandCount / BANDS_PR_REPROJ);\n    for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\n      const sources = [];\n      for (let i = 0, len = dataSources.length; i < len; ++i) {\n        const dataSource = dataSources[i];\n\n        const pixelSize = dataSource.pixelSize;\n        const width = pixelSize[0];\n        const height = pixelSize[1];\n\n        const data = new dataSource.dataType(BANDS_PR_REPROJ * width * height);\n        const dataS = dataSource.data;\n        let offset = reproj * BANDS_PR_REPROJ;\n        for (let j = 0, len = data.length; j < len; j += BANDS_PR_REPROJ) {\n          data[j] = dataS[offset];\n          data[j + 1] = dataS[offset + 1];\n          data[j + 2] = dataS[offset + 2];\n          data[j + 3] = dataS[offset + 3];\n          offset += bandCount;\n        }\n\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        if (willInterpolate) {\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        } else {\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        }\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texImage2D(\n          gl.TEXTURE_2D,\n          0,\n          format,\n          width,\n          height,\n          0,\n          format,\n          textureType,\n          data,\n        );\n\n        sources.push({\n          extent: dataSource.extent,\n          clipExtent: dataSource.clipExtent,\n          texture: texture,\n          width: width,\n          height: height,\n        });\n      }\n\n      const {framebuffer, width, height} = renderReprojected(\n        gl,\n        targetWidth,\n        targetHeight,\n        this.pixelRatio_,\n        sourceResolution,\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        textureType,\n        this.renderEdges_,\n        willInterpolate,\n      );\n\n      // The texture is always RGBA.\n      const rows = width;\n      const cols = height * BANDS_PR_REPROJ;\n      const data = new dataSources[0].dataType(rows * cols);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n      gl.readPixels(0, 0, width, height, gl.RGBA, textureType, data);\n\n      let offset = reproj * BANDS_PR_REPROJ;\n      for (let i = 0, len = data.length; i < len; i += BANDS_PR_REPROJ) {\n        // The data read by `readPixels` is flipped in the y-axis so flip it again.\n        const flipY = (rows - 1 - ((i / cols) | 0)) * cols + (i % cols);\n        dataR[offset] = data[flipY];\n        dataR[offset + 1] = data[flipY + 1];\n        dataR[offset + 2] = data[flipY + 2];\n        dataR[offset + 3] = data[flipY + 3];\n        offset += bandCount;\n      }\n    }\n\n    releaseGLCanvas(gl);\n    canvasGLPool.push(gl.canvas);\n\n    if (imageLike) {\n      const context = createCanvasContext2D(targetWidth, targetHeight);\n      const imageData = new ImageData(dataR, targetWidth);\n      context.putImageData(imageData, 0, 0);\n      this.reprojData_ = context.canvas;\n    } else {\n      this.reprojData_ = dataR;\n    }\n    this.reprojSize_ = [Math.round(outWidth), Math.round(outHeight)];\n    this.state = TileState.LOADED;\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    let leftToLoad = 0;\n\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach(({tile}) => {\n      const state = tile.getState();\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\n        return;\n      }\n      leftToLoad++;\n\n      const sourceListenKey = listen(tile, EventType.CHANGE, () => {\n        const state = tile.getState();\n        if (\n          state == TileState.LOADED ||\n          state == TileState.ERROR ||\n          state == TileState.EMPTY\n        ) {\n          unlistenByKey(sourceListenKey);\n          leftToLoad--;\n          if (leftToLoad === 0) {\n            this.unlistenSources_();\n            this.reproject_();\n          }\n        }\n      });\n      this.sourcesListenerKeys_.push(sourceListenKey);\n    });\n\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    } else {\n      this.sourceTiles_.forEach(function ({tile}) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\n\nexport default ReprojDataTile;\n","/**\n * @module ol/source/DataTile\n */\nimport DataTile from '../DataTile.js';\nimport TileState from '../TileState.js';\nimport EventType from '../events/EventType.js';\nimport {toPromise} from '../functions.js';\nimport {equivalent, get as getProjection} from '../proj.js';\nimport ReprojDataTile from '../reproj/DataTile.js';\nimport {toSize} from '../size.js';\nimport {\n  createXYZ,\n  extentFromProjection,\n  getForProjection as getTileGridForProjection,\n} from '../tilegrid.js';\nimport {getUid} from '../util.js';\nimport TileSource, {TileSourceEvent} from './Tile.js';\nimport TileEventType from './TileEventType.js';\n\n/**\n * @typedef {'anonymous'|'use-credentials'} CrossOriginAttribute\n */\n\n/**\n * @typedef {Object} LoaderOptions\n * @property {AbortSignal} signal An abort controller signal.\n * @property {CrossOriginAttribute} [crossOrigin] The cross-origin attribute for images.\n * @property {number} [maxY] The maximum y coordinate at the given z level.  Will be undefined if the\n * underlying tile grid does not have a known extent.\n */\n\n/**\n * Data tile loading function.  The function is called with z, x, and y tile coordinates and\n * returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * @typedef {function(number, number, number, LoaderOptions) : (import(\"../DataTile.js\").Data|Promise<import(\"../DataTile.js\").Data>)} Loader\n */\n\n/**\n * @typedef {Object} Options\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\n * Returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * For loaders that generate images, the promise should not resolve until the image is loaded.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.\n * This may be different than the rendered pixel size if a `tileGrid` is provided.\n * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.\n * This allows artifacts of rendering at tile edges to be ignored.\n * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"./Source.js\").State} [state] The source state.\n * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.\n * @property {number} [transition] Transition time when fading in new tiles (in milliseconds).\n * @property {number} [bandCount=4] Number of bands represented in the data.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {CrossOriginAttribute} [crossOrigin='anonymous'] The crossOrigin property to pass to loaders for image data.\n * @property {string} [key] Key for use in caching tiles.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * A source for typed array data tiles.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @template {import(\"../Tile.js\").default} [TileType=DataTile]\n * @extends TileSource<TileType>\n * @api\n */\nclass DataTileSource extends TileSource {\n  /**\n   * @param {Options} options DataTile source options.\n   */\n  constructor(options) {\n    const projection =\n      options.projection === undefined ? 'EPSG:3857' : options.projection;\n\n    let tileGrid = options.tileGrid;\n    if (tileGrid === undefined && projection) {\n      tileGrid = createXYZ({\n        extent: extentFromProjection(projection),\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize,\n      });\n    }\n\n    super({\n      cacheSize: 0.1, // don't cache on the source\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: projection,\n      tileGrid: tileGrid,\n      state: options.state,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate,\n      key: options.key,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\n\n    /**\n     * @private\n     * @type {import('../size.js').Size|null}\n     */\n    this.tileSize_ = options.tileSize ? toSize(options.tileSize) : null;\n\n    /**\n     * @private\n     * @type {Array<import('../size.js').Size>|null}\n     */\n    this.tileSizes_ = null;\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n\n    /**\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @private\n     */\n    this.handleTileChange_ = this.handleTileChange_.bind(this);\n\n    /**\n     * @type {number}\n     */\n    this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGridForProjection_ = {};\n\n    /**\n     * @private\n     * @type {CrossOriginAttribute}\n     */\n    this.crossOrigin_ = options.crossOrigin || 'anonymous';\n\n    /**\n     * @type {import(\"../transform.js\").Transform|null}\n     */\n    this.transformMatrix = null;\n  }\n\n  /**\n   * Set the source tile sizes.  The length of the array is expected to match the number of\n   * levels in the tile grid.\n   * @protected\n   * @param {Array<import('../size.js').Size>} tileSizes An array of tile sizes.\n   */\n  setTileSizes(tileSizes) {\n    this.tileSizes_ = tileSizes;\n  }\n\n  /**\n   * Get the source tile size at the given zoom level.  This may be different than the rendered tile\n   * size.\n   * @protected\n   * @param {number} z Tile zoom level.\n   * @return {import('../size.js').Size} The source tile size.\n   */\n  getTileSize(z) {\n    if (this.tileSizes_) {\n      return this.tileSizes_[z];\n    }\n    if (this.tileSize_) {\n      return this.tileSize_;\n    }\n    const tileGrid = this.getTileGrid();\n    return tileGrid ? toSize(tileGrid.getTileSize(z)) : [256, 256];\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   * @override\n   */\n  getGutterForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (\n      (!thisProj || equivalent(thisProj, projection)) &&\n      !this.transformMatrix\n    ) {\n      return this.gutter_;\n    }\n\n    return 0;\n  }\n\n  /**\n   * @param {Loader} loader The data loader.\n   * @protected\n   */\n  setLoader(loader) {\n    this.loader_ = loader;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} targetProj The output projection.\n   * @param {import(\"../proj/Projection.js\").default} sourceProj The input projection.\n   * @return {!TileType} Tile.\n   */\n  getReprojTile_(z, x, y, targetProj, sourceProj) {\n    const sourceTileGrid =\n      this.tileGrid || this.getTileGridForProjection(sourceProj || targetProj);\n    const reprojTilePixelRatio = Math.max.apply(\n      null,\n      sourceTileGrid.getResolutions().map((r, z) => {\n        const tileSize = toSize(sourceTileGrid.getTileSize(z));\n        const textureSize = this.getTileSize(z);\n        return Math.max(\n          textureSize[0] / tileSize[0],\n          textureSize[1] / tileSize[1],\n        );\n      }),\n    );\n\n    const targetTileGrid = this.getTileGridForProjection(targetProj);\n    const tileCoord = [z, x, y];\n    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      targetProj,\n    );\n\n    const options = Object.assign(\n      {\n        sourceProj: sourceProj || targetProj,\n        sourceTileGrid,\n        targetProj,\n        targetTileGrid,\n        tileCoord,\n        wrappedTileCoord,\n        pixelRatio: reprojTilePixelRatio,\n        gutter: this.gutter_,\n        getTileFunction: (z, x, y, pixelRatio) =>\n          this.getTile(z, x, y, pixelRatio),\n        transformMatrix: this.transformMatrix,\n      },\n      /** @type {import(\"../reproj/DataTile.js\").Options} */ (this.tileOptions),\n    );\n    const tile = /** @type {TileType} */ (\n      /** @type {*} */ (new ReprojDataTile(options))\n    );\n    tile.key = this.getKey();\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\n   * @return {TileType|null} Tile (or null if outside source extent).\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (\n      projection &&\n      ((sourceProjection && !equivalent(sourceProjection, projection)) ||\n        this.transformMatrix)\n    ) {\n      return this.getReprojTile_(z, x, y, projection, sourceProjection);\n    }\n\n    const size = this.getTileSize(z);\n\n    const sourceLoader = this.loader_;\n\n    const controller = new AbortController();\n\n    /**\n     * @type {LoaderOptions}\n     */\n    const loaderOptions = {\n      signal: controller.signal,\n      crossOrigin: this.crossOrigin_,\n    };\n\n    const tileCoord = this.getTileCoordForTileUrlFunction([z, x, y]);\n    if (!tileCoord) {\n      return null;\n    }\n\n    const requestZ = tileCoord[0];\n    const requestX = tileCoord[1];\n    const requestY = tileCoord[2];\n    const range = this.getTileGrid()?.getFullTileRange(requestZ);\n    if (range) {\n      loaderOptions.maxY = range.getHeight() - 1;\n    }\n    function loader() {\n      return toPromise(function () {\n        return sourceLoader(requestZ, requestX, requestY, loaderOptions);\n      });\n    }\n\n    /**\n     * @type {import(\"../DataTile.js\").Options}\n     */\n    const options = Object.assign(\n      {\n        tileCoord: [z, x, y],\n        loader: loader,\n        size: size,\n        controller: controller,\n      },\n      this.tileOptions,\n    );\n\n    const tile = /** @type {TileType} */ (\n      /** @type {*} */ (new DataTile(options))\n    );\n    tile.key = this.getKey();\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\n\n    return tile;\n  }\n\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   */\n  handleTileChange_(event) {\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n    const uid = getUid(tile);\n    const tileState = tile.getState();\n    let type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type =\n        tileState == TileState.ERROR\n          ? TileEventType.TILELOADERROR\n          : tileState == TileState.LOADED\n            ? TileEventType.TILELOADEND\n            : undefined;\n    }\n    if (type) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @override\n   */\n  getTileGridForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (\n      this.tileGrid &&\n      (!thisProj || equivalent(thisProj, projection)) &&\n      !this.transformMatrix\n    ) {\n      return this.tileGrid;\n    }\n\n    const projKey = getUid(projection);\n    if (!(projKey in this.tileGridForProjection_)) {\n      this.tileGridForProjection_[projKey] =\n        getTileGridForProjection(projection);\n    }\n    return this.tileGridForProjection_[projKey];\n  }\n\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  setTileGridForProjection(projection, tilegrid) {\n    const proj = getProjection(projection);\n    if (proj) {\n      const projKey = getUid(proj);\n      if (!(projKey in this.tileGridForProjection_)) {\n        this.tileGridForProjection_[projKey] = tilegrid;\n      }\n    }\n  }\n}\n\nexport default DataTileSource;\n"],"names":["TILELOADSTART","TILELOADEND","TILELOADERROR","VERTEX_SHADER","FRAGMENT_SHADER","Canvas","constructor","gl","this","gl_","program_","createProgram","positionLocation","getAttribLocation","texcoordLocation","matrixLocation","getUniformLocation","textureMatrixLocation","textureLocation","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","positions","bufferData","Float32Array","STATIC_DRAW","texcoordBuffer","texcoords","drawImage","tex","texWidth","texHeight","srcX","srcY","srcWidth","srcHeight","dstX","dstY","dstWidth","dstHeight","width","height","undefined","canvas","bindTexture","TEXTURE_2D","useProgram","enableVertexAttribArray","vertexAttribPointer","FLOAT","matrix","mat4","uniformMatrix4fv","texMatrix","uniform1i","drawArrays","TRIANGLES","length","createShader","type","source","shader","Error","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","log","getShaderInfoLog","fragmentSource","vertexSource","program","vertexShader","fragmentShader","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","EDGE_VERTEX_SHADER","EDGE_FRAGMENT_SHADER","TRIANGLE_VERTEX_SHADER","TRIANGLE_FRAGMENT_SHADER","createCanvasContextWebGL","canvasPool","settings","shift","OffscreenCanvas","document","createElement","getContext","releaseGLCanvas","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","canvasGLPool","render","width_","height_","pixelRatio","sourceResolution","targetResolution","targetExtent","triangulation","sources","gutter","dataType","renderEdges","interpolate","drawSingle","Math","round","resultFrameBuffer","resultTexture","createTexture","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_MAG_FILTER","NEAREST","texImage2D","RGBA","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","framebuffer","texture","sourceDataExtent","stitchTexture","stitchWidth","stitchHeight","forEach","src","i","arr","extent","stitchScale","maxTexSize","getParameter","MAX_TEXTURE_SIZE","largeSide","max","scaleFactor","stitchWidthFixed","stitchHeightFixed","fb","webGLCanvas","xPos","yPos","viewport","clipExtent","enable","SCISSOR_TEST","scissor","disable","deleteFramebuffer","targetTopLeft","sourceTopLeft","getUVs","target","u0","v0","u1","v1","u2","v2","vertices","triProgram","getTriangles","triangle","su0","sv0","su1","sv1","su2","sv2","push","edgeProgram","burnval","Array","isArray","burnvalLocation","isFloat","uniform4fv","uniform4iv","lines","reduce","concat","LINES","ReprojDataTile","DataTile","options","super","tileCoord","loader","Promise","resolve","Uint8ClampedArray","transition","renderEdges_","pixelRatio_","gutter_","reprojData_","reprojError_","reprojSize_","sourceTileGrid_","sourceTileGrid","targetTileGrid_","targetTileGrid","wrappedTileCoord_","wrappedTileCoord","sourceTiles_","sourcesListenerKeys_","sourceZ_","sourceProj","sourceProjExtent","getExtent","sourceTileGridExtent","clipExtent_","canWrapX","getTileCoordExtent","maxTargetExtent","maxSourceExtent","limitedTargetExtent","state","TileState","EMPTY","getResolution","targetProj","isFinite","errorThresholdInPixels","errorThreshold","triangulation_","Triangulation","transformMatrix","getZForResolution","sourceExtent","calculateSourceExtent","worldWidth","worldsAway","floor","sourceExtents","slice","sourceRange","getTileRangeForExtentAndZ","getTile","getTileFunction","minX","maxX","minY","maxY","tile","offset","getSize","getData","getError","reproject_","dataSources","imageLike","getState","LOADED","size","tileData","arrayData","pixelSize","pixelCount","DataType","tileDataR","buffer","bytesPerElement","BYTES_PER_ELEMENT","bytesPerPixel","bytesPerRow","byteLength","bandCount","data","ERROR","changed","z","getTileSize","targetWidth","targetHeight","outWidth","outHeight","dataR","premultipliedAlpha","antialias","willInterpolate","format","textureType","getExtension","extension","canInterpolate","UNSIGNED_BYTE","BANDS_PR_REPROJ","reprojs","ceil","reproj","len","dataSource","dataS","j","rows","cols","readPixels","flipY","context","imageData","ImageData","putImageData","load","IDLE","LOADING","leftToLoad","sourceListenKey","EventType","CHANGE","unlistenSources_","setTimeout","bind","DataTileSource","Tile","projection","tileGrid","maxResolution","maxZoom","minZoom","tileSize","cacheSize","attributions","attributionsCollapsible","wrapX","key","zDirection","tileSize_","tileSizes_","tileLoadingKeys_","loader_","handleTileChange_","tileGridForProjection_","crossOrigin_","crossOrigin","setTileSizes","tileSizes","getTileGrid","getGutterForProjection","thisProj","getProjection","setLoader","getReprojTile_","x","y","getTileGridForProjection","reprojTilePixelRatio","apply","getResolutions","map","r","textureSize","getTileCoordForTileUrlFunction","Object","assign","getKey","sourceProjection","sourceLoader","controller","AbortController","loaderOptions","signal","requestZ","requestX","requestY","range","getFullTileRange","getHeight","tileOptions","addEventListener","event","uid","tileState","TileEventType","dispatchEvent","TileSourceEvent","projKey","setTileGridForProjection","tilegrid","proj"],"sourceRoot":""}