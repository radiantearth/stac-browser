{"version":3,"file":"js/6017.e25e5777.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/source/Tile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/tilegrid.js"],"sourcesContent":["/**\n * @module ol/source/Tile\n */\nimport Event from '../events/Event.js';\nimport {scale as scaleSize, toSize} from '../size.js';\nimport {withinExtentAndZ} from '../tilecoord.js';\nimport {\n  getForProjection as getTileGridForProjection,\n  wrapX,\n} from '../tilegrid.js';\nimport {abstract, getUid} from '../util.js';\nimport Source from './Source.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./TileEventType\").TileSourceEventTypes, TileSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     import(\"./TileEventType\").TileSourceEventTypes, Return>} TileSourceOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./Source.js\").State} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {boolean} [wrapX=false] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n *\n * @template {import(\"../Tile.js\").default} [TileType=import(\"../Tile.js\").default]\n * @abstract\n * @api\n */\nclass TileSource extends Source {\n  /**\n   * @param {Options} options SourceTile source options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: options.projection,\n      state: options.state,\n      wrapX: options.wrapX,\n      interpolate: options.interpolate,\n    });\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {TileSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilePixelRatio_ =\n      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n\n    /**\n     * @type {import(\"../tilegrid/TileGrid.js\").default|null}\n     * @protected\n     */\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n\n    const tileSize = [256, 256];\n    if (this.tileGrid) {\n      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);\n    }\n\n    /**\n     * @protected\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize = [0, 0];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.key_ = options.key || getUid(this);\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").Options}\n     */\n    this.tileOptions = {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    };\n\n    /**\n     * zDirection hint, read by the renderer. Indicates which resolution should be used\n     * by a renderer if the views resolution does not match any resolution of the tile source.\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n     * will be used. If -1, the nearest higher resolution will be used.\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\n     */\n    this.zDirection = options.zDirection ? options.zDirection : 0;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  getGutterForProjection(projection) {\n    return 0;\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   */\n  getKey() {\n    return this.key_;\n  }\n\n  /**\n   * Set the value to be used as the key for all tiles in the source.\n   * @param {string} key The key for tiles.\n   * @protected\n   */\n  setKey(key) {\n    if (this.key_ !== key) {\n      this.key_ = key;\n      this.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   * @override\n   */\n  getResolutions(projection) {\n    const tileGrid = projection\n      ? this.getTileGridForProjection(projection)\n      : this.tileGrid;\n    if (!tileGrid) {\n      return null;\n    }\n    return tileGrid.getResolutions();\n  }\n\n  /**\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {TileType|null} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    return abstract();\n  }\n\n  /**\n   * Return the tile grid of the tile source.\n   * @return {import(\"../tilegrid/TileGrid.js\").default|null} Tile grid.\n   * @api\n   */\n  getTileGrid() {\n    return this.tileGrid;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    if (!this.tileGrid) {\n      return getTileGridForProjection(projection);\n    }\n    return this.tileGrid;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source. Subclasses may override this\n   * method, which is meant to return a supported pixel ratio that matches the\n   * provided `pixelRatio` as close as possible.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return this.tilePixelRatio_;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    if (tilePixelRatio == 1) {\n      return tileSize;\n    }\n    return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n  }\n\n  /**\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n   * is outside the resolution and extent range of the tile grid, `null` will be\n   * returned.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n   *     null if no tile URL should be created for the passed `tileCoord`.\n   */\n  getTileCoordForTileUrlFunction(tileCoord, projection) {\n    const gridProjection =\n      projection !== undefined ? projection : this.getProjection();\n    const tileGrid =\n      projection !== undefined\n        ? this.getTileGridForProjection(gridProjection)\n        : this.tileGrid || this.getTileGridForProjection(gridProjection);\n    if (this.getWrapX() && gridProjection.isGlobal()) {\n      tileCoord = wrapX(tileGrid, tileCoord, gridProjection);\n    }\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n  }\n\n  /**\n   * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.\n   * @api\n   */\n  clear() {}\n\n  /**\n   * @override\n   */\n  refresh() {\n    this.clear();\n    super.refresh();\n  }\n}\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\nexport class TileSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Tile.js\").default} tile The tile.\n   */\n  constructor(type, tile) {\n    super(type);\n\n    /**\n     * The tile related to the event.\n     * @type {import(\"../Tile.js\").default}\n     * @api\n     */\n    this.tile = tile;\n  }\n}\n\nexport default TileSource;\n","/**\n * @module ol/tilegrid\n */\nimport {\n  containsCoordinate,\n  createOrUpdate,\n  getCorner,\n  getHeight,\n  getWidth,\n} from './extent.js';\nimport {METERS_PER_UNIT, get as getProjection} from './proj.js';\nimport {toSize} from './size.js';\nimport TileGrid from './tilegrid/TileGrid.js';\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\n\nexport {TileGrid};\nexport {default as WMTS} from './tilegrid/WMTS.js';\n\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n  let tileGrid = projection.getDefaultTileGrid();\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n  return tileGrid;\n}\n\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n  const z = tileCoord[0];\n  const center = tileGrid.getTileCoordCenter(tileCoord);\n  const projectionExtent = extentFromProjection(projection);\n  if (!containsCoordinate(projectionExtent, center)) {\n    const worldWidth = getWidth(projectionExtent);\n    const worldsAway = Math.ceil(\n      (projectionExtent[0] - center[0]) / worldWidth,\n    );\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\n  }\n  return tileCoord;\n}\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, maxZoom, tileSize, corner) {\n  corner = corner !== undefined ? corner : 'top-left';\n\n  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);\n\n  return new TileGrid({\n    extent: extent,\n    origin: getCorner(extent, corner),\n    resolutions: resolutions,\n    tileSize: tileSize,\n  });\n}\n\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions} [options] Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(options) {\n  const xyzOptions = options || {};\n\n  const extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n\n  const gridOptions = {\n    extent: extent,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(\n      extent,\n      xyzOptions.maxZoom,\n      xyzOptions.tileSize,\n      xyzOptions.maxResolution,\n    ),\n  };\n  return new TileGrid(gridOptions);\n}\n\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number} [maxResolution] Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {\n  maxZoom = maxZoom !== undefined ? maxZoom : DEFAULT_MAX_ZOOM;\n  tileSize = toSize(tileSize !== undefined ? tileSize : DEFAULT_TILE_SIZE);\n\n  const height = getHeight(extent);\n  const width = getWidth(extent);\n\n  maxResolution =\n    maxResolution > 0\n      ? maxResolution\n      : Math.max(width / tileSize[0], height / tileSize[1]);\n\n  const length = maxZoom + 1;\n  const resolutions = new Array(length);\n  for (let z = 0; z < length; ++z) {\n    resolutions[z] = maxResolution / Math.pow(2, z);\n  }\n  return resolutions;\n}\n\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, maxZoom, tileSize, corner) {\n  const extent = extentFromProjection(projection);\n  return createForExtent(extent, maxZoom, tileSize, corner);\n}\n\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n  projection = getProjection(projection);\n  let extent = projection.getExtent();\n  if (!extent) {\n    const half =\n      (180 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit();\n    extent = createOrUpdate(-half, -half, half, half);\n  }\n  return extent;\n}\n"],"names":["TileSource","constructor","options","super","attributions","attributionsCollapsible","projection","state","wrapX","interpolate","this","on","once","un","tilePixelRatio_","undefined","tilePixelRatio","tileGrid","tileSize","getTileSize","getMinZoom","tmpSize","key_","key","tileOptions","transition","zDirection","getGutterForProjection","getKey","setKey","changed","getResolutions","getTileGridForProjection","getTile","z","x","y","pixelRatio","getTileGrid","getTilePixelRatio","getTilePixelSize","getTileCoordForTileUrlFunction","tileCoord","gridProjection","getProjection","getWrapX","isGlobal","clear","refresh","TileSourceEvent","type","tile","getForProjection","getDefaultTileGrid","createForProjection","setDefaultTileGrid","center","getTileCoordCenter","projectionExtent","extentFromProjection","worldWidth","worldsAway","Math","ceil","getTileCoordForCoordAndZ","createForExtent","extent","maxZoom","corner","resolutions","resolutionsFromExtent","origin","createXYZ","xyzOptions","getExtent","gridOptions","minZoom","maxResolution","height","width","max","length","Array","pow","half","degrees","getMetersPerUnit"],"sourceRoot":""}