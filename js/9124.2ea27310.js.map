{"version":3,"file":"js/9124.2ea27310.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/geom/flat/geodesic.js","webpack://@radiantearth/stac-browser/./node_modules/ol/render.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/Graticule.js"],"sourcesContent":["/**\n * @module ol/geom/flat/geodesic\n */\nimport {squaredSegmentDistance, toDegrees, toRadians} from '../../math.js';\nimport {get as getProjection, getTransform} from '../../proj.js';\n\n/**\n * @param {function(number): import(\"../../coordinate.js\").Coordinate} interpolate Interpolate function.\n * @param {import(\"../../proj.js\").TransformFunction} transform Transform from longitude/latitude to\n *     projected coordinates.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nfunction line(interpolate, transform, squaredTolerance) {\n  // FIXME reduce garbage generation\n  // FIXME optimize stack operations\n\n  /** @type {Array<number>} */\n  const flatCoordinates = [];\n\n  let geoA = interpolate(0);\n  let geoB = interpolate(1);\n\n  let a = transform(geoA);\n  let b = transform(geoB);\n\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n  const geoStack = [geoB, geoA];\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n  const stack = [b, a];\n  /** @type {Array<number>} */\n  const fractionStack = [1, 0];\n\n  /** @type {!Object<string, boolean>} */\n  const fractions = {};\n\n  let maxIterations = 1e5;\n  let geoM, m, fracA, fracB, fracM, key;\n\n  while (--maxIterations > 0 && fractionStack.length > 0) {\n    // Pop the a coordinate off the stack\n    fracA = fractionStack.pop();\n    geoA = geoStack.pop();\n    a = stack.pop();\n    // Add the a coordinate if it has not been added yet\n    key = fracA.toString();\n    if (!(key in fractions)) {\n      flatCoordinates.push(a[0], a[1]);\n      fractions[key] = true;\n    }\n    // Pop the b coordinate off the stack\n    fracB = fractionStack.pop();\n    geoB = geoStack.pop();\n    b = stack.pop();\n    // Find the m point between the a and b coordinates\n    fracM = (fracA + fracB) / 2;\n    geoM = interpolate(fracM);\n    m = transform(geoM);\n    if (\n      squaredSegmentDistance(m[0], m[1], a[0], a[1], b[0], b[1]) <\n      squaredTolerance\n    ) {\n      // If the m point is sufficiently close to the straight line, then we\n      // discard it.  Just use the b coordinate and move on to the next line\n      // segment.\n      flatCoordinates.push(b[0], b[1]);\n      key = fracB.toString();\n      fractions[key] = true;\n    } else {\n      // Otherwise, we need to subdivide the current line segment.  Split it\n      // into two and push the two line segments onto the stack.\n      fractionStack.push(fracB, fracM, fracM, fracA);\n      stack.push(b, m, m, a);\n      geoStack.push(geoB, geoM, geoM, geoA);\n    }\n  }\n\n  return flatCoordinates;\n}\n\n/**\n * Generate a great-circle arcs between two lat/lon points.\n * @param {number} lon1 Longitude 1 in degrees.\n * @param {number} lat1 Latitude 1 in degrees.\n * @param {number} lon2 Longitude 2 in degrees.\n * @param {number} lat2 Latitude 2 in degrees.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function greatCircleArc(\n  lon1,\n  lat1,\n  lon2,\n  lat2,\n  projection,\n  squaredTolerance,\n) {\n  const geoProjection = getProjection('EPSG:4326');\n\n  const cosLat1 = Math.cos(toRadians(lat1));\n  const sinLat1 = Math.sin(toRadians(lat1));\n  const cosLat2 = Math.cos(toRadians(lat2));\n  const sinLat2 = Math.sin(toRadians(lat2));\n  const cosDeltaLon = Math.cos(toRadians(lon2 - lon1));\n  const sinDeltaLon = Math.sin(toRadians(lon2 - lon1));\n  const d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;\n\n  return line(\n    /**\n     * @param {number} frac Fraction.\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n     */\n    function (frac) {\n      if (1 <= d) {\n        return [lon2, lat2];\n      }\n      const D = frac * Math.acos(d);\n      const cosD = Math.cos(D);\n      const sinD = Math.sin(D);\n      const y = sinDeltaLon * cosLat2;\n      const x = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon;\n      const theta = Math.atan2(y, x);\n      const lat = Math.asin(sinLat1 * cosD + cosLat1 * sinD * Math.cos(theta));\n      const lon =\n        toRadians(lon1) +\n        Math.atan2(\n          Math.sin(theta) * sinD * cosLat1,\n          cosD - sinLat1 * Math.sin(lat),\n        );\n      return [toDegrees(lon), toDegrees(lat)];\n    },\n    getTransform(geoProjection, projection),\n    squaredTolerance,\n  );\n}\n\n/**\n * Generate a meridian (line at constant longitude).\n * @param {number} lon Longitude.\n * @param {number} lat1 Latitude 1.\n * @param {number} lat2 Latitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function meridian(lon, lat1, lat2, projection, squaredTolerance) {\n  const epsg4326Projection = getProjection('EPSG:4326');\n  return line(\n    /**\n     * @param {number} frac Fraction.\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n     */\n    function (frac) {\n      return [lon, lat1 + (lat2 - lat1) * frac];\n    },\n    getTransform(epsg4326Projection, projection),\n    squaredTolerance,\n  );\n}\n\n/**\n * Generate a parallel (line at constant latitude).\n * @param {number} lat Latitude.\n * @param {number} lon1 Longitude 1.\n * @param {number} lon2 Longitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function parallel(lat, lon1, lon2, projection, squaredTolerance) {\n  const epsg4326Projection = getProjection('EPSG:4326');\n  return line(\n    /**\n     * @param {number} frac Fraction.\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n     */\n    function (frac) {\n      return [lon1 + (lon2 - lon1) * frac, lat];\n    },\n    getTransform(epsg4326Projection, projection),\n    squaredTolerance,\n  );\n}\n","/**\n * @module ol/render\n */\nimport {DEVICE_PIXEL_RATIO} from './has.js';\nimport {getTransformFromProjections, getUserProjection} from './proj.js';\nimport CanvasImmediateRenderer from './render/canvas/Immediate.js';\nimport {getSquaredTolerance} from './renderer/vector.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply as multiplyTransform,\n  scale as scaleTransform,\n} from './transform.js';\n\n/**\n * @typedef {Object} State\n * @property {CanvasRenderingContext2D} context Canvas context that the layer is being rendered to.\n * @property {import(\"./Feature.js\").FeatureLike} feature Feature.\n * @property {import(\"./geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} pixelRatio Pixel ratio used by the layer renderer.\n * @property {number} resolution Resolution that the render batch was created and optimized for.\n * This is not the view's resolution that is being rendered.\n * @property {number} rotation Rotation of the rendered layer in radians.\n */\n\n/**\n * A function to be used when sorting features before rendering.\n * It takes two instances of {@link module:ol/Feature~Feature} or\n * {@link module:ol/render/Feature~RenderFeature} and returns a `{number}`.\n *\n * @typedef {function(import(\"./Feature.js\").FeatureLike, import(\"./Feature.js\").FeatureLike):number} OrderFunction\n */\n\n/**\n * @typedef {Object} ToContextOptions\n * @property {import(\"./size.js\").Size} [size] Desired size of the canvas in css\n * pixels. When provided, both canvas and css size will be set according to the\n * `pixelRatio`. If not provided, the current canvas and css sizes will not be\n * altered.\n * @property {number} [pixelRatio=window.devicePixelRatio] Pixel ratio (canvas\n * pixel to css pixel ratio) for the canvas.\n */\n\n/**\n * Binds a Canvas Immediate API to a canvas context, to allow drawing geometries\n * to the context's canvas.\n *\n * The units for geometry coordinates are css pixels relative to the top left\n * corner of the canvas element.\n * ```js\n * import {toContext} from 'ol/render.js';\n * import Fill from 'ol/style/Fill.js';\n * import Polygon from 'ol/geom/Polygon.js';\n *\n * const canvas = document.createElement('canvas');\n * const render = toContext(\n *     canvas.getContext('2d'),\n *     {size: [100, 100]}\n * );\n * render.setFillStrokeStyle(new Fill({ color: blue }));\n * render.drawPolygon(\n *     new Polygon([[[0, 0], [100, 100], [100, 0], [0, 0]]])\n * );\n * ```\n *\n * @param {CanvasRenderingContext2D} context Canvas context.\n * @param {ToContextOptions} [options] Options.\n * @return {CanvasImmediateRenderer} Canvas Immediate.\n * @api\n */\nexport function toContext(context, options) {\n  const canvas = context.canvas;\n  options = options ? options : {};\n  const pixelRatio = options.pixelRatio || DEVICE_PIXEL_RATIO;\n  const size = options.size;\n  if (size) {\n    canvas.width = size[0] * pixelRatio;\n    canvas.height = size[1] * pixelRatio;\n    canvas.style.width = size[0] + 'px';\n    canvas.style.height = size[1] + 'px';\n  }\n  const extent = [0, 0, canvas.width, canvas.height];\n  const transform = scaleTransform(createTransform(), pixelRatio, pixelRatio);\n  return new CanvasImmediateRenderer(context, pixelRatio, extent, transform, 0);\n}\n\n/**\n * Gets a vector context for drawing to the event's canvas.\n * @param {import(\"./render/Event.js\").default} event Render event.\n * @return {CanvasImmediateRenderer} Vector context.\n * @api\n */\nexport function getVectorContext(event) {\n  if (!(event.context instanceof CanvasRenderingContext2D)) {\n    throw new Error('Only works for render events from Canvas 2D layers');\n  }\n\n  // canvas may be at a different pixel ratio than frameState.pixelRatio\n  const a = event.inversePixelTransform[0];\n  const b = event.inversePixelTransform[1];\n  const canvasPixelRatio = Math.sqrt(a * a + b * b);\n  const frameState = event.frameState;\n  const transform = multiplyTransform(\n    event.inversePixelTransform.slice(),\n    frameState.coordinateToPixelTransform,\n  );\n  const squaredTolerance = getSquaredTolerance(\n    frameState.viewState.resolution,\n    canvasPixelRatio,\n  );\n  let userTransform;\n  const userProjection = getUserProjection();\n  if (userProjection) {\n    userTransform = getTransformFromProjections(\n      userProjection,\n      frameState.viewState.projection,\n    );\n  }\n\n  return new CanvasImmediateRenderer(\n    event.context,\n    canvasPixelRatio,\n    frameState.extent,\n    transform,\n    frameState.viewState.rotation,\n    squaredTolerance,\n    userTransform,\n  );\n}\n\n/**\n * Gets the pixel of the event's canvas context from the map viewport's CSS pixel.\n * @param {import(\"./render/Event.js\").default} event Render event.\n * @param {import(\"./pixel.js\").Pixel} pixel CSS pixel relative to the top-left\n * corner of the map viewport.\n * @return {import(\"./pixel.js\").Pixel} Pixel on the event's canvas context.\n * @api\n */\nexport function getRenderPixel(event, pixel) {\n  return applyTransform(event.inversePixelTransform, pixel.slice(0));\n}\n","/**\n * @module ol/layer/Graticule\n */\nimport Collection from '../Collection.js';\nimport Feature from '../Feature.js';\nimport {degreesToStringHDMS} from '../coordinate.js';\nimport {\n  applyTransform,\n  approximatelyEquals,\n  containsCoordinate,\n  containsExtent,\n  equals,\n  getCenter,\n  getIntersection,\n  getWidth,\n  intersects,\n  isEmpty,\n  wrapX as wrapExtentX,\n} from '../extent.js';\nimport LineString from '../geom/LineString.js';\nimport Point from '../geom/Point.js';\nimport {meridian, parallel} from '../geom/flat/geodesic.js';\nimport {clamp} from '../math.js';\nimport {\n  equivalent as equivalentProjection,\n  get as getProjection,\n  getTransform,\n} from '../proj.js';\nimport EventType from '../render/EventType.js';\nimport {getVectorContext} from '../render.js';\nimport VectorSource from '../source/Vector.js';\nimport Fill from '../style/Fill.js';\nimport Stroke from '../style/Stroke.js';\nimport Style from '../style/Style.js';\nimport Text from '../style/Text.js';\nimport VectorLayer from './Vector.js';\n\n/**\n * @type {Stroke}\n * @private\n * @const\n */\nconst DEFAULT_STROKE_STYLE = new Stroke({\n  color: 'rgba(0,0,0,0.2)',\n});\n\n/**\n * @type {Array<number>}\n * @private\n */\nconst INTERVALS = [\n  90,\n  45,\n  30,\n  20,\n  10,\n  5,\n  2,\n  1,\n  30 / 60,\n  20 / 60,\n  10 / 60,\n  5 / 60,\n  2 / 60,\n  1 / 60,\n  30 / 3600,\n  20 / 3600,\n  10 / 3600,\n  5 / 3600,\n  2 / 3600,\n  1 / 3600,\n];\n\n/**\n * @typedef {Object} GraticuleLabelDataType\n * @property {Point} geom Geometry.\n * @property {string} text Text.\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [maxLines=100] The maximum number of meridians and\n * parallels from the center of the map. The default value of 100 means that at\n * most 200 meridians and 200 parallels will be displayed. The default value is\n * appropriate for conformal projections like Spherical Mercator. If you\n * increase the value, more lines will be drawn and the drawing performance will\n * decrease.\n * @property {Stroke} [strokeStyle] The\n * stroke style to use for drawing the graticule. If not provided, the following stroke will be used:\n * ```js\n * new Stroke({\n *   color: 'rgba(0, 0, 0, 0.2)' // a not fully opaque black\n * });\n * ```\n * @property {number} [targetSize=100] The target size of the graticule cells,\n * in pixels.\n * @property {boolean} [showLabels=false] Render a label with the respective\n * latitude/longitude for each graticule line.\n * @property {function(number):string} [lonLabelFormatter] Label formatter for\n * longitudes. This function is called with the longitude as argument, and\n * should return a formatted string representing the longitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {function(number):string} [latLabelFormatter] Label formatter for\n * latitudes. This function is called with the latitude as argument, and\n * should return a formatted string representing the latitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {number} [lonLabelPosition=0] Longitude label position in fractions\n * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the\n * top.\n * @property {number} [latLabelPosition=1] Latitude label position in fractions\n * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the\n * right.\n * @property {Text} [lonLabelStyle] Longitude label text\n * style. If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textBaseline: 'bottom',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: new Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textBaseline` configuration will not work well for\n * `lonLabelPosition` configurations that position labels close to the top of\n * the viewport.\n * @property {Text} [latLabelStyle] Latitude label text style.\n * If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textAlign: 'end',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textAlign` configuration will not work well for\n * `latLabelPosition` configurations that position labels close to the left of\n * the viewport.\n * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 30/60, 20/60, 10/60, 5/60, 2/60, 1/60, 30/3600, 20/3600, 10/3600, 5/3600, 2/3600, 1/3600]]\n * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:\n * ```js\n * [30, 10]\n * ```\n * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Layer that renders a grid for a coordinate system (currently only EPSG:4326 is supported).\n * Note that the view projection must define both extent and worldExtent.\n *\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\n * @extends {VectorLayer<VectorSource<Feature>>}\n * @api\n */\nclass Graticule extends VectorLayer {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign(\n      {\n        updateWhileAnimating: true,\n        updateWhileInteracting: true,\n        renderBuffer: 0,\n      },\n      options,\n    );\n\n    delete baseOptions.maxLines;\n    delete baseOptions.strokeStyle;\n    delete baseOptions.targetSize;\n    delete baseOptions.showLabels;\n    delete baseOptions.lonLabelFormatter;\n    delete baseOptions.latLabelFormatter;\n    delete baseOptions.lonLabelPosition;\n    delete baseOptions.latLabelPosition;\n    delete baseOptions.lonLabelStyle;\n    delete baseOptions.latLabelStyle;\n    delete baseOptions.intervals;\n    super(baseOptions);\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.projection_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxLat_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxLon_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minLat_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minLon_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxX_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxY_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minX_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minY_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.targetSize_ =\n      options.targetSize !== undefined ? options.targetSize : 100;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;\n\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n    this.meridians_ = [];\n\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n    this.parallels_ = [];\n\n    /**\n     * @type {Stroke}\n     * @private\n     */\n    this.strokeStyle_ =\n      options.strokeStyle !== undefined\n        ? options.strokeStyle\n        : DEFAULT_STROKE_STYLE;\n\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n    this.fromLonLatTransform_ = undefined;\n\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n    this.toLonLatTransform_ = undefined;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.projectionCenterLonLat_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.bottomLeft_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.bottomRight_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.topLeft_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.topRight_ = null;\n\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n    this.meridiansLabels_ = null;\n\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n    this.parallelsLabels_ = null;\n\n    if (options.showLabels) {\n      /**\n       * @type {null|function(number):string}\n       * @private\n       */\n      this.lonLabelFormatter_ =\n        options.lonLabelFormatter == undefined\n          ? degreesToStringHDMS.bind(this, 'EW')\n          : options.lonLabelFormatter;\n\n      /**\n       * @type {function(number):string}\n       * @private\n       */\n      this.latLabelFormatter_ =\n        options.latLabelFormatter == undefined\n          ? degreesToStringHDMS.bind(this, 'NS')\n          : options.latLabelFormatter;\n\n      /**\n       * Longitude label position in fractions (0..1) of view extent. 0 means\n       * bottom, 1 means top.\n       * @type {number}\n       * @private\n       */\n      this.lonLabelPosition_ =\n        options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;\n\n      /**\n       * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1\n       * means right.\n       * @type {number}\n       * @private\n       */\n      this.latLabelPosition_ =\n        options.latLabelPosition == undefined ? 1 : options.latLabelPosition;\n\n      /**\n       * @type {Style}\n       * @private\n       */\n      this.lonLabelStyleBase_ = new Style({\n        text:\n          options.lonLabelStyle !== undefined\n            ? options.lonLabelStyle.clone()\n            : new Text({\n                font: '12px Calibri,sans-serif',\n                textBaseline: 'bottom',\n                fill: new Fill({\n                  color: 'rgba(0,0,0,1)',\n                }),\n                stroke: new Stroke({\n                  color: 'rgba(255,255,255,1)',\n                  width: 3,\n                }),\n              }),\n      });\n\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n      this.lonLabelStyle_ = (feature) => {\n        const label = feature.get('graticule_label');\n        this.lonLabelStyleBase_.getText().setText(label);\n        return this.lonLabelStyleBase_;\n      };\n\n      /**\n       * @type {Style}\n       * @private\n       */\n      this.latLabelStyleBase_ = new Style({\n        text:\n          options.latLabelStyle !== undefined\n            ? options.latLabelStyle.clone()\n            : new Text({\n                font: '12px Calibri,sans-serif',\n                textAlign: 'right',\n                fill: new Fill({\n                  color: 'rgba(0,0,0,1)',\n                }),\n                stroke: new Stroke({\n                  color: 'rgba(255,255,255,1)',\n                  width: 3,\n                }),\n              }),\n      });\n\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n      this.latLabelStyle_ = (feature) => {\n        const label = feature.get('graticule_label');\n        this.latLabelStyleBase_.getText().setText(label);\n        return this.latLabelStyleBase_;\n      };\n\n      this.meridiansLabels_ = [];\n      this.parallelsLabels_ = [];\n\n      this.addEventListener(EventType.POSTRENDER, this.drawLabels_.bind(this));\n    }\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.intervals_ =\n      options.intervals !== undefined ? options.intervals : INTERVALS;\n\n    // use a source with a custom loader for lines & text\n    this.setSource(\n      new VectorSource({\n        loader: this.loaderFunction.bind(this),\n        strategy: this.strategyFunction.bind(this),\n        features: new Collection(),\n        overlaps: false,\n        useSpatialIndex: false,\n        wrapX: options.wrapX,\n      }),\n    );\n\n    /**\n     * feature pool to use when updating graticule\n     * @type {Array<Feature>}\n     * @private\n     */\n    this.featurePool_ = [];\n\n    /**\n     * @type {Style}\n     * @private\n     */\n    this.lineStyle_ = new Style({\n      stroke: this.strokeStyle_,\n    });\n\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.loadedExtent_ = null;\n\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.renderedResolution_ = null;\n\n    this.setRenderOrder(null);\n  }\n\n  /**\n   * Strategy function for loading features based on the view's extent and\n   * resolution.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array<import(\"../extent.js\").Extent>} Extents.\n   */\n  strategyFunction(extent, resolution) {\n    // extents may be passed in different worlds, to avoid endless loop we use only one\n    let realWorldExtent = extent.slice();\n    if (this.projection_ && this.getSource().getWrapX()) {\n      wrapExtentX(realWorldExtent, this.projection_);\n    }\n    if (this.loadedExtent_) {\n      if (\n        approximatelyEquals(this.loadedExtent_, realWorldExtent, resolution)\n      ) {\n        // make sure result is exactly equal to previous extent\n        realWorldExtent = this.loadedExtent_.slice();\n      } else {\n        // we should not keep track of loaded extents\n        this.getSource().removeLoadedExtent(this.loadedExtent_);\n      }\n    }\n    return [realWorldExtent];\n  }\n\n  /**\n   * Update geometries in the source based on current view\n   * @param {import(\"../extent\").Extent} extent Extent\n   * @param {number} resolution Resolution\n   * @param {import(\"../proj/Projection.js\").default} projection Projection\n   */\n  loaderFunction(extent, resolution, projection) {\n    this.loadedExtent_ = extent;\n    const source = this.getSource();\n\n    // only consider the intersection between our own extent & the requested one\n    const layerExtent = this.getExtent() || [\n      -Infinity,\n      -Infinity,\n      Infinity,\n      Infinity,\n    ];\n    const renderExtent = getIntersection(layerExtent, extent);\n\n    if (\n      this.renderedExtent_ &&\n      equals(this.renderedExtent_, renderExtent) &&\n      this.renderedResolution_ === resolution\n    ) {\n      return;\n    }\n    this.renderedExtent_ = renderExtent;\n    this.renderedResolution_ = resolution;\n\n    // bail out if nothing to render\n    if (isEmpty(renderExtent)) {\n      return;\n    }\n\n    // update projection info\n    const center = getCenter(renderExtent);\n    const squaredTolerance = (resolution * resolution) / 4;\n\n    const updateProjectionInfo =\n      !this.projection_ || !equivalentProjection(this.projection_, projection);\n\n    if (updateProjectionInfo) {\n      this.updateProjectionInfo_(projection);\n    }\n\n    this.createGraticule_(renderExtent, center, resolution, squaredTolerance);\n\n    // first make sure we have enough features in the pool\n    let featureCount = this.meridians_.length + this.parallels_.length;\n    if (this.meridiansLabels_) {\n      featureCount += this.meridians_.length;\n    }\n    if (this.parallelsLabels_) {\n      featureCount += this.parallels_.length;\n    }\n\n    let feature;\n    while (featureCount > this.featurePool_.length) {\n      feature = new Feature();\n      this.featurePool_.push(feature);\n    }\n\n    const featuresColl = source.getFeaturesCollection();\n    featuresColl.clear();\n    let poolIndex = 0;\n\n    // add features for the lines & labels\n    let i, l;\n    for (i = 0, l = this.meridians_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.meridians_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n    for (i = 0, l = this.parallels_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.parallels_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n  }\n\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n  addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, index) {\n    const lineString = this.getMeridian_(\n      lon,\n      minLat,\n      maxLat,\n      squaredTolerance,\n      index,\n    );\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.meridiansLabels_) {\n        const text = this.lonLabelFormatter_(lon);\n        if (index in this.meridiansLabels_) {\n          this.meridiansLabels_[index].text = text;\n        } else {\n          this.meridiansLabels_[index] = {\n            geom: new Point([]),\n            text: text,\n          };\n        }\n      }\n      this.meridians_[index++] = lineString;\n    }\n    return index;\n  }\n\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n  addParallel_(lat, minLon, maxLon, squaredTolerance, extent, index) {\n    const lineString = this.getParallel_(\n      lat,\n      minLon,\n      maxLon,\n      squaredTolerance,\n      index,\n    );\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.parallelsLabels_) {\n        const text = this.latLabelFormatter_(lat);\n        if (index in this.parallelsLabels_) {\n          this.parallelsLabels_[index].text = text;\n        } else {\n          this.parallelsLabels_[index] = {\n            geom: new Point([]),\n            text: text,\n          };\n        }\n      }\n      this.parallels_[index++] = lineString;\n    }\n    return index;\n  }\n\n  /**\n   * @param {import(\"../render/Event.js\").default} event Render event.\n   * @private\n   */\n  drawLabels_(event) {\n    const rotation = event.frameState.viewState.rotation;\n    const resolution = event.frameState.viewState.resolution;\n    const size = event.frameState.size;\n    const extent = event.frameState.extent;\n    const rotationCenter = getCenter(extent);\n    let rotationExtent = extent;\n    if (rotation) {\n      const unrotatedWidth = size[0] * resolution;\n      const unrotatedHeight = size[1] * resolution;\n      rotationExtent = [\n        rotationCenter[0] - unrotatedWidth / 2,\n        rotationCenter[1] - unrotatedHeight / 2,\n        rotationCenter[0] + unrotatedWidth / 2,\n        rotationCenter[1] + unrotatedHeight / 2,\n      ];\n    }\n\n    let startWorld = 0;\n    let endWorld = 0;\n    let labelsAtStart = this.latLabelPosition_ < 0.5;\n    const projectionExtent = this.projection_.getExtent();\n    const worldWidth = getWidth(projectionExtent);\n    if (\n      this.getSource().getWrapX() &&\n      this.projection_.canWrapX() &&\n      !containsExtent(projectionExtent, extent)\n    ) {\n      startWorld = Math.floor((extent[0] - projectionExtent[0]) / worldWidth);\n      endWorld = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth);\n      const inverted = Math.abs(rotation) > Math.PI / 2;\n      labelsAtStart = labelsAtStart !== inverted;\n    }\n    const vectorContext = getVectorContext(event);\n\n    for (let world = startWorld; world <= endWorld; ++world) {\n      let poolIndex = this.meridians_.length + this.parallels_.length;\n      let feature, index, l, textPoint;\n\n      if (this.meridiansLabels_) {\n        for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {\n          const lineString = this.meridians_[index];\n          if (!rotation && world === 0) {\n            textPoint = this.getMeridianPoint_(lineString, extent, index);\n          } else {\n            const clone = lineString.clone();\n            clone.translate(world * worldWidth, 0);\n            clone.rotate(-rotation, rotationCenter);\n            textPoint = this.getMeridianPoint_(clone, rotationExtent, index);\n            textPoint.rotate(rotation, rotationCenter);\n          }\n          feature = this.featurePool_[poolIndex++];\n          feature.setGeometry(textPoint);\n          feature.set('graticule_label', this.meridiansLabels_[index].text);\n          vectorContext.drawFeature(feature, this.lonLabelStyle_(feature));\n        }\n      }\n      if (this.parallelsLabels_) {\n        if (\n          (world === startWorld && labelsAtStart) ||\n          (world === endWorld && !labelsAtStart)\n        ) {\n          for (index = 0, l = this.parallels_.length; index < l; ++index) {\n            const lineString = this.parallels_[index];\n            if (!rotation && world === 0) {\n              textPoint = this.getParallelPoint_(lineString, extent, index);\n            } else {\n              const clone = lineString.clone();\n              clone.translate(world * worldWidth, 0);\n              clone.rotate(-rotation, rotationCenter);\n              textPoint = this.getParallelPoint_(clone, rotationExtent, index);\n              textPoint.rotate(rotation, rotationCenter);\n            }\n            feature = this.featurePool_[poolIndex++];\n            feature.setGeometry(textPoint);\n            feature.set('graticule_label', this.parallelsLabels_[index].text);\n            vectorContext.drawFeature(feature, this.latLabelStyle_(feature));\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @private\n   */\n  createGraticule_(extent, center, resolution, squaredTolerance) {\n    const interval = this.getInterval_(resolution);\n    if (interval == -1) {\n      this.meridians_.length = 0;\n      this.parallels_.length = 0;\n      if (this.meridiansLabels_) {\n        this.meridiansLabels_.length = 0;\n      }\n      if (this.parallelsLabels_) {\n        this.parallelsLabels_.length = 0;\n      }\n      return;\n    }\n\n    let wrapX = false;\n    const projectionExtent = this.projection_.getExtent();\n    const worldWidth = getWidth(projectionExtent);\n    if (\n      this.getSource().getWrapX() &&\n      this.projection_.canWrapX() &&\n      !containsExtent(projectionExtent, extent)\n    ) {\n      if (getWidth(extent) >= worldWidth) {\n        extent[0] = projectionExtent[0];\n        extent[2] = projectionExtent[2];\n      } else {\n        wrapX = true;\n      }\n    }\n\n    // Constrain the center to fit into the extent available to the graticule\n\n    const validCenterP = [\n      clamp(center[0], this.minX_, this.maxX_),\n      clamp(center[1], this.minY_, this.maxY_),\n    ];\n\n    // Transform the center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n\n    const centerLonLat = this.toLonLatTransform_(validCenterP);\n    if (isNaN(centerLonLat[1])) {\n      centerLonLat[1] =\n        Math.abs(this.maxLat_) >= Math.abs(this.minLat_)\n          ? this.maxLat_\n          : this.minLat_;\n    }\n    let centerLon = clamp(centerLonLat[0], this.minLon_, this.maxLon_);\n    let centerLat = clamp(centerLonLat[1], this.minLat_, this.maxLat_);\n    const maxLines = this.maxLines_;\n    let cnt, idx, lat, lon;\n\n    // Limit the extent to fit into the extent available to the graticule\n\n    let validExtentP = extent;\n    if (!wrapX) {\n      validExtentP = [\n        clamp(extent[0], this.minX_, this.maxX_),\n        clamp(extent[1], this.minY_, this.maxY_),\n        clamp(extent[2], this.minX_, this.maxX_),\n        clamp(extent[3], this.minY_, this.maxY_),\n      ];\n    }\n\n    // Transform the extent to get the lon lat ranges for the edges of the extent\n\n    const validExtent = applyTransform(\n      validExtentP,\n      this.toLonLatTransform_,\n      undefined,\n      8,\n    );\n\n    let maxLat = validExtent[3];\n    let maxLon = validExtent[2];\n    let minLat = validExtent[1];\n    let minLon = validExtent[0];\n\n    if (!wrapX) {\n      // Check if extremities of the world extent lie inside the extent\n      // (for example the pole in a polar projection)\n      // and extend the extent as appropriate\n\n      if (containsCoordinate(validExtentP, this.bottomLeft_)) {\n        minLon = this.minLon_;\n        minLat = this.minLat_;\n      }\n      if (containsCoordinate(validExtentP, this.bottomRight_)) {\n        maxLon = this.maxLon_;\n        minLat = this.minLat_;\n      }\n      if (containsCoordinate(validExtentP, this.topLeft_)) {\n        minLon = this.minLon_;\n        maxLat = this.maxLat_;\n      }\n      if (containsCoordinate(validExtentP, this.topRight_)) {\n        maxLon = this.maxLon_;\n        maxLat = this.maxLat_;\n      }\n\n      // The transformed center may also extend the lon lat ranges used for rendering\n\n      maxLat = clamp(maxLat, centerLat, this.maxLat_);\n      maxLon = clamp(maxLon, centerLon, this.maxLon_);\n      minLat = clamp(minLat, this.minLat_, centerLat);\n      minLon = clamp(minLon, this.minLon_, centerLon);\n    }\n\n    // Create meridians\n\n    centerLon = Math.floor(centerLon / interval) * interval;\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n\n    idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);\n\n    cnt = 0;\n    if (wrapX) {\n      while ((lon -= interval) >= minLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(\n          lon,\n          minLat,\n          maxLat,\n          squaredTolerance,\n          extent,\n          idx,\n        );\n      }\n    } else {\n      while (lon != this.minLon_ && cnt++ < maxLines) {\n        lon = Math.max(lon - interval, this.minLon_);\n        idx = this.addMeridian_(\n          lon,\n          minLat,\n          maxLat,\n          squaredTolerance,\n          extent,\n          idx,\n        );\n      }\n    }\n\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n\n    cnt = 0;\n    if (wrapX) {\n      while ((lon += interval) <= maxLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(\n          lon,\n          minLat,\n          maxLat,\n          squaredTolerance,\n          extent,\n          idx,\n        );\n      }\n    } else {\n      while (lon != this.maxLon_ && cnt++ < maxLines) {\n        lon = Math.min(lon + interval, this.maxLon_);\n        idx = this.addMeridian_(\n          lon,\n          minLat,\n          maxLat,\n          squaredTolerance,\n          extent,\n          idx,\n        );\n      }\n    }\n\n    this.meridians_.length = idx;\n    if (this.meridiansLabels_) {\n      this.meridiansLabels_.length = idx;\n    }\n\n    // Create parallels\n\n    centerLat = Math.floor(centerLat / interval) * interval;\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n\n    idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);\n\n    cnt = 0;\n    while (lat != this.minLat_ && cnt++ < maxLines) {\n      lat = Math.max(lat - interval, this.minLat_);\n      idx = this.addParallel_(\n        lat,\n        minLon,\n        maxLon,\n        squaredTolerance,\n        extent,\n        idx,\n      );\n    }\n\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n\n    cnt = 0;\n    while (lat != this.maxLat_ && cnt++ < maxLines) {\n      lat = Math.min(lat + interval, this.maxLat_);\n      idx = this.addParallel_(\n        lat,\n        minLon,\n        maxLon,\n        squaredTolerance,\n        extent,\n        idx,\n      );\n    }\n\n    this.parallels_.length = idx;\n    if (this.parallelsLabels_) {\n      this.parallelsLabels_.length = idx;\n    }\n  }\n\n  /**\n   * @param {number} resolution Resolution.\n   * @return {number} The interval in degrees.\n   * @private\n   */\n  getInterval_(resolution) {\n    const centerLon = this.projectionCenterLonLat_[0];\n    const centerLat = this.projectionCenterLonLat_[1];\n    let interval = -1;\n    const target = Math.pow(this.targetSize_ * resolution, 2);\n    /** @type {Array<number>} **/\n    const p1 = [];\n    /** @type {Array<number>} **/\n    const p2 = [];\n    for (let i = 0, ii = this.intervals_.length; i < ii; ++i) {\n      const delta = clamp(this.intervals_[i] / 2, 0, 90);\n      // Don't attempt to transform latitudes beyond the poles!\n      const clampedLat = clamp(centerLat, -90 + delta, 90 - delta);\n      p1[0] = centerLon - delta;\n      p1[1] = clampedLat - delta;\n      p2[0] = centerLon + delta;\n      p2[1] = clampedLat + delta;\n      this.fromLonLatTransform_(p1, p1);\n      this.fromLonLatTransform_(p2, p2);\n      const dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);\n      if (dist <= target) {\n        break;\n      }\n      interval = this.intervals_[i];\n    }\n    return interval;\n  }\n\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The meridian line string.\n   * @param {number} index Index.\n   * @private\n   */\n  getMeridian_(lon, minLat, maxLat, squaredTolerance, index) {\n    const flatCoordinates = meridian(\n      lon,\n      minLat,\n      maxLat,\n      this.projection_,\n      squaredTolerance,\n    );\n    let lineString = this.meridians_[index];\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, 'XY');\n      this.meridians_[index] = lineString;\n    } else {\n      lineString.setFlatCoordinates('XY', flatCoordinates);\n      lineString.changed();\n    }\n    return lineString;\n  }\n\n  /**\n   * @param {LineString} lineString Meridian\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Meridian point.\n   * @private\n   */\n  getMeridianPoint_(lineString, extent, index) {\n    const flatCoordinates = lineString.getFlatCoordinates();\n    let bottom = 1;\n    let top = flatCoordinates.length - 1;\n    if (flatCoordinates[bottom] > flatCoordinates[top]) {\n      bottom = top;\n      top = 1;\n    }\n    const clampedBottom = Math.max(extent[1], flatCoordinates[bottom]);\n    const clampedTop = Math.min(extent[3], flatCoordinates[top]);\n    const lat = clamp(\n      extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_,\n      clampedBottom,\n      clampedTop,\n    );\n    const coordinate0 =\n      flatCoordinates[bottom - 1] +\n      ((flatCoordinates[top - 1] - flatCoordinates[bottom - 1]) *\n        (lat - flatCoordinates[bottom])) /\n        (flatCoordinates[top] - flatCoordinates[bottom]);\n    const coordinate = [coordinate0, lat];\n    const point = this.meridiansLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  }\n\n  /**\n   * Get the list of meridians.  Meridians are lines of equal longitude.\n   * @return {Array<LineString>} The meridians.\n   * @api\n   */\n  getMeridians() {\n    return this.meridians_;\n  }\n\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The parallel line string.\n   * @param {number} index Index.\n   * @private\n   */\n  getParallel_(lat, minLon, maxLon, squaredTolerance, index) {\n    const flatCoordinates = parallel(\n      lat,\n      minLon,\n      maxLon,\n      this.projection_,\n      squaredTolerance,\n    );\n    let lineString = this.parallels_[index];\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, 'XY');\n    } else {\n      lineString.setFlatCoordinates('XY', flatCoordinates);\n      lineString.changed();\n    }\n    return lineString;\n  }\n\n  /**\n   * @param {LineString} lineString Parallels.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Parallel point.\n   * @private\n   */\n  getParallelPoint_(lineString, extent, index) {\n    const flatCoordinates = lineString.getFlatCoordinates();\n    let left = 0;\n    let right = flatCoordinates.length - 2;\n    if (flatCoordinates[left] > flatCoordinates[right]) {\n      left = right;\n      right = 0;\n    }\n    const clampedLeft = Math.max(extent[0], flatCoordinates[left]);\n    const clampedRight = Math.min(extent[2], flatCoordinates[right]);\n    const lon = clamp(\n      extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_,\n      clampedLeft,\n      clampedRight,\n    );\n    const coordinate1 =\n      flatCoordinates[left + 1] +\n      ((flatCoordinates[right + 1] - flatCoordinates[left + 1]) *\n        (lon - flatCoordinates[left])) /\n        (flatCoordinates[right] - flatCoordinates[left]);\n    const coordinate = [lon, coordinate1];\n    const point = this.parallelsLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  }\n\n  /**\n   * Get the list of parallels.  Parallels are lines of equal latitude.\n   * @return {Array<LineString>} The parallels.\n   * @api\n   */\n  getParallels() {\n    return this.parallels_;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateProjectionInfo_(projection) {\n    const epsg4326Projection = getProjection('EPSG:4326');\n\n    const worldExtent = projection.getWorldExtent();\n\n    this.maxLat_ = worldExtent[3];\n    this.maxLon_ = worldExtent[2];\n    this.minLat_ = worldExtent[1];\n    this.minLon_ = worldExtent[0];\n\n    // If the world extent crosses the dateline define a custom transform to\n    // return longitudes which wrap the dateline\n\n    const toLonLatTransform = getTransform(projection, epsg4326Projection);\n    if (this.minLon_ < this.maxLon_) {\n      this.toLonLatTransform_ = toLonLatTransform;\n    } else {\n      const split = this.minLon_ + this.maxLon_ / 2;\n      this.maxLon_ += 360;\n      this.toLonLatTransform_ = function (coordinates, output, dimension) {\n        dimension = dimension || 2;\n        const lonLatCoordinates = toLonLatTransform(\n          coordinates,\n          output,\n          dimension,\n        );\n        for (let i = 0, l = lonLatCoordinates.length; i < l; i += dimension) {\n          if (lonLatCoordinates[i] < split) {\n            lonLatCoordinates[i] += 360;\n          }\n        }\n        return lonLatCoordinates;\n      };\n    }\n\n    // Transform the extent to get the limits of the view projection extent\n    // which should be available to the graticule\n\n    this.fromLonLatTransform_ = getTransform(epsg4326Projection, projection);\n    const worldExtentP = applyTransform(\n      [this.minLon_, this.minLat_, this.maxLon_, this.maxLat_],\n      this.fromLonLatTransform_,\n      undefined,\n      8,\n    );\n\n    this.minX_ = worldExtentP[0];\n    this.maxX_ = worldExtentP[2];\n    this.minY_ = worldExtentP[1];\n    this.maxY_ = worldExtentP[3];\n\n    // Determine the view projection coordinates of the extremities of the world extent\n    // as these may lie inside a view extent (for example the pole in a polar projection)\n\n    this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);\n    this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);\n    this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);\n    this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]);\n\n    // Transform the projection center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n\n    this.projectionCenterLonLat_ = this.toLonLatTransform_(\n      getCenter(projection.getExtent()),\n    );\n    if (isNaN(this.projectionCenterLonLat_[1])) {\n      this.projectionCenterLonLat_[1] =\n        Math.abs(this.maxLat_) >= Math.abs(this.minLat_)\n          ? this.maxLat_\n          : this.minLat_;\n    }\n\n    this.projection_ = projection;\n  }\n}\n\nexport default Graticule;\n"],"names":["line","interpolate","transform","squaredTolerance","flatCoordinates","geoA","geoB","a","b","geoStack","stack","fractionStack","fractions","geoM","m","fracA","fracB","fracM","key","maxIterations","length","pop","toString","push","meridian","lon","lat1","lat2","projection","epsg4326Projection","frac","parallel","lat","lon1","lon2","getVectorContext","event","context","CanvasRenderingContext2D","Error","inversePixelTransform","canvasPixelRatio","Math","sqrt","frameState","slice","coordinateToPixelTransform","viewState","resolution","userTransform","userProjection","extent","rotation","DEFAULT_STROKE_STYLE","Stroke","color","INTERVALS","Graticule","constructor","options","baseOptions","Object","assign","updateWhileAnimating","updateWhileInteracting","renderBuffer","maxLines","strokeStyle","targetSize","showLabels","lonLabelFormatter","latLabelFormatter","lonLabelPosition","latLabelPosition","lonLabelStyle","latLabelStyle","intervals","super","this","projection_","maxLat_","Infinity","maxLon_","minLat_","minLon_","maxX_","maxY_","minX_","minY_","targetSize_","undefined","maxLines_","meridians_","parallels_","strokeStyle_","fromLonLatTransform_","toLonLatTransform_","projectionCenterLonLat_","bottomLeft_","bottomRight_","topLeft_","topRight_","meridiansLabels_","parallelsLabels_","lonLabelFormatter_","bind","latLabelFormatter_","lonLabelPosition_","latLabelPosition_","lonLabelStyleBase_","Style","text","clone","Text","font","textBaseline","fill","Fill","stroke","width","lonLabelStyle_","feature","label","get","getText","setText","latLabelStyleBase_","textAlign","latLabelStyle_","addEventListener","EventType","POSTRENDER","drawLabels_","intervals_","setSource","Vector","loader","loaderFunction","strategy","strategyFunction","features","Collection","overlaps","useSpatialIndex","wrapX","featurePool_","lineStyle_","loadedExtent_","renderedExtent_","renderedResolution_","setRenderOrder","realWorldExtent","getSource","getWrapX","removeLoadedExtent","source","layerExtent","getExtent","renderExtent","center","updateProjectionInfo","updateProjectionInfo_","createGraticule_","featureCount","Feature","featuresColl","getFeaturesCollection","clear","i","l","poolIndex","setGeometry","setStyle","addMeridian_","minLat","maxLat","index","lineString","getMeridian_","geom","Point","addParallel_","minLon","maxLon","getParallel_","size","rotationCenter","rotationExtent","unrotatedWidth","unrotatedHeight","startWorld","endWorld","labelsAtStart","projectionExtent","worldWidth","canWrapX","floor","ceil","inverted","abs","PI","vectorContext","world","textPoint","translate","rotate","getMeridianPoint_","set","drawFeature","getParallelPoint_","interval","getInterval_","validCenterP","centerLonLat","isNaN","centerLon","centerLat","cnt","idx","validExtentP","validExtent","max","min","target","pow","p1","p2","ii","delta","clampedLat","dist","setFlatCoordinates","changed","LineString","getFlatCoordinates","bottom","top","clampedBottom","clampedTop","coordinate0","coordinate","point","setCoordinates","getMeridians","left","right","clampedLeft","clampedRight","coordinate1","getParallels","worldExtent","getWorldExtent","toLonLatTransform","split","coordinates","output","dimension","lonLatCoordinates","worldExtentP"],"sourceRoot":""}