{"version":3,"file":"js/7936.44299638.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/Tile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/net.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/UTFGrid.js","webpack://@radiantearth/stac-browser/./node_modules/ol/structs/LRUCache.js"],"sourcesContent":["/**\n * @module ol/Tile\n */\nimport TileState from './TileState.js';\nimport {easeIn} from './easing.js';\nimport EventType from './events/EventType.js';\nimport EventTarget from './events/Target.js';\nimport {abstract} from './util.js';\n\n/**\n * A function that takes a {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState.js';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   const xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     const data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes a {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * A key assigned to the tile. This is used in conjunction with a source key\n     * to determine if a cached version of this tile may be used by the renderer.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @private\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n\n    /**\n     * @type {boolean}\n     */\n    this.interpolate = !!options.interpolate;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {\n    // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`\n    this.setState(TileState.EMPTY);\n  }\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state === TileState.EMPTY) {\n      // no more state changes\n      return;\n    }\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    this.release();\n    super.disposeInternal();\n  }\n}\n\nexport default Tile;\n","/**\n * @module ol/net\n */\nimport {getUid} from './util.js';\n\n/**\n * Simple JSONP helper. Supports error callbacks and a custom callback param.\n * The error callback will be called when no JSONP is executed after 10 seconds.\n *\n * @param {string} url Request url. A 'callback' query parameter will be\n *     appended.\n * @param {Function} callback Callback on success.\n * @param {Function} [errback] Callback on error.\n * @param {string} [callbackParam] Custom query parameter for the JSONP\n *     callback. Default is 'callback'.\n */\nexport function jsonp(url, callback, errback, callbackParam) {\n  const script = document.createElement('script');\n  const key = 'olc_' + getUid(callback);\n  function cleanup() {\n    delete window[key];\n    script.parentNode.removeChild(script);\n  }\n  script.async = true;\n  script.src =\n    url +\n    (url.includes('?') ? '&' : '?') +\n    (callbackParam || 'callback') +\n    '=' +\n    key;\n  const timer = setTimeout(function () {\n    cleanup();\n    if (errback) {\n      errback();\n    }\n  }, 10000);\n  window[key] = function (data) {\n    clearTimeout(timer);\n    cleanup();\n    callback(data);\n  };\n  document.head.appendChild(script);\n}\n\nexport class ResponseError extends Error {\n  /**\n   * @param {XMLHttpRequest} response The XHR object.\n   */\n  constructor(response) {\n    const message = 'Unexpected response status: ' + response.status;\n    super(message);\n\n    /**\n     * @type {string}\n     */\n    this.name = 'ResponseError';\n\n    /**\n     * @type {XMLHttpRequest}\n     */\n    this.response = response;\n  }\n}\n\nexport class ClientError extends Error {\n  /**\n   * @param {XMLHttpRequest} client The XHR object.\n   */\n  constructor(client) {\n    super('Failed to issue request');\n\n    /**\n     * @type {string}\n     */\n    this.name = 'ClientError';\n\n    /**\n     * @type {XMLHttpRequest}\n     */\n    this.client = client;\n  }\n}\n\n/**\n * @param {string} url The URL.\n * @return {Promise<Object>} A promise that resolves to the JSON response.\n */\nexport function getJSON(url) {\n  return new Promise(function (resolve, reject) {\n    /**\n     * @param {ProgressEvent<XMLHttpRequest>} event The load event.\n     */\n    function onLoad(event) {\n      const client = event.target;\n      // status will be 0 for file:// urls\n      if (!client.status || (client.status >= 200 && client.status < 300)) {\n        let data;\n        try {\n          data = JSON.parse(client.responseText);\n        } catch (err) {\n          const message = 'Error parsing response text as JSON: ' + err.message;\n          reject(new Error(message));\n          return;\n        }\n        resolve(data);\n        return;\n      }\n\n      reject(new ResponseError(client));\n    }\n\n    /**\n     * @param {ProgressEvent<XMLHttpRequest>} event The error event.\n     */\n    function onError(event) {\n      reject(new ClientError(event.target));\n    }\n\n    const client = new XMLHttpRequest();\n    client.addEventListener('load', onLoad);\n    client.addEventListener('error', onError);\n    client.open('GET', url);\n    client.setRequestHeader('Accept', 'application/json');\n    client.send();\n  });\n}\n\n/**\n * @param {string} base The base URL.\n * @param {string} url The potentially relative URL.\n * @return {string} The full URL.\n */\nexport function resolveUrl(base, url) {\n  if (url.includes('://')) {\n    return url;\n  }\n  return new URL(url, base).href;\n}\n\nlet originalXHR;\nexport function overrideXHR(xhr) {\n  if (typeof XMLHttpRequest !== 'undefined') {\n    originalXHR = XMLHttpRequest;\n  }\n  global.XMLHttpRequest = xhr;\n}\n\nexport function restoreXHR() {\n  global.XMLHttpRequest = originalXHR;\n}\n","/**\n * @module ol/source/UTFGrid\n */\n\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport EventType from '../events/EventType.js';\nimport {listenOnce} from '../events.js';\nimport {applyTransform, intersects} from '../extent.js';\nimport {jsonp as requestJSONP} from '../net.js';\nimport {get as getProjection, getTransformFromProjections} from '../proj.js';\nimport LRUCache from '../structs/LRUCache.js';\nimport {getKeyZXY} from '../tilecoord.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\nimport {createFromTemplates, nullTileUrlFunction} from '../tileurlfunction.js';\nimport TileSource from './Tile.js';\n\n/**\n * @typedef {Object} UTFGridJSON\n * @property {Array<string>} grid The grid.\n * @property {Array<string>} keys The keys.\n * @property {Object<string, Object>} [data] Optional data.\n */\n\nexport class CustomTile extends Tile {\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {import(\"../extent.js\").Extent} extent Extent of the tile.\n   * @param {boolean} preemptive Load the tile when visible (before it's needed).\n   * @param {boolean} jsonp Load the tile as a script.\n   */\n  constructor(tileCoord, state, src, extent, preemptive, jsonp) {\n    super(tileCoord, state);\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = extent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ = preemptive;\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.grid_ = null;\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.keys_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, Object>|undefined}\n     */\n    this.data_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = jsonp;\n  }\n\n  /**\n   * Get the image element for this tile.\n   * @return {HTMLImageElement} Image.\n   */\n  getImage() {\n    return null;\n  }\n\n  /**\n   * Synchronously returns data at given coordinate (if available).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {*} The data.\n   */\n  getData(coordinate) {\n    if (!this.grid_ || !this.keys_) {\n      return null;\n    }\n    const xRelative =\n      (coordinate[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]);\n    const yRelative =\n      (coordinate[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]);\n\n    const row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];\n\n    if (typeof row !== 'string') {\n      return null;\n    }\n\n    let code = row.charCodeAt(Math.floor(xRelative * row.length));\n    if (code >= 93) {\n      code--;\n    }\n    if (code >= 35) {\n      code--;\n    }\n    code -= 32;\n\n    let data = null;\n    if (code in this.keys_) {\n      const id = this.keys_[code];\n      if (this.data_ && id in this.data_) {\n        data = this.data_[id];\n      } else {\n        data = id;\n      }\n    }\n    return data;\n  }\n\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate (or `null` if not yet loaded).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean} [request] If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   */\n  forDataAtCoordinate(coordinate, callback, request) {\n    if (this.state == TileState.EMPTY && request === true) {\n      this.state = TileState.IDLE;\n      listenOnce(this, EventType.CHANGE, (e) => {\n        callback(this.getData(coordinate));\n      });\n      this.loadInternal_();\n    } else {\n      if (request === true) {\n        setTimeout(() => {\n          callback(this.getData(coordinate));\n        }, 0);\n      } else {\n        callback(this.getData(coordinate));\n      }\n    }\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   * @override\n   */\n  getKey() {\n    return this.src_;\n  }\n\n  /**\n   * @private\n   */\n  handleError_() {\n    this.state = TileState.ERROR;\n    this.changed();\n  }\n\n  /**\n   * @param {!UTFGridJSON} json UTFGrid data.\n   * @private\n   */\n  handleLoad_(json) {\n    this.grid_ = json['grid'];\n    this.keys_ = json['keys'];\n    this.data_ = json['data'];\n\n    this.state = TileState.LOADED;\n    this.changed();\n  }\n\n  /**\n   * @private\n   */\n  loadInternal_() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      if (this.jsonp_) {\n        requestJSONP(\n          this.src_,\n          this.handleLoad_.bind(this),\n          this.handleError_.bind(this),\n        );\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', this.src_);\n        client.send();\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {!UTFGridJSON} */ (\n          JSON.parse(client.responseText)\n        );\n      } catch {\n        this.handleError_();\n        return;\n      }\n      this.handleLoad_(response);\n    } else {\n      this.handleError_();\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleError_();\n  }\n\n  /**\n   * @override\n   */\n  load() {\n    if (this.preemptive_) {\n      this.loadInternal_();\n    } else {\n      this.setState(TileState.EMPTY);\n    }\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [preemptive=true]\n * If `true` the UTFGrid source loads the tiles based on their \"visibility\".\n * This improves the speed of response, but increases traffic.\n * Note that if set to `false` (lazy loading), you need to pass `true` as\n * `request` to the `forDataAtCoordinateAndResolution` method otherwise no\n * data will ever be loaded.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {import(\"./TileJSON.js\").Config} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {string} [url] TileJSON endpoint that provides the configuration for this source.\n * Request will be made through JSONP. If not provided, `tileJSON` must be configured.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for UTFGrid interaction data loaded from TileJSON format.\n * @api\n */\nclass UTFGrid extends TileSource {\n  /**\n   * @param {Options} options Source options.\n   */\n  constructor(options) {\n    super({\n      projection: getProjection('EPSG:3857'),\n      state: 'loading',\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ =\n      options.preemptive !== undefined ? options.preemptive : true;\n\n    /**\n     * @private\n     * @type {!import(\"../Tile.js\").UrlFunction}\n     */\n    this.tileUrlFunction_ = nullTileUrlFunction;\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.template_ = undefined;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = options.jsonp || false;\n\n    /**\n     * @private\n     * @type {LRUCache}\n     */\n    this.tileCache_ = new LRUCache(512);\n\n    if (options.url) {\n      if (this.jsonp_) {\n        requestJSONP(\n          options.url,\n          this.handleTileJSONResponse.bind(this),\n          this.handleTileJSONError.bind(this),\n        );\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', options.url);\n        client.send();\n      }\n    } else if (options.tileJSON) {\n      this.handleTileJSONResponse(options.tileJSON);\n    } else {\n      throw new Error('Either `url` or `tileJSON` options must be provided');\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {import(\"./TileJSON.js\").Config} */ (\n          JSON.parse(client.responseText)\n        );\n      } catch {\n        this.handleTileJSONError();\n        return;\n      }\n      this.handleTileJSONResponse(response);\n    } else {\n      this.handleTileJSONError();\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleTileJSONError();\n  }\n\n  /**\n   * Return the template from TileJSON.\n   * @return {string|undefined} The template from TileJSON.\n   * @api\n   */\n  getTemplate() {\n    return this.template_;\n  }\n\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate and resolution (or `null` if not yet loaded or\n   * in case of an error).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean} [request] If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   * @api\n   */\n  forDataAtCoordinateAndResolution(coordinate, resolution, callback, request) {\n    if (this.tileGrid) {\n      const z = this.tileGrid.getZForResolution(resolution, this.zDirection);\n      const tileCoord = this.tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = /** @type {!CustomTile} */ (\n        this.getTile(\n          tileCoord[0],\n          tileCoord[1],\n          tileCoord[2],\n          1,\n          this.getProjection(),\n        )\n      );\n      if (tile.getState() == TileState.IDLE) {\n        tile.load();\n      }\n      tile.forDataAtCoordinate(coordinate, callback, request);\n    } else {\n      if (request === true) {\n        setTimeout(function () {\n          callback(null);\n        }, 0);\n      } else {\n        callback(null);\n      }\n    }\n  }\n\n  /**\n   * @protected\n   */\n  handleTileJSONError() {\n    this.setState('error');\n  }\n\n  /**\n   * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse\n   * @protected\n   * @param {import(\"./TileJSON.js\").Config} tileJSON Tile JSON.\n   */\n  handleTileJSONResponse(tileJSON) {\n    const epsg4326Projection = getProjection('EPSG:4326');\n\n    const sourceProjection = this.getProjection();\n    let extent;\n    if (tileJSON['bounds'] !== undefined) {\n      const transform = getTransformFromProjections(\n        epsg4326Projection,\n        sourceProjection,\n      );\n      extent = applyTransform(tileJSON['bounds'], transform);\n    }\n\n    const gridExtent = extentFromProjection(sourceProjection);\n    const minZoom = tileJSON['minzoom'] || 0;\n    const maxZoom = tileJSON['maxzoom'] || 22;\n    const tileGrid = createXYZ({\n      extent: gridExtent,\n      maxZoom: maxZoom,\n      minZoom: minZoom,\n    });\n    this.tileGrid = tileGrid;\n\n    this.template_ = tileJSON['template'];\n\n    const grids = tileJSON['grids'];\n    if (!grids) {\n      this.setState('error');\n      return;\n    }\n\n    this.tileUrlFunction_ = createFromTemplates(grids, tileGrid);\n\n    if (tileJSON['attribution']) {\n      const attributionExtent = extent !== undefined ? extent : gridExtent;\n      this.setAttributions(function (frameState) {\n        if (intersects(attributionExtent, frameState.extent)) {\n          return [tileJSON['attribution']];\n        }\n        return null;\n      });\n    }\n\n    this.setState('ready');\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!CustomTile} Tile.\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tileCoord = [z, x, y];\n    const urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection,\n    );\n    const tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);\n    const tileKey = `${this.getKey()},${getKeyZXY(z, x, y)}`;\n    if (this.tileCache_.containsKey(tileKey)) {\n      return this.tileCache_.get(tileKey);\n    }\n    this.tileCache_.expireCache();\n    const tile = new CustomTile(\n      tileCoord,\n      tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\n      tileUrl !== undefined ? tileUrl : '',\n      this.tileGrid.getTileCoordExtent(tileCoord),\n      this.preemptive_,\n      this.jsonp_,\n    );\n    this.tileCache_.set(tileKey, tile);\n    return tile;\n  }\n}\n\nexport default UTFGrid;\n","/**\n * @module ol/structs/LRUCache\n */\n\nimport Disposable from '../Disposable.js';\nimport {assert} from '../asserts.js';\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Entry|null} newer Newer.\n * @property {Entry|null} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nclass LRUCache {\n  /**\n   * @param {number} [highWaterMark] High water mark.\n   */\n  constructor(highWaterMark) {\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n\n  deleteOldest() {\n    const entry = this.pop();\n    if (entry instanceof Disposable) {\n      entry.dispose();\n    }\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  }\n\n  /**\n   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},\n   * the entry will be disposed.\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n   */\n  expireCache(keep) {\n    while (this.canExpireCache()) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    while (this.oldest_) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  }\n\n  /**\n   * @param {function(T, string, LRUCache<T>): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   */\n  forEach(f) {\n    let entry = this.oldest_;\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {*} [options] Options (reserved for subclasses).\n   * @return {T} Value.\n   */\n  get(key, options) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      return entry.value_;\n    }\n    if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  }\n\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  remove(key) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {Entry} */ (entry.older);\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.count_;\n  }\n\n  /**\n   * @return {Array<string>} Keys.\n   */\n  getKeys() {\n    const keys = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  }\n\n  /**\n   * @return {Array<T>} Values.\n   */\n  getValues() {\n    const values = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  }\n\n  /**\n   * @return {T} Last value.\n   */\n  peekLast() {\n    return this.oldest_.value_;\n  }\n\n  /**\n   * @return {string} Last key.\n   */\n  peekLastKey() {\n    return this.oldest_.key_;\n  }\n\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  peekFirstKey() {\n    return this.newest_.key_;\n  }\n\n  /**\n   * Return an entry without updating least recently used time.\n   * @param {string} key Key.\n   * @return {T|undefined} Value.\n   */\n  peek(key) {\n    return this.entries_[key]?.value_;\n  }\n\n  /**\n   * @return {T} value Value.\n   */\n  pop() {\n    const entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  replace(key, value) {\n    this.get(key); // update `newest_`\n    this.entries_[key].value_ = value;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  set(key, value) {\n    assert(\n      !(key in this.entries_),\n      'Tried to set a value for a key that is used already',\n    );\n    const entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value,\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  }\n\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n  setSize(size) {\n    this.highWaterMark = size;\n  }\n}\n\nexport default LRUCache;\n"],"names":["Tile","constructor","tileCoord","state","options","super","this","key","transition_","undefined","transition","transitionStarts_","interpolate","changed","dispatchEvent","CHANGE","release","setState","EMPTY","getKey","getTileCoord","getState","ERROR","Error","load","getAlpha","id","time","start","delta","inTransition","endTransition","disposeInternal","jsonp","url","callback","errback","callbackParam","script","document","createElement","cleanup","window","parentNode","removeChild","async","src","includes","timer","setTimeout","data","clearTimeout","head","appendChild","ResponseError","response","message","status","name","ClientError","client","getJSON","Promise","resolve","reject","onLoad","event","target","JSON","parse","responseText","err","onError","XMLHttpRequest","addEventListener","open","setRequestHeader","send","resolveUrl","base","URL","href","CustomTile","extent","preemptive","src_","extent_","preemptive_","grid_","keys_","data_","jsonp_","getImage","getData","coordinate","xRelative","yRelative","row","Math","floor","length","code","charCodeAt","forDataAtCoordinate","request","IDLE","e","loadInternal_","handleError_","handleLoad_","json","LOADED","LOADING","bind","onXHRLoad_","onXHRError_","UTFGrid","projection","wrapX","zDirection","tileUrlFunction_","template_","tileCache_","handleTileJSONResponse","handleTileJSONError","tileJSON","getTemplate","forDataAtCoordinateAndResolution","resolution","tileGrid","z","getZForResolution","getTileCoordForCoordAndZ","tile","getTile","getProjection","epsg4326Projection","sourceProjection","transform","gridExtent","minZoom","maxZoom","grids","attributionExtent","setAttributions","frameState","x","y","pixelRatio","urlTileCoord","getTileCoordForTileUrlFunction","tileUrl","tileKey","containsKey","get","expireCache","getTileCoordExtent","set","LRUCache","highWaterMark","count_","entries_","oldest_","newest_","deleteOldest","entry","pop","dispose","canExpireCache","getCount","keep","clear","hasOwnProperty","forEach","f","value_","key_","newer","older","remove","getKeys","keys","Array","i","getValues","values","peekLast","peekLastKey","peekFirstKey","peek","replace","value","setSize","size"],"sourceRoot":""}