{"version":3,"file":"js/8843.5478d763.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/ImageTile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/Tile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/reproj/Tile.js"],"sourcesContent":["/**\n * @module ol/ImageTile\n */\nimport {listenImage} from './Image.js';\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\n    super(tileCoord, state, options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n   */\n  setImage(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   *\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\n   * that checks for error status codes and reloads only when the status code is\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\n   * made already:\n   *\n   * ```js\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\n   * const retries = {};\n   * source.setTileLoadFunction((tile, src) => {\n   *   const image = tile.getImage();\n   *   fetch(src)\n   *     .then((response) => {\n   *       if (retryCodes.includes(response.status)) {\n   *         retries[src] = (retries[src] || 0) + 1;\n   *         if (retries[src] <= 3) {\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\n   *         }\n   *         return Promise.reject();\n   *       }\n   *       return response.blob();\n   *     })\n   *     .then((blob) => {\n   *       const imageUrl = URL.createObjectURL(blob);\n   *       image.src = imageUrl;\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\n   *     })\n   *     .catch(() => tile.setState(3)); // error\n   * });\n   * ```\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(\n        this.image_,\n        this.handleImageLoad_.bind(this),\n        this.handleImageError_.bind(this),\n      );\n    }\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    this.unlistenImage_();\n    this.image_ = null;\n    super.disposeInternal();\n  }\n}\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n","/**\n * @module ol/Tile\n */\nimport TileState from './TileState.js';\nimport {easeIn} from './easing.js';\nimport EventType from './events/EventType.js';\nimport EventTarget from './events/Target.js';\nimport {abstract} from './util.js';\n\n/**\n * A function that takes a {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState.js';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   const xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     const data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes a {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * A key assigned to the tile. This is used in conjunction with a source key\n     * to determine if a cached version of this tile may be used by the renderer.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @private\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n\n    /**\n     * @type {boolean}\n     */\n    this.interpolate = !!options.interpolate;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {\n    // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`\n    this.setState(TileState.EMPTY);\n  }\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state === TileState.EMPTY) {\n      // no more state changes\n      return;\n    }\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    this.release();\n    super.disposeInternal();\n  }\n}\n\nexport default Tile;\n","/**\n * @module ol/reproj/Tile\n */\n\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport {releaseCanvas} from '../dom.js';\nimport EventType from '../events/EventType.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport Triangulation from './Triangulation.js';\nimport {ERROR_THRESHOLD} from './common.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {import(\"../ImageTile.js\").default} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    options,\n  ) {\n    super(tileCoord, TileState.IDLE, options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceProj.getExtent()\n      : undefined;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (tile && tile.getState() == TileState.LOADED) {\n        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n        extent[0] += source.offset;\n        extent[2] += source.offset;\n        const clipExtent = this.clipExtent_?.slice();\n        if (clipExtent) {\n          clipExtent[0] += source.offset;\n          clipExtent[2] += source.offset;\n        }\n        sources.push({\n          extent: extent,\n          clipExtent: clipExtent,\n          image: tile.getImage(),\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_,\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_,\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate,\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(({tile}) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = listen(tile, EventType.CHANGE, (e) => {\n            const state = tile.getState();\n            if (\n              state == TileState.LOADED ||\n              state == TileState.ERROR ||\n              state == TileState.EMPTY\n            ) {\n              unlistenByKey(sourceListenKey);\n              leftToLoad--;\n              if (leftToLoad === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          });\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function ({tile}, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   * @override\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\nexport default ReprojTile;\n"],"names":["ImageTile","constructor","tileCoord","state","src","crossOrigin","tileLoadFunction","options","super","this","crossOrigin_","src_","key","image_","Image","unlisten_","tileLoadFunction_","getImage","setImage","element","LOADED","unlistenImage_","changed","handleImageError_","ERROR","getBlankImage","handleImageLoad_","image","naturalWidth","naturalHeight","EMPTY","load","IDLE","LOADING","bind","disposeInternal","ctx","fillStyle","fillRect","canvas","Tile","transition_","undefined","transition","transitionStarts_","interpolate","dispatchEvent","CHANGE","release","setState","getKey","getTileCoord","getState","Error","getAlpha","id","time","start","delta","inTransition","endTransition","ReprojTile","sourceProj","sourceTileGrid","targetProj","targetTileGrid","wrappedTileCoord","pixelRatio","gutter","getTileFunction","errorThreshold","renderEdges","renderEdges_","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","clipExtent_","canWrapX","getExtent","targetExtent","getTileCoordExtent","maxTargetExtent","maxSourceExtent","limitedTargetExtent","sourceProjExtent","targetResolution","getResolution","sourceResolution","isFinite","errorThresholdInPixels","triangulation_","getTriangles","length","getZForResolution","sourceExtent","calculateSourceExtent","worldWidth","worldsAway","Math","floor","sourceExtents","slice","forEach","extent","sourceRange","getTileRangeForExtentAndZ","srcX","minX","maxX","srcY","minY","maxY","tile","offset","push","reproject_","sources","source","clipExtent","z","size","getTileSize","width","height","leftToLoad","sourceListenKey","e","unlistenSources_","setTimeout","i","arr","getContext"],"sourceRoot":""}