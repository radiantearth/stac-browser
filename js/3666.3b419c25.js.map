{"version":3,"file":"js/3666.3b419c25.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/net.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/ogcTileUtil.js"],"sourcesContent":["/**\n * @module ol/net\n */\nimport {getUid} from './util.js';\n\n/**\n * Simple JSONP helper. Supports error callbacks and a custom callback param.\n * The error callback will be called when no JSONP is executed after 10 seconds.\n *\n * @param {string} url Request url. A 'callback' query parameter will be\n *     appended.\n * @param {Function} callback Callback on success.\n * @param {Function} [errback] Callback on error.\n * @param {string} [callbackParam] Custom query parameter for the JSONP\n *     callback. Default is 'callback'.\n */\nexport function jsonp(url, callback, errback, callbackParam) {\n  const script = document.createElement('script');\n  const key = 'olc_' + getUid(callback);\n  function cleanup() {\n    delete window[key];\n    script.parentNode.removeChild(script);\n  }\n  script.async = true;\n  script.src =\n    url +\n    (url.includes('?') ? '&' : '?') +\n    (callbackParam || 'callback') +\n    '=' +\n    key;\n  const timer = setTimeout(function () {\n    cleanup();\n    if (errback) {\n      errback();\n    }\n  }, 10000);\n  window[key] = function (data) {\n    clearTimeout(timer);\n    cleanup();\n    callback(data);\n  };\n  document.head.appendChild(script);\n}\n\nexport class ResponseError extends Error {\n  /**\n   * @param {XMLHttpRequest} response The XHR object.\n   */\n  constructor(response) {\n    const message = 'Unexpected response status: ' + response.status;\n    super(message);\n\n    /**\n     * @type {string}\n     */\n    this.name = 'ResponseError';\n\n    /**\n     * @type {XMLHttpRequest}\n     */\n    this.response = response;\n  }\n}\n\nexport class ClientError extends Error {\n  /**\n   * @param {XMLHttpRequest} client The XHR object.\n   */\n  constructor(client) {\n    super('Failed to issue request');\n\n    /**\n     * @type {string}\n     */\n    this.name = 'ClientError';\n\n    /**\n     * @type {XMLHttpRequest}\n     */\n    this.client = client;\n  }\n}\n\n/**\n * @param {string} url The URL.\n * @return {Promise<Object>} A promise that resolves to the JSON response.\n */\nexport function getJSON(url) {\n  return new Promise(function (resolve, reject) {\n    /**\n     * @param {ProgressEvent<XMLHttpRequest>} event The load event.\n     */\n    function onLoad(event) {\n      const client = event.target;\n      // status will be 0 for file:// urls\n      if (!client.status || (client.status >= 200 && client.status < 300)) {\n        let data;\n        try {\n          data = JSON.parse(client.responseText);\n        } catch (err) {\n          const message = 'Error parsing response text as JSON: ' + err.message;\n          reject(new Error(message));\n          return;\n        }\n        resolve(data);\n        return;\n      }\n\n      reject(new ResponseError(client));\n    }\n\n    /**\n     * @param {ProgressEvent<XMLHttpRequest>} event The error event.\n     */\n    function onError(event) {\n      reject(new ClientError(event.target));\n    }\n\n    const client = new XMLHttpRequest();\n    client.addEventListener('load', onLoad);\n    client.addEventListener('error', onError);\n    client.open('GET', url);\n    client.setRequestHeader('Accept', 'application/json');\n    client.send();\n  });\n}\n\n/**\n * @param {string} base The base URL.\n * @param {string} url The potentially relative URL.\n * @return {string} The full URL.\n */\nexport function resolveUrl(base, url) {\n  if (url.includes('://')) {\n    return url;\n  }\n  return new URL(url, base).href;\n}\n\nlet originalXHR;\nexport function overrideXHR(xhr) {\n  if (typeof XMLHttpRequest !== 'undefined') {\n    originalXHR = XMLHttpRequest;\n  }\n  global.XMLHttpRequest = xhr;\n}\n\nexport function restoreXHR() {\n  global.XMLHttpRequest = originalXHR;\n}\n","/**\n * @module ol/source/ogcTileUtil\n */\n\nimport {error as logError} from '../console.js';\nimport {getIntersection as intersectExtents} from '../extent.js';\nimport {getJSON, resolveUrl} from '../net.js';\nimport {get as getProjection} from '../proj.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\n\n/**\n * See https://ogcapi.ogc.org/tiles/.\n */\n\n/**\n * @typedef {'map' | 'vector'} TileType\n */\n\n/**\n * @typedef {'topLeft' | 'bottomLeft'} CornerOfOrigin\n */\n\n/**\n * @typedef {Object} TileSet\n * @property {TileType} dataType Type of data represented in the tileset.\n * @property {string} [tileMatrixSetDefinition] Reference to a tile matrix set definition.\n * @property {TileMatrixSet} [tileMatrixSet] Tile matrix set definition.\n * @property {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.\n * @property {Array<Link>} links Tileset links.\n */\n\n/**\n * @typedef {Object} Link\n * @property {string} rel The link rel attribute.\n * @property {string} href The link URL.\n * @property {string} type The link type.\n */\n\n/**\n * @typedef {Object} TileMatrixSetLimit\n * @property {string} tileMatrix The tile matrix id.\n * @property {number} minTileRow The minimum tile row.\n * @property {number} maxTileRow The maximum tile row.\n * @property {number} minTileCol The minimum tile column.\n * @property {number} maxTileCol The maximum tile column.\n */\n\n/**\n * @typedef {Object} TileMatrixSet\n * @property {string} id The tile matrix set identifier.\n * @property {string|CrsUri|CrsWkt|CrsReferenceSystem} crs The coordinate reference system.\n * @property {Array<string>} [orderedAxes] Axis order.\n * @property {Array<TileMatrix>} tileMatrices Array of tile matrices.\n */\n\n/**\n * @typedef {Object} CrsUri\n * @property {string} uri Reference to one coordinate reference system (CRS).\n */\n\n/**\n * @typedef {Object} CrsWkt\n * @property {Object} wkt JSON encoding for WKT representation of CRS 2.0.\n */\n\n/**\n * @typedef {Object} CrsReferenceSystem\n * @property {Object} referenceSystem Data structure as defined in the MD_ReferenceSystem of the ISO 19115.\n */\n\n/**\n * @typedef {Object} TileMatrix\n * @property {string} id The tile matrix identifier.\n * @property {number} cellSize The pixel resolution (map units per pixel).\n * @property {Array<number>} pointOfOrigin The map location of the matrix origin.\n * @property {CornerOfOrigin} [cornerOfOrigin='topLeft'] The corner of the matrix that represents the origin ('topLeft' or 'bottomLeft').\n * @property {number} matrixWidth The number of columns.\n * @property {number} matrixHeight The number of rows.\n * @property {number} tileWidth The pixel width of a tile.\n * @property {number} tileHeight The pixel height of a tile.\n */\n\n/**\n * @type {Object<string, boolean>}\n */\nconst knownMapMediaTypes = {\n  'image/png': true,\n  'image/jpeg': true,\n  'image/gif': true,\n  'image/webp': true,\n};\n\n/**\n * @type {Object<string, boolean>}\n */\nconst knownVectorMediaTypes = {\n  'application/vnd.mapbox-vector-tile': true,\n  'application/geo+json': true,\n};\n\n/**\n * @typedef {Object} TileSetInfo\n * @property {string} urlTemplate The tile URL template.\n * @property {import(\"../proj/Projection.js\").default} projection The source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} grid The tile grid.\n * @property {import(\"../Tile.js\").UrlFunction} urlFunction The tile URL function.\n */\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} url The tile set URL.\n * @property {string} mediaType The preferred tile media type.\n * @property {Array<string>} [supportedMediaTypes] The supported media types.\n * @property {import(\"../proj/Projection.js\").default} projection The source projection.\n * @property {Object} [context] Optional context for constructing the URL.\n * @property {Array<string>} [collections] Optional collections to append the URL with.\n */\n\n/**\n * @param {string} tileUrlTemplate Tile URL template.\n * @param {Array<string>} collections List of collections to include as query parameter.\n * @return {string} The tile URL template with appended collections query parameter.\n */\nexport function appendCollectionsQueryParam(tileUrlTemplate, collections) {\n  if (!collections.length) {\n    return tileUrlTemplate;\n  }\n\n  // making sure we can always construct a URL instance.\n  const url = new URL(tileUrlTemplate, 'file:/');\n\n  if (url.pathname.split('/').includes('collections')) {\n    logError(\n      'The \"collections\" query parameter cannot be added to collection endpoints',\n    );\n    return tileUrlTemplate;\n  }\n  // According to conformance class\n  // http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/collections-selection\n  // commata in the identifiers of the `collections` query parameter\n  // need to be URLEncoded, while the commata separating the identifiers\n  // should not.\n  const encodedCollections = collections\n    .map((c) => encodeURIComponent(c))\n    .join(',');\n\n  url.searchParams.append('collections', encodedCollections);\n  const baseUrl = tileUrlTemplate.split('?')[0];\n  const queryParams = decodeURIComponent(url.searchParams.toString());\n  return `${baseUrl}?${queryParams}`;\n}\n\n/**\n * @param {Array<Link>} links Tileset links.\n * @param {string} [mediaType] The preferred media type.\n * @param {Array<string>} [collections] Optional collections to append the URL with.\n * @return {string} The tile URL template.\n */\nexport function getMapTileUrlTemplate(links, mediaType, collections) {\n  let tileUrlTemplate;\n  let fallbackUrlTemplate;\n  for (let i = 0; i < links.length; ++i) {\n    const link = links[i];\n    if (link.rel === 'item') {\n      if (link.type === mediaType) {\n        tileUrlTemplate = link.href;\n        break;\n      }\n      if (knownMapMediaTypes[link.type]) {\n        fallbackUrlTemplate = link.href;\n      } else if (!fallbackUrlTemplate && link.type.startsWith('image/')) {\n        fallbackUrlTemplate = link.href;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate) {\n    if (fallbackUrlTemplate) {\n      tileUrlTemplate = fallbackUrlTemplate;\n    } else {\n      throw new Error('Could not find \"item\" link');\n    }\n  }\n\n  if (collections) {\n    tileUrlTemplate = appendCollectionsQueryParam(tileUrlTemplate, collections);\n  }\n\n  return tileUrlTemplate;\n}\n\n/**\n * @param {Array<Link>} links Tileset links.\n * @param {string} [mediaType] The preferred media type.\n * @param {Array<string>} [supportedMediaTypes] The media types supported by the parser.\n * @param {Array<string>} [collections] Optional collections to append the URL with.\n * @return {string} The tile URL template.\n */\nexport function getVectorTileUrlTemplate(\n  links,\n  mediaType,\n  supportedMediaTypes,\n  collections,\n) {\n  let tileUrlTemplate;\n  let fallbackUrlTemplate;\n\n  /**\n   * Lookup of URL by media type.\n   * @type {Object<string, string>}\n   */\n  const hrefLookup = {};\n\n  for (let i = 0; i < links.length; ++i) {\n    const link = links[i];\n    hrefLookup[link.type] = link.href;\n    if (link.rel === 'item') {\n      if (link.type === mediaType) {\n        tileUrlTemplate = link.href;\n        break;\n      }\n      if (knownVectorMediaTypes[link.type]) {\n        fallbackUrlTemplate = link.href;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate && supportedMediaTypes) {\n    for (let i = 0; i < supportedMediaTypes.length; ++i) {\n      const supportedMediaType = supportedMediaTypes[i];\n      if (hrefLookup[supportedMediaType]) {\n        tileUrlTemplate = hrefLookup[supportedMediaType];\n        break;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate) {\n    if (fallbackUrlTemplate) {\n      tileUrlTemplate = fallbackUrlTemplate;\n    } else {\n      throw new Error('Could not find \"item\" link');\n    }\n  }\n\n  if (collections) {\n    tileUrlTemplate = appendCollectionsQueryParam(tileUrlTemplate, collections);\n  }\n\n  return tileUrlTemplate;\n}\n\n/**\n * @param {SourceInfo} sourceInfo The source info.\n * @param {TileMatrixSet} tileMatrixSet Tile matrix set.\n * @param {string} tileUrlTemplate Tile URL template.\n * @param {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.\n * @return {TileSetInfo} Tile set info.\n */\nfunction parseTileMatrixSet(\n  sourceInfo,\n  tileMatrixSet,\n  tileUrlTemplate,\n  tileMatrixSetLimits,\n) {\n  let projection = sourceInfo.projection;\n  if (!projection) {\n    if (typeof tileMatrixSet.crs === 'string') {\n      projection = getProjection(tileMatrixSet.crs);\n    } else if ('uri' in tileMatrixSet.crs) {\n      projection = getProjection(tileMatrixSet.crs.uri);\n    }\n    if (!projection) {\n      throw new Error(`Unsupported CRS: ${JSON.stringify(tileMatrixSet.crs)}`);\n    }\n  }\n  const orderedAxes = tileMatrixSet.orderedAxes;\n  const axisOrientation = orderedAxes\n    ? orderedAxes\n        .slice(0, 2)\n        .map((s) => s.replace(/E|X|Lon/i, 'e').replace(/N|Y|Lat/i, 'n'))\n        .join('')\n    : projection.getAxisOrientation();\n  const backwards = !axisOrientation.startsWith('en');\n\n  const matrices = tileMatrixSet.tileMatrices;\n\n  /**\n   * @type {Object<string, TileMatrix>}\n   */\n  const matrixLookup = {};\n  for (let i = 0; i < matrices.length; ++i) {\n    const matrix = matrices[i];\n    matrixLookup[matrix.id] = matrix;\n  }\n\n  /**\n   * @type {Object<string, TileMatrixSetLimit>}\n   */\n  const limitLookup = {};\n\n  /**\n   * @type {Array<string>}\n   */\n  const matrixIds = [];\n\n  if (tileMatrixSetLimits) {\n    for (let i = 0; i < tileMatrixSetLimits.length; ++i) {\n      const limit = tileMatrixSetLimits[i];\n      const id = limit.tileMatrix;\n      matrixIds.push(id);\n      limitLookup[id] = limit;\n    }\n  } else {\n    for (let i = 0; i < matrices.length; ++i) {\n      const id = matrices[i].id;\n      matrixIds.push(id);\n    }\n  }\n\n  const length = matrixIds.length;\n  const origins = new Array(length);\n  const resolutions = new Array(length);\n  const sizes = new Array(length);\n  const tileSizes = new Array(length);\n  const extent = [-Infinity, -Infinity, Infinity, Infinity];\n\n  for (let i = 0; i < length; ++i) {\n    const id = matrixIds[i];\n    const matrix = matrixLookup[id];\n    const origin = matrix.pointOfOrigin;\n    if (backwards) {\n      origins[i] = [origin[1], origin[0]];\n    } else {\n      origins[i] = origin;\n    }\n    resolutions[i] = matrix.cellSize;\n    sizes[i] = [matrix.matrixWidth, matrix.matrixHeight];\n    tileSizes[i] = [matrix.tileWidth, matrix.tileHeight];\n    const limit = limitLookup[id];\n    if (limit) {\n      const tileMapWidth = matrix.cellSize * matrix.tileWidth;\n      const minX = origins[i][0] + limit.minTileCol * tileMapWidth;\n      const maxX = origins[i][0] + (limit.maxTileCol + 1) * tileMapWidth;\n\n      const tileMapHeight = matrix.cellSize * matrix.tileHeight;\n      const upsideDown = matrix.cornerOfOrigin === 'bottomLeft';\n\n      let minY;\n      let maxY;\n      if (upsideDown) {\n        minY = origins[i][1] + limit.minTileRow * tileMapHeight;\n        maxY = origins[i][1] + (limit.maxTileRow + 1) * tileMapHeight;\n      } else {\n        minY = origins[i][1] - (limit.maxTileRow + 1) * tileMapHeight;\n        maxY = origins[i][1] - limit.minTileRow * tileMapHeight;\n      }\n\n      intersectExtents(extent, [minX, minY, maxX, maxY], extent);\n    }\n  }\n\n  const tileGrid = new TileGrid({\n    origins: origins,\n    resolutions: resolutions,\n    sizes: sizes,\n    tileSizes: tileSizes,\n    extent: tileMatrixSetLimits ? extent : undefined,\n  });\n\n  const context = sourceInfo.context;\n  const base = sourceInfo.url;\n\n  /** @type {import('../Tile.js').UrlFunction} */\n  function tileUrlFunction(tileCoord, pixelRatio, projection) {\n    if (!tileCoord) {\n      return undefined;\n    }\n\n    const id = matrixIds[tileCoord[0]];\n    const matrix = matrixLookup[id];\n    const upsideDown = matrix.cornerOfOrigin === 'bottomLeft';\n\n    const localContext = {\n      tileMatrix: id,\n      tileCol: tileCoord[1],\n      tileRow: upsideDown ? -tileCoord[2] - 1 : tileCoord[2],\n    };\n\n    if (tileMatrixSetLimits) {\n      const limit = limitLookup[matrix.id];\n      if (\n        localContext.tileCol < limit.minTileCol ||\n        localContext.tileCol > limit.maxTileCol ||\n        localContext.tileRow < limit.minTileRow ||\n        localContext.tileRow > limit.maxTileRow\n      ) {\n        return undefined;\n      }\n    }\n\n    Object.assign(localContext, context);\n\n    const url = tileUrlTemplate.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n      return localContext[p];\n    });\n\n    return resolveUrl(base, url);\n  }\n\n  return {\n    grid: tileGrid,\n    projection: projection,\n    urlTemplate: tileUrlTemplate,\n    urlFunction: tileUrlFunction,\n  };\n}\n\n/**\n * @param {SourceInfo} sourceInfo The source info.\n * @param {TileSet} tileSet Tile set.\n * @return {TileSetInfo|Promise<TileSetInfo>} Tile set info.\n */\nfunction parseTileSetMetadata(sourceInfo, tileSet) {\n  const tileMatrixSetLimits = tileSet.tileMatrixSetLimits;\n  /** @type {string} */\n  let tileUrlTemplate;\n\n  if (tileSet.dataType === 'map') {\n    tileUrlTemplate = getMapTileUrlTemplate(\n      tileSet.links,\n      sourceInfo.mediaType,\n      sourceInfo.collections,\n    );\n  } else if (tileSet.dataType === 'vector') {\n    tileUrlTemplate = getVectorTileUrlTemplate(\n      tileSet.links,\n      sourceInfo.mediaType,\n      sourceInfo.supportedMediaTypes,\n      sourceInfo.collections,\n    );\n  } else {\n    throw new Error('Expected tileset data type to be \"map\" or \"vector\"');\n  }\n\n  if (tileSet.tileMatrixSet) {\n    return parseTileMatrixSet(\n      sourceInfo,\n      tileSet.tileMatrixSet,\n      tileUrlTemplate,\n      tileMatrixSetLimits,\n    );\n  }\n\n  const tileMatrixSetLink = tileSet.links.find(\n    (link) =>\n      link.rel === 'http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme',\n  );\n  if (!tileMatrixSetLink) {\n    throw new Error(\n      'Expected http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme link or tileMatrixSet',\n    );\n  }\n  const tileMatrixSetDefinition = tileMatrixSetLink.href;\n\n  const url = resolveUrl(sourceInfo.url, tileMatrixSetDefinition);\n  return getJSON(url).then(function (tileMatrixSet) {\n    return parseTileMatrixSet(\n      sourceInfo,\n      tileMatrixSet,\n      tileUrlTemplate,\n      tileMatrixSetLimits,\n    );\n  });\n}\n\n/**\n * @param {SourceInfo} sourceInfo Source info.\n * @return {Promise<TileSetInfo>} Tile set info.\n */\nexport function getTileSetInfo(sourceInfo) {\n  return getJSON(sourceInfo.url).then(function (tileSet) {\n    return parseTileSetMetadata(sourceInfo, tileSet);\n  });\n}\n"],"names":["jsonp","url","callback","errback","callbackParam","script","document","createElement","key","cleanup","window","parentNode","removeChild","async","src","includes","timer","setTimeout","data","clearTimeout","head","appendChild","ResponseError","Error","constructor","response","message","status","super","this","name","ClientError","client","getJSON","Promise","resolve","reject","onLoad","event","target","JSON","parse","responseText","err","onError","XMLHttpRequest","addEventListener","open","setRequestHeader","send","resolveUrl","base","URL","href","knownMapMediaTypes","knownVectorMediaTypes","appendCollectionsQueryParam","tileUrlTemplate","collections","length","pathname","split","encodedCollections","map","c","encodeURIComponent","join","searchParams","append","baseUrl","queryParams","decodeURIComponent","toString","getMapTileUrlTemplate","links","mediaType","fallbackUrlTemplate","i","link","rel","type","startsWith","getVectorTileUrlTemplate","supportedMediaTypes","hrefLookup","supportedMediaType","parseTileMatrixSet","sourceInfo","tileMatrixSet","tileMatrixSetLimits","projection","crs","uri","stringify","orderedAxes","axisOrientation","slice","s","replace","getAxisOrientation","backwards","matrices","tileMatrices","matrixLookup","matrix","id","limitLookup","matrixIds","limit","tileMatrix","push","origins","Array","resolutions","sizes","tileSizes","extent","Infinity","origin","pointOfOrigin","cellSize","matrixWidth","matrixHeight","tileWidth","tileHeight","tileMapWidth","minX","minTileCol","maxX","maxTileCol","tileMapHeight","upsideDown","cornerOfOrigin","minY","maxY","minTileRow","maxTileRow","tileGrid","undefined","context","tileUrlFunction","tileCoord","pixelRatio","localContext","tileCol","tileRow","Object","assign","m","p","grid","urlTemplate","urlFunction","parseTileSetMetadata","tileSet","dataType","tileMatrixSetLink","find","tileMatrixSetDefinition","then","getTileSetInfo"],"sourceRoot":""}