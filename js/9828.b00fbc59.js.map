{"version":3,"file":"js/9828.b00fbc59.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/renderer/canvas/TileLayer.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/TileProperty.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport DataTile, {asImageLike} from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport {toSize} from '../../size.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport {createOrUpdate as createTileCoord, getKeyZXY} from '../../tilecoord.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport CanvasLayerRenderer from './Layer.js';\n\n/**\n * @param {import(\"../../source/Tile.js\").default} source The tile source.\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(source, sourceKey, z, x, y) {\n  return `${getUid(source)},${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default|null}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource, tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(\n        z,\n        x,\n        y,\n        frameState.pixelRatio,\n        frameState.viewState.projection,\n      );\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection) {\n      this.renderedProjection = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection) {\n      this.tileCache_.clear();\n      this.renderedProjection = frameState.viewState.projection;\n    }\n\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedSourceRevision_) {\n      this.renderedSourceRevision_ = sourceRevision;\n    } else if (this.renderedSourceRevision_ !== sourceRevision) {\n      this.renderedSourceRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    const rotation = viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          viewState.resolution,\n          rotation,\n          frameState.size,\n        )\n      : undefined;\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(\n        this.getLayer().getSource(),\n        staleKeys[i],\n        z,\n        x,\n        y,\n      );\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.peek(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.peek(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  maybe skip transition when not fully opaque\n     *  decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(\n        frameExtent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          renderExtent,\n          z - 1,\n          tilesByZ,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (tileState === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      if (tileState !== TileState.ERROR) {\n        this.renderComplete = false;\n      }\n\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tilesByZ,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tilesByZ,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (\n              intersects(\n                [x, y, x + w, y + h],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (this.renderComplete) {\n      /**\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = (map, frameState) => {\n        const tileSourceKey = getUid(tileSource);\n        const wantedTiles = frameState.wantedTiles[tileSourceKey];\n        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n        this.updateCacheSize(tilesCount);\n        this.tileCache_.expireCache();\n      };\n\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(\n      this.tileCache_.highWaterMark,\n      tileCount * 2,\n    );\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(\n        /** @type {import(\"../../ImageTile.js\").default} */ (tile),\n      );\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n","/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n"],"names":["getCacheKey","source","sourceKey","z","x","y","addTileToLookup","tilesByZ","tile","Set","set","existing","has","add","removeTileFromLookup","delete","getRenderExtent","frameState","extent","layerState","layerStatesArray","layerIndex","viewState","projection","layer","getRenderSource","getWrapX","gridExtent","getTileGridForProjection","getExtent","CanvasTileLayerRenderer","constructor","tileLayer","options","super","this","extentChanged","renderComplete","renderedExtent_","renderedPixelRatio","renderedProjection","renderedTiles","renderedSourceKey_","renderedSourceRevision_","tempExtent","tempTileRange_","tempTileCoord_","cacheSize","undefined","tileCache_","maxStaleKeys","getTileCache","getOrCreateTile","tileCache","getLayer","tileSource","getSource","cacheKey","getKey","containsKey","get","getTile","pixelRatio","getData","pixel","coordinate","pixelToCoordinateTransform","slice","layerExtent","tileGrid","tilePixelRatio","getTilePixelRatio","getZForResolution","resolution","getMinZoom","tileCoord","getTileCoordForCoordAndZ","getState","LOADED","tileOrigin","getOrigin","tileSize","getTileSize","tileResolution","getResolution","image","getImage","col","Math","floor","row","gutter","round","getGutterForProjection","getImageData","prepareFrame","clear","sourceRevision","getRevision","enqueueTiles","initialZ","preload","tileSourceKey","wantedTiles","map","getMapInternal","minZ","max","min","getMaxResolution","getView","getResolutionForZoom","zDirection","rotation","viewport","center","size","tileRange","getTileRangeForExtentAndZ","minX","maxX","minY","maxY","tileCoordIntersectsViewport","added","tileQueueKey","IDLE","tileQueue","isKeyQueued","enqueue","getTileCoordCenter","findStaleTile_","staleKeys","getStaleKeys","i","length","peek","endTransition","findAltTiles_","altZ","getTileRangeForTileCoordAndZ","covered","loaded","renderFrame","target","viewResolution","viewCenter","prependStaleKey","frameExtent","prepareContainer","width","context","canvas","height","dx","dy","canvasExtent","getPreload","nextExtent","targetZ","nextResolution","renderExtent","setTimeout","container","uid","time","tileState","EMPTY","alpha","getAlpha","ERROR","hasStaleTile","animate","coveredByChildren","minZoom","parentZ","coveredByParent","canvasScale","getRenderContext","tempTransform","clipUnrotated","getInterpolate","imageSmoothingEnabled","preRender","zs","Object","keys","Number","currentClip","sort","clips","clipZs","currentZ","currentTilePixelSize","getTilePixelSize","currentResolution","currentScale","originTileCoord","originTileExtent","getTileCoordExtent","origin","tileGutter","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","ii","clip","save","beginPath","moveTo","lineTo","push","drawTile","restore","unshift","updateUsedTiles","usedTiles","renderedResolution","postRender","postRenderFunction","tilesCount","updateCacheSize","expireCache","postRenderFunctions","tileCount","highWaterMark","Error","getTileImage","opacity","alphaChanged","globalAlpha","drawImage","PRELOAD","USE_INTERIM_TILES_ON_ERROR"],"sourceRoot":""}