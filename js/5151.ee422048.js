"use strict";(self["webpackChunk_radiantearth_stac_browser"]=self["webpackChunk_radiantearth_stac_browser"]||[]).push([[5151],{55151:function(e,t,n){n.d(t,{my:function(){return w},s2:function(){return l}});var o=n(90588),i=n(85745),s=n(49825),a=n(27557),r=n(14943);function l(e,t,n){const o=(0,s.SR)();return(0,a.nR)(t,n,o,e)}function c(e){const t=(0,i._j)(e),n=256*t[0],o=t[1],s=256*t[2],a=Math.round(255*t[3]);return[n+o,s+a]}const p="vec4 unpackColor(vec2 packedColor) {\n  return vec4(\n    fract(floor(packedColor[0] / 256.0) / 256.0),\n    fract(packedColor[0] / 256.0),\n    fract(floor(packedColor[1] / 256.0) / 256.0),\n    fract(packedColor[1] / 256.0)\n  );\n}";function u(e){return e===s.mE||e===s.qA?2:e===s.Fq?4:1}function d(e){const t=u(e);return t>1?`vec${t}`:"float"}function f(e){const t=JSON.stringify(e).split("").reduce((e,t)=>(e<<5)-e+t.charCodeAt(0),0);return(t>>>0).toString()}function h(e,t,n,o){if(`${o}radius`in e&&"icon-"!==o){let i=l(n,e[`${o}radius`],s.wl);if(`${o}radius2`in e){const t=l(n,e[`${o}radius2`],s.wl);i=`max(${i}, ${t})`}`${o}stroke-width`in e&&(i=`(${i} + ${l(n,e[`${o}stroke-width`],s.wl)} * 0.5)`),t.setSymbolSizeExpression(`vec2(${i} * 2. + 0.5)`)}if(`${o}scale`in e){const i=l(n,e[`${o}scale`],s.qA);t.setSymbolSizeExpression(`${t.getSymbolSizeExpression()} * ${i}`)}`${o}displacement`in e&&t.setSymbolOffsetExpression(l(n,e[`${o}displacement`],s.Fq)),`${o}rotation`in e&&t.setSymbolRotationExpression(l(n,e[`${o}rotation`],s.wl)),`${o}rotate-with-view`in e&&t.setSymbolRotateWithView(!!e[`${o}rotate-with-view`])}function m(e,t,n,o,i){let s="vec4(0.)";if(null!==t&&(s=t),null!==n&&null!==o){const t=`smoothstep(-${o} + 0.63, -${o} - 0.58, ${e})`;s=`mix(${n}, ${s}, ${t})`}const a=`(1.0 - smoothstep(-0.63, 0.58, ${e}))`;let r=`${s} * vec4(1.0, 1.0, 1.0, ${a})`;return null!==i&&(r=`${r} * vec4(1.0, 1.0, 1.0, ${i})`),r}function $(e,t,n,i,s){const a=new Image;a.crossOrigin=void 0===e[`${i}cross-origin`]?"anonymous":e[`${i}cross-origin`],(0,o.v)("string"===typeof e[`${i}src`],`WebGL layers do not support expressions for the ${i}src style property`),a.src=e[`${i}src`],n[`u_texture${s}_size`]=()=>a.complete?[a.width,a.height]:[0,0],t.addUniform(`vec2 u_texture${s}_size`);const r=`u_texture${s}_size`;return n[`u_texture${s}`]=a,t.addUniform(`sampler2D u_texture${s}`),r}function x(e,t,n,o,i){let a=l(n,e[`${t}offset`],s.Fq);if(`${t}offset-origin`in e)switch(e[`${t}offset-origin`]){case"top-right":a=`vec2(${o}.x, 0.) + ${i} * vec2(-1., 0.) + ${a} * vec2(-1., 1.)`;break;case"bottom-left":a=`vec2(0., ${o}.y) + ${i} * vec2(0., -1.) + ${a} * vec2(1., -1.)`;break;case"bottom-right":a=`${o} - ${i} - ${a}`;break;default:}return a}function g(e,t,n,o,i){i.functions["circleDistanceField"]="float circleDistanceField(vec2 point, float radius) {\n  return length(point) - radius;\n}",h(e,t,o,"circle-");let a=null;"circle-opacity"in e&&(a=l(i,e["circle-opacity"],s.wl));let r="coordsPx";if("circle-scale"in e){const t=l(i,e["circle-scale"],s.qA);r=`coordsPx / ${t}`}let c=null;"circle-fill-color"in e&&(c=l(i,e["circle-fill-color"],s.mE));let p=null;"circle-stroke-color"in e&&(p=l(i,e["circle-stroke-color"],s.mE));let u=l(i,e["circle-radius"],s.wl),d=null;"circle-stroke-width"in e&&(d=l(i,e["circle-stroke-width"],s.wl),u=`(${u} + ${d} * 0.5)`);const f=`circleDistanceField(${r}, ${u})`,$=m(f,c,p,d,a);t.setSymbolColorExpression($)}function v(e,t,n,o,i){i.functions["round"]="float round(float v) {\n  return sign(v) * floor(abs(v) + 0.5);\n}",i.functions["starDistanceField"]="float starDistanceField(vec2 point, float numPoints, float radius, float radius2, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round(beta / alpha) * alpha; // angle in sector\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  vec2 tipToPoint = inSector + vec2(-radius, 0.);\n  vec2 edgeNormal = vec2(radius2 * sin(alpha * 0.5), -radius2 * cos(alpha * 0.5) + radius);\n  return dot(normalize(edgeNormal), tipToPoint);\n}",i.functions["regularDistanceField"]="float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float radiusIn = radius * cos(PI / numPoints);\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  return inSector.x - radiusIn;\n}",h(e,t,o,"shape-");let a=null;"shape-opacity"in e&&(a=l(i,e["shape-opacity"],s.wl));let r="coordsPx";if("shape-scale"in e){const t=l(i,e["shape-scale"],s.qA);r=`coordsPx / ${t}`}let c=null;"shape-fill-color"in e&&(c=l(i,e["shape-fill-color"],s.mE));let p=null;"shape-stroke-color"in e&&(p=l(i,e["shape-stroke-color"],s.mE));let u=null;"shape-stroke-width"in e&&(u=l(i,e["shape-stroke-width"],s.wl));const d=l(i,e["shape-points"],s.wl);let f,$="0.";"shape-angle"in e&&($=l(i,e["shape-angle"],s.wl));let x=l(i,e["shape-radius"],s.wl);if(null!==u&&(x=`${x} + ${u} * 0.5`),"shape-radius2"in e){let t=l(i,e["shape-radius2"],s.wl);null!==u&&(t=`${t} + ${u} * 0.5`),f=`starDistanceField(${r}, ${d}, ${x}, ${t}, ${$})`}else f=`regularDistanceField(${r}, ${d}, ${x}, ${$})`;const g=m(f,c,p,u,a);t.setSymbolColorExpression(g)}function S(e,t,n,o,i){let a="vec4(1.0)";"icon-color"in e&&(a=l(i,e["icon-color"],s.mE)),"icon-opacity"in e&&(a=`${a} * vec4(1.0, 1.0, 1.0, ${l(i,e["icon-opacity"],s.wl)})`);const r=f(e["icon-src"]),c=$(e,t,n,"icon-",r);if(t.setSymbolColorExpression(`${a} * texture2D(u_texture${r}, v_texCoord)`).setSymbolSizeExpression(c),"icon-width"in e&&"icon-height"in e&&t.setSymbolSizeExpression(`vec2(${l(o,e["icon-width"],s.wl)}, ${l(o,e["icon-height"],s.wl)})`),"icon-offset"in e&&"icon-size"in e){const n=l(o,e["icon-size"],s.Fq),i=t.getSymbolSizeExpression();t.setSymbolSizeExpression(n);const a=x(e,"icon-",o,"v_quadSizePx",n);t.setTextureCoordinateExpression(`(vec4((${a}).xyxy) + vec4(0., 0., ${n})) / (${i}).xyxy`)}if(h(e,t,o,"icon-"),"icon-anchor"in e){const n=l(o,e["icon-anchor"],s.Fq);let i,a="1.0";"icon-scale"in e&&(a=l(o,e["icon-scale"],s.qA)),i="pixels"===e["icon-anchor-x-units"]&&"pixels"===e["icon-anchor-y-units"]?`${n} * ${a}`:"pixels"===e["icon-anchor-x-units"]?`${n} * vec2(vec2(${a}).x, v_quadSizePx.y)`:"pixels"===e["icon-anchor-y-units"]?`${n} * vec2(v_quadSizePx.x, vec2(${a}).x)`:`${n} * v_quadSizePx`;let r=`v_quadSizePx * vec2(0.5, -0.5) + ${i} * vec2(-1., 1.)`;if("icon-anchor-origin"in e)switch(e["icon-anchor-origin"]){case"top-right":r=`v_quadSizePx * -0.5 + ${i}`;break;case"bottom-left":r=`v_quadSizePx * 0.5 - ${i}`;break;case"bottom-right":r=`v_quadSizePx * vec2(-0.5, 0.5) + ${i} * vec2(1., -1.)`;break;default:}t.setSymbolOffsetExpression(`${t.getSymbolOffsetExpression()} + ${r}`)}}function y(e,t,n,o,i){if("stroke-color"in e&&t.setStrokeColorExpression(l(i,e["stroke-color"],s.mE)),"stroke-pattern-src"in e){const o=f(e["stroke-pattern-src"]),a=$(e,t,n,"stroke-pattern-",o);let r=a,c="vec2(0.)";"stroke-pattern-offset"in e&&"stroke-pattern-size"in e&&(r=l(i,e["stroke-pattern-size"],s.Fq),c=x(e,"stroke-pattern-",i,a,r));let p="0.";"stroke-pattern-spacing"in e&&(p=l(i,e["stroke-pattern-spacing"],s.wl)),i.functions["sampleStrokePattern"]="vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {\n  float currentLengthScaled = currentLengthPx * sampleSize.y / lineWidth;\n  float spacingScaled = spacingPx * sampleSize.y / lineWidth;\n  float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));\n  // make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\n  uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);\n  float vCoordPx = (-currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;\n  vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;\n  return texture2D(texture, texCoord);\n}";const u=`u_texture${o}`;let d="1.";"stroke-color"in e&&(d=t.getStrokeColorExpression()),t.setStrokeColorExpression(`${d} * sampleStrokePattern(${u}, ${a}, ${c}, ${r}, ${p}, currentLengthPx, currentRadiusRatio, v_width)`)}if("stroke-width"in e&&t.setStrokeWidthExpression(l(o,e["stroke-width"],s.wl)),"stroke-offset"in e&&t.setStrokeOffsetExpression(l(o,e["stroke-offset"],s.wl)),"stroke-line-cap"in e&&t.setStrokeCapExpression(l(o,e["stroke-line-cap"],s.cT)),"stroke-line-join"in e&&t.setStrokeJoinExpression(l(o,e["stroke-line-join"],s.cT)),"stroke-miter-limit"in e&&t.setStrokeMiterLimitExpression(l(o,e["stroke-miter-limit"],s.wl)),"stroke-line-dash"in e){i.functions["getSingleDashDistance"]=`float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\n  float localDistance = mod(distance, dashLengthTotal);\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\n  if (capType == ${(0,a.Tl)("square")}) {\n    distanceSegment -= v_width * 0.5;\n  } else if (capType == ${(0,a.Tl)("round")}) {\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\n  }\n  return distanceSegment;\n}`;let n=e["stroke-line-dash"].map(e=>l(i,e,s.wl));n.length%2===1&&(n=[...n,...n]);let r="0.";"stroke-line-dash-offset"in e&&(r=l(o,e["stroke-line-dash-offset"],s.wl));const c=f(e["stroke-line-dash"]),p=`dashDistanceField_${c}`,u=n.map((e,t)=>`float dashLength${t} = ${e};`),d=n.map((e,t)=>`dashLength${t}`).join(" + ");let h="0.",m=`getSingleDashDistance(distance, radius, ${h}, dashLength0, totalDashLength, capType)`;for(let e=2;e<n.length;e+=2)h=`${h} + dashLength${e-2} + dashLength${e-1}`,m=`min(${m}, getSingleDashDistance(distance, radius, ${h}, dashLength${e}, totalDashLength, capType))`;i.functions[p]=`float ${p}(float distance, float radius, float capType) {\n  ${u.join("\n  ")}\n  float totalDashLength = ${d};\n  return ${m};\n}`,t.setStrokeDistanceFieldExpression(`${p}(currentLengthPx + ${r}, currentRadiusPx, capType)`)}}function k(e,t,n,o,i){if("fill-color"in e&&t.setFillColorExpression(l(i,e["fill-color"],s.mE)),"fill-pattern-src"in e){const o=f(e["fill-pattern-src"]),a=$(e,t,n,"fill-pattern-",o);let r=a,c="vec2(0.)";"fill-pattern-offset"in e&&"fill-pattern-size"in e&&(r=l(i,e["fill-pattern-size"],s.Fq),c=x(e,"fill-pattern-",i,a,r)),i.functions["sampleFillPattern"]="vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {\n  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);\n  vec2 pxRelativePos = pxPosition - pxOrigin;\n  // rotate the relative position from origin by the current view rotation\n  pxRelativePos = vec2(pxRelativePos.x * cos(u_rotation) - pxRelativePos.y * sin(u_rotation), pxRelativePos.x * sin(u_rotation) + pxRelativePos.y * cos(u_rotation));\n  // sample position is computed according to the sample offset & size\n  vec2 samplePos = mod(pxRelativePos / scaleRatio, sampleSize);\n  // also make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\n  samplePos = clamp(samplePos, vec2(0.5), sampleSize - vec2(0.5));\n  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright\n  return texture2D(texture, (samplePos + textureOffset) / textureSize);\n}";const p=`u_texture${o}`;let u="1.";"fill-color"in e&&(u=t.getFillColorExpression()),t.setFillColorExpression(`${u} * sampleFillPattern(${p}, ${a}, ${c}, ${r}, pxOrigin, pxPos)`)}}function w(e,t,n){const o=(0,a.z0)(),f={...(0,a.z0)(),inFragmentShader:!0,variables:o.variables},h=new r.N,m={};if("icon-src"in e?S(e,h,m,o,f):"shape-points"in e?v(e,h,m,o,f):"circle-radius"in e&&g(e,h,m,o,f),y(e,h,m,o,f),k(e,h,m,o,f),n){const e=l(f,n,s.T8);h.setFragmentDiscardExpression(`!${e}`)}for(const r in f.variables){const e=f.variables[r],n=(0,a.Sl)(e.name);let o=d(e.type);e.type===s.mE&&(o="vec4"),h.addUniform(`${o} ${n}`),m[n]=()=>{const n=t[e.name];return"number"===typeof n?n:"boolean"===typeof n?n?1:0:e.type===s.mE?(0,i._j)(n||"#eee"):"string"===typeof n?(0,a.Lm)(n):n}}for(const i in f.properties){const e=f.properties[i];o.properties[i]||(o.properties[i]=e);let t=d(e.type),n=`a_prop_${e.name}`;e.type===s.mE&&(t="vec4",n=`unpackColor(${n})`,h.addVertexShaderFunction(p)),h.addVarying(`v_prop_${e.name}`,t,n)}for(const i in o.properties){const e=o.properties[i];h.addAttribute(`${d(e.type)} a_prop_${e.name}`)}for(const i in o.functions)h.addVertexShaderFunction(o.functions[i]);for(const i in f.functions)h.addFragmentShaderFunction(f.functions[i]);const $={};for(const r in o.properties){const e=o.properties[r],t=t=>{const n=t.get(e.name);return e.type===s.mE?c([...(0,i._j)(n||"#eee")]):"string"===typeof n?(0,a.Lm)(n):"boolean"===typeof n?n?1:0:n};$[`prop_${e.name}`]={size:u(e.type),callback:t}}function x(e,t,n,i){const s=o[e],a=f[e];if(!s&&!a)return;const r=d(n),l=u(n);h.addAttribute(`${r} a_${t}`),a&&h.addVarying(`v_${t}`,r,`a_${t}`),$[t]={size:l,callback:i}}return x("geometryType",a.M7,s.cT,e=>(0,a.Lm)((0,s.Ye)(e.getGeometry()))),x("featureId",a.L$,s.cT|s.wl,e=>{const t=e.getId()??null;return"string"===typeof t?(0,a.Lm)(t):t}),{builder:h,attributes:$,uniforms:m}}}}]);
//# sourceMappingURL=5151.ee422048.js.map