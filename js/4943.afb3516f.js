"use strict";(self["webpackChunk_radiantearth_stac_browser"]=self["webpackChunk_radiantearth_stac_browser"]||[]).push([[4943],{8001:function(e,t,n){n.d(t,{et:function(){return v},gF:function(){return g}});var r=n(91110),i=n(11078),o=n(66514),s=n(70915),a=n(38599),l=n(6782),h=n(14969),c=n(40186),u=n(9703),f=n(4087),_=n(83954),d=n(60492);const g={TILE_TRANSFORM:"u_tileTransform",TRANSITION_ALPHA:"u_transitionAlpha",DEPTH:"u_depth",RENDER_EXTENT:"u_renderExtent",PATTERN_ORIGIN:"u_patternOrigin",RESOLUTION:"u_resolution",ZOOM:"u_zoom",GLOBAL_ALPHA:"u_globalAlpha",PROJECTION_MATRIX:"u_projectionMatrix",SCREEN_TO_WORLD_MATRIX:"u_screenToWorldMatrix"};function p(e){return 1/(e+2)}function m(){return{tileIds:new Set,representationsByZ:{}}}function T(e,t){return e.tileIds.has((0,f.v6)(t))}function E(e,t,n){const r=e.representationsByZ;n in r||(r[n]=new Set),r[n].add(t),e.tileIds.add((0,f.v6)(t.tile))}function x(e,t){const n=e.layerStatesArray[e.layerIndex];n.extent&&(t=(0,s._N)(t,(0,a.SD)(n.extent,e.viewState.projection)));const r=n.layer.getRenderSource();if(!r.getWrapX()){const n=r.getTileGridForProjection(e.viewState.projection).getExtent();n&&(t=(0,s._N)(t,n))}return t}function v(e,t){return`${e.getKey()},${e.getRevision()},${(0,c.i7)(t)}`}class R extends d.A{constructor(e,t){super(e,{uniforms:t.uniforms,postProcesses:t.postProcesses}),this.renderComplete=!1,this.tileTransform_=(0,u.vt)(),this.tempMat4=(0,_.vt)(),this.tempTileRange_=new r.A(0,0,0,0),this.tempTileCoord_=(0,c.N)(0,0,0),this.tempSize_=[0,0];const n=void 0!==t.cacheSize?t.cacheSize:512;this.tileRepresentationCache=new h.A(n),this.frameState=null,this.renderedProjection_=void 0}reset(e){super.reset({uniforms:e.uniforms})}prepareFrameInternal(e){this.renderedProjection_?e.viewState.projection!==this.renderedProjection_&&(this.clearCache(),this.renderedProjection_=e.viewState.projection):this.renderedProjection_=e.viewState.projection;const t=this.getLayer(),n=t.getRenderSource();return!!n&&(!(0,s.Im)(x(e,e.extent))&&"ready"===n.getState())}createTileRepresentation(e){return(0,f.b0)()}enqueueTiles(e,t,n,r,o){const a=e.viewState,l=this.getLayer(),h=l.getRenderSource(),u=h.getTileGridForProjection(a.projection),_=h.getGutterForProjection(a.projection),d=(0,f.v6)(h);d in e.wantedTiles||(e.wantedTiles[d]={});const g=e.wantedTiles[d],p=this.tileRepresentationCache,m=l.getMapInternal(),x=Math.max(n-o,u.getMinZoom(),u.getZForResolution(Math.min(l.getMaxResolution(),m?m.getView().getResolutionForZoom(Math.max(l.getMinZoom(),0)):u.getResolution(0)),h.zDirection)),R=a.rotation,P=R?(0,s.Yw)(a.center,a.resolution,R,e.size):void 0;for(let s=n;s>=x;--s){const n=u.getTileRangeForExtentAndZ(t,s,this.tempTileRange_),o=u.getResolution(s);for(let t=n.minX;t<=n.maxX;++t)for(let l=n.minY;l<=n.maxY;++l){if(R&&!u.tileCoordIntersectsViewport([s,t,l],P))continue;const n=(0,c.N)(s,t,l,this.tempTileCoord_),f=v(h,n);let m,x;if(p.containsKey(f)&&(m=p.get(f),x=m.tile),(!m||m.tile.key!==h.getKey())&&(x=h.getTile(s,t,l,e.pixelRatio,a.projection),!x))continue;if(T(r,x))continue;m?m.setTile(x):(m=this.createTileRepresentation({tile:x,grid:u,helper:this.helper,gutter:_}),p.set(f,m)),E(r,m,s);const y=x.getKey();g[y]=!0,x.getState()===i.A.IDLE&&(e.tileQueue.isKeyQueued(y)||e.tileQueue.enqueue([x,d,u.getTileCoordCenter(n),o]))}}}beforeTilesRender(e,t){this.helper.prepareDraw(this.frameState,!t,!0)}beforeTilesMaskRender(e){return!1}renderTile(e,t,n,r,i,o,s,a,l,h,c){}renderTileMask(e,t,n,r){}drawTile_(e,t,n,r,i,o,s){if(!t.ready)return;const a=t.tile,h=a.tileCoord,f=(0,c.i7)(h),_=f in o?o[f]:1,d=s.getResolution(n),g=(0,l.xq)(s.getTileSize(n),this.tempSize_),m=s.getOrigin(n),T=s.getTileCoordExtent(h),E=_<1?-1:p(n);_<1&&(e.animate=!0);const x=e.viewState,v=x.center[0],R=x.center[1],P=g[0]+2*r,y=g[1]+2*r,S=P/y,A=(v-m[0])/(g[0]*d),b=(m[1]-R)/(g[1]*d),C=x.resolution/d,D=h[1],L=h[2];(0,u.cL)(this.tileTransform_),(0,u.hs)(this.tileTransform_,2/(e.size[0]*C/P),-2/(e.size[1]*C/P)),(0,u.e$)(this.tileTransform_,x.rotation),(0,u.hs)(this.tileTransform_,1,1/S),(0,u.Tl)(this.tileTransform_,(g[0]*(D-A)-r)/P,(g[1]*(L-b)-r)/y),this.renderTile(t,this.tileTransform_,e,i,d,g,m,T,E,r,_)}renderFrame(e){this.frameState=e,this.renderComplete=!0;const t=this.helper.getGL();this.preRender(t,e);const n=e.viewState,r=this.getLayer(),s=r.getRenderSource(),a=s.getTileGridForProjection(n.projection),l=s.getGutterForProjection(n.projection),h=x(e,e.extent),u=a.getZForResolution(n.resolution,s.zDirection),_=m(),d=r.getPreload();if(e.nextExtent){const t=a.getZForResolution(n.nextResolution,s.zDirection),r=x(e,e.nextExtent);this.enqueueTiles(e,r,t,_,d)}this.enqueueTiles(e,h,u,_,0),d>0&&setTimeout(()=>{this.enqueueTiles(e,h,u-1,_,d-1)},0);const g={};let T=!1;const E=_.representationsByZ;if(u in E){const t=(0,f.v6)(this),n=e.time;for(const e of E[u]){const r=e.tile;if(r.getState()===i.A.EMPTY)continue;const o=r.tileCoord;if(e.ready){const e=r.getAlpha(t,n);if(1===e){r.endTransition(t);continue}T=!0;const i=(0,c.i7)(o);g[i]=e}this.renderComplete=!1;const s=this.findAltTiles_(a,o,u+1,_);if(s)continue;const l=a.getMinZoom();for(let e=u-1;e>=l;--e){const t=this.findAltTiles_(a,o,e,_);if(t)break}}}const v=Object.keys(E).map(Number).sort(o.rG),R=this.beforeTilesMaskRender(e);if(R)for(let i=0,o=v.length;i<o;++i){const e=v[i];for(const t of E[e]){const n=t.tile.tileCoord,r=(0,c.i7)(n);if(r in g)continue;const i=a.getTileCoordExtent(n);this.renderTileMask(t,e,i,p(e))}}this.beforeTilesRender(e,T);for(let i=0,o=v.length;i<o;++i){const t=v[i];for(const n of E[t]){const r=n.tile.tileCoord,i=(0,c.i7)(r);i in g||this.drawTile_(e,n,t,l,h,g,a)}}if(u in E)for(const i of E[u]){const t=i.tile.tileCoord,n=(0,c.i7)(t);n in g&&this.drawTile_(e,i,u,l,h,g,a)}this.beforeFinalize(e),this.helper.finalizeDraw(e,this.dispatchPreComposeEvent,this.dispatchPostComposeEvent);const P=this.helper.getCanvas(),y=this.tileRepresentationCache;while(y.canExpireCache()){const e=y.pop();e.dispose()}return this.postRender(t,e),P}beforeFinalize(e){}findAltTiles_(e,t,n,r){const i=e.getTileRangeForTileCoordAndZ(t,n,this.tempTileRange_);if(!i)return!1;let o=!0;const s=this.tileRepresentationCache,a=this.getLayer().getRenderSource();for(let l=i.minX;l<=i.maxX;++l)for(let e=i.minY;e<=i.maxY;++e){const t=v(a,[n,l,e]);let i=!1;if(s.containsKey(t)){const e=s.get(t);e.ready&&!T(r,e.tile)&&(E(r,e,n),i=!0)}i||(o=!1)}return o}clearCache(){super.clearCache();const e=this.tileRepresentationCache;e.forEach(e=>e.dispose()),e.clear()}afterHelperCreated(){super.afterHelperCreated(),this.tileRepresentationCache.forEach(e=>e.setHelper(this.helper))}disposeInternal(){super.disposeInternal(),delete this.frameState}}t.Ay=R},14943:function(e,t,n){n.d(t,{N:function(){return l}});var r=n(27557),i=n(32627);function o(){return{"fill-color":"rgba(255,255,255,0.4)","stroke-color":"#3399CC","stroke-width":1.25,"circle-radius":5,"circle-fill-color":"rgba(255,255,255,0.4)","circle-stroke-width":1.25,"circle-stroke-color":"#3399CC"}}const s="#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_screenToWorldMatrix;\nuniform vec2 u_viewportSizePx;\nuniform float u_pixelRatio;\nuniform float u_globalAlpha;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\nuniform float u_rotation;\nuniform vec4 u_renderExtent;\nuniform vec2 u_patternOrigin;\nuniform float u_depth;\nuniform mediump int u_hitDetection;\n\nconst float PI = 3.141592653589793238;\nconst float TWO_PI = 2.0 * PI;\nfloat currentLineMetric = 0.; // an actual value will be used in the stroke shaders\n",a=o();class l{constructor(){this.uniforms_=[],this.attributes_=[],this.varyings_=[],this.hasSymbol_=!1,this.symbolSizeExpression_=`vec2(${(0,r.$R)(a["circle-radius"])} + ${(0,r.$R)(.5*a["circle-stroke-width"])})`,this.symbolRotationExpression_="0.0",this.symbolOffsetExpression_="vec2(0.0)",this.symbolColorExpression_=(0,r.VO)(a["circle-fill-color"]),this.texCoordExpression_="vec4(0.0, 0.0, 1.0, 1.0)",this.discardExpression_="false",this.symbolRotateWithView_=!1,this.hasStroke_=!1,this.strokeWidthExpression_=(0,r.$R)(a["stroke-width"]),this.strokeColorExpression_=(0,r.VO)(a["stroke-color"]),this.strokeOffsetExpression_="0.",this.strokeCapExpression_=(0,r.Tl)("round"),this.strokeJoinExpression_=(0,r.Tl)("round"),this.strokeMiterLimitExpression_="10.",this.strokeDistanceFieldExpression_="-1000.",this.hasFill_=!1,this.fillColorExpression_=(0,r.VO)(a["fill-color"]),this.vertexShaderFunctions_=[],this.fragmentShaderFunctions_=[]}addUniform(e){return this.uniforms_.push(e),this}addAttribute(e){return this.attributes_.push(e),this}addVarying(e,t,n){return this.varyings_.push({name:e,type:t,expression:n}),this}setSymbolSizeExpression(e){return this.hasSymbol_=!0,this.symbolSizeExpression_=e,this}getSymbolSizeExpression(){return this.symbolSizeExpression_}setSymbolRotationExpression(e){return this.symbolRotationExpression_=e,this}setSymbolOffsetExpression(e){return this.symbolOffsetExpression_=e,this}getSymbolOffsetExpression(){return this.symbolOffsetExpression_}setSymbolColorExpression(e){return this.hasSymbol_=!0,this.symbolColorExpression_=e,this}getSymbolColorExpression(){return this.symbolColorExpression_}setTextureCoordinateExpression(e){return this.texCoordExpression_=e,this}setFragmentDiscardExpression(e){return this.discardExpression_=e,this}getFragmentDiscardExpression(){return this.discardExpression_}setSymbolRotateWithView(e){return this.symbolRotateWithView_=e,this}setStrokeWidthExpression(e){return this.hasStroke_=!0,this.strokeWidthExpression_=e,this}setStrokeColorExpression(e){return this.hasStroke_=!0,this.strokeColorExpression_=e,this}getStrokeColorExpression(){return this.strokeColorExpression_}setStrokeOffsetExpression(e){return this.strokeOffsetExpression_=e,this}setStrokeCapExpression(e){return this.strokeCapExpression_=e,this}setStrokeJoinExpression(e){return this.strokeJoinExpression_=e,this}setStrokeMiterLimitExpression(e){return this.strokeMiterLimitExpression_=e,this}setStrokeDistanceFieldExpression(e){return this.strokeDistanceFieldExpression_=e,this}setFillColorExpression(e){return this.hasFill_=!0,this.fillColorExpression_=e,this}getFillColorExpression(){return this.fillColorExpression_}addVertexShaderFunction(e){this.vertexShaderFunctions_.includes(e)||this.vertexShaderFunctions_.push(e)}addFragmentShaderFunction(e){this.fragmentShaderFunctions_.includes(e)||this.fragmentShaderFunctions_.push(e)}getSymbolVertexShader(){return this.hasSymbol_?`${s}\n${this.uniforms_.map(function(e){return"uniform "+e+";"}).join("\n")}\nattribute vec2 a_position;\nattribute float a_index;\nattribute vec4 a_hitColor;\n${this.attributes_.map(function(e){return"attribute "+e+";"}).join("\n")}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\nvarying vec4 v_hitColor;\nvarying vec2 v_centerPx;\nvarying float v_angle;\nvarying vec2 v_quadSizePx;\n${this.varyings_.map(function(e){return"varying "+e.type+" "+e.name+";"}).join("\n")}\n${this.vertexShaderFunctions_.join("\n")}\nvec2 pxToScreen(vec2 coordPx) {\n  vec2 scaled = coordPx / u_viewportSizePx / 0.5;\n  return scaled;\n}\n\nvec2 screenToPx(vec2 coordScreen) {\n  return (coordScreen * 0.5 + 0.5) * u_viewportSizePx;\n}\n\nvoid main(void) {\n  v_quadSizePx = ${this.symbolSizeExpression_};\n  vec2 halfSizePx = v_quadSizePx * 0.5;\n  vec2 centerOffsetPx = ${this.symbolOffsetExpression_};\n  vec2 offsetPx = centerOffsetPx;\n  if (a_index == 0.0) {\n    offsetPx -= halfSizePx;\n  } else if (a_index == 1.0) {\n    offsetPx += halfSizePx * vec2(1., -1.);\n  } else if (a_index == 2.0) {\n    offsetPx += halfSizePx;\n  } else {\n    offsetPx += halfSizePx * vec2(-1., 1.);\n  }\n  float angle = ${this.symbolRotationExpression_};\n  ${this.symbolRotateWithView_?"angle += u_rotation;":""}\n  float c = cos(-angle);\n  float s = sin(-angle);\n  offsetPx = vec2(c * offsetPx.x - s * offsetPx.y, s * offsetPx.x + c * offsetPx.y);\n  vec4 center = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n  gl_Position = center + vec4(pxToScreen(offsetPx), u_depth, 0.);\n  vec4 texCoord = ${this.texCoordExpression_};\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  v_hitColor = a_hitColor;\n  v_angle = angle;\n  c = cos(-v_angle);\n  s = sin(-v_angle);\n  centerOffsetPx = vec2(c * centerOffsetPx.x - s * centerOffsetPx.y, s * centerOffsetPx.x + c * centerOffsetPx.y); \n  v_centerPx = screenToPx(center.xy) + centerOffsetPx;\n${this.varyings_.map(function(e){return"  "+e.name+" = "+e.expression+";"}).join("\n")}\n}`:null}getSymbolFragmentShader(){return this.hasSymbol_?`${s}\n${this.uniforms_.map(function(e){return"uniform "+e+";"}).join("\n")}\nvarying vec2 v_texCoord;\nvarying vec4 v_hitColor;\nvarying vec2 v_centerPx;\nvarying float v_angle;\nvarying vec2 v_quadSizePx;\n${this.varyings_.map(function(e){return"varying "+e.type+" "+e.name+";"}).join("\n")}\n${this.fragmentShaderFunctions_.join("\n")}\n\nvoid main(void) {\n  if (${this.discardExpression_}) { discard; }\n  vec2 coordsPx = gl_FragCoord.xy / u_pixelRatio - v_centerPx; // relative to center\n  float c = cos(v_angle);\n  float s = sin(v_angle);\n  coordsPx = vec2(c * coordsPx.x - s * coordsPx.y, s * coordsPx.x + c * coordsPx.y);\n  gl_FragColor = ${this.symbolColorExpression_};\n  gl_FragColor.rgb *= gl_FragColor.a;\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.05) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`:null}getStrokeVertexShader(){return this.hasStroke_?`${s}\n${this.uniforms_.map(function(e){return"uniform "+e+";"}).join("\n")}\nattribute vec2 a_segmentStart;\nattribute vec2 a_segmentEnd;\nattribute float a_measureStart;\nattribute float a_measureEnd;\nattribute float a_parameters;\nattribute float a_distance;\nattribute vec2 a_joinAngles;\nattribute vec4 a_hitColor;\n${this.attributes_.map(function(e){return"attribute "+e+";"}).join("\n")}\nvarying vec2 v_segmentStart;\nvarying vec2 v_segmentEnd;\nvarying float v_angleStart;\nvarying float v_angleEnd;\nvarying float v_width;\nvarying vec4 v_hitColor;\nvarying float v_distanceOffsetPx;\nvarying float v_measureStart;\nvarying float v_measureEnd;\n${this.varyings_.map(function(e){return"varying "+e.type+" "+e.name+";"}).join("\n")}\n${this.vertexShaderFunctions_.join("\n")}\nvec2 worldToPx(vec2 worldPos) {\n  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);\n  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;\n}\n\nvec4 pxToScreen(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return vec4(screenPos, u_depth, 1.0);\n}\n\nbool isCap(float joinAngle) {\n  return joinAngle < -0.1;\n}\n\nvec2 getJoinOffsetDirection(vec2 normalPx, float joinAngle) {\n  float halfAngle = joinAngle / 2.0;\n  float c = cos(halfAngle);\n  float s = sin(halfAngle);\n  vec2 angleBisectorNormal = vec2(s * normalPx.x + c * normalPx.y, -c * normalPx.x + s * normalPx.y);\n  float length = 1.0 / s;\n  return angleBisectorNormal * length;\n}\n\nvec2 getOffsetPoint(vec2 point, vec2 normal, float joinAngle, float offsetPx) {\n  // if on a cap or the join angle is too high, offset the line along the segment normal\n  if (cos(joinAngle) > 0.998 || isCap(joinAngle)) {\n    return point - normal * offsetPx;\n  }\n  // offset is applied along the inverted normal (positive offset goes "right" relative to line direction)\n  return point - getJoinOffsetDirection(normal, joinAngle) * offsetPx;\n}\n\nvoid main(void) {\n  v_angleStart = a_joinAngles.x;\n  v_angleEnd = a_joinAngles.y;\n  float vertexNumber = floor(abs(a_parameters) / 10000. + 0.5);\n  currentLineMetric = vertexNumber < 1.5 ? a_measureStart : a_measureEnd;\n  // we're reading the fractional part while keeping the sign (so -4.12 gives -0.12, 3.45 gives 0.45)\n  float angleTangentSum = fract(abs(a_parameters) / 10000.) * 10000. * sign(a_parameters);\n\n  float lineWidth = ${this.strokeWidthExpression_};\n  float lineOffsetPx = ${this.strokeOffsetExpression_};\n\n  // compute segment start/end in px with offset\n  vec2 segmentStartPx = worldToPx(a_segmentStart);\n  vec2 segmentEndPx = worldToPx(a_segmentEnd);\n  vec2 tangentPx = normalize(segmentEndPx - segmentStartPx);\n  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);\n  segmentStartPx = getOffsetPoint(segmentStartPx, normalPx, v_angleStart, lineOffsetPx),\n  segmentEndPx = getOffsetPoint(segmentEndPx, normalPx, v_angleEnd, lineOffsetPx);\n  \n  // compute current vertex position\n  float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;\n  float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;\n  float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;\n  vec2 joinDirection;\n  vec2 positionPx = vertexNumber < 1.5 ? segmentStartPx : segmentEndPx;\n  // if angle is too high, do not make a proper join\n  if (cos(angle) > ${i.qS} || isCap(angle)) {\n    joinDirection = normalPx * normalDir - tangentPx * tangentDir;\n  } else {\n    joinDirection = getJoinOffsetDirection(normalPx * normalDir, angle);\n  }\n  positionPx = positionPx + joinDirection * (lineWidth * 0.5 + 1.); // adding 1 pixel for antialiasing\n  gl_Position = pxToScreen(positionPx);\n\n  v_segmentStart = segmentStartPx;\n  v_segmentEnd = segmentEndPx;\n  v_width = lineWidth;\n  v_hitColor = a_hitColor;\n  v_distanceOffsetPx = a_distance / u_resolution - (lineOffsetPx * angleTangentSum);\n  v_measureStart = a_measureStart;\n  v_measureEnd = a_measureEnd;\n${this.varyings_.map(function(e){return"  "+e.name+" = "+e.expression+";"}).join("\n")}\n}`:null}getStrokeFragmentShader(){return this.hasStroke_?`${s}\n${this.uniforms_.map(function(e){return"uniform "+e+";"}).join("\n")}\nvarying vec2 v_segmentStart;\nvarying vec2 v_segmentEnd;\nvarying float v_angleStart;\nvarying float v_angleEnd;\nvarying float v_width;\nvarying vec4 v_hitColor;\nvarying float v_distanceOffsetPx;\nvarying float v_measureStart;\nvarying float v_measureEnd;\n${this.varyings_.map(function(e){return"varying "+e.type+" "+e.name+";"}).join("\n")}\n${this.fragmentShaderFunctions_.join("\n")}\n\nvec2 pxToWorld(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;\n}\n\nbool isCap(float joinAngle) {\n  return joinAngle < -0.1;\n}\n\nfloat segmentDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  vec2 tangent = normalize(end - start);\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 startToPoint = point - start;\n  return abs(dot(startToPoint, normal)) - width * 0.5;\n}\n\nfloat buttCapDistanceField(vec2 point, vec2 start, vec2 end) {\n  vec2 startToPoint = point - start;\n  vec2 tangent = normalize(end - start);\n  return dot(startToPoint, -tangent);\n}\n\nfloat squareCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  return buttCapDistanceField(point, start, end) - width * 0.5;\n}\n\nfloat roundCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  float onSegment = max(0., 1000. * dot(point - start, end - start)); // this is very high when inside the segment\n  return length(point - start) - width * 0.5 - onSegment;\n}\n\nfloat roundJoinDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  return roundCapDistanceField(point, start, end, width);\n}\n\nfloat bevelJoinField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {\n  vec2 startToPoint = point - start;\n  vec2 tangent = normalize(end - start);\n  float c = cos(joinAngle * 0.5);\n  float s = sin(joinAngle * 0.5);\n  float direction = -sign(sin(joinAngle));\n  vec2 bisector = vec2(c * tangent.x - s * tangent.y, s * tangent.x + c * tangent.y);\n  float radius = width * 0.5 * s;\n  return dot(startToPoint, bisector * direction) - radius;\n}\n\nfloat miterJoinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {\n  if (cos(joinAngle) > ${i.qS}) { // avoid risking a division by zero\n    return bevelJoinField(point, start, end, width, joinAngle);\n  }\n  float miterLength = 1. / sin(joinAngle * 0.5);\n  float miterLimit = ${this.strokeMiterLimitExpression_};\n  if (miterLength > miterLimit) {\n    return bevelJoinField(point, start, end, width, joinAngle);\n  }\n  return -1000.;\n}\n\nfloat capDistanceField(vec2 point, vec2 start, vec2 end, float width, float capType) {\n   if (capType == ${(0,r.Tl)("butt")}) {\n    return buttCapDistanceField(point, start, end);\n  } else if (capType == ${(0,r.Tl)("square")}) {\n    return squareCapDistanceField(point, start, end, width);\n  }\n  return roundCapDistanceField(point, start, end, width);\n}\n\nfloat joinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float joinType) {\n  if (joinType == ${(0,r.Tl)("bevel")}) {\n    return bevelJoinField(point, start, end, width, joinAngle);\n  } else if (joinType == ${(0,r.Tl)("miter")}) {\n    return miterJoinDistanceField(point, start, end, width, joinAngle);\n  }\n  return roundJoinDistanceField(point, start, end, width);\n}\n\nfloat computeSegmentPointDistance(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float capType, float joinType) {\n  if (isCap(joinAngle)) {\n    return capDistanceField(point, start, end, width, capType);\n  }\n  return joinDistanceField(point, start, end, width, joinAngle, joinType);\n}\n\nvoid main(void) {\n  vec2 currentPoint = gl_FragCoord.xy / u_pixelRatio;\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  vec2 worldPos = pxToWorld(currentPoint);\n  if (\n    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (\n      worldPos[0] < u_renderExtent[0] ||\n      worldPos[1] < u_renderExtent[1] ||\n      worldPos[0] > u_renderExtent[2] ||\n      worldPos[1] > u_renderExtent[3]\n    )\n  ) {\n    discard;\n  }\n  #endif\n\n  float segmentLength = length(v_segmentEnd - v_segmentStart);\n  vec2 segmentTangent = (v_segmentEnd - v_segmentStart) / segmentLength;\n  vec2 segmentNormal = vec2(-segmentTangent.y, segmentTangent.x);\n  vec2 startToPoint = currentPoint - v_segmentStart;\n  float lengthToPoint = max(0., min(dot(segmentTangent, startToPoint), segmentLength));\n  float currentLengthPx = lengthToPoint + v_distanceOffsetPx; \n  float currentRadiusPx = abs(dot(segmentNormal, startToPoint));\n  float currentRadiusRatio = dot(segmentNormal, startToPoint) * 2. / v_width;\n  currentLineMetric = mix(v_measureStart, v_measureEnd, lengthToPoint / segmentLength);\n\n  if (${this.discardExpression_}) { discard; }\n\n  vec4 color = ${this.strokeColorExpression_};\n  float capType = ${this.strokeCapExpression_};\n  float joinType = ${this.strokeJoinExpression_};\n  float segmentStartDistance = computeSegmentPointDistance(currentPoint, v_segmentStart, v_segmentEnd, v_width, v_angleStart, capType, joinType);\n  float segmentEndDistance = computeSegmentPointDistance(currentPoint, v_segmentEnd, v_segmentStart, v_width, v_angleEnd, capType, joinType);\n  float distance = max(\n    segmentDistanceField(currentPoint, v_segmentStart, v_segmentEnd, v_width),\n    max(segmentStartDistance, segmentEndDistance)\n  );\n  distance = max(distance, ${this.strokeDistanceFieldExpression_});\n  color.a *= smoothstep(0.5, -0.5, distance);\n  gl_FragColor = color;\n  gl_FragColor.a *= u_globalAlpha;\n  gl_FragColor.rgb *= gl_FragColor.a;\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.1) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`:null}getFillVertexShader(){return this.hasFill_?`${s}\n${this.uniforms_.map(function(e){return"uniform "+e+";"}).join("\n")}\nattribute vec2 a_position;\nattribute vec4 a_hitColor;\n${this.attributes_.map(function(e){return"attribute "+e+";"}).join("\n")}\nvarying vec4 v_hitColor;\n${this.varyings_.map(function(e){return"varying "+e.type+" "+e.name+";"}).join("\n")}\n${this.vertexShaderFunctions_.join("\n")}\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, u_depth, 1.0);\n  v_hitColor = a_hitColor;\n${this.varyings_.map(function(e){return"  "+e.name+" = "+e.expression+";"}).join("\n")}\n}`:null}getFillFragmentShader(){return this.hasFill_?`${s}\n${this.uniforms_.map(function(e){return"uniform "+e+";"}).join("\n")}\nvarying vec4 v_hitColor;\n${this.varyings_.map(function(e){return"varying "+e.type+" "+e.name+";"}).join("\n")}\n${this.fragmentShaderFunctions_.join("\n")}\nvec2 pxToWorld(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;\n}\n\nvec2 worldToPx(vec2 worldPos) {\n  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);\n  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;\n}\n\nvoid main(void) {\n  vec2 pxPos = gl_FragCoord.xy / u_pixelRatio;\n  vec2 pxOrigin = worldToPx(u_patternOrigin);\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  vec2 worldPos = pxToWorld(pxPos);\n  if (\n    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (\n      worldPos[0] < u_renderExtent[0] ||\n      worldPos[1] < u_renderExtent[1] ||\n      worldPos[0] > u_renderExtent[2] ||\n      worldPos[1] > u_renderExtent[3]\n    )\n  ) {\n    discard;\n  }\n  #endif\n  if (${this.discardExpression_}) { discard; }\n  gl_FragColor = ${this.fillColorExpression_};\n  gl_FragColor.a *= u_globalAlpha;\n  gl_FragColor.rgb *= gl_FragColor.a;\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.1) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`:null}}},14969:function(e,t,n){var r=n(90025),i=n(90588);class o{constructor(e){this.highWaterMark=void 0!==e?e:2048,this.count_=0,this.entries_={},this.oldest_=null,this.newest_=null}deleteOldest(){const e=this.pop();e instanceof r.A&&e.dispose()}canExpireCache(){return this.highWaterMark>0&&this.getCount()>this.highWaterMark}expireCache(e){while(this.canExpireCache())this.deleteOldest()}clear(){while(this.oldest_)this.deleteOldest()}containsKey(e){return this.entries_.hasOwnProperty(e)}forEach(e){let t=this.oldest_;while(t)e(t.value_,t.key_,this),t=t.newer}get(e,t){const n=this.entries_[e];return(0,i.v)(void 0!==n,"Tried to get a value for a key that does not exist in the cache"),n===this.newest_||(n===this.oldest_?(this.oldest_=this.oldest_.newer,this.oldest_.older=null):(n.newer.older=n.older,n.older.newer=n.newer),n.newer=null,n.older=this.newest_,this.newest_.newer=n,this.newest_=n),n.value_}remove(e){const t=this.entries_[e];return(0,i.v)(void 0!==t,"Tried to get a value for a key that does not exist in the cache"),t===this.newest_?(this.newest_=t.older,this.newest_&&(this.newest_.newer=null)):t===this.oldest_?(this.oldest_=t.newer,this.oldest_&&(this.oldest_.older=null)):(t.newer.older=t.older,t.older.newer=t.newer),delete this.entries_[e],--this.count_,t.value_}getCount(){return this.count_}getKeys(){const e=new Array(this.count_);let t,n=0;for(t=this.newest_;t;t=t.older)e[n++]=t.key_;return e}getValues(){const e=new Array(this.count_);let t,n=0;for(t=this.newest_;t;t=t.older)e[n++]=t.value_;return e}peekLast(){return this.oldest_.value_}peekLastKey(){return this.oldest_.key_}peekFirstKey(){return this.newest_.key_}peek(e){return this.entries_[e]?.value_}pop(){const e=this.oldest_;return delete this.entries_[e.key_],e.newer&&(e.newer.older=null),this.oldest_=e.newer,this.oldest_||(this.newest_=null),--this.count_,e.value_}replace(e,t){this.get(e),this.entries_[e].value_=t}set(e,t){(0,i.v)(!(e in this.entries_),"Tried to set a value for a key that is used already");const n={key_:e,newer:null,older:this.newest_,value_:t};this.newest_?this.newest_.newer=n:this.oldest_=n,this.newest_=n,this.entries_[e]=n,++this.count_}setSize(e){this.highWaterMark=e}}t.A=o},20259:function(e,t,n){var r=n(90588),i=n(90130);const o={STATIC_DRAW:i.Ek,STREAM_DRAW:i.Ss,DYNAMIC_DRAW:i.Be};class s{constructor(e,t){this.array_=null,this.type_=e,(0,r.v)(e===i.H7||e===i.IP,"A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`"),this.usage_=void 0!==t?t:o.STATIC_DRAW}ofSize(e){return this.array_=new(a(this.type_))(e),this}fromArray(e){return this.array_=a(this.type_).from(e),this}fromArrayBuffer(e){return this.array_=new(a(this.type_))(e),this}getType(){return this.type_}getArray(){return this.array_}setArray(e){const t=a(this.type_);if(!(e instanceof t))throw new Error(`Expected ${t}`);this.array_=e}getUsage(){return this.usage_}getSize(){return this.array_?this.array_.length:0}}function a(e){switch(e){case i.H7:return Float32Array;case i.IP:return Uint32Array;default:return Float32Array}}t.Ay=s},27557:function(e,t,n){n.d(t,{L$:function(){return R},M7:function(){return P},uZ:function(){return v},nR:function(){return y},VO:function(){return f},Lm:function(){return p},z0:function(){return E},$R:function(){return c},Tl:function(){return m},Sl:function(){return T}});var r=n(85745),i=n(34799),o=n(6782);class s{constructor(e,t){this.name=e,this.data=t,this.texture_=null}getTexture(e){if(!this.texture_){const t=e.createTexture();e.bindTexture(e.TEXTURE_2D,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,this.data.length/4,1,0,e.RGBA,e.UNSIGNED_BYTE,this.data),this.texture_=t}return this.texture_}delete(e){this.texture_&&e.deleteTexture(this.texture_),this.texture_=null}}var a=s,l=n(49825);function h(e,t){return`operator_${e}_${Object.keys(t.functions).length}`}function c(e){const t=e.toString();return t.includes(".")?t:t+".0"}function u(e){if(e.length<2||e.length>4)throw new Error("`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.");return`vec${e.length}(${e.map(c).join(", ")})`}function f(e){const t=(0,r._j)(e),n=t.length>3?t[3]:1;return u([t[0]/255,t[1]/255,t[2]/255,n])}function _(e){const t=(0,o.xq)(e);return u(t)}const d={};let g=0;function p(e){return e in d||(d[e]=g++),d[e]}function m(e){return c(p(e))}function T(e){return"u_var_"+e}function E(){return{inFragmentShader:!1,variables:{},properties:{},functions:{},bandCount:0,featureId:!1,geometryType:!1}}const x="getBandValue",v="u_paletteTextures",R="featureId",P="geometryType";function y(e,t,n,r){const i=(0,l.qg)(e,t,n);return b(i,t,r)}function S(e){return(t,n,r)=>{const i=n.args.length,o=new Array(i);for(let e=0;e<i;++e)o[e]=b(n.args[e],r,t);return e(o,t)}}const A={[l.ZD.Get]:(e,t)=>{const n=t.args[0],r=n.value,i=r in e.properties;i||(e.properties[r]={name:r,type:t.type});const o=e.inFragmentShader?"v_prop_":"a_prop_";return o+r},[l.ZD.Id]:e=>{e.featureId=!0;const t=e.inFragmentShader?"v_":"a_";return t+R},[l.ZD.GeometryType]:e=>{e.geometryType=!0;const t=e.inFragmentShader?"v_":"a_";return t+P},[l.ZD.LineMetric]:()=>"currentLineMetric",[l.ZD.Var]:(e,t)=>{const n=t.args[0],r=n.value,i=r in e.variables;return i||(e.variables[r]={name:r,type:t.type}),T(r)},[l.ZD.Resolution]:()=>"u_resolution",[l.ZD.Zoom]:()=>"u_zoom",[l.ZD.Time]:()=>"u_time",[l.ZD.Any]:S(e=>`(${e.join(" || ")})`),[l.ZD.All]:S(e=>`(${e.join(" && ")})`),[l.ZD.Not]:S(([e])=>`(!${e})`),[l.ZD.Equal]:S(([e,t])=>`(${e} == ${t})`),[l.ZD.NotEqual]:S(([e,t])=>`(${e} != ${t})`),[l.ZD.GreaterThan]:S(([e,t])=>`(${e} > ${t})`),[l.ZD.GreaterThanOrEqualTo]:S(([e,t])=>`(${e} >= ${t})`),[l.ZD.LessThan]:S(([e,t])=>`(${e} < ${t})`),[l.ZD.LessThanOrEqualTo]:S(([e,t])=>`(${e} <= ${t})`),[l.ZD.Multiply]:S(e=>`(${e.join(" * ")})`),[l.ZD.Divide]:S(([e,t])=>`(${e} / ${t})`),[l.ZD.Add]:S(e=>`(${e.join(" + ")})`),[l.ZD.Subtract]:S(([e,t])=>`(${e} - ${t})`),[l.ZD.Clamp]:S(([e,t,n])=>`clamp(${e}, ${t}, ${n})`),[l.ZD.Mod]:S(([e,t])=>`mod(${e}, ${t})`),[l.ZD.Pow]:S(([e,t])=>`pow(${e}, ${t})`),[l.ZD.Abs]:S(([e])=>`abs(${e})`),[l.ZD.Floor]:S(([e])=>`floor(${e})`),[l.ZD.Ceil]:S(([e])=>`ceil(${e})`),[l.ZD.Round]:S(([e])=>`floor(${e} + 0.5)`),[l.ZD.Sin]:S(([e])=>`sin(${e})`),[l.ZD.Cos]:S(([e])=>`cos(${e})`),[l.ZD.Atan]:S(([e,t])=>void 0!==t?`atan(${e}, ${t})`:`atan(${e})`),[l.ZD.Sqrt]:S(([e])=>`sqrt(${e})`),[l.ZD.Match]:S(e=>{const t=e[0],n=e[e.length-1];let r=null;for(let i=e.length-3;i>=1;i-=2){const o=e[i],s=e[i+1];r=`(${t} == ${o} ? ${s} : ${r||n})`}return r}),[l.ZD.Between]:S(([e,t,n])=>`(${e} >= ${t} && ${e} <= ${n})`),[l.ZD.Interpolate]:S(([e,t,...n])=>{let r="";for(let i=0;i<n.length-2;i+=2){const o=n[i],s=r||n[i+1],a=n[i+2],l=n[i+3];let h;h=e===c(1)?`(${t} - ${o}) / (${a} - ${o})`:`(pow(${e}, (${t} - ${o})) - 1.0) / (pow(${e}, (${a} - ${o})) - 1.0)`,r=`mix(${s}, ${l}, clamp(${h}, 0.0, 1.0))`}return r}),[l.ZD.Case]:S(e=>{const t=e[e.length-1];let n=null;for(let r=e.length-3;r>=0;r-=2){const i=e[r],o=e[r+1];n=`(${i} ? ${o} : ${n||t})`}return n}),[l.ZD.In]:S(([e,...t],n)=>{const r=h("in",n),i=[];for(let o=0;o<t.length;o+=1)i.push(`  if (inputValue == ${t[o]}) { return true; }`);return n.functions[r]=`bool ${r}(float inputValue) {\n${i.join("\n")}\n  return false;\n}`,`${r}(${e})`}),[l.ZD.Array]:S(e=>`vec${e.length}(${e.join(", ")})`),[l.ZD.Color]:S(e=>{if(1===e.length)return`vec4(vec3(${e[0]} / 255.0), 1.0)`;if(2===e.length)return`vec4(vec3(${e[0]} / 255.0), ${e[1]})`;const t=e.slice(0,3).map(e=>`${e} / 255.0`);if(3===e.length)return`vec4(${t.join(", ")}, 1.0)`;const n=e[3];return`vec4(${t.join(", ")}, ${n})`}),[l.ZD.Band]:S(([e,t,n],r)=>{if(!(x in r.functions)){let e="";const t=r.bandCount||1;for(let n=0;n<t;n++){const r=Math.floor(n/4);let o=n%4;n===t-1&&1===o&&(o=3);const s=`${i.gF.TILE_TEXTURE_ARRAY}[${r}]`;e+=`  if (band == ${n+1}.0) {\n    return texture2D(${s}, v_textureCoord + vec2(dx, dy))[${o}];\n  }\n`}r.functions[x]=`float getBandValue(float band, float xOffset, float yOffset) {\n  float dx = xOffset / ${i.gF.TEXTURE_PIXEL_WIDTH};\n  float dy = yOffset / ${i.gF.TEXTURE_PIXEL_HEIGHT};\n${e}\n}`}return`${x}(${e}, ${t??"0.0"}, ${n??"0.0"})`}),[l.ZD.Palette]:(e,t)=>{const[n,...i]=t.args,o=i.length,s=new Uint8Array(4*o);for(let a=0;a<i.length;a++){const e=i[a].value,t=(0,r._j)(e),n=4*a;s[n]=t[0],s[n+1]=t[1],s[n+2]=t[2],s[n+3]=255*t[3]}e.paletteTextures||(e.paletteTextures=[]);const h=`${v}[${e.paletteTextures.length}]`,c=new a(h,s);e.paletteTextures.push(c);const u=b(n,l.wl,e);return`texture2D(${h}, vec2((${u} + 0.5) / ${o}.0, 0.5))`}};function b(e,t,n){if(e instanceof l.DG){const r=A[e.operator];if(void 0===r)throw new Error(`No compiler defined for this operator: ${JSON.stringify(e.operator)}`);return r(n,e,t)}if((e.type&l.wl)>0)return c(e.value);if((e.type&l.T8)>0)return e.value.toString();if((e.type&l.cT)>0)return m(e.value.toString());if((e.type&l.mE)>0)return f(e.value);if((e.type&l.Fq)>0)return u(e.value);if((e.type&l.qA)>0)return _(e.value);throw new Error(`Unexpected expression ${e.value} (expected type ${(0,l.go)(t)})`)}},27607:function(e,t,n){n.d(t,{$r:function(){return c},bL:function(){return a},xo:function(){return s}});var r=n(8143),i=n(11078),o=n(68711);function s(e){return e instanceof Image||e instanceof HTMLCanvasElement||e instanceof HTMLVideoElement||e instanceof ImageBitmap?e:null}function a(e){return e instanceof Uint8Array||e instanceof Uint8ClampedArray||e instanceof Float32Array||e instanceof DataView?e:null}const l=new Error("disposed");let h=null;function c(e){h||(h=(0,o.Y)(e.width,e.height,void 0,{willReadFrequently:!0}));const t=h.canvas,n=e.width;t.width!==n&&(t.width=n);const r=e.height;return t.height!==r&&(t.height=r),h.clearRect(0,0,n,r),h.drawImage(e,0,0),h.getImageData(0,0,n,r).data}const u=[256,256];class f extends r.A{constructor(e){const t=i.A.IDLE;super(e.tileCoord,t,{transition:e.transition,interpolate:e.interpolate}),this.loader_=e.loader,this.data_=null,this.error_=null,this.size_=e.size||null,this.controller_=e.controller||null}getSize(){if(this.size_)return this.size_;const e=s(this.data_);return e?[e.width,e.height]:u}getData(){return this.data_}getError(){return this.error_}load(){if(this.state!==i.A.IDLE&&this.state!==i.A.ERROR)return;this.state=i.A.LOADING,this.changed();const e=this;this.loader_().then(function(t){e.data_=t,e.state=i.A.LOADED,e.changed()}).catch(function(t){e.error_=t,e.state=i.A.ERROR,e.changed()})}disposeInternal(){this.controller_&&(this.controller_.abort(l),this.controller_=null),super.disposeInternal()}}t.Ay=f},32627:function(e,t,n){n.d(t,{LW:function(){return o},bA:function(){return i},iA:function(){return s},qS:function(){return r}});const r=.985;function i(e,t){t=t||[];const n=256,r=n-1;return t[0]=Math.floor(e/n/n/n)/r,t[1]=Math.floor(e/n/n)%n/r,t[2]=Math.floor(e/n)%n/r,t[3]=e%n/r,t}function o(e){let t=0;const n=256,r=n-1;return t+=Math.round(e[0]*n*n*n*r),t+=Math.round(e[1]*n*n*r),t+=Math.round(e[2]*n*r),t+=Math.round(e[3]*r),t}function s(e){const t=Array.isArray(e)?e:[e];if("style"in t[0]){const e=[],n=t,r=[];for(const t of n){const n=Array.isArray(t.style)?t.style:[t.style];let i=t.filter;t.else&&r.length&&(i=["all",...r.map(e=>["!",e])],t.filter&&i.push(t.filter),i.length<3&&(i=i[1])),t.filter&&r.push(t.filter);const o=n.map(e=>({style:e,...i&&{filter:i}}));e.push(...o)}return e}return"builder"in t[0]?t:t.map(e=>({style:e}))}},34799:function(e,t,n){n.d(t,{eS:function(){return A},gF:function(){return S},Ay:function(){return D}});var r=n(11078),i=n(70915),o=n(38599),s=n(6782),a=n(9703),l=n(83954),h=n(20259),c=n(63722),u=n(27607),f=n(40190),_=n(68711),d=n(97404),g=n(90130),p=n(69049);function m(e,t,n){const r=n?e.LINEAR:e.NEAREST;e.bindTexture(e.TEXTURE_2D,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,r),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,r)}function T(e,t,n,r){m(e,t,r),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)}function E(e,t,n,r,i,o){const s=e.getGL();let a,l;if(n instanceof Float32Array){a=s.FLOAT,e.getExtension("OES_texture_float");const t=e.getExtension("OES_texture_float_linear");l=null!==t}else a=s.UNSIGNED_BYTE,l=!0;m(s,t,o&&l);const h=n.byteLength/r[1];let c,u=1;switch(h%8===0?u=8:h%4===0?u=4:h%2===0&&(u=2),i){case 1:c=s.LUMINANCE;break;case 2:c=s.LUMINANCE_ALPHA;break;case 3:c=s.RGB;break;case 4:c=s.RGBA;break;default:throw new Error(`Unsupported number of bands: ${i}`)}const f=s.getParameter(s.UNPACK_ALIGNMENT);s.pixelStorei(s.UNPACK_ALIGNMENT,u),s.texImage2D(s.TEXTURE_2D,0,c,r[0],r[1],0,c,a,n),s.pixelStorei(s.UNPACK_ALIGNMENT,f)}let x=null;function v(){x=(0,_.Y)(1,1,void 0,{willReadFrequently:!0})}class R extends p.A{constructor(e){super(e),this.textures=[],this.renderSize_=(0,s.xq)(e.grid.getTileSize(e.tile.tileCoord[0])),this.bandCount=NaN;const t=new h.Ay(g.H7,g.Ek);t.fromArray([0,1,1,1,1,0,0,0]),this.helper.flushBufferData(t),this.coords=t,this.setTile(e.tile)}setHelper(e){const t=this.helper?.getGL();if(t){this.helper.deleteBuffer(this.coords);for(let e=0;e<this.textures.length;++e)t.deleteTexture(this.textures[e])}super.setHelper(e),e&&e.flushBufferData(this.coords)}uploadTile(){const e=this.helper,t=e.getGL(),n=this.tile;let r;this.textures.length=0,r=n instanceof f.A||n instanceof d.A?n.getImage():n.getData();const i=(0,u.xo)(r);if(i){const e=t.createTexture();return this.textures.push(e),this.bandCount=4,T(t,e,i,n.interpolate),void this.setReady()}r=(0,u.bL)(r);const o=n.getSize(),s=[o[0]+2*this.gutter,o[1]+2*this.gutter],a=r instanceof Float32Array,l=s[0]*s[1],h=a?Float32Array:Uint8Array,c=h.BYTES_PER_ELEMENT,_=r.byteLength/s[1];this.bandCount=Math.floor(_/c/s[0]);const g=Math.ceil(this.bandCount/4);if(1===g){const i=t.createTexture();return this.textures.push(i),E(e,i,r,s,this.bandCount,n.interpolate),void this.setReady()}const p=new Array(g);for(let u=0;u<g;++u){const e=t.createTexture();this.textures.push(e);const n=u<g-1?4:(this.bandCount-1)%4+1;p[u]=new h(l*n)}let m=0,x=0;const v=s[0]*this.bandCount;for(let u=0;u<s[1];++u){for(let e=0;e<v;++e){const t=r[x+e],n=Math.floor(m/this.bandCount),i=e%this.bandCount,o=Math.floor(i/4),s=p[o],a=s.length/l,h=i%4;s[n*a+h]=t,++m}x+=_/c}for(let u=0;u<g;++u){const t=this.textures[u],r=p[u],i=r.length/l;E(e,t,r,s,i,n.interpolate)}this.setReady()}getImagePixelData_(e,t,n){const r=this.gutter,i=this.renderSize_[0],o=this.renderSize_[1];x||v(),x.clearRect(0,0,1,1);const s=e.width,a=e.height,l=s-2*r,h=a-2*r,c=r+Math.floor(l*(t/i)),u=r+Math.floor(h*(n/o));let f;try{x.drawImage(e,c,u,1,1,0,0,1,1),f=x.getImageData(0,0,1,1).data}catch{return x=null,null}return f}getArrayPixelData_(e,t,n,r){const i=this.gutter,o=this.renderSize_[0],s=this.renderSize_[1],a=t[0],l=t[1],h=a+2*i,c=l+2*i,u=i+Math.floor(a*(n/o)),f=i+Math.floor(l*(r/s));if(e instanceof DataView){const t=e.byteLength/(h*c),n=t*(f*h+u),r=e.buffer.slice(n,n+t);return new DataView(r)}const _=this.bandCount*(f*h+u);return e.slice(_,_+this.bandCount)}getPixelData(e,t){if(!this.loaded)return null;if(this.tile instanceof u.Ay){const n=this.tile.getData(),r=(0,u.bL)(n);if(r){const n=this.tile.getSize();return this.getArrayPixelData_(r,n,e,t)}return this.getImagePixelData_((0,u.xo)(n),e,t)}return this.getImagePixelData_(this.tile.getImage(),e,t)}}var P=R,y=n(8001);const S={...y.gF,TILE_TEXTURE_ARRAY:"u_tileTextures",TEXTURE_PIXEL_WIDTH:"u_texturePixelWidth",TEXTURE_PIXEL_HEIGHT:"u_texturePixelHeight",TEXTURE_RESOLUTION:"u_textureResolution",TEXTURE_ORIGIN_X:"u_textureOriginX",TEXTURE_ORIGIN_Y:"u_textureOriginY"},A={TEXTURE_COORD:"a_textureCoord"},b=[{name:A.TEXTURE_COORD,size:2,type:c.jQ.FLOAT}];class C extends y.Ay{constructor(e,t){super(e,t),this.program_,this.vertexShader_=t.vertexShader,this.fragmentShader_=t.fragmentShader,this.indices_=new h.Ay(g.IP,g.Ek),this.indices_.fromArray([0,1,3,1,2,3]),this.paletteTextures_=t.paletteTextures||[]}reset(e){if(super.reset(e),this.helper){const e=this.helper.getGL();for(const t of this.paletteTextures_)t.delete(e)}if(this.vertexShader_=e.vertexShader,this.fragmentShader_=e.fragmentShader,this.paletteTextures_=e.paletteTextures||[],this.helper){this.program_=this.helper.getProgram(this.fragmentShader_,this.vertexShader_);const e=this.helper.getGL();for(const t of this.paletteTextures_)t.getTexture(e)}}afterHelperCreated(){super.afterHelperCreated();const e=this.helper.getGL();for(const t of this.paletteTextures_)t.getTexture(e);this.program_=this.helper.getProgram(this.fragmentShader_,this.vertexShader_),this.helper.flushBufferData(this.indices_)}removeHelper(){if(this.helper){const e=this.helper.getGL();for(const t of this.paletteTextures_)t.delete(e)}super.removeHelper()}createTileRepresentation(e){return new P(e)}beforeTilesRender(e,t){super.beforeTilesRender(e,t),this.helper.useProgram(this.program_,e)}renderTile(e,t,n,r,o,s,a,h,c,u,f){const _=this.helper.getGL();this.helper.bindBuffer(e.coords),this.helper.bindBuffer(this.indices_),this.helper.enableAttributes(b);let d=0;while(d<e.textures.length){const t=`${S.TILE_TEXTURE_ARRAY}[${d}]`;this.helper.bindTexture(e.textures[d],d,t),++d}for(let i=0;i<this.paletteTextures_.length;++i){const e=this.paletteTextures_[i],t=e.getTexture(_);this.helper.bindTexture(t,d,e.name),++d}const g=n.viewState,p=s[0]+2*u,m=s[1]+2*u,T=e.tile,E=T.tileCoord,x=E[1],v=E[2];this.helper.setUniformMatrixValue(S.TILE_TRANSFORM,(0,l.Z1)(this.tempMat4,t)),this.helper.setUniformFloatValue(S.TRANSITION_ALPHA,f),this.helper.setUniformFloatValue(S.DEPTH,c);let R=r;u>0&&(R=h,(0,i._N)(R,r,R)),this.helper.setUniformFloatVec4(S.RENDER_EXTENT,R),this.helper.setUniformFloatValue(S.RESOLUTION,g.resolution),this.helper.setUniformFloatValue(S.ZOOM,g.zoom),this.helper.setUniformFloatValue(S.TEXTURE_PIXEL_WIDTH,p),this.helper.setUniformFloatValue(S.TEXTURE_PIXEL_HEIGHT,m),this.helper.setUniformFloatValue(S.TEXTURE_RESOLUTION,o),this.helper.setUniformFloatValue(S.TEXTURE_ORIGIN_X,a[0]+x*s[0]*o-u*o),this.helper.setUniformFloatValue(S.TEXTURE_ORIGIN_Y,a[1]-v*s[1]*o+u*o),this.helper.drawElements(0,this.indices_.getSize())}getData(e){const t=this.helper.getGL();if(!t)return null;const n=this.frameState;if(!n)return null;const l=this.getLayer(),h=(0,a.Bb)(n.pixelToCoordinateTransform,e.slice()),c=n.viewState,u=l.getExtent();if(u&&!(0,i.Ym)((0,o.SD)(u,c.projection),h))return null;const f=l.getSources((0,i.Tr)([h]),c.resolution);let _,d,g;for(_=f.length-1;_>=0;--_)if(d=f[_],"ready"===d.getState()){if(g=d.getTileGridForProjection(c.projection),d.getWrapX())break;const e=g.getExtent();if(!e||(0,i.Ym)(e,h))break}if(_<0)return null;const p=this.tileRepresentationCache;for(let i=g.getZForResolution(c.resolution);i>=g.getMinZoom();--i){const e=g.getTileCoordForCoordAndZ(h,i),t=(0,y.et)(d,e);if(!p.containsKey(t))continue;const n=p.get(t),o=n.tile;if(o.getState()===r.A.EMPTY)return null;if(!n.loaded)continue;const a=g.getOrigin(i),l=(0,s.xq)(g.getTileSize(i)),c=g.getResolution(i),u=(h[0]-a[0])/c-e[1]*l[0],f=(a[1]-h[1])/c-e[2]*l[1];return n.getPixelData(u,f)}return null}disposeInternal(){const e=this.helper;if(e){const t=e.getGL();for(const e of this.paletteTextures_)e.delete(t);this.paletteTextures_.length=0,t.deleteProgram(this.program_),delete this.program_,e.deleteBuffer(this.indices_)}super.disposeInternal(),delete this.indices_}}var D=C},60492:function(e,t,n){var r=n(75332),i=n(9960),o=n(83984),s=n(9703),a=n(63722),l=n(5986);class h extends l.A{constructor(e,t){super(e),t=t||{},this.inversePixelTransform_=(0,s.vt)(),this.postProcesses_=t.postProcesses,this.uniforms_=t.uniforms,this.helper,this.onMapChanged_=()=>{this.clearCache(),this.removeHelper()},e.addChangeListener(r["default"].MAP,this.onMapChanged_),this.dispatchPreComposeEvent=this.dispatchPreComposeEvent.bind(this),this.dispatchPostComposeEvent=this.dispatchPostComposeEvent.bind(this)}dispatchPreComposeEvent(e,t){const n=this.getLayer();if(n.hasListener(o.A.PRECOMPOSE)){const r=new i.A(o.A.PRECOMPOSE,void 0,t,e);n.dispatchEvent(r)}}dispatchPostComposeEvent(e,t){const n=this.getLayer();if(n.hasListener(o.A.POSTCOMPOSE)){const r=new i.A(o.A.POSTCOMPOSE,void 0,t,e);n.dispatchEvent(r)}}reset(e){this.uniforms_=e.uniforms,this.helper&&this.helper.setUniforms(this.uniforms_)}removeHelper(){this.helper&&(this.helper.dispose(),delete this.helper)}prepareFrame(e){if(this.getLayer().getRenderSource()){let t,n=!0,r=-1;for(let o=0,s=e.layerStatesArray.length;o<s;o++){const i=e.layerStatesArray[o].layer,s=i.getRenderer();if(!(s instanceof h)){n=!0;continue}const a=i.getClassName();if((n||a!==t)&&(r+=1,n=!1),t=a,s===this)break}const i="map/"+e.mapId+"/group/"+r;this.helper&&this.helper.canvasCacheKeyMatches(i)&&!this.helper.needsToBeRecreated()||(this.removeHelper(),this.helper=new a.Ay({postProcesses:this.postProcesses_,uniforms:this.uniforms_,canvasCacheKey:i}),t&&(this.helper.getCanvas().className=t),this.afterHelperCreated())}return this.prepareFrameInternal(e)}afterHelperCreated(){}prepareFrameInternal(e){return!0}clearCache(){}disposeInternal(){this.clearCache(),this.removeHelper(),this.getLayer()?.removeChangeListener(r["default"].MAP,this.onMapChanged_),super.disposeInternal()}dispatchRenderEvent_(e,t,n){const r=this.getLayer();if(r.hasListener(e)){(0,s.Zz)(this.inversePixelTransform_,0,0,n.pixelRatio,-n.pixelRatio,0,0,-n.size[1]);const o=new i.A(e,this.inversePixelTransform_,n,t);r.dispatchEvent(o)}}preRender(e,t){this.dispatchRenderEvent_(o.A.PRERENDER,e,t)}postRender(e,t){this.dispatchRenderEvent_(o.A.POSTRENDER,e,t)}}t.A=h},63722:function(e,t,n){n.d(t,{jQ:function(){return g},M8:function(){return d},Ay:function(){return S}});var r=n(90025),i=n(43530),o=n(9703),s=n(4087),a=n(83954),l={LOST:"webglcontextlost",RESTORED:"webglcontextrestored"},h=n(90130);const c="\n  precision mediump float;\n\n  attribute vec2 a_position;\n  varying vec2 v_texCoord;\n  varying vec2 v_screenCoord;\n\n  uniform vec2 u_screenSize;\n\n  void main() {\n    v_texCoord = a_position * 0.5 + 0.5;\n    v_screenCoord = v_texCoord * u_screenSize;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n  }\n",u="\n  precision mediump float;\n\n  uniform sampler2D u_image;\n  uniform float u_opacity;\n\n  varying vec2 v_texCoord;\n\n  void main() {\n    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n  }\n";class f{constructor(e){this.gl_=e.webGlContext;const t=this.gl_;this.scaleRatio_=e.scaleRatio||1,this.renderTargetTexture_=t.createTexture(),this.renderTargetTextureSize_=null,this.frameBuffer_=t.createFramebuffer(),this.depthBuffer_=t.createRenderbuffer();const n=t.createShader(t.VERTEX_SHADER);t.shaderSource(n,e.vertexShader||c),t.compileShader(n);const r=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(r,e.fragmentShader||u),t.compileShader(r),this.renderTargetProgram_=t.createProgram(),t.attachShader(this.renderTargetProgram_,n),t.attachShader(this.renderTargetProgram_,r),t.linkProgram(this.renderTargetProgram_),this.renderTargetVerticesBuffer_=t.createBuffer();const i=[-1,-1,1,-1,-1,1,1,-1,1,1,-1,1];t.bindBuffer(t.ARRAY_BUFFER,this.renderTargetVerticesBuffer_),t.bufferData(t.ARRAY_BUFFER,new Float32Array(i),t.STATIC_DRAW),this.renderTargetAttribLocation_=t.getAttribLocation(this.renderTargetProgram_,"a_position"),this.renderTargetUniformLocation_=t.getUniformLocation(this.renderTargetProgram_,"u_screenSize"),this.renderTargetOpacityLocation_=t.getUniformLocation(this.renderTargetProgram_,"u_opacity"),this.renderTargetTextureLocation_=t.getUniformLocation(this.renderTargetProgram_,"u_image"),this.uniforms_=[],e.uniforms&&Object.keys(e.uniforms).forEach(n=>{this.uniforms_.push({value:e.uniforms[n],location:t.getUniformLocation(this.renderTargetProgram_,n)})})}getRenderTargetTexture(){return this.renderTargetTexture_}getGL(){return this.gl_}init(e){const t=this.getGL(),n=[t.drawingBufferWidth*this.scaleRatio_,t.drawingBufferHeight*this.scaleRatio_];if(t.bindFramebuffer(t.FRAMEBUFFER,this.getFrameBuffer()),t.bindRenderbuffer(t.RENDERBUFFER,this.getDepthBuffer()),t.viewport(0,0,n[0],n[1]),!this.renderTargetTextureSize_||this.renderTargetTextureSize_[0]!==n[0]||this.renderTargetTextureSize_[1]!==n[1]){this.renderTargetTextureSize_=n;const e=0,r=t.RGBA,i=0,o=t.RGBA,s=t.UNSIGNED_BYTE,a=null;t.bindTexture(t.TEXTURE_2D,this.renderTargetTexture_),t.texImage2D(t.TEXTURE_2D,e,r,n[0],n[1],i,o,s,a),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.renderTargetTexture_,0),t.renderbufferStorage(t.RENDERBUFFER,t.DEPTH_COMPONENT16,n[0],n[1]),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.RENDERBUFFER,this.depthBuffer_)}}apply(e,t,n,r){const i=this.getGL(),o=e.size;if(i.bindFramebuffer(i.FRAMEBUFFER,t?t.getFrameBuffer():null),i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,this.renderTargetTexture_),!t){const t=(0,s.v6)(i.canvas);if(!e.renderTargets[t]){const n=i.getContextAttributes();n&&n.preserveDrawingBuffer&&(i.clearColor(0,0,0,0),i.clearDepth(1),i.clear(i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT)),e.renderTargets[t]=!0}}i.disable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFunc(i.ONE,i.ONE_MINUS_SRC_ALPHA),i.viewport(0,0,i.drawingBufferWidth,i.drawingBufferHeight),i.bindBuffer(i.ARRAY_BUFFER,this.renderTargetVerticesBuffer_),i.useProgram(this.renderTargetProgram_),i.enableVertexAttribArray(this.renderTargetAttribLocation_),i.vertexAttribPointer(this.renderTargetAttribLocation_,2,i.FLOAT,!1,0,0),i.uniform2f(this.renderTargetUniformLocation_,o[0],o[1]),i.uniform1i(this.renderTargetTextureLocation_,0);const a=e.layerStatesArray[e.layerIndex].opacity;i.uniform1f(this.renderTargetOpacityLocation_,a),this.applyUniforms(e),n&&n(i,e),i.drawArrays(i.TRIANGLES,0,6),r&&r(i,e)}getFrameBuffer(){return this.frameBuffer_}getDepthBuffer(){return this.depthBuffer_}applyUniforms(e){const t=this.getGL();let n,r=1;this.uniforms_.forEach(function(i){if(n="function"===typeof i.value?i.value(e):i.value,n instanceof HTMLCanvasElement||n instanceof ImageData)i.texture||(i.texture=t.createTexture()),t.activeTexture(t[`TEXTURE${r}`]),t.bindTexture(t.TEXTURE_2D,i.texture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),n instanceof ImageData?t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,n.width,n.height,0,t.UNSIGNED_BYTE,new Uint8Array(n.data)):t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n),t.uniform1i(i.location,r++);else if(Array.isArray(n))switch(n.length){case 2:return void t.uniform2f(i.location,n[0],n[1]);case 3:return void t.uniform3f(i.location,n[0],n[1],n[2]);case 4:return void t.uniform4f(i.location,n[0],n[1],n[2],n[3]);default:return}else"number"===typeof n&&t.uniform1f(i.location,n)})}}var _=f;const d={PROJECTION_MATRIX:"u_projectionMatrix",SCREEN_TO_WORLD_MATRIX:"u_screenToWorldMatrix",TIME:"u_time",ZOOM:"u_zoom",RESOLUTION:"u_resolution",ROTATION:"u_rotation",VIEWPORT_SIZE_PX:"u_viewportSizePx",PIXEL_RATIO:"u_pixelRatio",HIT_DETECTION:"u_hitDetection"},g={UNSIGNED_BYTE:h.l4,UNSIGNED_SHORT:h.JL,UNSIGNED_INT:h.UD,FLOAT:h.zH},p={};function m(e){return"shared/"+e}let T=0;function E(){const e="unique/"+T;return T+=1,e}function x(e){let t=p[e];if(!t){const n=document.createElement("canvas");n.width=1,n.height=1,n.style.position="absolute",n.style.left="0";const r=(0,h.SD)(n);t={users:0,context:r},p[e]=t}return t.users+=1,t.context}function v(e){const t=p[e];if(!t)return;if(t.users-=1,t.users>0)return;const n=t.context,r=n.getExtension("WEBGL_lose_context");r&&r.loseContext();const i=n.canvas;i.width=1,i.height=1,delete p[e]}class R extends r.A{constructor(e){super(),e=e||{},this.boundHandleWebGLContextLost_=this.handleWebGLContextLost.bind(this),this.boundHandleWebGLContextRestored_=this.handleWebGLContextRestored.bind(this),this.canvasCacheKey_=e.canvasCacheKey?m(e.canvasCacheKey):E(),this.gl_=x(this.canvasCacheKey_),this.bufferCache_={},this.extensionCache_={},this.currentProgram_=null,this.needsToBeRecreated_=!1;const t=this.gl_.canvas;t.addEventListener(l.LOST,this.boundHandleWebGLContextLost_),t.addEventListener(l.RESTORED,this.boundHandleWebGLContextRestored_),this.offsetRotateMatrix_=(0,o.vt)(),this.offsetScaleMatrix_=(0,o.vt)(),this.tmpMat4_=(0,a.vt)(),this.uniformLocationsByProgram_={},this.attribLocationsByProgram_={},this.uniforms_=[],e.uniforms&&this.setUniforms(e.uniforms),this.postProcessPasses_=e.postProcesses?e.postProcesses.map(e=>new _({webGlContext:this.gl_,scaleRatio:e.scaleRatio,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader,uniforms:e.uniforms})):[new _({webGlContext:this.gl_})],this.shaderCompileErrors_=null,this.startTime_=Date.now()}setUniforms(e){this.uniforms_=[],this.addUniforms(e)}addUniforms(e){for(const t in e)this.uniforms_.push({name:t,value:e[t]})}canvasCacheKeyMatches(e){return this.canvasCacheKey_===m(e)}getExtension(e){if(e in this.extensionCache_)return this.extensionCache_[e];const t=this.gl_.getExtension(e);return this.extensionCache_[e]=t,t}bindBuffer(e){const t=this.gl_,n=(0,s.v6)(e);let r=this.bufferCache_[n];if(!r){const i=t.createBuffer();r={buffer:e,webGlBuffer:i},this.bufferCache_[n]=r}t.bindBuffer(e.getType(),r.webGlBuffer)}flushBufferData(e){const t=this.gl_;this.bindBuffer(e),t.bufferData(e.getType(),e.getArray(),e.getUsage())}deleteBuffer(e){const t=(0,s.v6)(e);delete this.bufferCache_[t]}disposeInternal(){const e=this.gl_.canvas;e.removeEventListener(l.LOST,this.boundHandleWebGLContextLost_),e.removeEventListener(l.RESTORED,this.boundHandleWebGLContextRestored_),v(this.canvasCacheKey_),delete this.gl_}prepareDraw(e,t,n){const r=this.gl_,i=this.getCanvas(),o=e.size,s=e.pixelRatio;i.width===o[0]*s&&i.height===o[1]*s||(i.width=o[0]*s,i.height=o[1]*s,i.style.width=o[0]+"px",i.style.height=o[1]+"px");for(let a=this.postProcessPasses_.length-1;a>=0;a--)this.postProcessPasses_[a].init(e);r.bindTexture(r.TEXTURE_2D,null),r.clearColor(0,0,0,0),r.depthRange(0,1),r.clearDepth(1),r.clear(r.COLOR_BUFFER_BIT|r.DEPTH_BUFFER_BIT),r.enable(r.BLEND),r.blendFunc(r.ONE,t?r.ZERO:r.ONE_MINUS_SRC_ALPHA),n?(r.enable(r.DEPTH_TEST),r.depthFunc(r.LEQUAL)):r.disable(r.DEPTH_TEST)}bindFrameBuffer(e,t){const n=this.getGL();n.bindFramebuffer(n.FRAMEBUFFER,e),t&&n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0)}bindInitialFrameBuffer(){const e=this.getGL(),t=this.postProcessPasses_[0].getFrameBuffer();e.bindFramebuffer(e.FRAMEBUFFER,t);const n=this.postProcessPasses_[0].getRenderTargetTexture();e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0)}bindTexture(e,t,n){const r=this.gl_;r.activeTexture(r.TEXTURE0+t),r.bindTexture(r.TEXTURE_2D,e),r.uniform1i(this.getUniformLocation(n),t)}bindAttribute(e,t,n){const r=this.getGL();this.bindBuffer(e);const i=this.getAttributeLocation(t);r.enableVertexAttribArray(i),r.vertexAttribPointer(i,n,r.FLOAT,!1,0,0)}prepareDrawToRenderTarget(e,t,n,r){const i=this.gl_,o=t.getSize();i.bindFramebuffer(i.FRAMEBUFFER,t.getFramebuffer()),i.bindRenderbuffer(i.RENDERBUFFER,t.getDepthbuffer()),i.viewport(0,0,o[0],o[1]),i.bindTexture(i.TEXTURE_2D,t.getTexture()),i.clearColor(0,0,0,0),i.depthRange(0,1),i.clearDepth(1),i.clear(i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT),i.enable(i.BLEND),i.blendFunc(i.ONE,n?i.ZERO:i.ONE_MINUS_SRC_ALPHA),r?(i.enable(i.DEPTH_TEST),i.depthFunc(i.LEQUAL)):i.disable(i.DEPTH_TEST)}drawElements(e,t){const n=this.gl_;this.getExtension("OES_element_index_uint");const r=n.UNSIGNED_INT,i=4,o=t-e,s=e*i;n.drawElements(n.TRIANGLES,o,r,s)}finalizeDraw(e,t,n){for(let r=0,i=this.postProcessPasses_.length;r<i;r++)r===i-1?this.postProcessPasses_[r].apply(e,null,t,n):this.postProcessPasses_[r].apply(e,this.postProcessPasses_[r+1])}getCanvas(){return this.gl_.canvas}getGL(){return this.gl_}applyFrameState(e){const t=e.size,n=e.viewState.rotation,r=e.pixelRatio;this.setUniformFloatValue(d.TIME,.001*(Date.now()-this.startTime_)),this.setUniformFloatValue(d.ZOOM,e.viewState.zoom),this.setUniformFloatValue(d.RESOLUTION,e.viewState.resolution),this.setUniformFloatValue(d.PIXEL_RATIO,r),this.setUniformFloatVec2(d.VIEWPORT_SIZE_PX,[t[0],t[1]]),this.setUniformFloatValue(d.ROTATION,n)}applyHitDetectionUniform(e){const t=this.getUniformLocation(d.HIT_DETECTION);this.getGL().uniform1i(t,e?1:0),e&&this.setUniformFloatValue(d.PIXEL_RATIO,.5)}applyUniforms(e){const t=this.gl_;let n,r=0;this.uniforms_.forEach(i=>{if(n="function"===typeof i.value?i.value(e):i.value,n instanceof HTMLCanvasElement||n instanceof HTMLImageElement||n instanceof ImageData||n instanceof WebGLTexture){n instanceof WebGLTexture&&!i.texture?(i.prevValue=void 0,i.texture=n):i.texture||(i.prevValue=void 0,i.texture=t.createTexture()),this.bindTexture(i.texture,r,i.name),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE);const e=!(n instanceof HTMLImageElement)||n.complete;n instanceof WebGLTexture||!e||i.prevValue===n||(i.prevValue=n,t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),r++}else if(Array.isArray(n)&&6===n.length)this.setUniformMatrixValue(i.name,(0,a.Z1)(this.tmpMat4_,n));else if(Array.isArray(n)&&n.length<=4)switch(n.length){case 2:return void t.uniform2f(this.getUniformLocation(i.name),n[0],n[1]);case 3:return void t.uniform3f(this.getUniformLocation(i.name),n[0],n[1],n[2]);case 4:return void t.uniform4f(this.getUniformLocation(i.name),n[0],n[1],n[2],n[3]);default:return}else"number"===typeof n&&t.uniform1f(this.getUniformLocation(i.name),n)})}useProgram(e,t){const n=this.gl_;n.useProgram(e),this.currentProgram_=e,t&&(this.applyFrameState(t),this.applyUniforms(t))}compileShader(e,t){const n=this.gl_,r=n.createShader(t);return n.shaderSource(r,e),n.compileShader(r),r}getProgram(e,t){const n=this.gl_,r=this.compileShader(e,n.FRAGMENT_SHADER),i=this.compileShader(t,n.VERTEX_SHADER),o=n.createProgram();if(n.attachShader(o,r),n.attachShader(o,i),n.linkProgram(o),!n.getShaderParameter(r,n.COMPILE_STATUS)){const e=`Fragment shader compilation failed: ${n.getShaderInfoLog(r)}`;throw new Error(e)}if(n.deleteShader(r),!n.getShaderParameter(i,n.COMPILE_STATUS)){const e=`Vertex shader compilation failed: ${n.getShaderInfoLog(i)}`;throw new Error(e)}if(n.deleteShader(i),!n.getProgramParameter(o,n.LINK_STATUS)){const e=`GL program linking failed: ${n.getProgramInfoLog(o)}`;throw new Error(e)}return o}getUniformLocation(e){const t=(0,s.v6)(this.currentProgram_);return void 0===this.uniformLocationsByProgram_[t]&&(this.uniformLocationsByProgram_[t]={}),void 0===this.uniformLocationsByProgram_[t][e]&&(this.uniformLocationsByProgram_[t][e]=this.gl_.getUniformLocation(this.currentProgram_,e)),this.uniformLocationsByProgram_[t][e]}getAttributeLocation(e){const t=(0,s.v6)(this.currentProgram_);return void 0===this.attribLocationsByProgram_[t]&&(this.attribLocationsByProgram_[t]={}),void 0===this.attribLocationsByProgram_[t][e]&&(this.attribLocationsByProgram_[t][e]=this.gl_.getAttribLocation(this.currentProgram_,e)),this.attribLocationsByProgram_[t][e]}makeProjectionTransform(e,t){const n=e.size,r=e.viewState.rotation,i=e.viewState.resolution,s=e.viewState.center;return(0,o.Zz)(t,0,0,2/(i*n[0]),2/(i*n[1]),-r,-s[0],-s[1]),t}setUniformFloatValue(e,t){this.gl_.uniform1f(this.getUniformLocation(e),t)}setUniformFloatVec2(e,t){this.gl_.uniform2fv(this.getUniformLocation(e),t)}setUniformFloatVec4(e,t){this.gl_.uniform4fv(this.getUniformLocation(e),t)}setUniformMatrixValue(e,t){this.gl_.uniformMatrix4fv(this.getUniformLocation(e),!1,t)}enableAttributeArray_(e,t,n,r,i){const o=this.getAttributeLocation(e);o<0||(this.gl_.enableVertexAttribArray(o),this.gl_.vertexAttribPointer(o,t,n,!1,r,i))}enableAttributes(e){const t=P(e);let n=0;for(let r=0;r<e.length;r++){const i=e[r];this.enableAttributeArray_(i.name,i.size,i.type||h.zH,t,n),n+=i.size*y(i.type)}}handleWebGLContextLost(e){(0,i.I)(this.bufferCache_),this.currentProgram_=null,e.preventDefault()}handleWebGLContextRestored(){this.needsToBeRecreated_=!0}needsToBeRecreated(){return this.needsToBeRecreated_}createTexture(e,t,n,r){const i=this.gl_;n=n||i.createTexture();const o=r?i.NEAREST:i.LINEAR;i.bindTexture(i.TEXTURE_2D,n),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,o),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,o),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE);const s=0,a=i.RGBA,l=0,h=i.RGBA,c=i.UNSIGNED_BYTE;return t instanceof Uint8Array?i.texImage2D(i.TEXTURE_2D,s,a,e[0],e[1],l,h,c,t):t?i.texImage2D(i.TEXTURE_2D,s,a,h,c,t):i.texImage2D(i.TEXTURE_2D,s,a,e[0],e[1],l,h,c,null),n}}function P(e){let t=0;for(let n=0;n<e.length;n++){const r=e[n];t+=r.size*y(r.type)}return t}function y(e){switch(e){case g.UNSIGNED_BYTE:return Uint8Array.BYTES_PER_ELEMENT;case g.UNSIGNED_SHORT:return Uint16Array.BYTES_PER_ELEMENT;case g.UNSIGNED_INT:return Uint32Array.BYTES_PER_ELEMENT;case g.FLOAT:default:return Float32Array.BYTES_PER_ELEMENT}}var S=R},69049:function(e,t,n){var r=n(40190),i=n(11078),o=n(6837),s=n(79332),a=n(4087);class l extends s.A{constructor(e){super(),this.tile,this.handleTileChange_=this.handleTileChange_.bind(this),this.gutter=e.gutter||0,this.helper=e.helper,this.loaded=!1,this.ready=!1}setTile(e){if(e!==this.tile)if(this.tile&&this.tile.removeEventListener(o.A.CHANGE,this.handleTileChange_),this.tile=e,this.loaded=e.getState()===i.A.LOADED,this.loaded)this.uploadTile();else{if(e instanceof r.A){const t=e.getImage();t instanceof Image&&!t.crossOrigin&&(t.crossOrigin="anonymous")}e.addEventListener(o.A.CHANGE,this.handleTileChange_)}}uploadTile(){(0,a.b0)()}setReady(){this.ready=!0,this.dispatchEvent(o.A.CHANGE)}handleTileChange_(){this.tile.getState()===i.A.LOADED&&(this.loaded=!0,this.uploadTile())}setHelper(e){this.helper=e,this.helper&&this.loaded&&this.uploadTile()}disposeInternal(){this.setHelper(null),this.tile.removeEventListener(o.A.CHANGE,this.handleTileChange_)}}t.A=l},83954:function(e,t,n){function r(){return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}function i(e,t){return e[0]=t[0],e[1]=t[1],e[4]=t[2],e[5]=t[3],e[12]=t[4],e[13]=t[5],e}function o(e,t,n,i,o,s,a){a=a??r();const l=1/(e-t),h=1/(n-i),c=1/(o-s);return a[0]=-2*l,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=-2*h,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=2*c,a[11]=0,a[12]=(e+t)*l,a[13]=(i+n)*h,a[14]=(s+o)*c,a[15]=1,a}function s(e,t,n,i,o){return o=o??r(),o[0]=e[0]*t,o[1]=e[1]*t,o[2]=e[2]*t,o[3]=e[3]*t,o[4]=e[4]*n,o[5]=e[5]*n,o[6]=e[6]*n,o[7]=e[7]*n,o[8]=e[8]*i,o[9]=e[9]*i,o[10]=e[10]*i,o[11]=e[11]*i,o[12]=e[12],o[13]=e[13],o[14]=e[14],o[15]=e[15],o}function a(e,t,n,i,o){let s,a,l,h,c,u,f,_,d,g,p,m;return o=o??r(),e===o?(o[12]=e[0]*t+e[4]*n+e[8]*i+e[12],o[13]=e[1]*t+e[5]*n+e[9]*i+e[13],o[14]=e[2]*t+e[6]*n+e[10]*i+e[14],o[15]=e[3]*t+e[7]*n+e[11]*i+e[15]):(s=e[0],a=e[1],l=e[2],h=e[3],c=e[4],u=e[5],f=e[6],_=e[7],d=e[8],g=e[9],p=e[10],m=e[11],o[0]=s,o[1]=a,o[2]=l,o[3]=h,o[4]=c,o[5]=u,o[6]=f,o[7]=_,o[8]=d,o[9]=g,o[10]=p,o[11]=m,o[12]=s*t+c*n+d*i+e[12],o[13]=a*t+u*n+g*i+e[13],o[14]=l*t+f*n+p*i+e[14],o[15]=h*t+_*n+m*i+e[15]),o}function l(e,t,n,i){return i=i??r(),i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=e,i[13]=t,i[14]=n,i[15]=1,i}n.d(t,{Tl:function(){return a},Z1:function(){return i},hs:function(){return s},j0:function(){return o},vt:function(){return r},wT:function(){return l}})},90130:function(e,t,n){n.d(t,{Be:function(){return l},Ek:function(){return a},H7:function(){return i},IP:function(){return o},JL:function(){return c},SD:function(){return d},Ss:function(){return s},UD:function(){return u},l4:function(){return h},zH:function(){return f}});var r=n(7771);const i=34962,o=34963,s=35040,a=35044,l=35048,h=5121,c=5123,u=5125,f=5126,_=["experimental-webgl","webgl","webkit-3d","moz-webgl"];function d(e,t){t=Object.assign({preserveDrawingBuffer:!0,antialias:!r.oF},t);const n=_.length;for(let r=0;r<n;++r)try{const n=e.getContext(_[r],t);if(n)return n}catch{}return null}}}]);
//# sourceMappingURL=4943.afb3516f.js.map