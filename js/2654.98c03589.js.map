{"version":3,"file":"js/2654.98c03589.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/Tile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/ogcTileUtil.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/TileEventType.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/OGCVectorTile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/source/UrlTile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/net.js"],"sourcesContent":["/**\n * @module ol/Tile\n */\nimport TileState from './TileState.js';\nimport {easeIn} from './easing.js';\nimport EventType from './events/EventType.js';\nimport EventTarget from './events/Target.js';\nimport {abstract} from './util.js';\n\n/**\n * A function that takes a {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState.js';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   const xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     const data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes a {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * A key assigned to the tile. This is used in conjunction with a source key\n     * to determine if a cached version of this tile may be used by the renderer.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @private\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n\n    /**\n     * @type {boolean}\n     */\n    this.interpolate = !!options.interpolate;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {\n    // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`\n    this.setState(TileState.EMPTY);\n  }\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state === TileState.EMPTY) {\n      // no more state changes\n      return;\n    }\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    this.release();\n    super.disposeInternal();\n  }\n}\n\nexport default Tile;\n","/**\n * @module ol/source/ogcTileUtil\n */\n\nimport {error as logError} from '../console.js';\nimport {getIntersection as intersectExtents} from '../extent.js';\nimport {getJSON, resolveUrl} from '../net.js';\nimport {get as getProjection} from '../proj.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\n\n/**\n * See https://ogcapi.ogc.org/tiles/.\n */\n\n/**\n * @typedef {'map' | 'vector'} TileType\n */\n\n/**\n * @typedef {'topLeft' | 'bottomLeft'} CornerOfOrigin\n */\n\n/**\n * @typedef {Object} TileSet\n * @property {TileType} dataType Type of data represented in the tileset.\n * @property {string} [tileMatrixSetDefinition] Reference to a tile matrix set definition.\n * @property {TileMatrixSet} [tileMatrixSet] Tile matrix set definition.\n * @property {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.\n * @property {Array<Link>} links Tileset links.\n */\n\n/**\n * @typedef {Object} Link\n * @property {string} rel The link rel attribute.\n * @property {string} href The link URL.\n * @property {string} type The link type.\n */\n\n/**\n * @typedef {Object} TileMatrixSetLimit\n * @property {string} tileMatrix The tile matrix id.\n * @property {number} minTileRow The minimum tile row.\n * @property {number} maxTileRow The maximum tile row.\n * @property {number} minTileCol The minimum tile column.\n * @property {number} maxTileCol The maximum tile column.\n */\n\n/**\n * @typedef {Object} TileMatrixSet\n * @property {string} id The tile matrix set identifier.\n * @property {string|CrsUri|CrsWkt|CrsReferenceSystem} crs The coordinate reference system.\n * @property {Array<string>} [orderedAxes] Axis order.\n * @property {Array<TileMatrix>} tileMatrices Array of tile matrices.\n */\n\n/**\n * @typedef {Object} CrsUri\n * @property {string} uri Reference to one coordinate reference system (CRS).\n */\n\n/**\n * @typedef {Object} CrsWkt\n * @property {Object} wkt JSON encoding for WKT representation of CRS 2.0.\n */\n\n/**\n * @typedef {Object} CrsReferenceSystem\n * @property {Object} referenceSystem Data structure as defined in the MD_ReferenceSystem of the ISO 19115.\n */\n\n/**\n * @typedef {Object} TileMatrix\n * @property {string} id The tile matrix identifier.\n * @property {number} cellSize The pixel resolution (map units per pixel).\n * @property {Array<number>} pointOfOrigin The map location of the matrix origin.\n * @property {CornerOfOrigin} [cornerOfOrigin='topLeft'] The corner of the matrix that represents the origin ('topLeft' or 'bottomLeft').\n * @property {number} matrixWidth The number of columns.\n * @property {number} matrixHeight The number of rows.\n * @property {number} tileWidth The pixel width of a tile.\n * @property {number} tileHeight The pixel height of a tile.\n */\n\n/**\n * @type {Object<string, boolean>}\n */\nconst knownMapMediaTypes = {\n  'image/png': true,\n  'image/jpeg': true,\n  'image/gif': true,\n  'image/webp': true,\n};\n\n/**\n * @type {Object<string, boolean>}\n */\nconst knownVectorMediaTypes = {\n  'application/vnd.mapbox-vector-tile': true,\n  'application/geo+json': true,\n};\n\n/**\n * @typedef {Object} TileSetInfo\n * @property {string} urlTemplate The tile URL template.\n * @property {import(\"../proj/Projection.js\").default} projection The source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} grid The tile grid.\n * @property {import(\"../Tile.js\").UrlFunction} urlFunction The tile URL function.\n */\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} url The tile set URL.\n * @property {string} mediaType The preferred tile media type.\n * @property {Array<string>} [supportedMediaTypes] The supported media types.\n * @property {import(\"../proj/Projection.js\").default} projection The source projection.\n * @property {Object} [context] Optional context for constructing the URL.\n * @property {Array<string>} [collections] Optional collections to append the URL with.\n */\n\n/**\n * @param {string} tileUrlTemplate Tile URL template.\n * @param {Array<string>} collections List of collections to include as query parameter.\n * @return {string} The tile URL template with appended collections query parameter.\n */\nexport function appendCollectionsQueryParam(tileUrlTemplate, collections) {\n  if (!collections.length) {\n    return tileUrlTemplate;\n  }\n\n  // making sure we can always construct a URL instance.\n  const url = new URL(tileUrlTemplate, 'file:/');\n\n  if (url.pathname.split('/').includes('collections')) {\n    logError(\n      'The \"collections\" query parameter cannot be added to collection endpoints',\n    );\n    return tileUrlTemplate;\n  }\n  // According to conformance class\n  // http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/collections-selection\n  // commata in the identifiers of the `collections` query parameter\n  // need to be URLEncoded, while the commata separating the identifiers\n  // should not.\n  const encodedCollections = collections\n    .map((c) => encodeURIComponent(c))\n    .join(',');\n\n  url.searchParams.append('collections', encodedCollections);\n  const baseUrl = tileUrlTemplate.split('?')[0];\n  const queryParams = decodeURIComponent(url.searchParams.toString());\n  return `${baseUrl}?${queryParams}`;\n}\n\n/**\n * @param {Array<Link>} links Tileset links.\n * @param {string} [mediaType] The preferred media type.\n * @param {Array<string>} [collections] Optional collections to append the URL with.\n * @return {string} The tile URL template.\n */\nexport function getMapTileUrlTemplate(links, mediaType, collections) {\n  let tileUrlTemplate;\n  let fallbackUrlTemplate;\n  for (let i = 0; i < links.length; ++i) {\n    const link = links[i];\n    if (link.rel === 'item') {\n      if (link.type === mediaType) {\n        tileUrlTemplate = link.href;\n        break;\n      }\n      if (knownMapMediaTypes[link.type]) {\n        fallbackUrlTemplate = link.href;\n      } else if (!fallbackUrlTemplate && link.type.startsWith('image/')) {\n        fallbackUrlTemplate = link.href;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate) {\n    if (fallbackUrlTemplate) {\n      tileUrlTemplate = fallbackUrlTemplate;\n    } else {\n      throw new Error('Could not find \"item\" link');\n    }\n  }\n\n  if (collections) {\n    tileUrlTemplate = appendCollectionsQueryParam(tileUrlTemplate, collections);\n  }\n\n  return tileUrlTemplate;\n}\n\n/**\n * @param {Array<Link>} links Tileset links.\n * @param {string} [mediaType] The preferred media type.\n * @param {Array<string>} [supportedMediaTypes] The media types supported by the parser.\n * @param {Array<string>} [collections] Optional collections to append the URL with.\n * @return {string} The tile URL template.\n */\nexport function getVectorTileUrlTemplate(\n  links,\n  mediaType,\n  supportedMediaTypes,\n  collections,\n) {\n  let tileUrlTemplate;\n  let fallbackUrlTemplate;\n\n  /**\n   * Lookup of URL by media type.\n   * @type {Object<string, string>}\n   */\n  const hrefLookup = {};\n\n  for (let i = 0; i < links.length; ++i) {\n    const link = links[i];\n    hrefLookup[link.type] = link.href;\n    if (link.rel === 'item') {\n      if (link.type === mediaType) {\n        tileUrlTemplate = link.href;\n        break;\n      }\n      if (knownVectorMediaTypes[link.type]) {\n        fallbackUrlTemplate = link.href;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate && supportedMediaTypes) {\n    for (let i = 0; i < supportedMediaTypes.length; ++i) {\n      const supportedMediaType = supportedMediaTypes[i];\n      if (hrefLookup[supportedMediaType]) {\n        tileUrlTemplate = hrefLookup[supportedMediaType];\n        break;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate) {\n    if (fallbackUrlTemplate) {\n      tileUrlTemplate = fallbackUrlTemplate;\n    } else {\n      throw new Error('Could not find \"item\" link');\n    }\n  }\n\n  if (collections) {\n    tileUrlTemplate = appendCollectionsQueryParam(tileUrlTemplate, collections);\n  }\n\n  return tileUrlTemplate;\n}\n\n/**\n * @param {SourceInfo} sourceInfo The source info.\n * @param {TileMatrixSet} tileMatrixSet Tile matrix set.\n * @param {string} tileUrlTemplate Tile URL template.\n * @param {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.\n * @return {TileSetInfo} Tile set info.\n */\nfunction parseTileMatrixSet(\n  sourceInfo,\n  tileMatrixSet,\n  tileUrlTemplate,\n  tileMatrixSetLimits,\n) {\n  let projection = sourceInfo.projection;\n  if (!projection) {\n    if (typeof tileMatrixSet.crs === 'string') {\n      projection = getProjection(tileMatrixSet.crs);\n    } else if ('uri' in tileMatrixSet.crs) {\n      projection = getProjection(tileMatrixSet.crs.uri);\n    }\n    if (!projection) {\n      throw new Error(`Unsupported CRS: ${JSON.stringify(tileMatrixSet.crs)}`);\n    }\n  }\n  const orderedAxes = tileMatrixSet.orderedAxes;\n  const axisOrientation = orderedAxes\n    ? orderedAxes\n        .slice(0, 2)\n        .map((s) => s.replace(/E|X|Lon/i, 'e').replace(/N|Y|Lat/i, 'n'))\n        .join('')\n    : projection.getAxisOrientation();\n  const backwards = !axisOrientation.startsWith('en');\n\n  const matrices = tileMatrixSet.tileMatrices;\n\n  /**\n   * @type {Object<string, TileMatrix>}\n   */\n  const matrixLookup = {};\n  for (let i = 0; i < matrices.length; ++i) {\n    const matrix = matrices[i];\n    matrixLookup[matrix.id] = matrix;\n  }\n\n  /**\n   * @type {Object<string, TileMatrixSetLimit>}\n   */\n  const limitLookup = {};\n\n  /**\n   * @type {Array<string>}\n   */\n  const matrixIds = [];\n\n  if (tileMatrixSetLimits) {\n    for (let i = 0; i < tileMatrixSetLimits.length; ++i) {\n      const limit = tileMatrixSetLimits[i];\n      const id = limit.tileMatrix;\n      matrixIds.push(id);\n      limitLookup[id] = limit;\n    }\n  } else {\n    for (let i = 0; i < matrices.length; ++i) {\n      const id = matrices[i].id;\n      matrixIds.push(id);\n    }\n  }\n\n  const length = matrixIds.length;\n  const origins = new Array(length);\n  const resolutions = new Array(length);\n  const sizes = new Array(length);\n  const tileSizes = new Array(length);\n  const extent = [-Infinity, -Infinity, Infinity, Infinity];\n\n  for (let i = 0; i < length; ++i) {\n    const id = matrixIds[i];\n    const matrix = matrixLookup[id];\n    const origin = matrix.pointOfOrigin;\n    if (backwards) {\n      origins[i] = [origin[1], origin[0]];\n    } else {\n      origins[i] = origin;\n    }\n    resolutions[i] = matrix.cellSize;\n    sizes[i] = [matrix.matrixWidth, matrix.matrixHeight];\n    tileSizes[i] = [matrix.tileWidth, matrix.tileHeight];\n    const limit = limitLookup[id];\n    if (limit) {\n      const tileMapWidth = matrix.cellSize * matrix.tileWidth;\n      const minX = origins[i][0] + limit.minTileCol * tileMapWidth;\n      const maxX = origins[i][0] + (limit.maxTileCol + 1) * tileMapWidth;\n\n      const tileMapHeight = matrix.cellSize * matrix.tileHeight;\n      const upsideDown = matrix.cornerOfOrigin === 'bottomLeft';\n\n      let minY;\n      let maxY;\n      if (upsideDown) {\n        minY = origins[i][1] + limit.minTileRow * tileMapHeight;\n        maxY = origins[i][1] + (limit.maxTileRow + 1) * tileMapHeight;\n      } else {\n        minY = origins[i][1] - (limit.maxTileRow + 1) * tileMapHeight;\n        maxY = origins[i][1] - limit.minTileRow * tileMapHeight;\n      }\n\n      intersectExtents(extent, [minX, minY, maxX, maxY], extent);\n    }\n  }\n\n  const tileGrid = new TileGrid({\n    origins: origins,\n    resolutions: resolutions,\n    sizes: sizes,\n    tileSizes: tileSizes,\n    extent: tileMatrixSetLimits ? extent : undefined,\n  });\n\n  const context = sourceInfo.context;\n  const base = sourceInfo.url;\n\n  /** @type {import('../Tile.js').UrlFunction} */\n  function tileUrlFunction(tileCoord, pixelRatio, projection) {\n    if (!tileCoord) {\n      return undefined;\n    }\n\n    const id = matrixIds[tileCoord[0]];\n    const matrix = matrixLookup[id];\n    const upsideDown = matrix.cornerOfOrigin === 'bottomLeft';\n\n    const localContext = {\n      tileMatrix: id,\n      tileCol: tileCoord[1],\n      tileRow: upsideDown ? -tileCoord[2] - 1 : tileCoord[2],\n    };\n\n    if (tileMatrixSetLimits) {\n      const limit = limitLookup[matrix.id];\n      if (\n        localContext.tileCol < limit.minTileCol ||\n        localContext.tileCol > limit.maxTileCol ||\n        localContext.tileRow < limit.minTileRow ||\n        localContext.tileRow > limit.maxTileRow\n      ) {\n        return undefined;\n      }\n    }\n\n    Object.assign(localContext, context);\n\n    const url = tileUrlTemplate.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n      return localContext[p];\n    });\n\n    return resolveUrl(base, url);\n  }\n\n  return {\n    grid: tileGrid,\n    projection: projection,\n    urlTemplate: tileUrlTemplate,\n    urlFunction: tileUrlFunction,\n  };\n}\n\n/**\n * @param {SourceInfo} sourceInfo The source info.\n * @param {TileSet} tileSet Tile set.\n * @return {TileSetInfo|Promise<TileSetInfo>} Tile set info.\n */\nfunction parseTileSetMetadata(sourceInfo, tileSet) {\n  const tileMatrixSetLimits = tileSet.tileMatrixSetLimits;\n  /** @type {string} */\n  let tileUrlTemplate;\n\n  if (tileSet.dataType === 'map') {\n    tileUrlTemplate = getMapTileUrlTemplate(\n      tileSet.links,\n      sourceInfo.mediaType,\n      sourceInfo.collections,\n    );\n  } else if (tileSet.dataType === 'vector') {\n    tileUrlTemplate = getVectorTileUrlTemplate(\n      tileSet.links,\n      sourceInfo.mediaType,\n      sourceInfo.supportedMediaTypes,\n      sourceInfo.collections,\n    );\n  } else {\n    throw new Error('Expected tileset data type to be \"map\" or \"vector\"');\n  }\n\n  if (tileSet.tileMatrixSet) {\n    return parseTileMatrixSet(\n      sourceInfo,\n      tileSet.tileMatrixSet,\n      tileUrlTemplate,\n      tileMatrixSetLimits,\n    );\n  }\n\n  const tileMatrixSetLink = tileSet.links.find(\n    (link) =>\n      link.rel === 'http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme',\n  );\n  if (!tileMatrixSetLink) {\n    throw new Error(\n      'Expected http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme link or tileMatrixSet',\n    );\n  }\n  const tileMatrixSetDefinition = tileMatrixSetLink.href;\n\n  const url = resolveUrl(sourceInfo.url, tileMatrixSetDefinition);\n  return getJSON(url).then(function (tileMatrixSet) {\n    return parseTileMatrixSet(\n      sourceInfo,\n      tileMatrixSet,\n      tileUrlTemplate,\n      tileMatrixSetLimits,\n    );\n  });\n}\n\n/**\n * @param {SourceInfo} sourceInfo Source info.\n * @return {Promise<TileSetInfo>} Tile set info.\n */\nexport function getTileSetInfo(sourceInfo) {\n  return getJSON(sourceInfo.url).then(function (tileSet) {\n    return parseTileSetMetadata(sourceInfo, tileSet);\n  });\n}\n","/**\n * @module ol/source/TileEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a tile starts loading.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\n   * @api\n   */\n  TILELOADSTART: 'tileloadstart',\n\n  /**\n   * Triggered when a tile finishes loading, either when its data is loaded,\n   * or when loading was aborted because the tile is no longer needed.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadend\n   * @api\n   */\n  TILELOADEND: 'tileloadend',\n\n  /**\n   * Triggered if tile loading results in an error. Note that this is not the\n   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}\n   * for details.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\n   * @api\n   */\n  TILELOADERROR: 'tileloaderror',\n};\n\n/**\n * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes\n */\n","/**\n * @module ol/source/OGCVectorTile\n */\n\nimport {error as logError} from '../console.js';\nimport VectorTileSource from './VectorTile.js';\nimport {getTileSetInfo} from './ogcTileUtil.js';\n\n/**\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n * @typedef {Object} Options\n * @property {string} url URL to the OGC Vector Tileset endpoint.\n * @property {Object} [context] A lookup of values to use in the tile URL template.  The `{tileMatrix}`\n * (zoom level), `{tileRow}`, and `{tileCol}` variables in the URL will always be provided by the source.\n * @property {import(\"../format/Feature.js\").default<FeatureType>} [format] Feature format for tiles. Used and required by the default.\n * @property {string} [mediaType] The content type for the tiles (e.g. \"application/vnd.mapbox-vector-tile\").  If not provided,\n * the source will try to find a link with rel=\"item\" that uses a vector type supported by the configured format.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile~VectorTile}.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=1]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n * @property {Array<string>} [collections] A list of geospatial data sub-resources to include. If not provided, the entire dataset will\n * be included. This option is not applicable when requesting the tileset for a single collection.\n */\n\n/**\n * @classdesc\n * Layer source for map tiles from an [OGC API - Tiles](https://ogcapi.ogc.org/tiles/) service that provides \"vector\" type tiles.\n * The service must conform to at least the core (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/core)\n * and tileset (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/tileset) conformance classes. For supporting the `collections`\n * option, the service must conform to the collections selection\n * (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/collections-selection) conformance class.\n *\n * Vector tile sets may come in a variety of formats (e.g. GeoJSON, MVT).  The `format` option is used to determine\n * which of the advertised media types is used.  If you need to force the use of a particular media type, you can\n * provide the `mediaType` option.\n * @api\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n * @extends {VectorTileSource<FeatureType>}\n */\nclass OGCVectorTile extends VectorTileSource {\n  /**\n   * @param {Options<FeatureType>} options OGC vector tile options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      format: options.format,\n      overlaps: options.overlaps,\n      projection: options.projection,\n      tileClass: options.tileClass,\n      transition: options.transition,\n      wrapX: options.wrapX,\n      zDirection: options.zDirection,\n      state: 'loading',\n    });\n\n    const sourceInfo = {\n      url: options.url,\n      projection: this.getProjection(),\n      mediaType: options.mediaType,\n      supportedMediaTypes: options.format.supportedMediaTypes,\n      context: options.context || null,\n      collections: options.collections,\n    };\n\n    getTileSetInfo(sourceInfo)\n      .then(this.handleTileSetInfo_.bind(this))\n      .catch(this.handleError_.bind(this));\n  }\n\n  /**\n   * @param {import(\"./ogcTileUtil.js\").TileSetInfo} tileSetInfo Tile set info.\n   * @private\n   */\n  handleTileSetInfo_(tileSetInfo) {\n    this.tileGrid = tileSetInfo.grid;\n    this.projection = tileSetInfo.projection;\n    this.setTileUrlFunction(tileSetInfo.urlFunction, tileSetInfo.urlTemplate);\n    this.setState('ready');\n  }\n\n  /**\n   * @private\n   * @param {Error} error The error.\n   */\n  handleError_(error) {\n    logError(error);\n    this.setState('error');\n  }\n}\n\nexport default OGCVectorTile;\n","/**\n * @module ol/source/UrlTile\n */\nimport TileState from '../TileState.js';\nimport {createFromTemplates} from '../tileurlfunction.js';\nimport {expandUrl} from '../uri.js';\nimport {getUid} from '../util.js';\nimport TileSource, {TileSourceEvent} from './Tile.js';\nimport TileEventType from './TileEventType.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./Source.js\").State} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {import(\"../Tile.js\").LoadFunction} tileLoadFunction TileLoadFunction.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Deprecated.  Use an ImageTile source and provide a function\n * for the url option instead.\n * @property {string} [url] Url.\n * @property {Array<string>} [urls] Urls.\n * @property {boolean} [wrapX=true] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @deprecated Use the ol/source/ImageTile.js instead.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n */\nclass UrlTile extends TileSource {\n  /**\n   * @param {Options} options Image tile options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tilePixelRatio: options.tilePixelRatio,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.generateTileUrlFunction_ =\n      this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction = options.tileLoadFunction;\n\n    if (options.tileUrlFunction) {\n      this.tileUrlFunction = options.tileUrlFunction;\n    }\n\n    /**\n     * @protected\n     * @type {!Array<string>|null}\n     */\n    this.urls = null;\n\n    if (options.urls) {\n      this.setUrls(options.urls);\n    } else if (options.url) {\n      this.setUrl(options.url);\n    }\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Return the tile load function of the source.\n   * @return {import(\"../Tile.js\").LoadFunction} TileLoadFunction\n   * @api\n   */\n  getTileLoadFunction() {\n    return this.tileLoadFunction;\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Return the tile URL function of the source.\n   * @return {import(\"../Tile.js\").UrlFunction} TileUrlFunction\n   * @api\n   */\n  getTileUrlFunction() {\n    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction\n      ? this.tileUrlFunction.bind(this)\n      : this.tileUrlFunction;\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Return the URLs used for this source.\n   * When a tileUrlFunction is used instead of url or urls,\n   * null will be returned.\n   * @return {!Array<string>|null} URLs.\n   * @api\n   */\n  getUrls() {\n    return this.urls;\n  }\n\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   * @protected\n   */\n  handleTileChange(event) {\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n    const uid = getUid(tile);\n    const tileState = tile.getState();\n    let type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type =\n        tileState == TileState.ERROR\n          ? TileEventType.TILELOADERROR\n          : tileState == TileState.LOADED\n            ? TileEventType.TILELOADEND\n            : undefined;\n    }\n    if (type != undefined) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Set the tile load function of the source.\n   * @param {import(\"../Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @api\n   */\n  setTileLoadFunction(tileLoadFunction) {\n    this.tileLoadFunction = tileLoadFunction;\n    this.changed();\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Set the tile URL function of the source.\n   * @param {import(\"../Tile.js\").UrlFunction} tileUrlFunction Tile URL function.\n   * @param {string} [key] Optional new tile key for the source.\n   * @api\n   */\n  setTileUrlFunction(tileUrlFunction, key) {\n    this.tileUrlFunction = tileUrlFunction;\n    if (typeof key !== 'undefined') {\n      this.setKey(key);\n    } else {\n      this.changed();\n    }\n  }\n\n  /**\n   * Set the URL to use for requests.\n   * @param {string} url URL.\n   * @api\n   */\n  setUrl(url) {\n    const urls = expandUrl(url);\n    this.urls = urls;\n    this.setUrls(urls);\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Set the URLs to use for requests.\n   * @param {Array<string>} urls URLs.\n   * @api\n   */\n  setUrls(urls) {\n    this.urls = urls;\n    const key = urls.join('\\n');\n    if (this.generateTileUrlFunction_) {\n      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);\n    } else {\n      this.setKey(key);\n    }\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {string|undefined} Tile URL.\n   */\n  tileUrlFunction(tileCoord, pixelRatio, projection) {\n    return undefined;\n  }\n}\n\nexport default UrlTile;\n","/**\n * @module ol/net\n */\nimport {getUid} from './util.js';\n\n/**\n * Simple JSONP helper. Supports error callbacks and a custom callback param.\n * The error callback will be called when no JSONP is executed after 10 seconds.\n *\n * @param {string} url Request url. A 'callback' query parameter will be\n *     appended.\n * @param {Function} callback Callback on success.\n * @param {Function} [errback] Callback on error.\n * @param {string} [callbackParam] Custom query parameter for the JSONP\n *     callback. Default is 'callback'.\n */\nexport function jsonp(url, callback, errback, callbackParam) {\n  const script = document.createElement('script');\n  const key = 'olc_' + getUid(callback);\n  function cleanup() {\n    delete window[key];\n    script.parentNode.removeChild(script);\n  }\n  script.async = true;\n  script.src =\n    url +\n    (url.includes('?') ? '&' : '?') +\n    (callbackParam || 'callback') +\n    '=' +\n    key;\n  const timer = setTimeout(function () {\n    cleanup();\n    if (errback) {\n      errback();\n    }\n  }, 10000);\n  window[key] = function (data) {\n    clearTimeout(timer);\n    cleanup();\n    callback(data);\n  };\n  document.head.appendChild(script);\n}\n\nexport class ResponseError extends Error {\n  /**\n   * @param {XMLHttpRequest} response The XHR object.\n   */\n  constructor(response) {\n    const message = 'Unexpected response status: ' + response.status;\n    super(message);\n\n    /**\n     * @type {string}\n     */\n    this.name = 'ResponseError';\n\n    /**\n     * @type {XMLHttpRequest}\n     */\n    this.response = response;\n  }\n}\n\nexport class ClientError extends Error {\n  /**\n   * @param {XMLHttpRequest} client The XHR object.\n   */\n  constructor(client) {\n    super('Failed to issue request');\n\n    /**\n     * @type {string}\n     */\n    this.name = 'ClientError';\n\n    /**\n     * @type {XMLHttpRequest}\n     */\n    this.client = client;\n  }\n}\n\n/**\n * @param {string} url The URL.\n * @return {Promise<Object>} A promise that resolves to the JSON response.\n */\nexport function getJSON(url) {\n  return new Promise(function (resolve, reject) {\n    /**\n     * @param {ProgressEvent<XMLHttpRequest>} event The load event.\n     */\n    function onLoad(event) {\n      const client = event.target;\n      // status will be 0 for file:// urls\n      if (!client.status || (client.status >= 200 && client.status < 300)) {\n        let data;\n        try {\n          data = JSON.parse(client.responseText);\n        } catch (err) {\n          const message = 'Error parsing response text as JSON: ' + err.message;\n          reject(new Error(message));\n          return;\n        }\n        resolve(data);\n        return;\n      }\n\n      reject(new ResponseError(client));\n    }\n\n    /**\n     * @param {ProgressEvent<XMLHttpRequest>} event The error event.\n     */\n    function onError(event) {\n      reject(new ClientError(event.target));\n    }\n\n    const client = new XMLHttpRequest();\n    client.addEventListener('load', onLoad);\n    client.addEventListener('error', onError);\n    client.open('GET', url);\n    client.setRequestHeader('Accept', 'application/json');\n    client.send();\n  });\n}\n\n/**\n * @param {string} base The base URL.\n * @param {string} url The potentially relative URL.\n * @return {string} The full URL.\n */\nexport function resolveUrl(base, url) {\n  if (url.includes('://')) {\n    return url;\n  }\n  return new URL(url, base).href;\n}\n\nlet originalXHR;\nexport function overrideXHR(xhr) {\n  if (typeof XMLHttpRequest !== 'undefined') {\n    originalXHR = XMLHttpRequest;\n  }\n  global.XMLHttpRequest = xhr;\n}\n\nexport function restoreXHR() {\n  global.XMLHttpRequest = originalXHR;\n}\n"],"names":["Tile","constructor","tileCoord","state","options","super","this","key","transition_","undefined","transition","transitionStarts_","interpolate","changed","dispatchEvent","CHANGE","release","setState","EMPTY","getKey","getTileCoord","getState","ERROR","Error","load","getAlpha","id","time","start","delta","inTransition","endTransition","disposeInternal","knownMapMediaTypes","knownVectorMediaTypes","appendCollectionsQueryParam","tileUrlTemplate","collections","length","url","URL","pathname","split","includes","encodedCollections","map","c","encodeURIComponent","join","searchParams","append","baseUrl","queryParams","decodeURIComponent","toString","getMapTileUrlTemplate","links","mediaType","fallbackUrlTemplate","i","link","rel","type","href","startsWith","getVectorTileUrlTemplate","supportedMediaTypes","hrefLookup","supportedMediaType","parseTileMatrixSet","sourceInfo","tileMatrixSet","tileMatrixSetLimits","projection","crs","uri","JSON","stringify","orderedAxes","axisOrientation","slice","s","replace","getAxisOrientation","backwards","matrices","tileMatrices","matrixLookup","matrix","limitLookup","matrixIds","limit","tileMatrix","push","origins","Array","resolutions","sizes","tileSizes","extent","Infinity","origin","pointOfOrigin","cellSize","matrixWidth","matrixHeight","tileWidth","tileHeight","tileMapWidth","minX","minTileCol","maxX","maxTileCol","tileMapHeight","upsideDown","cornerOfOrigin","minY","maxY","minTileRow","maxTileRow","tileGrid","context","base","tileUrlFunction","pixelRatio","localContext","tileCol","tileRow","Object","assign","m","p","grid","urlTemplate","urlFunction","parseTileSetMetadata","tileSet","dataType","tileMatrixSetLink","find","tileMatrixSetDefinition","then","getTileSetInfo","TILELOADSTART","TILELOADEND","TILELOADERROR","OGCVectorTile","attributions","attributionsCollapsible","cacheSize","format","overlaps","tileClass","wrapX","zDirection","getProjection","handleTileSetInfo_","bind","catch","handleError_","tileSetInfo","setTileUrlFunction","error","UrlTile","tilePixelRatio","generateTileUrlFunction_","prototype","tileLoadFunction","urls","setUrls","setUrl","tileLoadingKeys_","getTileLoadFunction","getTileUrlFunction","getPrototypeOf","getUrls","handleTileChange","event","tile","uid","tileState","LOADING","LOADED","TileSourceEvent","setTileLoadFunction","setKey","jsonp","callback","errback","callbackParam","script","document","createElement","cleanup","window","parentNode","removeChild","async","src","timer","setTimeout","data","clearTimeout","head","appendChild","ResponseError","response","message","status","name","ClientError","client","getJSON","Promise","resolve","reject","onLoad","target","parse","responseText","err","onError","XMLHttpRequest","addEventListener","open","setRequestHeader","send","resolveUrl"],"sourceRoot":""}