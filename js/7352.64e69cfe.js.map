{"version":3,"file":"js/7352.64e69cfe.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/TileRange.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/BaseTile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/TileProperty.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/WebGLTile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/tilecoord.js"],"sourcesContent":["/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nclass TileRange {\n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   */\n  constructor(minX, maxX, minY, maxY) {\n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  contains(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  containsTileRange(tileRange) {\n    return (\n      this.minX <= tileRange.minX &&\n      tileRange.maxX <= this.maxX &&\n      this.minY <= tileRange.minY &&\n      tileRange.maxY <= this.maxY\n    );\n  }\n\n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  containsXY(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  equals(tileRange) {\n    return (\n      this.minX == tileRange.minX &&\n      this.minY == tileRange.minY &&\n      this.maxX == tileRange.maxX &&\n      this.maxY == tileRange.maxY\n    );\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   */\n  extend(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  }\n\n  /**\n   * @return {number} Height.\n   */\n  getHeight() {\n    return this.maxY - this.minY + 1;\n  }\n\n  /**\n   * @return {import(\"./size.js\").Size} Size.\n   */\n  getSize() {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  /**\n   * @return {number} Width.\n   */\n  getWidth() {\n    return this.maxX - this.minX + 1;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  intersects(tileRange) {\n    return (\n      this.minX <= tileRange.maxX &&\n      this.maxX >= tileRange.minX &&\n      this.minY <= tileRange.maxY &&\n      this.maxY >= tileRange.minY\n    );\n  }\n}\n\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  }\n  return new TileRange(minX, maxX, minY, maxY);\n}\n\nexport default TileRange;\n","/**\n * @module ol/layer/BaseTile\n */\nimport Layer from './Layer.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *   import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {TileSourceType} [source] Source for this layer.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n * @property {number} [cacheSize=512] The internal tile cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n */\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<TileSourceType, RendererType>}\n * @api\n */\nclass BaseTileLayer extends Layer {\n  /**\n   * @param {Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    const cacheSize = options.cacheSize;\n    delete options.cacheSize;\n\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    super(baseOptions);\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true,\n    );\n  }\n\n  /**\n   * @return {number|undefined} The suggested cache size\n   * @protected\n   */\n  getCacheSize() {\n    return this.cacheSize_;\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Deprecated.  Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Deprecated.  Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n\n  /**\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   * @override\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default BaseTileLayer;\n","/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n","/**\n * @module ol/layer/WebGLTile\n */\nimport {ColorType, NumberType} from '../expr/expression.js';\nimport {\n  PALETTE_TEXTURE_ARRAY,\n  getStringNumberEquivalent,\n  newCompilationContext,\n  uniformNameForVariable,\n} from '../expr/gpu.js';\nimport LayerProperty from '../layer/Property.js';\nimport {expressionToGlsl} from '../render/webgl/compileUtil.js';\nimport WebGLTileLayerRenderer, {\n  Attributes,\n  Uniforms,\n} from '../renderer/webgl/TileLayer.js';\nimport BaseTileLayer from './BaseTile.js';\n\n/**\n * @typedef {import(\"../source/DataTile.js\").default<import(\"../DataTile.js\").default|import(\"../ImageTile.js\").default>} SourceType\n */\n\n/**\n * @typedef {Object} Style\n * Translates tile data to rendered pixels.\n *\n * @property {Object<string, (string|number)>} [variables] Style variables.  Each variable must hold a number or string.  These\n * variables can be used in the `color`, `brightness`, `contrast`, `exposure`, `saturation` and `gamma`\n * {@link import(\"../expr/expression.js\").ExpressionValue expressions}, using the `['var', 'varName']` operator.\n * To update style variables, use the {@link import(\"./WebGLTile.js\").default#updateStyleVariables} method.\n * @property {import(\"../expr/expression.js\").ExpressionValue} [color] An expression applied to color values.\n * @property {import(\"../expr/expression.js\").ExpressionValue} [brightness=0] Value used to decrease or increase\n * the layer brightness.  Values range from -1 to 1.\n * @property {import(\"../expr/expression.js\").ExpressionValue} [contrast=0] Value used to decrease or increase\n * the layer contrast.  Values range from -1 to 1.\n * @property {import(\"../expr/expression.js\").ExpressionValue} [exposure=0] Value used to decrease or increase\n * the layer exposure.  Values range from -1 to 1.\n * @property {import(\"../expr/expression.js\").ExpressionValue} [saturation=0] Value used to decrease or increase\n * the layer saturation.  Values range from -1 to 1.\n * @property {import(\"../expr/expression.js\").ExpressionValue} [gamma=1] Apply a gamma correction to the layer.\n * Values range from 0 to infinity.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Style} [style] Style to apply to the layer.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {SourceType} [source] Source for this layer.\n * @property {Array<SourceType>|function(import(\"../extent.js\").Extent, number):Array<SourceType>} [sources] Array\n * of sources for this layer. Takes precedence over `source`. Can either be an array of sources, or a function that\n * expects an extent and a resolution (in view projection units per pixel) and returns an array of sources. See\n * {@link module:ol/source.sourcesFromTileGrid} for a helper function to generate sources that are organized in a\n * pyramid following the same pattern as a tile grid. **Note:** All sources must have the same band count and content.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link module:ol/Map~Map#addLayer}.\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\n * @property {number} [cacheSize=512] The internal texture cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @typedef {Object} ParsedStyle\n * @property {string} vertexShader The vertex shader.\n * @property {string} fragmentShader The fragment shader.\n * @property {Object<string,import(\"../webgl/Helper.js\").UniformValue>} uniforms Uniform definitions.\n * @property {Array<import(\"../webgl/PaletteTexture.js\").default>} paletteTextures Palette textures.\n */\n\n/**\n * @param {Style} style The layer style.\n * @param {number} [bandCount] The number of bands.\n * @return {ParsedStyle} Shaders and uniforms generated from the style.\n */\nfunction parseStyle(style, bandCount) {\n  const vertexShader = `\n    attribute vec2 ${Attributes.TEXTURE_COORD};\n    uniform mat4 ${Uniforms.TILE_TRANSFORM};\n    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};\n    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n    uniform float ${Uniforms.TEXTURE_RESOLUTION};\n    uniform float ${Uniforms.TEXTURE_ORIGIN_X};\n    uniform float ${Uniforms.TEXTURE_ORIGIN_Y};\n    uniform float ${Uniforms.DEPTH};\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n\n    void main() {\n      v_textureCoord = ${Attributes.TEXTURE_COORD};\n      v_mapCoord = vec2(\n        ${Uniforms.TEXTURE_ORIGIN_X} + ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],\n        ${Uniforms.TEXTURE_ORIGIN_Y} - ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]\n      );\n      gl_Position = ${Uniforms.TILE_TRANSFORM} * vec4(${Attributes.TEXTURE_COORD}, ${Uniforms.DEPTH}, 1.0);\n    }\n  `;\n\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const context = {\n    ...newCompilationContext(),\n    bandCount: bandCount,\n  };\n\n  const pipeline = [];\n\n  if (style.color !== undefined) {\n    const color = expressionToGlsl(context, style.color, ColorType);\n    pipeline.push(`color = ${color};`);\n  }\n\n  if (style.contrast !== undefined) {\n    const contrast = expressionToGlsl(context, style.contrast, NumberType);\n    pipeline.push(\n      `color.rgb = clamp((${contrast} + 1.0) * color.rgb - (${contrast} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`,\n    );\n  }\n\n  if (style.exposure !== undefined) {\n    const exposure = expressionToGlsl(context, style.exposure, NumberType);\n    pipeline.push(\n      `color.rgb = clamp((${exposure} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`,\n    );\n  }\n\n  if (style.saturation !== undefined) {\n    const saturation = expressionToGlsl(context, style.saturation, NumberType);\n    pipeline.push(`\n      float saturation = ${saturation} + 1.0;\n      float sr = (1.0 - saturation) * 0.2126;\n      float sg = (1.0 - saturation) * 0.7152;\n      float sb = (1.0 - saturation) * 0.0722;\n      mat3 saturationMatrix = mat3(\n        sr + saturation, sr, sr,\n        sg, sg + saturation, sg,\n        sb, sb, sb + saturation\n      );\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    `);\n  }\n\n  if (style.gamma !== undefined) {\n    const gamma = expressionToGlsl(context, style.gamma, NumberType);\n    pipeline.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${gamma}));`);\n  }\n\n  if (style.brightness !== undefined) {\n    const brightness = expressionToGlsl(context, style.brightness, NumberType);\n    pipeline.push(\n      `color.rgb = clamp(color.rgb + ${brightness}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`,\n    );\n  }\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  const numVariables = Object.keys(context.variables).length;\n  if (numVariables > 1 && !style.variables) {\n    throw new Error(\n      `Missing variables in style (expected ${context.variables})`,\n    );\n  }\n\n  for (let i = 0; i < numVariables; ++i) {\n    const variable = context.variables[Object.keys(context.variables)[i]];\n    if (!(variable.name in style.variables)) {\n      throw new Error(`Missing '${variable.name}' in style variables`);\n    }\n    const uniformName = uniformNameForVariable(variable.name);\n    uniforms[uniformName] = function () {\n      let value = style.variables[variable.name];\n      if (typeof value === 'string') {\n        value = getStringNumberEquivalent(value);\n      }\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  }\n\n  const uniformDeclarations = Object.keys(uniforms).map(function (name) {\n    return `uniform float ${name};`;\n  });\n\n  const textureCount = Math.ceil(bandCount / 4);\n  uniformDeclarations.push(\n    `uniform sampler2D ${Uniforms.TILE_TEXTURE_ARRAY}[${textureCount}];`,\n  );\n\n  if (context.paletteTextures) {\n    uniformDeclarations.push(\n      `uniform sampler2D ${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}];`,\n    );\n  }\n\n  const functionDefintions = Object.keys(context.functions).map(\n    function (name) {\n      return context.functions[name];\n    },\n  );\n\n  const fragmentShader = `\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n    uniform vec4 ${Uniforms.RENDER_EXTENT};\n    uniform float ${Uniforms.TRANSITION_ALPHA};\n    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};\n    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n    uniform float ${Uniforms.RESOLUTION};\n    uniform float ${Uniforms.ZOOM};\n\n    ${uniformDeclarations.join('\\n')}\n\n    ${functionDefintions.join('\\n')}\n\n    void main() {\n      if (\n        v_mapCoord[0] < ${Uniforms.RENDER_EXTENT}[0] ||\n        v_mapCoord[1] < ${Uniforms.RENDER_EXTENT}[1] ||\n        v_mapCoord[0] > ${Uniforms.RENDER_EXTENT}[2] ||\n        v_mapCoord[1] > ${Uniforms.RENDER_EXTENT}[3]\n      ) {\n        discard;\n      }\n\n      vec4 color = texture2D(${\n        Uniforms.TILE_TEXTURE_ARRAY\n      }[0],  v_textureCoord);\n\n      ${pipeline.join('\\n')}\n\n      gl_FragColor = color;\n      gl_FragColor.rgb *= gl_FragColor.a;\n      gl_FragColor *= ${Uniforms.TRANSITION_ALPHA};\n    }`;\n\n  return {\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader,\n    uniforms: uniforms,\n    paletteTextures: context.paletteTextures,\n  };\n}\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @extends BaseTileLayer<SourceType, WebGLTileLayerRenderer>\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\n * @api\n */\nclass WebGLTileLayer extends BaseTileLayer {\n  /**\n   * @param {Options} [options] Tile layer options.\n   */\n  constructor(options) {\n    options = options ? Object.assign({}, options) : {};\n\n    const style = options.style || {};\n    delete options.style;\n\n    super(options);\n\n    /**\n     * @type {Array<SourceType>|function(import(\"../extent.js\").Extent, number):Array<SourceType>}\n     * @private\n     */\n    this.sources_ = options.sources;\n\n    /**\n     * @type {SourceType|null}\n     * @private\n     */\n    this.renderedSource_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.renderedResolution_ = NaN;\n\n    /**\n     * @type {Style}\n     * @private\n     */\n    this.style_ = style;\n\n    /**\n     * @type {Object<string, (string|number)>}\n     * @private\n     */\n    this.styleVariables_ = this.style_.variables || {};\n\n    this.handleSourceUpdate_();\n    this.addChangeListener(LayerProperty.SOURCE, this.handleSourceUpdate_);\n  }\n\n  /**\n   * Gets the sources for this layer, for a given extent and resolution.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array<SourceType>} Sources.\n   */\n  getSources(extent, resolution) {\n    const source = this.getSource();\n    return this.sources_\n      ? typeof this.sources_ === 'function'\n        ? this.sources_(extent, resolution)\n        : this.sources_\n      : source\n        ? [source]\n        : [];\n  }\n\n  /**\n   * @return {SourceType} The source being rendered.\n   * @override\n   */\n  getRenderSource() {\n    return this.renderedSource_ || this.getSource();\n  }\n\n  /**\n   * @return {import(\"../source/Source.js\").State} Source state.\n   * @override\n   */\n  getSourceState() {\n    const source = this.getRenderSource();\n    return source ? source.getState() : 'undefined';\n  }\n\n  /**\n   * @private\n   */\n  handleSourceUpdate_() {\n    if (this.hasRenderer()) {\n      this.getRenderer().clearCache();\n    }\n    const source = this.getSource();\n    if (source) {\n      if (source.getState() === 'loading') {\n        const onChange = () => {\n          if (source.getState() === 'ready') {\n            source.removeEventListener('change', onChange);\n            this.setStyle(this.style_);\n          }\n        };\n        source.addEventListener('change', onChange);\n      } else {\n        this.setStyle(this.style_);\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @return {number} The number of source bands.\n   */\n  getSourceBandCount_() {\n    const max = Number.MAX_SAFE_INTEGER;\n    const sources = this.getSources([-max, -max, max, max], max);\n    return sources && sources.length && 'bandCount' in sources[0]\n      ? sources[0].bandCount\n      : 4;\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());\n\n    return new WebGLTileLayerRenderer(this, {\n      vertexShader: parsedStyle.vertexShader,\n      fragmentShader: parsedStyle.fragmentShader,\n      uniforms: parsedStyle.uniforms,\n      cacheSize: this.getCacheSize(),\n      paletteTextures: parsedStyle.paletteTextures,\n    });\n  }\n\n  /**\n   * @param {import(\"../Map\").FrameState} frameState Frame state.\n   * @param {Array<SourceType>} sources Sources.\n   * @return {HTMLElement} Canvas.\n   */\n  renderSources(frameState, sources) {\n    const layerRenderer = this.getRenderer();\n    let canvas;\n    for (let i = 0, ii = sources.length; i < ii; ++i) {\n      this.renderedSource_ = sources[i];\n      if (layerRenderer.prepareFrame(frameState)) {\n        canvas = layerRenderer.renderFrame(frameState);\n      }\n    }\n    return canvas;\n  }\n\n  /**\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target which the renderer may (but need not) use\n   * for rendering its content.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  render(frameState, target) {\n    this.rendered = true;\n    const viewState = frameState.viewState;\n    const sources = this.getSources(frameState.extent, viewState.resolution);\n    let ready = true;\n    for (let i = 0, ii = sources.length; i < ii; ++i) {\n      const source = sources[i];\n      const sourceState = source.getState();\n      if (sourceState == 'loading') {\n        const onChange = () => {\n          if (source.getState() == 'ready') {\n            source.removeEventListener('change', onChange);\n            this.changed();\n          }\n        };\n        source.addEventListener('change', onChange);\n      }\n      ready = ready && sourceState == 'ready';\n    }\n    const canvas = this.renderSources(frameState, sources);\n    if (this.getRenderer().renderComplete && ready) {\n      // Fully rendered, done.\n      this.renderedResolution_ = viewState.resolution;\n      return canvas;\n    }\n    // Render sources from previously fully rendered frames\n    if (this.renderedResolution_ > 0.5 * viewState.resolution) {\n      const altSources = this.getSources(\n        frameState.extent,\n        this.renderedResolution_,\n      ).filter((source) => !sources.includes(source));\n      if (altSources.length > 0) {\n        return this.renderSources(frameState, altSources);\n      }\n    }\n    return canvas;\n  }\n\n  /**\n   * Update the layer style.  The `updateStyleVariables` function is a more efficient\n   * way to update layer rendering.  In cases where the whole style needs to be updated,\n   * this method may be called instead.  Note that calling this method will also replace\n   * any previously set variables, so the new style also needs to include new variables,\n   * if needed.\n   * @param {Style} style The new style.\n   */\n  setStyle(style) {\n    this.styleVariables_ = style.variables || {};\n    this.style_ = style;\n    if (this.hasRenderer()) {\n      const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());\n      const renderer = this.getRenderer();\n      renderer.reset({\n        vertexShader: parsedStyle.vertexShader,\n        fragmentShader: parsedStyle.fragmentShader,\n        uniforms: parsedStyle.uniforms,\n        paletteTextures: parsedStyle.paletteTextures,\n      });\n      this.changed();\n    }\n  }\n\n  /**\n   * Update any variables used by the layer style and trigger a re-render.\n   * @param {Object<string, number>} variables Variables to update.\n   * @api\n   */\n  updateStyleVariables(variables) {\n    Object.assign(this.styleVariables_, variables);\n    this.changed();\n  }\n}\n\n/**\n * Clean up underlying WebGL resources.\n * @function\n * @api\n */\nWebGLTileLayer.prototype.dispose;\n\nexport default WebGLTileLayer;\n","/**\n * @module ol/tilecoord\n */\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, tileCoord) {\n  if (tileCoord !== undefined) {\n    tileCoord[0] = z;\n    tileCoord[1] = x;\n    tileCoord[2] = y;\n    return tileCoord;\n  }\n  return [z, x, y];\n}\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n  return z + '/' + x + '/' + y;\n}\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nexport function getCacheKeyForTileKey(tileKey) {\n  const [z, x, y] = tileKey\n    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\n    .split(',')\n    .map(Number);\n  return getKeyZXY(z, x, y);\n}\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n  return key.split('/').map(Number);\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n  return hashZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * @param {number} z The tile z coordinate.\n * @param {number} x The tile x coordinate.\n * @param {number} y The tile y coordinate.\n * @return {number} Hash.\n */\nexport function hashZXY(z, x, y) {\n  return (x << z) + y;\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n  const z = tileCoord[0];\n  const x = tileCoord[1];\n  const y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  const tileRange = tileGrid.getFullTileRange(z);\n  if (!tileRange) {\n    return true;\n  }\n  return tileRange.containsXY(x, y);\n}\n"],"names":["TileRange","constructor","minX","maxX","minY","maxY","this","contains","tileCoord","containsXY","containsTileRange","tileRange","x","y","equals","extend","getHeight","getSize","getWidth","intersects","createOrUpdate","undefined","BaseTileLayer","options","baseOptions","Object","assign","cacheSize","preload","useInterimTilesOnError","super","on","once","un","cacheSize_","setPreload","setUseInterimTilesOnError","getCacheSize","getPreload","get","PRELOAD","set","getUseInterimTilesOnError","USE_INTERIM_TILES_ON_ERROR","getData","pixel","parseStyle","style","bandCount","vertexShader","TEXTURE_COORD","TILE_TRANSFORM","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","TEXTURE_RESOLUTION","TEXTURE_ORIGIN_X","TEXTURE_ORIGIN_Y","DEPTH","context","pipeline","color","push","contrast","exposure","saturation","gamma","brightness","uniforms","numVariables","keys","variables","length","Error","i","variable","name","uniformName","value","uniformDeclarations","map","textureCount","Math","ceil","TILE_TEXTURE_ARRAY","paletteTextures","functionDefintions","functions","fragmentShader","RENDER_EXTENT","TRANSITION_ALPHA","RESOLUTION","ZOOM","join","WebGLTileLayer","sources_","sources","renderedSource_","renderedResolution_","NaN","style_","styleVariables_","handleSourceUpdate_","addChangeListener","SOURCE","getSources","extent","resolution","source","getSource","getRenderSource","getSourceState","getState","hasRenderer","getRenderer","clearCache","onChange","removeEventListener","setStyle","addEventListener","getSourceBandCount_","max","Number","MAX_SAFE_INTEGER","createRenderer","parsedStyle","renderSources","frameState","layerRenderer","canvas","ii","prepareFrame","renderFrame","render","target","rendered","viewState","ready","sourceState","changed","renderComplete","altSources","filter","includes","renderer","reset","updateStyleVariables","prototype","dispose","z","getKeyZXY","getKey","hash","hashZXY","withinExtentAndZ","tileGrid","getMinZoom","getMaxZoom","getFullTileRange"],"sourceRoot":""}