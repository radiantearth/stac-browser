{"version":3,"file":"js/9721.e2f606dc.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/TileRange.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/BaseTile.js","webpack://@radiantearth/stac-browser/./node_modules/ol/renderer/webgl/FlowLayer.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/Flow.js","webpack://@radiantearth/stac-browser/./node_modules/ol/layer/TileProperty.js","webpack://@radiantearth/stac-browser/./node_modules/ol/tilecoord.js"],"sourcesContent":["/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nclass TileRange {\n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   */\n  constructor(minX, maxX, minY, maxY) {\n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  contains(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  containsTileRange(tileRange) {\n    return (\n      this.minX <= tileRange.minX &&\n      tileRange.maxX <= this.maxX &&\n      this.minY <= tileRange.minY &&\n      tileRange.maxY <= this.maxY\n    );\n  }\n\n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  containsXY(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  equals(tileRange) {\n    return (\n      this.minX == tileRange.minX &&\n      this.minY == tileRange.minY &&\n      this.maxX == tileRange.maxX &&\n      this.maxY == tileRange.maxY\n    );\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   */\n  extend(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  }\n\n  /**\n   * @return {number} Height.\n   */\n  getHeight() {\n    return this.maxY - this.minY + 1;\n  }\n\n  /**\n   * @return {import(\"./size.js\").Size} Size.\n   */\n  getSize() {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  /**\n   * @return {number} Width.\n   */\n  getWidth() {\n    return this.maxX - this.minX + 1;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  intersects(tileRange) {\n    return (\n      this.minX <= tileRange.maxX &&\n      this.maxX >= tileRange.minX &&\n      this.minY <= tileRange.maxY &&\n      this.maxY >= tileRange.minY\n    );\n  }\n}\n\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  }\n  return new TileRange(minX, maxX, minY, maxY);\n}\n\nexport default TileRange;\n","/**\n * @module ol/layer/BaseTile\n */\nimport Layer from './Layer.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *   import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {TileSourceType} [source] Source for this layer.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n * @property {number} [cacheSize=512] The internal tile cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n */\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<TileSourceType, RendererType>}\n * @api\n */\nclass BaseTileLayer extends Layer {\n  /**\n   * @param {Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    const cacheSize = options.cacheSize;\n    delete options.cacheSize;\n\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    super(baseOptions);\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true,\n    );\n  }\n\n  /**\n   * @return {number|undefined} The suggested cache size\n   * @protected\n   */\n  getCacheSize() {\n    return this.cacheSize_;\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Deprecated.  Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Deprecated.  Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n\n  /**\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   * @override\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default BaseTileLayer;\n","/**\n * @module ol/renderer/webgl/FlowLayer\n */\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport {DefaultUniform} from '../../webgl/Helper.js';\nimport {ARRAY_BUFFER, STATIC_DRAW} from '../../webgl.js';\nimport WebGLTileLayerRenderer from './TileLayer.js';\n\n/**\n * @typedef {import(\"../../layer/Flow.js\").default} LayerType\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} maxSpeed The maximum particle speed in the input data.\n * @property {number} [speedFactor=0.001] A larger factor increases the rate at which particles cross the screen.\n * @property {number} [particles=65536] The number of particles to render.\n * @property {number} [cacheSize=512] The texture cache size.\n * @property {string} tileVertexShader The flow tile vertex shader.\n * @property {string} tileFragmentShader The flow tile fragment shader.\n * @property {string} textureVertexShader Generic texture fragment shader.\n * @property {string} textureFragmentShader Generic texture fragment shader.\n * @property {string} particlePositionVertexShader The particle position vertex shader.\n * @property {string} particlePositionFragmentShader The particle position fragment shader.\n * @property {string} particleColorVertexShader The particle color vertex shader.\n * @property {string} particleColorFragmentShader The particle color fragment shader.\n */\n\n/**\n * Shader uniforms.\n * @enum {string}\n */\nexport const U = {\n  TEXTURE: 'u_texture',\n  VELOCITY_TEXTURE: 'u_velocityTexture',\n  POSITION_TEXTURE: 'u_positionTexture',\n  PARTICLE_COUNT_SQRT: 'u_particleCountSqrt',\n  MAX_SPEED: 'u_maxSpeed',\n  GAIN: 'u_gain',\n  OFFSET: 'u_offset',\n  IS_FLOAT: 'u_isFloat',\n  RANDOM_SEED: 'u_randomSeed',\n  SPEED_FACTOR: 'u_speedFactor',\n  DROP_RATE: 'u_dropRate',\n  DROP_RATE_BUMP: 'u_dropRateBump',\n  OPACITY: 'u_opacity',\n  ROTATION: DefaultUniform.ROTATION,\n  VIEWPORT_SIZE_PX: DefaultUniform.VIEWPORT_SIZE_PX,\n};\n\n/**\n * Shader attributes.\n * @enum {string}\n */\nexport const A = {\n  POSITION: 'a_position',\n  INDEX: 'a_index',\n};\n\n/**\n * Shader varyings.\n * @enum {string}\n */\nexport const V = {\n  POSITION: 'v_position',\n};\n\n/**\n * @classdesc\n * Experimental WebGL renderer for vector fields.\n * @extends {WebGLTileLayerRenderer<LayerType>}\n */\nclass FlowLayerRenderer extends WebGLTileLayerRenderer {\n  /**\n   * @param {LayerType} layer The tiled field layer.\n   * @param {Options} options The renderer options.\n   */\n  constructor(layer, options) {\n    super(layer, {\n      vertexShader: options.tileVertexShader,\n      fragmentShader: options.tileFragmentShader,\n      cacheSize: options.cacheSize,\n      // TODO: rework the post-processing logic\n      // see https://github.com/openlayers/openlayers/issues/16120\n      postProcesses: [{}],\n      uniforms: {\n        [U.MAX_SPEED]: options.maxSpeed,\n      },\n    });\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.particleColorFragmentShader_ = options.particleColorFragmentShader;\n\n    /**\n     * @type {WebGLTexture|null}\n     * @private\n     */\n    this.velocityTexture_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.particleCountSqrt_ = options.particles\n      ? Math.ceil(Math.sqrt(options.particles))\n      : 256;\n\n    /**\n     * @type {WebGLArrayBuffer}\n     * @private\n     */\n    this.particleIndexBuffer_;\n\n    /**\n     * @type {WebGLArrayBuffer}\n     * @private\n     */\n    this.quadBuffer_;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.particlePositionProgram_;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.particlePositionVertexShader_ = options.particlePositionVertexShader;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.particlePositionFragmentShader_ =\n      options.particlePositionFragmentShader;\n\n    /**\n     * @type {WebGLTexture}\n     * @private\n     */\n    this.previousPositionTexture_;\n\n    /**\n     * @type {WebGLTexture}\n     * @private\n     */\n    this.nextPositionTexture_;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.particleColorProgram_;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.particleColorVertexShader_ = options.particleColorVertexShader;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.particleColorFragmentShader_ = options.particleColorFragmentShader;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.textureProgram_;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.textureVertexShader_ = options.textureVertexShader;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.textureFragmentShader_ = options.textureFragmentShader;\n\n    /**\n     * @type {WebGLTexture}\n     * @private\n     */\n    this.previousTrailsTexture_;\n\n    /**\n     * @type {WebGLTexture}\n     * @private\n     */\n    this.nextTrailsTexture_;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.fadeOpacity_ = 0.996; // how fast the particle trails fade on each frame\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxSpeed_ = options.maxSpeed;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.speedFactor_ = options.speedFactor || 0.001;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.dropRate_ = 0.003; // how often the particles move to a random place\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.dropRateBump_ = 0.01; // drop rate increase relative to individual particle speed\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.tempVec2_ = [0, 0];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.renderedWidth_ = 0;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.renderedHeight_ = 0;\n  }\n\n  /**\n   * @override\n   */\n  afterHelperCreated() {\n    super.afterHelperCreated();\n    const helper = this.helper;\n\n    const gl = helper.getGL();\n    this.framebuffer_ = gl.createFramebuffer();\n\n    const particleCount = this.particleCountSqrt_ * this.particleCountSqrt_;\n    const particleIndices = new Float32Array(particleCount);\n    for (let i = 0; i < particleCount; ++i) {\n      particleIndices[i] = i;\n    }\n    const particleIndexBuffer = new WebGLArrayBuffer(ARRAY_BUFFER, STATIC_DRAW);\n    particleIndexBuffer.setArray(particleIndices);\n    helper.flushBufferData(particleIndexBuffer);\n    this.particleIndexBuffer_ = particleIndexBuffer;\n\n    const quadIndices = new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]);\n    const quadBuffer = new WebGLArrayBuffer(ARRAY_BUFFER, STATIC_DRAW);\n    quadBuffer.setArray(quadIndices);\n    helper.flushBufferData(quadBuffer);\n    this.quadBuffer_ = quadBuffer;\n\n    const particlePositions = new Uint8Array(particleCount * 4);\n    for (let i = 0; i < particlePositions.length; ++i) {\n      particlePositions[i] = Math.floor(Math.random() * 256);\n    }\n\n    this.previousPositionTexture_ = helper.createTexture(\n      [this.particleCountSqrt_, this.particleCountSqrt_],\n      particlePositions,\n      null,\n      true,\n    );\n\n    this.nextPositionTexture_ = helper.createTexture(\n      [this.particleCountSqrt_, this.particleCountSqrt_],\n      particlePositions,\n      null,\n      true,\n    );\n\n    this.particlePositionProgram_ = helper.getProgram(\n      this.particlePositionFragmentShader_,\n      this.particlePositionVertexShader_,\n    );\n\n    this.particleColorProgram_ = helper.getProgram(\n      this.particleColorFragmentShader_,\n      this.particleColorVertexShader_,\n    );\n\n    this.textureProgram_ = helper.getProgram(\n      this.textureFragmentShader_,\n      this.textureVertexShader_,\n    );\n  }\n\n  createSizeDependentTextures_() {\n    const helper = this.helper;\n    const gl = helper.getGL();\n    const canvas = helper.getCanvas();\n    const screenWidth = canvas.width;\n    const screenHeight = canvas.height;\n\n    const blank = new Uint8Array(screenWidth * screenHeight * 4);\n\n    if (this.nextTrailsTexture_) {\n      gl.deleteTexture(this.nextTrailsTexture_);\n    }\n    this.nextTrailsTexture_ = helper.createTexture(\n      [screenWidth, screenHeight],\n      blank,\n      null,\n      true,\n    );\n\n    if (this.previousTrailsTexture_) {\n      gl.deleteTexture(this.previousTrailsTexture_);\n    }\n    this.previousTrailsTexture_ = helper.createTexture(\n      [screenWidth, screenHeight],\n      blank,\n      null,\n      true,\n    );\n  }\n\n  /**\n   * @override\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  beforeFinalize(frameState) {\n    const helper = this.helper;\n    const gl = helper.getGL();\n    const canvas = helper.getCanvas();\n    const screenWidth = canvas.width;\n    const screenHeight = canvas.height;\n\n    if (\n      this.renderedWidth_ != screenWidth ||\n      this.renderedHeight_ != screenHeight\n    ) {\n      this.createSizeDependentTextures_();\n    }\n\n    const size = [screenWidth, screenHeight];\n\n    // copy current frame buffer to the velocity texture\n    this.velocityTexture_ = helper.createTexture(\n      size,\n      null,\n      this.velocityTexture_,\n    );\n    gl.copyTexImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      0,\n      0,\n      screenWidth,\n      screenHeight,\n      0,\n    );\n\n    this.drawParticleTrails_(frameState);\n    this.updateParticlePositions_(frameState);\n\n    frameState.animate = true;\n    this.renderedWidth_ = screenWidth;\n    this.renderedHeight_ = screenHeight;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  drawParticleTrails_(frameState) {\n    const helper = this.helper;\n    const gl = helper.getGL();\n\n    helper.bindFrameBuffer(this.framebuffer_, this.nextTrailsTexture_);\n\n    this.drawTexture_(this.previousTrailsTexture_, this.fadeOpacity_);\n    this.drawParticleColor_(frameState);\n\n    helper.bindInitialFrameBuffer();\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n    this.drawTexture_(this.nextTrailsTexture_, 1);\n    gl.disable(gl.BLEND);\n\n    const current = this.nextTrailsTexture_;\n    this.nextTrailsTexture_ = this.previousTrailsTexture_;\n    this.previousTrailsTexture_ = current;\n  }\n\n  /**\n   * @param {WebGLTexture} texture The texture to draw.\n   * @param {number} opacity The opacity.\n   */\n  drawTexture_(texture, opacity) {\n    const helper = this.helper;\n    const gl = helper.getGL();\n\n    helper.useProgram(this.textureProgram_);\n    helper.bindTexture(texture, 0, U.TEXTURE);\n    helper.bindAttribute(this.quadBuffer_, A.POSITION, 2);\n    this.helper.setUniformFloatValue(U.OPACITY, opacity);\n\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  drawParticleColor_(frameState) {\n    const helper = this.helper;\n    const gl = helper.getGL();\n\n    helper.useProgram(this.particleColorProgram_);\n\n    const particleCount = this.particleCountSqrt_ * this.particleCountSqrt_;\n\n    helper.bindAttribute(this.particleIndexBuffer_, A.INDEX, 1);\n\n    helper.bindTexture(this.previousPositionTexture_, 0, U.POSITION_TEXTURE);\n    helper.bindTexture(this.velocityTexture_, 1, U.VELOCITY_TEXTURE);\n\n    this.helper.setUniformFloatValue(\n      U.PARTICLE_COUNT_SQRT,\n      this.particleCountSqrt_,\n    );\n\n    const rotation = this.tempVec2_;\n    rotation[0] = Math.cos(-frameState.viewState.rotation);\n    rotation[1] = Math.sin(-frameState.viewState.rotation);\n    this.helper.setUniformFloatVec2(U.ROTATION, rotation);\n\n    this.helper.setUniformFloatValue(U.MAX_SPEED, this.maxSpeed_);\n\n    gl.drawArrays(gl.POINTS, 0, particleCount);\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  updateParticlePositions_(frameState) {\n    const helper = this.helper;\n    const gl = helper.getGL();\n\n    helper.useProgram(this.particlePositionProgram_);\n    gl.viewport(0, 0, this.particleCountSqrt_, this.particleCountSqrt_);\n    helper.bindFrameBuffer(this.framebuffer_, this.nextPositionTexture_);\n\n    helper.bindTexture(this.previousPositionTexture_, 0, U.POSITION_TEXTURE);\n    helper.bindTexture(this.velocityTexture_, 1, U.VELOCITY_TEXTURE);\n    helper.bindAttribute(this.quadBuffer_, A.POSITION, 2);\n\n    helper.setUniformFloatValue(U.RANDOM_SEED, Math.random());\n    helper.setUniformFloatValue(U.SPEED_FACTOR, this.speedFactor_);\n    helper.setUniformFloatValue(U.DROP_RATE, this.dropRate_);\n    helper.setUniformFloatValue(U.DROP_RATE_BUMP, this.dropRateBump_);\n\n    const rotation = this.tempVec2_;\n    rotation[0] = Math.cos(-frameState.viewState.rotation);\n    rotation[1] = Math.sin(-frameState.viewState.rotation);\n    this.helper.setUniformFloatVec2(U.ROTATION, rotation);\n\n    const size = frameState.size;\n    this.helper.setUniformFloatVec2(U.VIEWPORT_SIZE_PX, [size[0], size[1]]);\n\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n    const current = this.nextPositionTexture_;\n    this.nextPositionTexture_ = this.previousPositionTexture_;\n    this.previousPositionTexture_ = current;\n  }\n}\n\nexport default FlowLayerRenderer;\n","/**\n * @module ol/layer/Flow\n */\nimport {ColorType} from '../expr/expression.js';\nimport {\n  getStringNumberEquivalent,\n  newCompilationContext,\n  uniformNameForVariable,\n} from '../expr/gpu.js';\nimport {expressionToGlsl} from '../render/webgl/compileUtil.js';\nimport FlowLayerRenderer, {A, U, V} from '../renderer/webgl/FlowLayer.js';\nimport {Attributes as BA, Uniforms as BU} from '../renderer/webgl/TileLayer.js';\nimport BaseTileLayer from './BaseTile.js';\nimport LayerProperty from './Property.js';\n\n/**\n * @typedef {import(\"../source/DataTile.js\").default} SourceType\n */\n\n/**\n * @typedef {Object} Style\n * Translates tile data to rendered pixels.\n *\n * @property {Object<string, (string|number)>} [variables] Style variables.  Each variable must hold a number or string.  These\n * variables can be used in the `color` {@link import(\"../expr/expression.js\").ExpressionValue expression} using\n * the `['var', 'varName']` operator.  To update style variables, use the {@link import(\"./WebGLTile.js\").default#updateStyleVariables} method.\n * @property {import(\"../expr/expression.js\").ExpressionValue} [color] An expression applied to color values.\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} maxSpeed The maximum particle speed.\n * @property {number} [speedFactor=0.001] A larger factor increases the rate at which particles cross the screen.\n * @property {number} [particles=65536] The number of particles to render.\n * @property {Style} [style] Style to apply to the layer.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {SourceType} [source] Source for this layer.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link module:ol/Map~Map#addLayer}.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {number} [cacheSize=512] The internal texture cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n */\n\nconst tileVertexShader = `\n  attribute vec2 ${BA.TEXTURE_COORD};\n  uniform mat4 ${BU.TILE_TRANSFORM};\n  uniform float ${BU.TEXTURE_PIXEL_WIDTH};\n  uniform float ${BU.TEXTURE_PIXEL_HEIGHT};\n  uniform float ${BU.TEXTURE_RESOLUTION};\n  uniform float ${BU.TEXTURE_ORIGIN_X};\n  uniform float ${BU.TEXTURE_ORIGIN_Y};\n  uniform float ${BU.DEPTH};\n\n  varying vec2 v_textureCoord;\n  varying vec2 v_mapCoord;\n\n  void main() {\n    v_textureCoord = ${BA.TEXTURE_COORD};\n    v_mapCoord = vec2(\n      ${BU.TEXTURE_ORIGIN_X} + ${BU.TEXTURE_RESOLUTION} * ${BU.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],\n      ${BU.TEXTURE_ORIGIN_Y} - ${BU.TEXTURE_RESOLUTION} * ${BU.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]\n    );\n    gl_Position = ${BU.TILE_TRANSFORM} * vec4(${BA.TEXTURE_COORD}, ${BU.DEPTH}, 1.0);\n  }\n`;\n\nconst tileFragmentShader = `\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  #else\n  precision mediump float;\n  #endif\n\n  uniform vec4 ${BU.RENDER_EXTENT};\n  uniform float ${U.MAX_SPEED};\n  uniform sampler2D ${BU.TILE_TEXTURE_ARRAY}[1];\n\n  varying vec2 v_textureCoord;\n  varying vec2 v_mapCoord;\n\n  void main() {\n    if (\n      v_mapCoord[0] < ${BU.RENDER_EXTENT}[0] ||\n      v_mapCoord[1] < ${BU.RENDER_EXTENT}[1] ||\n      v_mapCoord[0] > ${BU.RENDER_EXTENT}[2] ||\n      v_mapCoord[1] > ${BU.RENDER_EXTENT}[3]\n    ) {\n      discard;\n    }\n\n    vec4 velocity = texture2D(${BU.TILE_TEXTURE_ARRAY}[0],  v_textureCoord);\n    gl_FragColor = vec4((velocity.xy + ${U.MAX_SPEED}) / (2.0 * ${U.MAX_SPEED}), 0, 1);\n  }\n`;\n\n/**\n * Sets up a varying position for rendering textures.\n */\nconst quadVertexShader = `\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  #else\n  precision mediump float;\n  #endif\n\n  attribute vec2 ${A.POSITION};\n\n  varying vec2 ${V.POSITION};\n\n  void main() {\n    ${V.POSITION} = ${A.POSITION};\n    gl_Position = vec4(1.0 - 2.0 * ${A.POSITION}, 0, 1);\n  }\n`;\n\n/**\n * Sampes a texture and renders it with a new opacity.\n */\nconst textureFragmentShader = `\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  #else\n  precision mediump float;\n  #endif\n\n  uniform sampler2D ${U.TEXTURE};\n  uniform float ${U.OPACITY};\n\n  varying vec2 ${V.POSITION};\n\n  void main() {\n    vec4 color = texture2D(${U.TEXTURE}, 1.0 - ${V.POSITION});\n    gl_FragColor = vec4(floor(255.0 * color * ${U.OPACITY}) / 255.0);\n  }\n`;\n\n/**\n * Samples current particle positions, determines new positions based on velocity, and\n * encodes the new position as a color.\n */\nconst particlePositionFragmentShader = `\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  #else\n  precision mediump float;\n  #endif\n\n  uniform sampler2D ${U.POSITION_TEXTURE};\n  uniform sampler2D ${U.VELOCITY_TEXTURE};\n  uniform float ${U.RANDOM_SEED};\n  uniform float ${U.SPEED_FACTOR};\n  uniform float ${U.DROP_RATE};\n  uniform float ${U.DROP_RATE_BUMP};\n  uniform vec2 ${U.ROTATION};\n  uniform vec2 ${U.VIEWPORT_SIZE_PX};\n\n  varying vec2 ${V.POSITION};\n\n  // pseudo-random generator\n  const vec3 randConstants = vec3(12.9898, 78.233, 4375.85453);\n\n  float rand(const vec2 co) {\n    float t = dot(randConstants.xy, co);\n    return fract(sin(t) * (randConstants.z + t));\n  }\n\n  void main() {\n    vec4 positionColor = texture2D(${U.POSITION_TEXTURE}, ${V.POSITION});\n\n    // decode particle position from pixel RGBA\n    vec2 particlePosition = vec2(\n      positionColor.r / 255.0 + positionColor.b,\n      positionColor.g / 255.0 + positionColor.a\n    );\n\n    vec4 velocityColor = texture2D(${U.VELOCITY_TEXTURE}, particlePosition);\n    if (velocityColor.a == 0.0) {\n      discard;\n    }\n\n    float vx = 2.0 * velocityColor.r - 1.0;\n    float vy = 2.0 * velocityColor.g - 1.0;\n\n    // normalized veloicty (magnitude 0 - 1)\n    vec2 velocity = vec2(\n      vx * ${U.ROTATION}.x - vy * ${U.ROTATION}.y,\n      vx * ${U.ROTATION}.y + vy * ${U.ROTATION}.x\n    );\n\n    // account for aspect ratio (square particle position texture, non-square map)\n    float aspectRatio = ${U.VIEWPORT_SIZE_PX}.x / ${U.VIEWPORT_SIZE_PX}.y;\n    vec2 offset = vec2(velocity.x / aspectRatio, velocity.y) * ${U.SPEED_FACTOR};\n\n    // update particle position, wrapping around the edge\n    particlePosition = fract(1.0 + particlePosition + offset);\n\n    // a random seed to use for the particle drop\n    vec2 seed = (particlePosition + ${V.POSITION}) * ${U.RANDOM_SEED};\n\n    // drop rate is a chance a particle will restart at random position, to avoid degeneration\n    float dropRate = ${U.DROP_RATE} + length(velocity) * ${U.DROP_RATE_BUMP};\n    float drop = step(1.0 - dropRate, rand(seed));\n\n    vec2 randomPosition = vec2(rand(seed + 1.3), rand(seed + 2.1));\n    particlePosition = mix(particlePosition, randomPosition, drop);\n\n    // encode the new particle position back into RGBA\n    gl_FragColor = vec4(\n      fract(particlePosition * 255.0),\n      floor(particlePosition * 255.0) / 255.0\n    );\n  }\n`;\n\n/**\n * Samples the particle position texture to decode the particle position\n * based on pixel color.\n */\nconst particleColorVertexShader = `\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  #else\n  precision mediump float;\n  #endif\n\n  attribute float ${A.INDEX};\n\n  uniform sampler2D ${U.POSITION_TEXTURE};\n  uniform float ${U.PARTICLE_COUNT_SQRT};\n\n  varying vec2 ${V.POSITION};\n\n  void main() {\n    vec4 color = texture2D(\n      ${U.POSITION_TEXTURE},\n      vec2(\n        fract(${A.INDEX} / ${U.PARTICLE_COUNT_SQRT}),\n        floor(${A.INDEX} / ${U.PARTICLE_COUNT_SQRT}) / ${U.PARTICLE_COUNT_SQRT}\n      )\n    );\n\n    ${V.POSITION} = vec2(\n      color.r / 255.0 + color.b,\n      color.g / 255.0 + color.a\n    );\n\n    gl_PointSize = 1.0;\n    gl_Position = vec4(\n      2.0 * ${V.POSITION}.x - 1.0,\n      2.0 * ${V.POSITION}.y - 1.0,\n      0,\n      1\n    );\n  }\n`;\n\n/**\n * @typedef {Object} ParsedStyle\n * @property {string} tileVertexShader The flow tile vertex shader.\n * @property {string} tileFragmentShader The flow tile fragment shader.\n * @property {string} textureVertexShader Generic texture fragment shader.\n * @property {string} textureFragmentShader Generic texture fragment shader.\n * @property {string} particlePositionVertexShader The particle position vertex shader.\n * @property {string} particlePositionFragmentShader The particle position fragment shader.\n * @property {string} particleColorVertexShader The particle color vertex shader.\n * @property {string} particleColorFragmentShader The particle color fragment shader.\n */\n\n/**\n * @param {Style} style The layer style.\n * @return {ParsedStyle} Shaders and uniforms generated from the style.\n */\nfunction parseStyle(style) {\n  const context = newCompilationContext();\n  const pipeline = [];\n\n  if (style.color !== undefined) {\n    const color = expressionToGlsl(context, style.color, ColorType);\n    pipeline.push(`color = ${color};`);\n  }\n\n  const variableNames = Object.keys(context.variables);\n  if (variableNames.length > 1 && !style.variables) {\n    throw new Error(\n      `Missing variables in style (expected ${context.variables})`,\n    );\n  }\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  for (const variableName of variableNames) {\n    if (!(variableName in style.variables)) {\n      throw new Error(`Missing '${variableName}' in style variables`);\n    }\n\n    const uniformName = uniformNameForVariable(variableName);\n    uniforms[uniformName] = function () {\n      let value = style.variables[variableName];\n      if (typeof value === 'string') {\n        value = getStringNumberEquivalent(value);\n      }\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  }\n\n  const uniformDeclarations = Object.keys(uniforms).map(function (name) {\n    return `uniform float ${name};`;\n  });\n\n  const functionDefintions = Object.keys(context.functions).map(\n    function (name) {\n      return context.functions[name];\n    },\n  );\n\n  const particleColorFragmentShader = `\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n\n    uniform sampler2D ${U.VELOCITY_TEXTURE};\n    uniform float ${U.MAX_SPEED};\n    uniform vec2 ${U.ROTATION};\n\n    ${uniformDeclarations.join('\\n')}\n\n    varying vec2 ${V.POSITION};\n    \n    ${functionDefintions.join('\\n')}\n\n    void main() {\n      vec4 velocityColor = texture2D(${U.VELOCITY_TEXTURE}, ${V.POSITION});\n\n      float vx = mix(-${U.MAX_SPEED}, ${U.MAX_SPEED}, velocityColor.r);\n      float vy = mix(-${U.MAX_SPEED}, ${U.MAX_SPEED}, velocityColor.g);\n\n      vec2 velocity = vec2(\n        vx * ${U.ROTATION}.x - vy * ${U.ROTATION}.y,\n        vx * ${U.ROTATION}.y + vy * ${U.ROTATION}.x\n      );\n\n      float a_prop_speed = length(velocity);\n\n      vec4 color;\n\n      ${pipeline.join('\\n')}\n\n      if (color.a == 0.0) {\n        discard;\n      }\n\n      gl_FragColor = color;\n    }\n  `;\n\n  return {\n    tileVertexShader,\n    tileFragmentShader,\n    particleColorVertexShader,\n    particleColorFragmentShader,\n    particlePositionVertexShader: quadVertexShader,\n    particlePositionFragmentShader,\n    textureVertexShader: quadVertexShader,\n    textureFragmentShader,\n  };\n}\n\n/**\n * @type {Array<SourceType>}\n */\nconst sources = [];\n\n/**\n * @classdesc\n * Experimental layer that renders particles moving through a vector field.\n *\n * @extends BaseTileLayer<SourceType, FlowLayerRenderer>\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\n */\nclass FlowLayer extends BaseTileLayer {\n  /**\n   * @param {Options} options Flow layer options.\n   */\n  constructor(options) {\n    const baseOptions = Object.assign({}, options);\n    delete baseOptions.maxSpeed;\n    delete baseOptions.speedFactor;\n    delete baseOptions.particles;\n    super(baseOptions);\n\n    /**\n     * @type {Style}\n     * @private\n     */\n    this.style_ = options.style || {};\n\n    if (!(options.maxSpeed > 0)) {\n      throw new Error('maxSpeed is required');\n    }\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxSpeed_ = options.maxSpeed;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.speedFactor_ = options.speedFactor;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.particles_ = options.particles;\n\n    /**\n     * @type {Object<string, (string|number)>}\n     * @private\n     */\n    this.styleVariables_ = this.style_.variables || {};\n\n    this.addChangeListener(LayerProperty.SOURCE, this.handleSourceUpdate_);\n  }\n\n  /**\n   * @private\n   */\n  handleSourceUpdate_() {\n    if (this.hasRenderer()) {\n      this.getRenderer().clearCache();\n    }\n  }\n\n  /**\n   * Update any variables used by the layer style and trigger a re-render.\n   * @param {Object<string, number>} variables Variables to update.\n   */\n  updateStyleVariables(variables) {\n    Object.assign(this.styleVariables_, variables);\n    this.changed();\n  }\n\n  /**\n   * Gets the sources for this layer, for a given extent and resolution.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array<SourceType>} Sources.\n   */\n  getSources(extent, resolution) {\n    const source = this.getSource();\n    sources[0] = source;\n    return sources;\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    const parsedStyle = parseStyle(this.style_);\n\n    return new FlowLayerRenderer(this, {\n      ...parsedStyle,\n      cacheSize: this.getCacheSize(),\n      maxSpeed: this.maxSpeed_,\n      speedFactor: this.speedFactor_,\n      particles: this.particles_,\n    });\n  }\n}\n\n/**\n * Clean up underlying WebGL resources.\n * @function\n */\nFlowLayer.prototype.dispose;\n\nexport default FlowLayer;\n","/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n","/**\n * @module ol/tilecoord\n */\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, tileCoord) {\n  if (tileCoord !== undefined) {\n    tileCoord[0] = z;\n    tileCoord[1] = x;\n    tileCoord[2] = y;\n    return tileCoord;\n  }\n  return [z, x, y];\n}\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n  return z + '/' + x + '/' + y;\n}\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nexport function getCacheKeyForTileKey(tileKey) {\n  const [z, x, y] = tileKey\n    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\n    .split(',')\n    .map(Number);\n  return getKeyZXY(z, x, y);\n}\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n  return key.split('/').map(Number);\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n  return hashZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * @param {number} z The tile z coordinate.\n * @param {number} x The tile x coordinate.\n * @param {number} y The tile y coordinate.\n * @return {number} Hash.\n */\nexport function hashZXY(z, x, y) {\n  return (x << z) + y;\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n  const z = tileCoord[0];\n  const x = tileCoord[1];\n  const y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  const tileRange = tileGrid.getFullTileRange(z);\n  if (!tileRange) {\n    return true;\n  }\n  return tileRange.containsXY(x, y);\n}\n"],"names":["TileRange","constructor","minX","maxX","minY","maxY","this","contains","tileCoord","containsXY","containsTileRange","tileRange","x","y","equals","extend","getHeight","getSize","getWidth","intersects","createOrUpdate","undefined","BaseTileLayer","options","baseOptions","Object","assign","cacheSize","preload","useInterimTilesOnError","super","on","once","un","cacheSize_","setPreload","setUseInterimTilesOnError","getCacheSize","getPreload","get","PRELOAD","set","getUseInterimTilesOnError","USE_INTERIM_TILES_ON_ERROR","getData","pixel","U","TEXTURE","VELOCITY_TEXTURE","POSITION_TEXTURE","PARTICLE_COUNT_SQRT","MAX_SPEED","GAIN","OFFSET","IS_FLOAT","RANDOM_SEED","SPEED_FACTOR","DROP_RATE","DROP_RATE_BUMP","OPACITY","ROTATION","VIEWPORT_SIZE_PX","A","POSITION","INDEX","V","FlowLayerRenderer","layer","vertexShader","tileVertexShader","fragmentShader","tileFragmentShader","postProcesses","uniforms","maxSpeed","particleColorFragmentShader_","particleColorFragmentShader","velocityTexture_","particleCountSqrt_","particles","Math","ceil","sqrt","particleIndexBuffer_","quadBuffer_","particlePositionProgram_","particlePositionVertexShader_","particlePositionVertexShader","particlePositionFragmentShader_","particlePositionFragmentShader","previousPositionTexture_","nextPositionTexture_","particleColorProgram_","particleColorVertexShader_","particleColorVertexShader","textureProgram_","textureVertexShader_","textureVertexShader","textureFragmentShader_","textureFragmentShader","previousTrailsTexture_","nextTrailsTexture_","fadeOpacity_","maxSpeed_","speedFactor_","speedFactor","dropRate_","dropRateBump_","tempVec2_","renderedWidth_","renderedHeight_","afterHelperCreated","helper","gl","getGL","framebuffer_","createFramebuffer","particleCount","particleIndices","Float32Array","i","particleIndexBuffer","setArray","flushBufferData","quadIndices","quadBuffer","particlePositions","Uint8Array","length","floor","random","createTexture","getProgram","createSizeDependentTextures_","canvas","getCanvas","screenWidth","width","screenHeight","height","blank","deleteTexture","beforeFinalize","frameState","size","copyTexImage2D","TEXTURE_2D","RGBA","drawParticleTrails_","updateParticlePositions_","animate","bindFrameBuffer","drawTexture_","drawParticleColor_","bindInitialFrameBuffer","clearColor","clear","COLOR_BUFFER_BIT","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","disable","current","texture","opacity","useProgram","bindTexture","bindAttribute","setUniformFloatValue","drawArrays","TRIANGLES","rotation","cos","viewState","sin","setUniformFloatVec2","POINTS","viewport","TEXTURE_COORD","TILE_TRANSFORM","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","TEXTURE_RESOLUTION","TEXTURE_ORIGIN_X","TEXTURE_ORIGIN_Y","DEPTH","RENDER_EXTENT","TILE_TEXTURE_ARRAY","quadVertexShader","parseStyle","style","context","pipeline","color","push","variableNames","keys","variables","Error","variableName","uniformName","value","uniformDeclarations","map","name","functionDefintions","functions","join","sources","FlowLayer","BaseTile","style_","particles_","styleVariables_","addChangeListener","SOURCE","handleSourceUpdate_","hasRenderer","getRenderer","clearCache","updateStyleVariables","changed","getSources","extent","resolution","source","getSource","createRenderer","parsedStyle","prototype","dispose","z","getKeyZXY","getKey","hash","hashZXY","withinExtentAndZ","tileGrid","getMinZoom","getMaxZoom","getFullTileRange"],"sourceRoot":""}