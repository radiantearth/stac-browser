{"version":3,"file":"js/8035.95ed074a.js","mappings":"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","sources":["webpack://@radiantearth/stac-browser/./node_modules/ol/layer/WebGLVector.js","webpack://@radiantearth/stac-browser/./node_modules/ol/renderer/webgl/VectorLayer.js","webpack://@radiantearth/stac-browser/./node_modules/ol/renderer/webgl/worldUtil.js"],"sourcesContent":["/**\n * @module ol/layer/WebGLVector\n */\nimport WebGLVectorLayerRenderer from '../renderer/webgl/VectorLayer.js';\nimport Layer from './Layer.js';\n\n/***\n * @template T\n * @typedef {T extends import(\"../source/Vector.js\").default<infer U extends import(\"../Feature.js\").FeatureLike> ? U : never} ExtractedFeatureType\n */\n\n/**\n * @template {import(\"../source/Vector.js\").default<FeatureType>} [VectorSourceType=import(\"../source/Vector.js\").default<*>]\n * @template {import('../Feature.js').FeatureLike} [FeatureType=ExtractedFeatureType<VectorSourceType>]\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * FIXME: not supported yet\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {VectorSourceType} [source] Source.\n * @property {import('../style/flat.js').FlatStyleLike} style Layer style.\n * @property {import('../style/flat.js').StyleVariables} [variables] Style variables. Each variable must hold a literal value (not\n * an expression). These variables can be used as {@link import(\"../expr/expression.js\").ExpressionValue expressions} in the styles properties\n * using the `['var', 'varName']` operator.\n * To update style variables, use the {@link import(\"./WebGLVector.js\").default#updateStyleVariables} method.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * FIXME: not supported yet\n * @property {boolean} [disableHitDetection=false] Setting this to true will provide a slight performance boost, but will\n * prevent all hit detection on the layer.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Layer optimized for rendering large vector datasets.\n *\n * **Important: a `WebGLVector` layer must be manually disposed when removed, otherwise the underlying WebGL context\n * will not be garbage collected.**\n *\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Vector.js\").default<FeatureType>} [VectorSourceType=import(\"../source/Vector.js\").default<*>]\n * @template {import('../Feature.js').FeatureLike} [FeatureType=ExtractedFeatureType<VectorSourceType>]\n * @extends {Layer<VectorSourceType, WebGLVectorLayerRenderer>}\n */\nclass WebGLVectorLayer extends Layer {\n  /**\n   * @param {Options<VectorSourceType, FeatureType>} [options] Options.\n   */\n  constructor(options) {\n    const baseOptions = Object.assign({}, options);\n\n    super(baseOptions);\n\n    /**\n     * @type {import('../style/flat.js').StyleVariables}\n     * @private\n     */\n    this.styleVariables_ = options.variables || {};\n\n    /**\n     * @private\n     */\n    this.style_ = options.style;\n\n    /**\n     * @private\n     */\n    this.hitDetectionDisabled_ = !!options.disableHitDetection;\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    return new WebGLVectorLayerRenderer(this, {\n      style: this.style_,\n      variables: this.styleVariables_,\n      disableHitDetection: this.hitDetectionDisabled_,\n    });\n  }\n\n  /**\n   * Update any variables used by the layer style and trigger a re-render.\n   * @param {import('../style/flat.js').StyleVariables} variables Variables to update.\n   */\n  updateStyleVariables(variables) {\n    Object.assign(this.styleVariables_, variables);\n    this.changed();\n  }\n\n  /**\n   * Set the layer style.\n   * @param {import('../style/flat.js').FlatStyleLike} style Layer style.\n   */\n  setStyle(style) {\n    this.style_ = style;\n    this.clearRenderer();\n    this.changed();\n  }\n}\n\nexport default WebGLVectorLayer;\n","/**\n * @module ol/renderer/webgl/VectorLayer\n */\nimport ViewHint from '../../ViewHint.js';\nimport {assert} from '../../asserts.js';\nimport {listen, unlistenByKey} from '../../events.js';\nimport {buffer, createEmpty, equals} from '../../extent.js';\nimport BaseVector from '../../layer/BaseVector.js';\nimport {\n  getTransformFromProjections,\n  getUserProjection,\n  toUserExtent,\n  toUserResolution,\n} from '../../proj.js';\nimport MixedGeometryBatch from '../../render/webgl/MixedGeometryBatch.js';\nimport VectorStyleRenderer from '../../render/webgl/VectorStyleRenderer.js';\nimport {colorDecodeId} from '../../render/webgl/encodeUtil.js';\nimport {breakDownFlatStyle} from '../../render/webgl/style.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n  setFromArray as setFromTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {\n  create as createMat4,\n  fromTransform as mat4FromTransform,\n} from '../../vec/mat4.js';\nimport {DefaultUniform} from '../../webgl/Helper.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {getWorldParameters} from './worldUtil.js';\n\nexport const Uniforms = {\n  ...DefaultUniform,\n  RENDER_EXTENT: 'u_renderExtent', // intersection of layer, source, and view extent\n  PATTERN_ORIGIN: 'u_patternOrigin',\n  GLOBAL_ALPHA: 'u_globalAlpha',\n};\n\n/**\n * @typedef {import('../../render/webgl/VectorStyleRenderer.js').AsShaders} StyleAsShaders\n */\n/**\n * @typedef {import('../../render/webgl/VectorStyleRenderer.js').AsRule} StyleAsRule\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {import('../../style/flat.js').FlatStyleLike | Array<StyleAsShaders> | StyleAsShaders} style Flat vector style; also accepts shaders\n * @property {Object<string, number|Array<number>|string|boolean>} variables Style variables\n * @property {boolean} [disableHitDetection=false] Setting this to true will provide a slight performance boost, but will\n * prevent all hit detection on the layer.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Experimental WebGL vector renderer. Supports polygons, lines and points:\n *  Polygons are broken down into triangles\n *  Lines are rendered as strips of quads\n *  Points are rendered as quads\n *\n * You need to provide vertex and fragment shaders as well as custom attributes for each type of geometry. All shaders\n * can access the uniforms in the {@link module:ol/webgl/Helper~DefaultUniform} enum.\n * The vertex shaders can access the following attributes depending on the geometry type:\n *  For polygons: {@link module:ol/render/webgl/PolygonBatchRenderer~Attributes}\n *  For line strings: {@link module:ol/render/webgl/LineStringBatchRenderer~Attributes}\n *  For points: {@link module:ol/render/webgl/PointBatchRenderer~Attributes}\n *\n * Please note that the fragment shaders output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Note: this uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n */\nclass WebGLVectorLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = {\n      [Uniforms.RENDER_EXTENT]: [0, 0, 0, 0],\n      [Uniforms.PATTERN_ORIGIN]: [0, 0],\n      [Uniforms.GLOBAL_ALPHA]: 1,\n    };\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hitDetectionEnabled_ = !options.disableHitDetection;\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    this.hitRenderTarget_;\n\n    /**\n     * @private\n     */\n    this.sourceRevision_ = -1;\n\n    /**\n     * @private\n     */\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = createTransform();\n\n    /**\n     * @private\n     */\n    this.tmpCoords_ = [0, 0];\n    /**\n     * @private\n     */\n    this.tmpTransform_ = createTransform();\n    /**\n     * @private\n     */\n    this.tmpMat4_ = createMat4();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentFrameStateTransform_ = createTransform();\n\n    /**\n     * @type {import('../../style/flat.js').StyleVariables}\n     * @private\n     */\n    this.styleVariables_ = {};\n\n    /**\n     * @type {Array<StyleAsRule | StyleAsShaders>}\n     * @private\n     */\n    this.styles_ = [];\n\n    /**\n     * @type {Array<VectorStyleRenderer>}\n     * @private\n     */\n    this.styleRenderers_ = [];\n\n    /**\n     * @type {Array<import('../../render/webgl/VectorStyleRenderer.js').WebGLBuffers>}\n     * @private\n     */\n    this.buffers_ = [];\n\n    this.applyOptions_(options);\n\n    /**\n     * @private\n     */\n    this.batch_ = new MixedGeometryBatch();\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.initialFeaturesAdded_ = false;\n\n    /**\n     * @private\n     * @type {Array<import(\"../../events.js\").EventsKey|null>}\n     */\n    this.sourceListenKeys_ = null;\n  }\n\n  /**\n   * @private\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  addInitialFeatures_(frameState) {\n    const source = this.getLayer().getSource();\n    const userProjection = getUserProjection();\n    let projectionTransform;\n    if (userProjection) {\n      projectionTransform = getTransformFromProjections(\n        userProjection,\n        frameState.viewState.projection,\n      );\n    }\n    this.batch_.addFeatures(source.getFeatures(), projectionTransform);\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_.bind(this, projectionTransform),\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_.bind(this, projectionTransform),\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this,\n      ),\n    ];\n  }\n\n  /**\n   * @param {Options} options Options.\n   * @private\n   */\n  applyOptions_(options) {\n    this.styleVariables_ = options.variables;\n    this.styles_ = breakDownFlatStyle(options.style);\n  }\n\n  /**\n   * @private\n   */\n  createRenderers_() {\n    this.buffers_ = [];\n    this.styleRenderers_ = this.styles_.map(\n      (style) =>\n        new VectorStyleRenderer(\n          style,\n          this.styleVariables_,\n          this.helper,\n          this.hitDetectionEnabled_,\n          'filter' in style ? style.filter : null,\n        ),\n    );\n  }\n\n  /**\n   * @override\n   */\n  reset(options) {\n    this.applyOptions_(options);\n    if (this.helper) {\n      this.createRenderers_();\n    }\n    super.reset(options);\n  }\n\n  /**\n   * @override\n   */\n  afterHelperCreated() {\n    if (this.styleRenderers_.length) {\n      // To reuse buffers\n      this.styleRenderers_.forEach((renderer, i) =>\n        renderer.setHelper(this.helper, this.buffers_[i]),\n      );\n    } else {\n      this.createRenderers_();\n    }\n\n    if (this.hitDetectionEnabled_) {\n      this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n    }\n  }\n\n  /**\n   * @param {import(\"../../proj.js\").TransformFunction} projectionTransform Transform function.\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(projectionTransform, event) {\n    const feature = event.feature;\n    this.batch_.addFeature(feature, projectionTransform);\n  }\n\n  /**\n   * @param {import(\"../../proj.js\").TransformFunction} projectionTransform Transform function.\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(projectionTransform, event) {\n    const feature = event.feature;\n    this.batch_.changeFeature(feature, projectionTransform);\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    this.batch_.removeFeature(feature);\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.batch_.clear();\n  }\n\n  /**\n   * @param {import(\"../../transform.js\").Transform} batchInvertTransform Inverse of the transformation in which geometries are expressed\n   * @private\n   */\n  applyUniforms_(batchInvertTransform) {\n    // world to screen matrix\n    setFromTransform(this.tmpTransform_, this.currentFrameStateTransform_);\n    multiplyTransform(this.tmpTransform_, batchInvertTransform);\n    this.helper.setUniformMatrixValue(\n      Uniforms.PROJECTION_MATRIX,\n      mat4FromTransform(this.tmpMat4_, this.tmpTransform_),\n    );\n\n    // screen to world matrix\n    makeInverseTransform(this.tmpTransform_, this.tmpTransform_);\n    this.helper.setUniformMatrixValue(\n      Uniforms.SCREEN_TO_WORLD_MATRIX,\n      mat4FromTransform(this.tmpMat4_, this.tmpTransform_),\n    );\n\n    // pattern origin should always be [0, 0] in world coordinates\n    this.tmpCoords_[0] = 0;\n    this.tmpCoords_[1] = 0;\n    makeInverseTransform(this.tmpTransform_, batchInvertTransform);\n    applyTransform(this.tmpTransform_, this.tmpCoords_);\n    this.helper.setUniformFloatVec2(Uniforms.PATTERN_ORIGIN, this.tmpCoords_);\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const [startWorld, endWorld, worldWidth] = getWorldParameters(\n      frameState,\n      this.getLayer(),\n    );\n\n    // draw the normal canvas\n    this.helper.prepareDraw(frameState);\n    this.renderWorlds(frameState, false, startWorld, endWorld, worldWidth);\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent,\n    );\n\n    const canvas = this.helper.getCanvas();\n\n    if (this.hitDetectionEnabled_) {\n      this.renderWorlds(frameState, true, startWorld, endWorld, worldWidth);\n      this.hitRenderTarget_.clearCachedData();\n    }\n\n    this.postRender(gl, frameState);\n\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrameInternal(frameState) {\n    if (!this.initialFeaturesAdded_) {\n      this.addInitialFeatures_(frameState);\n      this.initialFeaturesAdded_ = true;\n    }\n\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n\n      const userProjection = getUserProjection();\n      if (userProjection) {\n        vectorSource.loadFeatures(\n          toUserExtent(extent, userProjection),\n          toUserResolution(resolution, projection),\n          userProjection,\n        );\n      } else {\n        vectorSource.loadFeatures(extent, resolution, projection);\n      }\n\n      this.ready = false;\n\n      const transform = this.helper.makeProjectionTransform(\n        frameState,\n        createTransform(),\n      );\n\n      const generatePromises = this.styleRenderers_.map((renderer, i) =>\n        renderer.generateBuffers(this.batch_, transform).then((buffers) => {\n          if (this.buffers_[i]) {\n            this.disposeBuffers(this.buffers_[i]);\n          }\n          this.buffers_[i] = buffers;\n        }),\n      );\n      Promise.all(generatePromises).then(() => {\n        this.ready = true;\n        this.getLayer().changed();\n      });\n\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    return true;\n  }\n\n  /**\n   * Render the world, either to the main framebuffer or to the hit framebuffer\n   * @param {import(\"../../Map.js\").FrameState} frameState current frame state\n   * @param {boolean} forHitDetection whether the rendering is for hit detection\n   * @param {number} startWorld the world to render in the first iteration\n   * @param {number} endWorld the last world to render\n   * @param {number} worldWidth the width of the worlds being rendered\n   */\n  renderWorlds(frameState, forHitDetection, startWorld, endWorld, worldWidth) {\n    let world = startWorld;\n\n    if (forHitDetection) {\n      this.hitRenderTarget_.setSize([\n        Math.floor(frameState.size[0] / 2),\n        Math.floor(frameState.size[1] / 2),\n      ]);\n      this.helper.prepareDrawToRenderTarget(\n        frameState,\n        this.hitRenderTarget_,\n        true,\n      );\n    }\n\n    do {\n      this.helper.makeProjectionTransform(\n        frameState,\n        this.currentFrameStateTransform_,\n      );\n      translateTransform(\n        this.currentFrameStateTransform_,\n        world * worldWidth,\n        0,\n      );\n      for (let i = 0, ii = this.styleRenderers_.length; i < ii; i++) {\n        const renderer = this.styleRenderers_[i];\n        const buffers = this.buffers_[i];\n        if (!buffers) {\n          continue;\n        }\n        renderer.render(buffers, frameState, () => {\n          this.applyUniforms_(buffers.invertVerticesTransform);\n          this.helper.applyHitDetectionUniform(forHitDetection);\n        });\n      }\n    } while (++world < endWorld);\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    assert(\n      this.hitDetectionEnabled_,\n      '`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option.',\n    );\n    if (!this.styleRenderers_.length || !this.hitDetectionEnabled_) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(\n      frameState.coordinateToPixelTransform,\n      coordinate.slice(),\n    );\n\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const ref = colorDecodeId(color);\n    const feature = this.batch_.getFeatureFromRef(ref);\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n    return undefined;\n  }\n\n  /**\n   * Will release a set of Webgl buffers\n   * @param {import('../../render/webgl/VectorStyleRenderer.js').WebGLBuffers} buffers Buffers\n   */\n  disposeBuffers(buffers) {\n    /**\n     * @param {Array<import('../../webgl/Buffer.js').default>} typeBuffers Buffers\n     */\n    const disposeBuffersOfType = (typeBuffers) => {\n      for (const buffer of typeBuffers) {\n        if (buffer) {\n          this.helper.deleteBuffer(buffer);\n        }\n      }\n    };\n    if (buffers.pointBuffers) {\n      disposeBuffersOfType(buffers.pointBuffers);\n    }\n    if (buffers.lineStringBuffers) {\n      disposeBuffersOfType(buffers.lineStringBuffers);\n    }\n    if (buffers.polygonBuffers) {\n      disposeBuffersOfType(buffers.polygonBuffers);\n    }\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    this.buffers_.forEach((buffers) => {\n      if (buffers) {\n        this.disposeBuffers(buffers);\n      }\n    });\n    if (this.sourceListenKeys_) {\n      this.sourceListenKeys_.forEach(function (key) {\n        unlistenByKey(key);\n      });\n      this.sourceListenKeys_ = null;\n    }\n    super.disposeInternal();\n  }\n\n  renderDeclutter() {}\n}\n\nexport default WebGLVectorLayerRenderer;\n","import {getWidth} from '../../extent.js';\n\n/**\n * Compute world params\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {any} layer The layer\n * @return {Array<number>} The world start, end and width.\n */\nexport function getWorldParameters(frameState, layer) {\n  const projection = frameState.viewState.projection;\n\n  const vectorSource = layer.getSource();\n  const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n  const projectionExtent = projection.getExtent();\n\n  const extent = frameState.extent;\n  const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n  const endWorld = multiWorld\n    ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n    : 1;\n\n  const startWorld = multiWorld\n    ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n    : 0;\n\n  return [startWorld, endWorld, worldWidth];\n}\n"],"names":["WebGLVectorLayer","constructor","options","baseOptions","Object","assign","super","this","styleVariables_","variables","style_","style","hitDetectionDisabled_","disableHitDetection","createRenderer","updateStyleVariables","changed","setStyle","clearRenderer","Uniforms","RENDER_EXTENT","PATTERN_ORIGIN","GLOBAL_ALPHA","WebGLVectorLayerRenderer","layer","uniforms","postProcesses","hitDetectionEnabled_","hitRenderTarget_","sourceRevision_","previousExtent_","currentTransform_","tmpCoords_","tmpTransform_","tmpMat4_","currentFrameStateTransform_","styles_","styleRenderers_","buffers_","applyOptions_","batch_","initialFeaturesAdded_","sourceListenKeys_","addInitialFeatures_","frameState","source","getLayer","getSource","userProjection","projectionTransform","viewState","projection","addFeatures","getFeatures","ADDFEATURE","handleSourceFeatureAdded_","bind","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","createRenderers_","map","helper","filter","reset","afterHelperCreated","length","forEach","renderer","i","setHelper","event","feature","addFeature","changeFeature","removeFeature","clear","applyUniforms_","batchInvertTransform","setUniformMatrixValue","PROJECTION_MATRIX","SCREEN_TO_WORLD_MATRIX","setUniformFloatVec2","renderFrame","gl","getGL","preRender","startWorld","endWorld","worldWidth","prepareDraw","renderWorlds","finalizeDraw","dispatchPreComposeEvent","dispatchPostComposeEvent","canvas","getCanvas","clearCachedData","postRender","prepareFrameInternal","vectorSource","viewNotMoving","viewHints","ANIMATING","INTERACTING","extentChanged","extent","sourceChanged","getRevision","resolution","renderBuffer","getRenderBuffer","loadFeatures","ready","transform","makeProjectionTransform","generatePromises","generateBuffers","then","buffers","disposeBuffers","Promise","all","slice","forHitDetection","world","setSize","Math","floor","size","prepareDrawToRenderTarget","ii","render","invertVerticesTransform","applyHitDetectionUniform","forEachFeatureAtCoordinate","coordinate","hitTolerance","callback","matches","pixel","coordinateToPixelTransform","data","readPixel","color","ref","getFeatureFromRef","disposeBuffersOfType","typeBuffers","buffer","deleteBuffer","pointBuffers","lineStringBuffers","polygonBuffers","disposeInternal","key","renderDeclutter","getWorldParameters","multiWorld","getWrapX","canWrapX","projectionExtent","getExtent","ceil"],"sourceRoot":""}